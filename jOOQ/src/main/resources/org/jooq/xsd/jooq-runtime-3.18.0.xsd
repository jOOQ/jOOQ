<?xml version="1.0" encoding="UTF-8"?>
<schema
  xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:jooq-runtime="http://www.jooq.org/xsd/jooq-runtime-3.18.0.xsd"
  xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
  xmlns:annox="http://annox.dev.java.net"
  targetNamespace="http://www.jooq.org/xsd/jooq-runtime-3.18.0.xsd"
  elementFormDefault="qualified"
  jxb:extensionBindingPrefixes="annox"
  jxb:version="2.1">

  <element name="settings" type="jooq-runtime:Settings"/>

  <complexType name="Settings">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[Settings that influence the way jOOQ renders SQL code.]]></jxb:javadoc></jxb:class></appinfo></annotation>
    <all>
      <element name="forceIntegerTypesOnZeroScaleDecimals" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Historically, zero-scale decimal types are generated as their most appropriate, corresponding integer type (e.g. NUMBER(2, 0) and less: Byte). The same behaviour is replicated in the {@link org.jooq.Meta} API. This flag allows for turning off this feature.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    
      <element name="renderCatalog" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether any catalog name should be rendered at all.
<p>
Use this for single-catalog environments, or when all objects are made
available using synonyms]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderSchema" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether any schema name should be rendered at all.
<p>
Setting this to false also implicitly sets "renderCatalog" to false.
<p>
Use this for single-schema environments, or when all objects are made
available using synonyms]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderMapping" type="jooq-runtime:RenderMapping" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Configure render mapping for runtime schema / table rewriting in
generated SQL.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderQuotedNames" type="jooq-runtime:RenderQuotedNames" minOccurs="0" maxOccurs="1" default="EXPLICIT_DEFAULT_QUOTED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether rendered schema, table, column names, etc should be quoted.
<p>
This only affects names created through {@link org.jooq.impl.DSL#name(String)} methods (including those that are implicitly created through this method), not {@link org.jooq.impl.DSL#quotedName(String)} or {@link org.jooq.impl.DSL#unquotedName(String)}, whose behaviour cannot be overridden.
<p>
This setting does not affect any plain SQL usage.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderNameCase" type="jooq-runtime:RenderNameCase" minOccurs="0" maxOccurs="1" default="AS_IS">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the case of {@link org.jooq.Name} references should be modified in any way.
<p>
Names are modified irrespective of the {@link #getRenderQuotedNames()} setting.
<p>
This setting does not affect any plain SQL usage.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderNameStyle" type="jooq-runtime:RenderNameStyle" minOccurs="0" maxOccurs="1" default="QUOTED">
        <annotation>
          <appinfo>
            <jxb:property>
              <jxb:javadoc><![CDATA[Whether rendered schema, table, column names, etc should be quoted
in rendered SQL, or transformed in any other way.
<p>
This is set to "QUOTED" by default for backwards-compatibility.
<p>
@deprecated - 3.12.0 - [#5909] - Use {@link RenderQuotedNames} and {@link RenderNameCase} instead.]]></jxb:javadoc>
            </jxb:property>
            <annox:annotate target="getter">@java.lang.Deprecated</annox:annotate>
            <annox:annotate target="setter">@java.lang.Deprecated</annox:annotate>
          </appinfo>
        </annotation>
      </element>
      
      <element name="renderNamedParamPrefix" type="string" minOccurs="0" maxOccurs="1" default=":">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The prefix to use for named parameters in generated SQL.
<p>
Named parameter syntax defaults to <code>:name</code> (such as supported by Oracle, JPA, Spring), but 
vendor specific parameters may look differently. This flag can be used to determine the prefix to be
used by named parameters, such as <code>@</code> for SQL Server's <code>@name</code> or <code>$</code>
for PostgreSQL's <code>$name</code>, when generating SQL.
<p>
"Named indexed" parameters can be obtained in the same way by specifingy {@code ParamType#NAMED} and not
providing a name to parameters, resulting in <code>:1</code> or <code>@1</code> or <code>$1</code>, etc.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderKeywordCase" type="jooq-runtime:RenderKeywordCase" minOccurs="0" maxOccurs="1" default="AS_IS">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the case of {@link org.jooq.Keyword} references should be modified in any way.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderKeywordStyle" type="jooq-runtime:RenderKeywordStyle" minOccurs="0" maxOccurs="1" default="AS_IS">
        <annotation>
          <appinfo>
            <jxb:property>
              <jxb:javadoc><![CDATA[Whether the case of {@link org.jooq.Keyword} references should be modified in any way.
<p>
@deprecated - 3.12.0 - [#5909] - Use {@link RenderKeywordCase} instead.]]></jxb:javadoc>
            </jxb:property>
            <annox:annotate target="getter">@java.lang.Deprecated</annox:annotate>
            <annox:annotate target="setter">@java.lang.Deprecated</annox:annotate>
          </appinfo>
        </annotation>
      </element>
      
      <element name="renderLocale" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The Locale to be used with any render locale dependent logic (as e.g. transforming names to lower / uppper case), defaulting to {@link #getLocale()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderFormatted" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether rendered SQL should be pretty-printed.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderFormatting" type="jooq-runtime:RenderFormatting" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[All sorts of formatting flags / settings.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOptionalAssociativityParentheses" type="jooq-runtime:RenderOptionalKeyword" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render optional parentheses to make associativity explicit, e.g. <code>((a + b) + c)</code> instead of (a + b + c).]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOptionalAsKeywordForTableAliases" type="jooq-runtime:RenderOptionalKeyword" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render the optional <code>AS</code> keyword in table aliases, if it is optional in the output dialect. This is ignored if the keyword is not supported (e.g. in Oracle)]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOptionalAsKeywordForFieldAliases" type="jooq-runtime:RenderOptionalKeyword" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render the optional <code>AS</code> keyword in table aliases, if it is optional in the output dialect.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOptionalInnerKeyword" type="jooq-runtime:RenderOptionalKeyword" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render the optional <code>INNER</code> keyword in <code>INNER JOIN</code>, if it is optional in the output dialect.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOptionalOuterKeyword" type="jooq-runtime:RenderOptionalKeyword" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render the optional <code>OUTER</code> keyword in <code>OUTER JOIN</code>, if it is optional in the output dialect.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderImplicitWindowRange" type="jooq-runtime:RenderImplicitWindowRange" minOccurs="0" maxOccurs="1" default="OFF">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to render an explicit window <code>RANGE</code> clause when an implicit clause is applied.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderScalarSubqueriesForStoredFunctions" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether stored function calls should be wrapped in scalar subqueries.
<p>
Oracle 11g (and potentially, other databases too) implements scalar subquery caching. With this flag
set to true, users can automatically profit from this feature in all SQL statements.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderImplicitJoinType" type="jooq-runtime:RenderImplicitJoinType" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The join type to be generated by implicit joins.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderDefaultNullability" type="jooq-runtime:RenderDefaultNullability" minOccurs="0" maxOccurs="1" default="IMPLICIT_NULL">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the {@link org.jooq.Nullability#DEFAULT} nullablity should be rendered in generated DDL, and how it should be rendered.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderCoalesceToEmptyStringInConcat" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether stored function calls should be wrapped in scalar subqueries.
<p>
Oracle 11g (and potentially, other databases too) implements scalar subquery caching. With this flag
set to true, users can automatically profit from this feature in all SQL statements.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="renderOrderByRownumberForEmulatedPagination" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether an additional <code>ORDER BY rn</code> clause should be rendered on emulated paginated queries.
<p>
Older databases did not support OFFSET .. FETCH pagination, so jOOQ emulates it using derived
tables and <code>ROWNUM</code> (Oracle 11g and older) or <code>ROW_NUMBER()</code> (e.g. DB2, 
SQL Server, etc.) filtering. While these subqueries are ordered, the ordering is not 
<em>guaranteed</em> to be stable in the outer most queries. It may be stable (and e.g. in Oracle, 
it mostly is, if queries are not parallel, or joined to other queries, etc.), so the excess 
<code>ORDER BY</code> clause may add some additional performance overhead. This setting forces 
jOOQ to not generate the additional <code>ORDER BY</code> clause.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/7609">https://github.com/jOOQ/jOOQ/issues/7609</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderOutputForSQLServerReturningClause" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the jOOQ <code>RETURNING</code> clause should map to SQL Server's <code>OUTPUT</code> clause.
<p>
SQL Server supports an <code>OUTPUT</code> clause in most DML statements, whose behaviour
is almost identical to <code>RETURNING</code> in Firebird, Oracle, PostgreSQL. Users who
want to prevent jOOQ from rendering this <code>OUTPUT</code> clause can deactivate this flag
to revert to jOOQ calling {@code java.sql.Statement#getGeneratedKeys()} instead, which
is only supported for single row inserts.
<p>
This <code>OUTPUT</code> clause does not support fetching trigger generated values. In order
to fetch trigger generated values, {@link #fetchTriggerValuesAfterSQLServerOutput} needs to
be enabled as well.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/4498">https://github.com/jOOQ/jOOQ/issues/4498</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderGroupConcatMaxLenSessionVariable" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the jOOQ <code>GROUP_CONCAT</code> function should be overflow-protected by setting the <code>@@group_concat_max_len</code> session variable in MySQL style database systems.
<p>
MySQL truncates <code>GROUP_CONCAT</code> results after a certain length, which may be way
too small for jOOQ's usage, especially when using the <code>MULTISET</code> emulation. By
default, jOOQ sets a session variable to the highest possible value prior to executing a
query containing <code>GROUP_CONCAT</code>. This flag can be used to opt out of this.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/12092">https://github.com/jOOQ/jOOQ/issues/12092</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderParenthesisAroundSetOperationQueries" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether queries combined with set operators (e.g. UNION and UNION ALL) should always be surrounded by a parenthesis pair.
<p>
By default (i.e. when this setting is set to <code>false</code> jOOQ will only render parenthesis pairs around queries combined with set operators when required.
This is for example the case when set operators are nested, when non-associative operators like EXCEPT are used, or when the queries are rendered as derived tables.
<p>
When this setting is set to <code>true</code> the queries combined with set operators will always be surrounded by a parenthesis pair.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/3676">https://github.com/jOOQ/jOOQ/issues/3676</a> and <a href="https://github.com/jOOQ/jOOQ/issues/9751">https://github.com/jOOQ/jOOQ/issues/9751</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="renderVariablesInDerivedTablesForEmulations" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether emulations that require repeating expressions should render variables for those expressions in derived tables.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/14065">https://github.com/jOOQ/jOOQ/issues/14065</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="namePathSeparator" type="string" minOccurs="0" maxOccurs="1" default=".">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The character(s) to be used as a separator in paths encoded in a {@link Name}
<p>
A few hierarchical mapping features work with paths encoded in names (specifically field aliases), such as the reflective mapping of nested values when aliasing fields as:
<p>
<pre><code>
SELECT 
  a.first_name AS "book.author.firstName"
  a.last_name AS "book.author.lastName"
FROM ...
</code></pre>
<p>
Not all dialects support "." in identifiers. This setting allows for specifying an alternative String to use as separator, e.g. "__".]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="bindOffsetDateTimeType" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the <code>java.time</code> (JSR 310) type {@link java.time.OffsetDateTime} should be bound natively to JDBC.
<p>
Historically, jOOQ encoded the <code>java.time</code> types as strings to offer better compatibility with older JDBC drivers. By now, most drivers should support the <code>java.time</code> types. Using them may produce better performance both on the server and on the client side.
<p>
This flag allows for reverting to pre-jOOQ 3.14 behaviour, where the default is to bind these types natively.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/9902">https://github.com/jOOQ/jOOQ/issues/9902</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="bindOffsetTimeType" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether the <code>java.time</code> (JSR 310) type {@link java.time.OffsetTime} should be bound natively to JDBC.
<p>
Historically, jOOQ encoded the <code>java.time</code> types as strings to offer better compatibility with older JDBC drivers. By now, most drivers should support the <code>java.time</code> types. Using them may produce better performance both on the server and on the client side.
<p>
This flag allows for reverting to pre-jOOQ 3.14 behaviour, where the default is to bind these types natively.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/9902">https://github.com/jOOQ/jOOQ/issues/9902</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="fetchTriggerValuesAfterSQLServerOutput" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Fetch trigger values after SQL Server <code>OUTPUT</code> clause.
<p>
SQL Server <code>OUTPUT</code> statements do not support fetching trigger generated values.
This is a limitation of the {@link #renderOutputForSQLServerReturningClause}. An additional
<code>MERGE</code> statement can run a second query if (and only if) the primary key has been
included in the <code>OUTPUT</code> clause.
<p>
For details, see <a href="https://github.com/jOOQ/jOOQ/issues/4498">https://github.com/jOOQ/jOOQ/issues/4498</a>.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="fetchIntermediateResult" type="jooq-runtime:FetchIntermediateResult" minOccurs="0" maxOccurs="1" default="WHEN_RESULT_REQUESTED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to fetch data into intermediate {@link org.jooq.Result} instances.
<p>
By default, a {@link org.jooq.ResultQuery} produces no intermediate {@link org.jooq.Result} 
instances if they are not explicitly requested by the caller, e.g. by calling
{@link org.jooq.ResultQuery#fetch()}, or in the presence of {@link org.jooq.ExecuteListener}
instances, which may require access to {@link org.jooq.ExecuteContext#result()}.
This default behaviour helps avoid unnecessary allocations of possibly large data structures.
<p>
Using this flag, fetching of intermediate results can be turned off even when execute listeners
are present, or turned on even if they're absent.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsDuplicateStatements" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#duplicateStatements(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsDuplicateStatementsUsingTransformPatterns" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#duplicateStatements(org.jooq.DiagnosticsContext) diagnostic with the {@link #transformPatterns} feature activated.
<p>
When transforming patterns, many more complex, duplicate SQL statements can be recognised than if simply
parsing and re-rendering the statement. This flag turns on all transformation patterns, independently of their
individual settings.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsMissingWasNullCall" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#missingWasNullCall(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsRepeatedStatements" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#repeatedStatements(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsConsecutiveAggregation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#consecutiveAggregation(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsTooManyColumnsFetched" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#tooManyColumnsFetched(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsTooManyRowsFetched" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#tooManyRowsFetched(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsUnnecessaryWasNullCall" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#unnecessaryWasNullCall(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsPatterns" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the various pattern transformation diagnostics.
<p>
{@link #transformPatterns} allows for applying numerous pattern transformations, which can be turned on separately when running
diagnostics. This flag overrides the {@link #transformPatterns} flag in the diagnostics context. Individual pattern flags
still allow to enable / disable the pattern for diagnostics. 
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsTrivialCondition" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#trivialCondition(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="diagnosticsNullCondition" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to run the {@link org.jooq.DiagnosticsListener#nullConditoin(org.jooq.DiagnosticsContext) diagnostic.
<p>
Diagnostics are turned off if no {@link org.jooq.Configuration#diagnosticsListenerProviders()} are configured.
Once configured, this diagnostic is turned on by default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatterns" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform various syntax patterns to better versions, if possible.
<p>
This flag enables the pattern transformation feature, which consists of several sub-flags that are
all prefixed with "transformPatterns", e.g. {@link #transformPatternsTrim}. While the sub-flags default
to being enabled, and can be disabled on an individual basis, the global feature itself is disabled by
default.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsLogging" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Activate debug logging of the {@link #transformPatterns} feature.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnnecessaryDistinct" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>SELECT DISTINCT a, b FROM t GROUP BY a, b</code> to <code>SELECT a, b FROM t GROUP BY a, b</code>.
<p>
The <code>GROUP BY</code> clause already removes duplicates, so if the <code>DISTINCT</code> clause
contains at least all the columns from <code>GROUP BY</code> then it can be removed.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnnecessaryGroupByExpressions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>SELECT a, b FROM t GROUP BY a, a, b</code> to <code>SELECT a, b FROM t GROUP BY a, b</code>.
<p>
Duplicate <code>GROUP BY</code> expressions can be removed.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnnecessaryOrderByExpressions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>SELECT a, b FROM t ORDER BY a, a, b</code> to <code>SELECT a, b FROM t ORDER BY a, b</code>.
<p>
Duplicate <code>ORDER BY</code> expressions can be removed.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnnecessaryExistsSubqueryClauses" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>[ NOT ] EXISTS (SELECT DISTINCT a, b FROM t ORDER BY c LIMIT d)</code> to <code>[ NOT ] EXISTS (SELECT 1 FROM t)</code>.
<p>
In <code>EXISTS</code> subqueries, quite a few <code>SELECT</code> clauses are meaningless, and can
thus be removed. These include:
<ul>
<li><code>SELECT</code> (any projection can be ignored)</li>
<li><code>DISTINCT</code></li>
<li><code>ORDER BY</code></li>
<li><code>LIMIT</code> (except <code>LIMIT 0</code>, in case of which {@link #transformPatternsTrivialPredicates} applies).</li>
</ul>
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsCountConstant" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>COUNT(1)</code> or any other <code>COUNT(const)</code> to <code>COUNT(*)</code>.
<p>
There is no benefit to counting a constant expression. In fact, in some RDBMS, it might even be slightly
slower, at least in benchmarks.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsTrim" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>LTRIM(RTRIM(x))</code> or <code>RTRIM(LTRIM(x))</code> to <code>TRIM(x)</code>.
<p>
Historically, a few dialects did not implement <code>TRIM(x)</code> or <code>TRIM(BOTH FROM x)</code>,
so users worked around this by wrapping <code>LTRIM()</code> and <code>RTRIM()</code> with each other.
Maintaining this is usually undesirable, so this transformation helps remove the unwanted wrapping.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNotNot" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>NOT(NOT(x))</code> to <code>x</code>.
<p>
This transformation removes a redundant logic negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNotComparison" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>NOT (a != b)</code> to <code>a = b</code>, and similar comparisons.
<p>
This transformation removes a redundant logical negation from the <code>DISTINCT</code> predicate.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNotNotDistinct" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>NOT (a IS NOT DISTINCT FROM b)</code> to <code>a IS DISTINCT FROM b</code>.
<p>
This transformation removes a redundant logical negation from the <code>DISTINCT</code> predicate.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsDistinctFromNull" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>a IS [ NOT ] DISTINCT FROM NULL</code> to <code>a IS [ NOT ] NULL</code>.
<p>
This simplifies the much more verbose <code>DISTINCT</code> predicate.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNormaliseAssociativeOps" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>(a + b) + (c + d)</code> to <code>((a + b) + c) + d</code>.
<p>
This transformation turns trees into lists, which greatly simplifies other tree traversal transformations.
Some of those other transformations currently rely on this flag to be active.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNormaliseInListSingleElementToComparison" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x IN (a)</code> to <code>x = a</code> and <code>x NOT IN (a)</code> to <code>x != a</code>.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNormaliseFieldCompareValue" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>1 = a</code> to <code>a = 1</code>.
<p>
This transformation inverses {@link TableField} [op] {@link org.jooq.impl.QOM.Val} comparisons, if they're not in that order.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNormaliseCoalesceToNvl" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform 2 argument <code>COALESCE(a, b)</code> to <code>NVL(a, b)</code>.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsOrEqToIn" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x = c1 OR x = c2</code> to <code>x IN (c1, c2)</code>.
<p>
This transformation simplifies verbose <code>OR</code> predicates into simpler <code>IN</code> predicates.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsAndNeToNotIn" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x != c1 AND x != c2</code> to <code>x NOT IN (c1, c2)</code>.
<p>
This transformation simplifies verbose <code>AND</code> predicates into simpler <code>NOT IN</code> predicates.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsMergeOrComparison" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x = a OR x > a</code> to <code>x >= a</code>.
<p>
This transformation merges multiple <code>OR</code> connected comparisons to a single comparison using a simpler operator.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsMergeAndComparison" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x >= a AND x <= a</code> to <code>x = a</code>.
<p>
This transformation merges multiple <code>AND</code> connected comparisons to a single comparison using a simpler operator.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsMergeInLists" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x IN (a, b, c) AND x IN (b, c, d)</code> to <code>x IN (b, c)</code>.
<p>
This transformation merges multiple <code>OR</code> connected comparisons to a single comparison using a simpler operator.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsMergeRangePredicates" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x >= a AND x <= b</code> to <code>x BETWEEN a AND b</code>.
<p>
This transformation merges multiple <code>AND</code> connected range predicates to a single comparison using <code>BETWEEN</code>.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsMergeBetweenSymmetricPredicates" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>x BETWEEN a AND b OR x BETWEEN b AND a</code> to <code>x BETWEEN SYMMETRIC a AND b</code>.
<p>
This transformation merges multiple <code>OR</code> connected <code>BETWEEN</code> predicates to a single comparison using <code>BETWEEN SYMMETRIC</code>.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsCaseElseNull" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE .. ELSE NULL</code> removing the <code>ELSE</code> clause.
<p>
<code>CASE WHEN x THEN y ELSE NULL END</code> is equivalent to <code>CASE WHEN x THEN y END</code>.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnreachableCaseClauses" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE</code> by removing unreachable clauses.
<p>
Case clauses can be proven to be unreachable, and thus removed:
<ul>
<li><code>CASE WHEN p THEN 1 WHEN TRUE THEN 2 WHEN q .. ELSE .. END</code> is equivalent to <code>CASE WHEN p THEN 1 ELSE 2 END</code></li>
<li><code>CASE WHEN p THEN 1 WHEN FALSE THEN 2 WHEN q .. ELSE .. END</code> is equivalent to <code>CASE WHEN p THEN 1 WHEN q .. ELSE .. END</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsUnreachableDecodeClauses" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>DECODE</code> by removing unreachable clauses.
<p>
DECODE clauses can be proven to be unreachable, and thus removed:
<ul>
<li><code>DECODE(a, b, 1, c, 2, b, 3)</code> is equivalent to <code>DECODE(a, b, 1, c, 2)</code></li>
<li><code>DECODE(a, b, 1, c, 2, b, 3, 4)</code> is equivalent to <code>DECODE(a, b, 1, c, 2, 4)</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsCaseDistinctToDecode" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE WHEN a IS NOT DISTINCT FROM b ..</code> to an equivalent <code>DECODE</code> function.
<p>
When all <code>WHEN</code> clauses of a <code>CASE</code> expression use the <code>DISTINCT</code> predicate, then the
<code>CASE</code> expression can be transformed into a <code>DECODE</code> function call:
<ul>
<li><code>CASE WHEN a IS NOT DISTINCT FROM b THEN 1 END</code> is equivalent to <code>DECODE(a, b, 1)</code></li>
<li><code>CASE WHEN a IS NOT DISTINCT FROM b THEN 1 ELSE 2 END</code> is equivalent to <code>DECODE(a, b, 1, 2)</code></li>
<li><code>CASE WHEN a IS NOT DISTINCT FROM b THEN 1 WHEN a IS NOT DISTINCT FROM c THEN 2 END</code> is equivalent to <code>DECODE(a, b, 1, c, 2)</code></li>
<li><code>CASE WHEN a IS NOT DISTINCT FROM b THEN 1 WHEN a IS NOT DISTINCT FROM c THEN 2 ELSE 3 END</code> is equivalent to <code>DECODE(a, b, 1, c, 2, 3)</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsCaseMergeWhenWhen" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE WHEN a THEN x WHEN b THEN x END</code> to <code>CASE WHEN a OR b THEN x END</code>.
<p>
Two consecutive <code>WHEN</code> clauses can be merged, if their respective <code>THEN</code> clause is identical.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsCaseMergeWhenElse" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE WHEN a THEN x WHEN b THEN y ELSE y END</code> to <code>CASE WHEN a THEN x ELSE y END</code>.
<p>
The ultimate <code>WHEN</code> clause can be merged with the <code>ELSE</code>, if their respective result is identical.
If the <code>WHEN</code> clause is the only <code>WHEN</code> clause, then the entire <code>CASE</code> expression can
be replaced by the <code>ELSE</code> clause content.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="transformPatternsCaseToCaseAbbreviation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE</code> expressions to their respective abbreviations.
<p>
Some <code>CASE</code> expressions have a shorter abbreviated form, such as <code>COALESCE()</code> or <code>NULLIF()</code>.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="transformPatternsSimplifyCaseAbbreviation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform complex predicates into simpler <code>CASE</code> abbreviations.
<p>
Some predicates can be simplified into case abbreviations, such as, for example
<ul>
<li><code>a IS NULL OR COALESCE(a = b, FALSE)</code> to <code>NULLIF(a, b) IS NULL</code></li>
<li><code>a IS NOT NULL AND COALESCE(a != b, TRUE)</code> to <code>NULLIF(a, b) IS NOT NULL</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsFlattenCaseAbbreviation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Flatten nested <code>CASE</code> abbreviations such as <code>NVL</code> or <code>CASE</code>.
<p>
Nested <code>CASE</code> abbreviations can be flattened, as such:
<ul>
<li><code>NVL(NVL(a, b), c)</code> to <code>COALESCE(a, b, c)</code></li>
<li><code>COALESCE(a, ..., COALESCE(b, ..., c), ..., d)</code> to <code>COALESCE(a, ..., b, ..., c, ..., d)</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsFlattenDecode" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Flatten nested <code>DECODE</code> functions.
<p>
Nested <code>DECODE</code> functions can be flattened, as such:
<ul>
<li><code>DECODE(a, b, c, DECODE(a, d, e))</code> to <code>DECODE(a, b, c, d, e)</code></li>
</ul>
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="transformPatternsFlattenCase" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>CASE .. ELSE CASE ..</code> by flattening the nested <code>CASE</code>.
<p>
<code>CASE WHEN a THEN b ELSE CASE WHEN c THEN d END END</code> is equivalent to <code>CASE WHEN a THEN b WHEN c THEN d END</code>.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
            
      <element name="transformPatternsTrivialCaseAbbreviation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform trivial case abbreviations like <code>NVL(NULL, a)</code> to <code>a</code>.
<p>
This transformation removes any trivial case abbreviations, such as <code>NVL()</code>,
<code>COALESCE()</code>, <code>NULLIF()</code>, etc.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsTrivialPredicates" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform trivial predicates like <code>1 = 1</code> to <code>TRUE</code>.
<p>
This transformation removes any trivial predicates.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsTrivialBitwiseOperations" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform trivial bitwise comparisons like <code>BIT_OR(a, 0)</code> to <code>a</code>.
<p>
This transformation removes any trivial predicates.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsScalarSubqueryCountAsteriskGtZero" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform predicates comparing scalar subqueries with a count <code>(SELECT COUNT(*) ..) > 0</code> to equivalent <code>EXISTS (SELECT 1 ..)</code>.
<p>
Scalar subqueries that count rows and whose count is compared to 0 can be transformed into equivalent, but likely cheaper to execute EXISTS queries.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsScalarSubqueryCountExpressionGtZero" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform predicates comparing scalar subqueries with a count <code>(SELECT COUNT(expr) ..) > 0</code> to equivalent <code>EXISTS (SELECT 1 .. WHERE expr IS NOT NULL)</code>.
<p>
Scalar subqueries that count non-null expressions and whose count is compared to 0 can be transformed into equivalent, but likely cheaper to execute EXISTS queries.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsEmptyScalarSubquery" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform empty scalar subqueries like <code>(SELECT 1 WHERE FALSE)</code> to <code>NULL</code>.
<p>
Scalar subqueries that are guaranteed to produce no results can be replaced by a <code>NULL</code> value.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNegNeg" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>-(-(x))</code> to <code>x</code>
<p>
This transformation removes a redundant arithmetic negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsBitNotBitNot" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>~(~(x))</code> to <code>x</code>.
<p>
This transformation removes a redundant bitwise negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsBitNotBitNand" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>~(bitnand(x, y))</code> to <code>bitand(x, y)</code> and <code>~(bitand(x, y)</code> to <code>bitnand(x, y)</code>.
<p>
This transformation removes a redundant bitwise negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsBitNotBitNor" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>~(bitnor(x, y))</code> to <code>bitor(x, y)</code> and <code>~(bitor(x, y)</code> to <code>bitnor(x, y)</code>.
<p>
This transformation removes a redundant bitwise negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsBitNotBitXNor" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>~(bitxnor(x, y))</code> to <code>bitxor(x, y)</code> and <code>~(bitxor(x, y)</code> to <code>bitxnor(x, y)</code>.
<p>
This transformation removes a redundant bitwise negation.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsNullOnNullInput" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Any {org.jooq.impl.QOM.UReturnsNullOnNullInput} function or expression with <code>NULL</code> arguments can be replaced by <code>NULL</code>.
<p>
There are many built-in SQL functions and operators with a <code>RETURNS NULL ON NULL INPUT</code> property, e.g.
<ul>
<li><code>ABS(NULL)</code></li>
<li><code>MOD(NULL, 1)</code></li>
<li><code>NULL + 1</code></li>
</ul>
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsIdempotentFunctionRepetition" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform all repetitions of idempotent functions, such as <code>UPPER(UPPER(s))</code> to <code>UPPER(s)</code>.
<p>
Idempotent functions that are covered so far, include:
<ul>
<li><code>LTRIM(LTRIM(s))</code> to <code>LTRIM(s)</code></li>
<li><code>LTRIM(TRIM(s))</code> to <code>TRIM(s)</code></li>
<li><code>RTRIM(RTRIM(s))</code> to <code>RTRIM(s)</code></li>
<li><code>RTRIM(TRIM(s))</code> to <code>TRIM(s)</code></li>
<li><code>TRIM(LTRIM(s))</code> to <code>TRIM(s)</code></li>
<li><code>TRIM(RTRIM(s))</code> to <code>TRIM(s)</code></li>
<li><code>UPPER(UPPER(s))</code> to <code>UPPER(s)</code></li>
<li><code>LOWER(LOWER(s))</code> to <code>LOWER(s)</code></li>
</ul>
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsArithmeticExpressions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>1 / y * x</code> to <code>x / y</code>, and other transformations.
<p>
This transformation simplifies arithmetic expressions.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsTrigonometricFunctions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>SIN(x) / COS(x)</code> to <code>TAN(x)</code>, and other transformations.
<p>
This transformation turns expanded trignonometric function definitions into their shorter equivalents.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsLogarithmicFunctions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>LN(value) / LN(base)</code> to <code>LOG(base, value)</code>, and other transformations.
<p>
This transformation turns expanded logarithmic function definitions into their shorter equivalents.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsHyperbolicFunctions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>(EXP(x) - EXP(-x)) / 2</code> to <code>SINH(x)</code>, and other transformations.
<p>
This transformation turns expanded hyperbolic function definitions into their shorter equivalents.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformPatternsInverseHyperbolicFunctions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>LN(x + SQRT(SQUARE(x) + 1))</code> to <code>ASINH(x)</code>, and other transformations.
<p>
This transformation turns expanded inverse hyperbolic function definitions into their shorter equivalents.
<p>
To enable this feature, {@link #transformPatterns} must be enabled as well.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformInlineBindValuesForFieldComparisons" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform {@link org.jooq.impl.QOM.CompareCondition} and a few other types of condition to inline their bind values, in case they match
         
<p>
Historically, prior to ANSI join syntax, joins were implemented by listing tables in 
the FROM clause and providing join predicates in the WHERE clause, possibly using vendor specific
operators like <code>(+)</code> (Oracle, DB2) or <code>*=</code> (SQL Server) for outer join
support. For backwards compatibility with older RDBMS versions, ANSI joins in jOOQ code may be
converted to equivalent table lists in generated SQL using this flag.
<p>
This flag has a limited implementation that supports inner joins (in most cases) and outer joins
(only for simple comparison predicates).
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformAnsiJoinToTableLists" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform ANSI join to table lists if possible.
<p>
Historically, prior to ANSI join syntax, joins were implemented by listing tables in 
the FROM clause and providing join predicates in the WHERE clause, possibly using vendor specific
operators like <code>(+)</code> (Oracle, DB2) or <code>*=</code> (SQL Server) for outer join
support. For backwards compatibility with older RDBMS versions, ANSI joins in jOOQ code may be
converted to equivalent table lists in generated SQL using this flag.
<p>
This flag has a limited implementation that supports inner joins (in most cases) and outer joins
(only for simple comparison predicates).
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
            
      <element name="transformInConditionSubqueryWithLimitToDerivedTable" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="WHEN_NEEDED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform a subquery from an IN condition with LIMIT to an equivalent derived table.
<p>
This transformation works around a known MySQL limitation "ERROR 1235 (42000): This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'"
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformQualify" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="WHEN_NEEDED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform the <code>QUALIFY</code> clause to an equivalent derived table to filter on window functions.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformTableListsToAnsiJoin" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform table lists to ANSI join if possible.
<p>
(Very) historically, prior to ANSI join syntax, joins were implemented by listing tables in 
the FROM clause and providing join predicates in the WHERE clause, possibly using vendor specific
operators like <code>(+)</code> (Oracle, DB2) or <code>*=</code> (SQL Server) for outer join
support. Migrating such join syntax is tedious. The jOOQ parser can parse the old syntax and
this flag enables the transformation to ANSI join syntax.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformRownum" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="NEVER">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>ROWNUM</code> expressions to corresponding <code>LIMIT</code> clauses or <code>ROW_NUMBER()</code> expressions.
<p>
In Oracle 11g and less, <code>ROWNUM</code> filtering was the most popular way to paginate. This pseudo
column is not supported in other RDBMS, and should be replaced in Oracle 12c by the FETCH clause or
<code>ROW_NUMBER() OVER ()</code> filtering. This transformation allows for replacing such a filter by
equivalent SQL, if possible.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformUnneededArithmeticExpressions" type="jooq-runtime:TransformUnneededArithmeticExpressions" minOccurs="0" maxOccurs="1" default="NEVER">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform arithmetic expressions on literals and bind variables.
<p>
Arithmetic expressions may be implemented by the user, or arise from emulations from within jOOQ.
Expressions on literals and bind variables could be evaluated in the client prior to generating SQL.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformGroupByColumnIndex" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="WHEN_NEEDED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform <code>GROUP BY [column index]</code> clauses by substituting the column index.
<p>
Not all dialects support grouping by column index, which is a convenient but also a bit confusing feature of
some dialects. jOOQ can transform the syntax into an equivalent syntax where the referenced <code>SELECT</code>
expression is duplicated into the <code>GROUP BY</code> clause.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="transformInlineCTE" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="WHEN_NEEDED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform Common Table Expressions (CTE) by inlining their <code>WITH</code> clause definition to wherever they're referenced.
<p>
Non-recursive CTE are just syntax sugar for inline views (derived tables). When they're not supported natively,
jOOQ can simply inline their definition to wherever they're referenced.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="backslashEscaping" type="jooq-runtime:BackslashEscaping" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether string literals should be escaped with backslash.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="paramType" type="jooq-runtime:ParamType" minOccurs="0" maxOccurs="1" default="INDEXED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Specify how bind variables are to be rendered.
<p>
Possibilities include:

- question marks
- named parameters
- named or inlined parameters
- inlined parameters

This value is overridden by statementType == STATIC_STATEMENT, in
case of which, this defaults to INLINED]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="paramCastMode" type="jooq-runtime:ParamCastMode" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether rendered bind values should be cast to their respective type.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="statementType" type="jooq-runtime:StatementType" minOccurs="0" maxOccurs="1" default="PREPARED_STATEMENT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The type of statement that is to be executed.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="inlineThreshold" type="int" minOccurs="0" maxOccurs="1" default="0">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The maximum number of allowed bind variables before inlining all values where <code>0</code> uses the dialect defaults: <ul>
<li>{@link org.jooq.SQLDialect#ACCESS} : 768</li>
<li>{@link org.jooq.SQLDialect#ASE} : 2000</li>
<li>{@link org.jooq.SQLDialect#INGRES} : 1024</li>
<li>{@link org.jooq.SQLDialect#ORACLE} : 32767</li>
<li>{@link org.jooq.SQLDialect#POSTGRES} : 32767</li>
<li>{@link org.jooq.SQLDialect#SQLITE} : 999</li>
<li>{@link org.jooq.SQLDialect#SQLSERVER} : 2100</li>
</ul>]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="transactionListenerStartInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]start() methods registered {@link org.jooq.TransactionListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="transactionListenerEndInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]end() methods registered {@link org.jooq.TransactionListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="migrationListenerStartInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]start() methods registered {@link org.jooq.MigrationListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="migrationListenerEndInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]end() methods registered {@link org.jooq.MigrationListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="visitListenerStartInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]start() methods registered {@link org.jooq.VisitListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="visitListenerEndInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]end() methods registered {@link org.jooq.VisitListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="recordListenerStartInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]start() methods registered {@link org.jooq.RecordListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="recordListenerEndInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]end() methods registered {@link org.jooq.RecordListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeListenerStartInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]start() methods registered {@link org.jooq.ExecuteListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeListenerEndInvocationOrder" type="jooq-runtime:InvocationOrder" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The order of invocation for [action]end() methods registered {@link org.jooq.ExecuteListener}s.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeLogging" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[When set to true, this will add jOOQ's default logging ExecuteListeners.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="diagnosticsLogging" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[When set to true, this will add jOOQ's default logging DiagnosticsListeners.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="updateRecordVersion" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether store(), insert(), and update() methods should update the record version prior to the operation, for use with {@link #executeWithOptimisticLocking}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="updateRecordTimestamp" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether store(), insert(), and update() methods should update the record timestamp prior to the operation, for use with {@link #executeWithOptimisticLocking}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeWithOptimisticLocking" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether store() and delete() methods should be executed with optimistic locking.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeWithOptimisticLockingExcludeUnversioned" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether store() and delete() methods should be executed with optimistic locking also on "unversioned" tables,
i.e. on tables that do not have a version and/or timestamp column.
<p>
This flag has no effect when "executeWithOptimisticLocking" is turned off.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="attachRecords" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether fetched records should be attached to the fetching configuration.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="insertUnchangedRecords" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether {@link org.jooq.TableRecord#insert()} calls should be executed if the record is unchanged. This also affects the <code>INSERT</code> part of {@link org.jooq.UpdatableRecord#store()} and {@link org.jooq.UpdatableRecord#merge()} calls.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="updateUnchangedRecords" type="jooq-runtime:UpdateUnchangedRecords" minOccurs="0" maxOccurs="1" default="NEVER">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether {@link org.jooq.UpdatableRecord#update()} calls should be executed if the record is unchanged. This also affects the <code>UPDATE</code> part of {@link org.jooq.UpdatableRecord#store()} and {@link org.jooq.UpdatableRecord#merge()} calls.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="updatablePrimaryKeys" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether primary key values are deemed to be "updatable" in jOOQ.
<p>
Setting this to "true" will allow for updating primary key values through
UpdatableRecord.store() and UpdatableRecord.update().]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="reflectionCaching" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether reflection information should be cached in the configuration.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="cacheRecordMappers" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether record mappers should be cached in the configuration.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="cacheParsingConnection" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether parsing connection translations should be cached in the configuration.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="cacheParsingConnectionLRUCacheSize" type="int" minOccurs="0" maxOccurs="1" default="8192">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default implementation of the ParsingConnection cache's LRU cache size.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="cachePreparedStatementInLoader" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether JDBC {@link java.sql.PreparedStatement} instances should be cached in loader API.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="throwExceptions" type="jooq-runtime:ThrowExceptions" minOccurs="0" maxOccurs="1" default="THROW_ALL">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[A strategy defining how exceptions from the database / JDBC driver should be propagated]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="fetchWarnings" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether warnings should be fetched after each query execution.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="fetchServerOutputSize" type="int" minOccurs="0" maxOccurs="1" default="0">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether server output should be fetched after each query execution.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="returnIdentityOnUpdatableRecord" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether calls to store(), insert() and update() should return the identity column.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="returnAllOnUpdatableRecord" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether calls to store(), insert() and update() should return all columns, not just identity columns.
<p>
Do note that only few databases support this feature. It is supported only in case the INSERT's or UPDATE's
RETURNING clause is fully supported, also for non-IDENTITY columns.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="returnRecordToPojo" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether calls to store(), insert(), update(), and delete() that are called on an UpdatableRecord
that is created from a POJO (e.g. in a DAO) should return all Record values to the POJO, including
IDENTITY values, and if {@link #returnAllOnUpdatableRecord} is active, also other values.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="mapJPAAnnotations" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether JPA annotations should be considered by the DefaultRecordMapper.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="mapRecordComponentParameterNames" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether constructor parameter names obtained from the {@link java.lang.Record} component names should be considered by the DefaultRecordMapper.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="mapConstructorPropertiesParameterNames" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether constructor parameter names obtained from the {@link java.beans.ConstructorProperties} annotation should be considered by the DefaultRecordMapper.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="mapConstructorParameterNames" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether constructor parameter names obtained via reflection in Java 8+ should be considered by the DefaultRecordMapper. This flag has no effect in Java 6 or 7.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="mapConstructorParameterNamesInKotlin" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether constructor parameter names obtained via reflection in Kotlin should be considered by the DefaultRecordMapper. This flag has no effect in Java.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="queryPoolable" type="jooq-runtime:QueryPoolable" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default JDBC poolable property that should be applied to all
jOOQ queries, for which no specific poolable flag was specified.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="queryTimeout" type="int" minOccurs="0" maxOccurs="1" default="0">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default JDBC queryTimeout property that should be applied to all
jOOQ queries, for which no specific queryTimeout was specified.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="maxRows" type="int" minOccurs="0" maxOccurs="1" default="0">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default JDBC maxRows property that should be applied to all
jOOQ queries, for which no specific maxRows value was specified.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="fetchSize" type="int" minOccurs="0" maxOccurs="1" default="0">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default JDBC fetchSize property that should be applied to all
jOOQ queries, for which no specific fetchSize value was specified.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="batchSize" type="int" minOccurs="0" maxOccurs="1" default="2147483647">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[A property specifying a batch size that should be applied to all automatically created {@link org.jooq.tools.jdbc.BatchedConnection} instances.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="debugInfoOnStackTrace" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#5570] Whether exception stack traces should be enhanced with additional debug information.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="inListPadding" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#5600] Whether IN lists in IN predicates should be padded to powers of inListPadBase (default 2).]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="inListPadBase" type="int" minOccurs="0" maxOccurs="1" default="2">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7095] The base to use to calculate the powers of when applying in list padding.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="delimiter" type="string" minOccurs="0" maxOccurs="1" default=";">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#5826] The delimiter character to be used to delimit statements in batches.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="emulateOnDuplicateKeyUpdateOnPrimaryKeyOnly" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#6462] Use only the primary key to emulate MySQL's INSERT .. ON DUPLICATE KEY UPDATE statement. In MySQL, the statement considers all unique keys for duplicates to apply an update rather than an insert. Earlier versions of jOOQ considered only the PRIMARY KEY. This flag can be turned on to maintain backwards compatibility.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="emulateMultiset" type="jooq-runtime:NestedCollectionEmulation" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#3884] How <code>MULTISET</code> support should be emulated.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="emulateComputedColumns" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#13418] Whether computed columns should be emulated in the client.
<p>
This can be useful if a schema was generated using a dialect that supports computed columns, but it is
deployed on an RDBMS that does not.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="executeUpdateWithoutWhere" type="jooq-runtime:ExecuteWithoutWhere" minOccurs="0" maxOccurs="1" default="LOG_DEBUG">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#6771] Specifies whether UPDATE statements are allowed to be executed lacking a WHERE clause. This has no effect on rendering the statements SQL string.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="executeDeleteWithoutWhere" type="jooq-runtime:ExecuteWithoutWhere" minOccurs="0" maxOccurs="1" default="LOG_DEBUG">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#6771] Specifies whether DELETE statements are allowed to be executed lacking a WHERE clause. This has no effect on rendering the statements SQL string.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="interpreterDialect" type="string" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7337] The dialect that should be used to interpret SQL DDL statements. {@link SQLDialect#DEFAULT} means that jOOQ interprets the SQL itself. Any other dialect (if supported) will be interpreted on an actual JDBC connection.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="interpreterNameLookupCaseSensitivity" type="jooq-runtime:InterpreterNameLookupCaseSensitivity" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9633] The case sensitivity of identifiers used when interpreting SQL DDL statements.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
            
      <element name="interpreterLocale" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The Locale to be used with any interpreter locale dependent logic, defaulting to {@link #getLocale()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="interpreterSearchPath" type="jooq-runtime:InterpreterSearchSchemata" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9677] The search path to be used for unqualified table lookups by the interpreter.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
            
      <element name="interpreterDelayForeignKeyDeclarations" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Using this flag, the interpreter will be able to delay the addition of foreign key declarations until the end of the interpretation run.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="metaIncludeSystemIndexes" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The {@link org.jooq.Meta} implementation that is backed by {@link java.sql.DatabaseMetaData} does not produce system generated indexes on constraints, by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="metaIncludeSystemSequences" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The {@link org.jooq.Meta} implementation that is backed by {@link java.sql.DatabaseMetaData} does not produce system generated sequences, by default.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationSchemata" type="jooq-runtime:MigrationSchemata" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The database objects that are included in the migration.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationAllowsUndo" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether migrations are allowed to be executed in inverse order.<p><strong>This is a potentially destructive feature, which should not be turned on in production</strong>. It is useful mostly to quickly switch between branches in a development environment. This feature is available only in commercial distributions.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationRevertUntracked" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether migrations revert any untracked changes in the schemas that are being migrated.<p><strong>This is a potentially destructive feature, which should not be turned on in production</strong>. It is useful mostly to quickly revert any elements created in a development environment. This feature is available only in commercial distributions.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationAutoBaseline" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether to automatically existing schemas that are not yet managed by jOOQ Migrations.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationAutoValidation" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Whether a migration automatically runs a validation first.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="migrationIgnoreDefaultTimestampPrecisionDiffs" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Various <code>migrateTo()</code> methods (e.g. {@link org.jooq.Meta#migrateTo(org.jooq.Meta)}) ignore the difference between <code>TIMESTAMP</code> and <code>TIMESTAMP(6)</code>, if 6 is the default precision for timestamps on the configured dialect.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="locale" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The Locale to be used with any locale dependent logic if there is not a more specific locale available. More specific locales include e.g. {@link #getRenderLocale()}, {@link #getParseLocale()}, or {@link #getInterpreterLocale()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseDialect" type="string" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7337] The input dialect that should be chosen to disambiguate ambiguous SQL syntax.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseLocale" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The Locale to be used with any parser locale dependent logic, defaulting to {@link #getLocale()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseDateFormat" type="string" minOccurs="0" maxOccurs="1" default="YYYY-MM-DD">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The date format to use when parsing functions whose behaviour depends on some session date format, such as NLS_DATE_FORMAT in Oracle]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseTimestampFormat" type="string" minOccurs="0" maxOccurs="1" default="YYYY-MM-DD HH24:MI:SS.FF">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The timestamp format to use when parsing functions whose behaviour depends on some session date format, such as NLS_TIMESTAMP_FORMAT in Oracle]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseNamedParamPrefix" type="string" minOccurs="0" maxOccurs="1" default=":">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The prefix to use for named parameters in parsed SQL.
<p>
Named parameter syntax defaults to <code>:name</code> (such as supported by Oracle, JPA, Spring), but 
vendor specific parameters may look differently. This flag can be used to determine the prefix to be
used by named parameters, such as <code>@</code> for SQL Server's <code>@name</code> or <code>$</code>
for PostgreSQL's <code>$name</code> when parsing SQL.
<p>
"Named indexed" parameters can be obtained in the same way by specifingy {@code ParamType#NAMED} and not
providing a name to parameters, resulting in <code>:1</code> or <code>@1</code> or <code>$1</code>, etc.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseNameCase" type="jooq-runtime:ParseNameCase" minOccurs="0" maxOccurs="1" default="DEFAULT">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7337] The default name case for parsed identifiers.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseWithMetaLookups" type="jooq-runtime:ParseWithMetaLookups" minOccurs="0" maxOccurs="1" default="OFF">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7163] Whether the parser should perform meta lookups in the Configuration's MetaProvider.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseAppendMissingTableReferences" type="jooq-runtime:Transformation" minOccurs="0" maxOccurs="1" default="WHEN_NEEDED">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Transform the parsed SQL to append missing table references to the query's <code>FROM</code> or <code>USING</code> clause, if applicable.
<p>
Teradata (and possibly others) allow for referencing tables that are not listed in the <code>FROM</code>
clause, such as <code>SELECT t.* FROM t WHERE t.i = u.i</code>. This transformation is executed in the
parser, to produce <code>SELECT t.* FROM t, u WHERE t.i = u.i</code>, instead. By default, it is active
when the input dialect supports this syntax.
<p>
This feature is available in the commercial distribution only.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseSearchPath" type="jooq-runtime:ParseSearchSchemata" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#8616] The search path to be used for unqualified table lookups by the parser.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseSetCommands" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9780] Whether commands of the type <code>SET key = value</code> should be parsed rather than ignored.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseUnsupportedSyntax" type="jooq-runtime:ParseUnsupportedSyntax" minOccurs="0" maxOccurs="1" default="IGNORE">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#5917] Whether the parser should accept unsupported (but known) syntax.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseUnknownFunctions" type="jooq-runtime:ParseUnknownFunctions" minOccurs="0" maxOccurs="1" default="FAIL">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7344] Whether the parser should accept unknown functions.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseIgnoreCommercialOnlyFeatures" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#13109] Whether the parser of the jOOQ Open Source Edition should ignore commercial only features, rather than failing.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseIgnoreComments" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#8325] Whether the parser should ignore content between ignore comment tokens.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseIgnoreCommentStart" type="string" minOccurs="0" maxOccurs="1" default="[jooq ignore start]">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#8325] The ignore comment start token]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseIgnoreCommentStop" type="string" minOccurs="0" maxOccurs="1" default="[jooq ignore stop]">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#8325] The ignore comment stop token]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="parseRetainCommentsBetweenQueries" type="boolean" minOccurs="0" maxOccurs="1" default="false">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#12538] Whether the parser should retain comments and whitespace between queries when parsing multiple queries through {@link org.jooq.Parser#parse(String)}.
<p>
jOOQ's query object model doesn't have a way to represent comments
or other whitespace, and as such, the parser simply skips them by default.
However, it may be desirable to retain comments before or in between top
level queries, when parsing multiple such queries in a script. Comments
inside of queries (including procedural statements) are still not supported.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="parseMetaDefaultExpressions" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#8469] Whether to parse default expressions retrieved from {@link java.sql.DatabaseMetaData}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="readonlyTableRecordInsert" type="jooq-runtime:WriteIfReadonly" minOccurs="0" maxOccurs="1" default="IGNORE">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9864] The behaviour when trying to insert into readonly columns using {@link org.jooq.TableRecord#insert()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="readonlyUpdatableRecordUpdate" type="jooq-runtime:WriteIfReadonly" minOccurs="0" maxOccurs="1" default="IGNORE">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9864] The behaviour when trying to update a readonly column using {@link org.jooq.UpdatableRecord#update()}.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="readonlyInsert" type="jooq-runtime:WriteIfReadonly" minOccurs="0" maxOccurs="1" default="IGNORE">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9864] The behaviour when trying to insert into readonly columns using {@link org.jooq.Insert} statements, or the insert clause of a {@link org.jooq.Merge} statement.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="readonlyUpdate" type="jooq-runtime:WriteIfReadonly" minOccurs="0" maxOccurs="1" default="IGNORE">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#9864] The behaviour when trying to update a readonly column using {@link org.jooq.Update} statements, or the update clause of a {@link org.jooq.Merge} statement.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      
      <element name="applyWorkaroundFor7962" type="boolean" minOccurs="0" maxOccurs="1" default="true">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[[#7963] Apply workaround for ORA-04043 when inserting into Oracle tables with qualified, quoted identifiers, and fetching generated keys]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="ParseSearchSchemata">
    <sequence>
      <element name="schema" type="jooq-runtime:ParseSearchSchema" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <complexType name="ParseSearchSchema">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A schema that is on the search path.]]></jxb:javadoc></jxb:class></appinfo></annotation>
    <all>
      <element name="catalog" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The catalog qualifier of the schema, if applicable.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      <element name="schema" type="string" minOccurs="1" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The schema qualifier whose elements can be found from the search path.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="InterpreterSearchSchemata">
    <sequence>
      <element name="schema" type="jooq-runtime:InterpreterSearchSchema" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <complexType name="InterpreterSearchSchema">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A schema that is on the search path.]]></jxb:javadoc></jxb:class></appinfo></annotation>
    
    <all>
      <element name="catalog" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The catalog qualifier of the schema, if applicable.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      <element name="schema" type="string" minOccurs="1" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The schema qualifier whose elements can be found from the search path.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>
  
  <complexType name="MigrationSchemata">
    <sequence>
      <element name="schema" type="jooq-runtime:MigrationSchema" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>  
  
  <complexType name="MigrationSchema">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A migration schema configuration.]]></jxb:javadoc></jxb:class></appinfo></annotation>
    
    <all>
      <element name="catalog" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The catalog qualifier of the schema, if applicable.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
      <element name="schema" type="string" minOccurs="1" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The schema qualifier whose elements can be found from the search path.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="RenderMapping">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[The runtime schema and table mapping.]]></jxb:javadoc></jxb:class></appinfo></annotation>

    <all>
      <element name="defaultCatalog" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default catalog as defined in {@link org.jooq.Catalog#getName()}.
<p>
This catalog will be omitted in rendered SQL.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="defaultSchema" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The default schema as defined in {@link org.jooq.Schema#getName()}.
<p>
This schema will be omitted in rendered SQL.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="catalogs" type="jooq-runtime:MappedCatalogs" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The mapped catalogs configuration.
<p>
Either &lt;catalogs/&gt; or &lt;schemata/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="schemata" type="jooq-runtime:MappedSchemata" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The mapped schemata configuration.
<p>
Either &lt;catalogs/&gt; or &lt;schemata/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="MappedCatalogs">
    <sequence>
      <element name="catalog" type="jooq-runtime:MappedCatalog" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <complexType name="MappedCatalog">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A catalog mapping configuration.]]></jxb:javadoc></jxb:class></appinfo></annotation>

    <all>
      <element name="input" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The input catalog name as defined in {@link org.jooq.Catalog#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="inputExpression" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[A regular expression matching the input catalog name as defined in {@link org.jooq.Catalog#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="output" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The output catalog as it will be rendered in SQL.
<ul>
<li>When this is omitted, you can still apply schema and table mapping.</li>
<li>When &lt;input/&gt; is provided, &lt;output/&gt; is a constant value.</li>
<li>When &lt;inputExpression/&gt; is provided, &lt;output/&gt; is a replacement expression</li>
</ul>]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="schemata" type="jooq-runtime:MappedSchemata" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Configure schema mapping for runtime table rewriting in generated SQL.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="MappedSchemata">
    <sequence>
      <element name="schema" type="jooq-runtime:MappedSchema" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <complexType name="MappedSchema">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A schema mapping configuration.]]></jxb:javadoc></jxb:class></appinfo></annotation>

    <all>
      <element name="input" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The input schema name as defined in {@link org.jooq.Schema#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="inputExpression" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[A regular expression matching the input schema name as defined in {@link org.jooq.Schema#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="output" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The output schema as it will be rendered in SQL.
<ul>
<li>When this is omitted, you can still apply table mapping.</li>
<li>When &lt;input/&gt; is provided, &lt;output/&gt; is a constant value.</li>
<li>When &lt;inputExpression/&gt; is provided, &lt;output/&gt; is a replacement expression</li>
</ul>]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="tables" type="jooq-runtime:MappedTables" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[Configure table mapping for runtime table rewriting in generated SQL.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <complexType name="MappedTables">
    <sequence>
      <element name="table" type="jooq-runtime:MappedTable" minOccurs="0" maxOccurs="unbounded"/>
    </sequence>
  </complexType>

  <complexType name="MappedTable">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[A table mapping configuration.]]></jxb:javadoc></jxb:class></appinfo></annotation>

    <all>

      <element name="input" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The input table as defined in {@link org.jooq.Table#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="inputExpression" type="string" minOccurs="0" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[A regular expression matching the input table name as defined in {@link org.jooq.Table#getName()}
<p>
Either &lt;input/&gt; or &lt;inputExpression/&gt; must be provided]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="output" type="string" minOccurs="1" maxOccurs="1">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The output table as it will be rendered in SQL.
<ul>
<li>When &lt;input/&gt; is provided, &lt;output/&gt; is a constant value.</li>
<li>When &lt;inputExpression/&gt; is provided, &lt;output/&gt; is a replacement expression.</li>
</ul>]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <simpleType name="ParamType">
    <restriction base="string">

      <!-- Execute statements with indexed parameters, the way JDBC expects them -->
      <enumeration value="INDEXED"/>

      <!-- Execute statements with indexed parameters, forcing explicit inlined and named parameters to be indexed as well -->
      <enumeration value="FORCE_INDEXED"/>

      <!-- Execute statements with named parameters -->
      <enumeration value="NAMED"/>

      <!-- Execute statements with named parameters, if a name is given, or inlined parameters otherwise -->
      <enumeration value="NAMED_OR_INLINED"/>

      <!-- Execute statements with inlined parameters -->
      <enumeration value="INLINED"/>
    </restriction>
  </simpleType>

  <simpleType name="ParamCastMode">
    <restriction base="string">

      <!-- Bind values are always cast to their respective type. -->
      <enumeration value="ALWAYS"/>

      <!-- Bind values are cast to their respective type when needed.

           Some databases are not able to delay bind value type inference until the execution of a statement.
           They will either reject the value of unknown type, or assume a possibly inappropriate type. In these
           cases, jOOQ will generate an explicit cast(? as datatype) expression around the bind value to help
           the query parser do its job. The exact behaviour of this mode is undefined and subject to change. -->
      <enumeration value="DEFAULT"/>

      <!-- Bind values are never cast to their respective type. -->
      <enumeration value="NEVER"/>
    </restriction>
  </simpleType>

  <simpleType name="StatementType">
    <restriction base="string">

      <!-- Execute statements with inlined bind values, avoiding JDBC's PreparedStatements -->
      <enumeration value="STATIC_STATEMENT"/>

      <!-- Execute statements with bind values, using JDBC's PreparedStatements -->
      <enumeration value="PREPARED_STATEMENT"/>
    </restriction>
  </simpleType>
  
  <simpleType name="InvocationOrder">
    <restriction base="string">
    
      <!-- The first registered listener is invoked first -->
      <enumeration value="DEFAULT"/>
    
      <!-- The first registered listener is invoked last -->
      <enumeration value="REVERSE"/>
    </restriction>
  </simpleType>

  <simpleType name="RenderNameStyle">
    <annotation>
      <appinfo>
        <annox:annotateEnum>@java.lang.Deprecated</annox:annotateEnum>
      </appinfo>
    </annotation>
    <restriction base="string">

      <!-- Render object names quoted, as defined in the database. Use this
           to stay on the safe side with case-sensitivity and special
           characters. For instance:
           Oracle    : "SYS"."ALL_TAB_COLS"
           MySQL     : `information_schema`.`TABLES`
           SQL Server: [INFORMATION_SCHEMA].[TABLES] -->
      <enumeration value="QUOTED"/>

      <!-- Render object names, as defined in the database. For instance:
           Oracle    : SYS.ALL_TAB_COLS
           MySQL     : information_schema.TABLES
           SQL Server: INFORMATION_SCHEMA.TABLES -->
      <enumeration value="AS_IS"/>

      <!-- Force rendering object names in lower case. For instance:
           Oracle    : sys.all_tab_cols
           MySQL     : information_schema.tables
           SQL Server: information_schema.tables -->
      <enumeration value="LOWER"/>

      <!-- Force rendering object names in upper case. For instance:
           Oracle    : SYS.ALL_TAB_COLS
           MySQL     : INFORMATION_SCHEMA.TABLES
           SQL Server: INFORMATION_SCHEMA.TABLES -->
      <enumeration value="UPPER"/>
    </restriction>
  </simpleType>

  <simpleType name="RenderQuotedNames">
    <restriction base="string">

      <!-- Always render object names quoted, as defined in the database.
           Use this to stay on the safe side with case-sensitivity, special
           characters, and keywords. For instance:
           Oracle    : "SYS"."ALL_TAB_COLS"
           MySQL     : `information_schema`.`TABLES`
           SQL Server: [INFORMATION_SCHEMA].[TABLES] -->
      <enumeration value="ALWAYS"/>
      
      <!-- Render object names quoted if they are constructed using DSL.quotedName() or DSL.name() -->
      <enumeration value="EXPLICIT_DEFAULT_QUOTED"/>
      
      <!-- Render object names quoted if they are constructed using DSL.quotedName() -->
      <enumeration value="EXPLICIT_DEFAULT_UNQUOTED"/>

      <!-- Never quote names -->
      <enumeration value="NEVER"/>
    </restriction>
  </simpleType>

  <simpleType name="RenderNameCase">
    <restriction base="string">

      <!-- Render object names, as defined in the database. For instance: schema.TABLE -->
      <enumeration value="AS_IS"/>

      <!-- Force rendering object names in lower case. For instance: schema."table" -->
      <enumeration value="LOWER"/>

      <!-- Force rendering object names in lower case, if unquoted. For instance schema."TABLE" -->
      <enumeration value="LOWER_IF_UNQUOTED"/>

      <!-- Force rendering object names in upper case. For instance: SCHEMA."TABLE" -->
      <enumeration value="UPPER"/>

      <!-- Force rendering object names in upper case, if unquoted. For instance SCHEMA."table" -->
      <enumeration value="UPPER_IF_UNQUOTED"/>
    </restriction>
  </simpleType>

  <simpleType name="RenderKeywordCase">
    <restriction base="string">

      <!-- Keywords are rendered "as is", i.e. mostly in lower case. For instance:
           select .. from .. where .. -->
      <enumeration value="AS_IS"/>

      <!-- Keywords are rendered in lower case. For instance:
           select .. from .. where .. -->
      <enumeration value="LOWER"/>

      <!-- Keywords are rendered in upper case. For instance:
           SELECT .. FROM .. WHERE .. -->
      <enumeration value="UPPER"/>

      <!-- Keywords are rendered in Pascal Case. For instance:
           Select .. From .. Where .. -->
      <enumeration value="PASCAL"/>
    </restriction>
  </simpleType>

  <simpleType name="RenderKeywordStyle">
    <annotation>
      <appinfo>
        <annox:annotateEnum>@java.lang.Deprecated</annox:annotateEnum>
      </appinfo>
    </annotation>
    <restriction base="string">

      <!-- Keywords are rendered "as is", i.e. mostly in lower case. For instance:
           select .. from .. where .. -->
      <enumeration value="AS_IS"/>

      <!-- Keywords are rendered in lower case. For instance:
           select .. from .. where .. -->
      <enumeration value="LOWER"/>

      <!-- Keywords are rendered in upper case. For instance:
           SELECT .. FROM .. WHERE .. -->
      <enumeration value="UPPER"/>

      <!-- Keywords are rendered in Pascal Case. For instance:
           Select .. From .. Where .. -->
      <enumeration value="PASCAL"/>
    </restriction>
  </simpleType>

  <complexType name="RenderFormatting">
    <annotation><appinfo><jxb:class><jxb:javadoc><![CDATA[All sorts of formatting flags / settings.]]></jxb:javadoc></jxb:class></appinfo></annotation>

    <all>
      <element name="newline" type="string" minOccurs="0" maxOccurs="1" default="&#10;">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The character to be used for line breaks.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="indentation" type="string" minOccurs="0" maxOccurs="1" default="  ">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The characters to be used for indentation.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>

      <element name="printMargin" type="int" minOccurs="0" maxOccurs="1" default="80">
        <annotation><appinfo><jxb:property><jxb:javadoc><![CDATA[The print margin after which (some) formatted elements will break lines.]]></jxb:javadoc></jxb:property></appinfo></annotation>
      </element>
    </all>
  </complexType>

  <simpleType name="BackslashEscaping">
    <restriction base="string">

      <!-- Use the JDBC connection's setting for backslash escaping. In most databases, this
           is the same as OFF. In MySQL and MariaDB, the actual setting is extracted.

           This is not yet implemented, as the JDBC connection might not be available to the renderer
      <enumeration value="AUTO"/>
        -->

      <!-- Use the database's most sensible default value for ON (MySQL, MariaDB) / OFF (all other databases) -->
      <enumeration value="DEFAULT"/>

      <!-- Always escape backslashes. -->
      <enumeration value="ON"/>

      <!-- Never escape backslashes. -->
      <enumeration value="OFF"/>
    </restriction>
  </simpleType>

  <simpleType name="ThrowExceptions">
    <restriction base="string">

      <!-- Collect all exceptions from a batch and throw them all together -->
      <enumeration value="THROW_ALL"/>

      <!-- Throw only the first exception from a batch -->
      <enumeration value="THROW_FIRST"/>

      <!-- Throw no exceptions, but collect them in ResultOrRows -->
      <enumeration value="THROW_NONE"/>
    </restriction>
  </simpleType>

  <simpleType name="ExecuteWithoutWhere">
    <restriction base="string">

      <!-- UPDATE and DELETE statements are allowed to lack a WHERE clause -->
      <enumeration value="IGNORE"/>

      <!-- UPDATE and DELETE statements are allowed to lack a WHERE clause, but this is logged as DEBUG level -->
      <enumeration value="LOG_DEBUG"/>

      <!-- UPDATE and DELETE statements are allowed to lack a WHERE clause, but this is logged as INFO level -->
      <enumeration value="LOG_INFO"/>

      <!-- UPDATE and DELETE statements are allowed to lack a WHERE clause, but this is logged as WARN level -->
      <enumeration value="LOG_WARN"/>

      <!-- UPDATE and DELETE statements are not allowed to lack a WHERE clause -->
      <enumeration value="THROW"/>
    </restriction>
  </simpleType>
  
  <simpleType name="RenderImplicitJoinType">
    <restriction base="string">
    
      <!-- By default, render LEFT JOIN for nullable foreign keys, and INNER JOIN for non-nullable foreign keys -->
      <enumeration value="DEFAULT"/>
      
      <!-- Always render INNER JOIN -->
      <enumeration value="INNER_JOIN"/>
      
      <!-- Always render LEFT JOIN -->
      <enumeration value="LEFT_JOIN"/>
    </restriction>
  </simpleType>
  
  <simpleType name="RenderDefaultNullability">
    <restriction base="string">
    
      <!-- Do not produce any nullability clause for Nullability.DEFAULT, and thus produce the dialect specific default behaviors -->
      <enumeration value="IMPLICIT_DEFAULT"/>
      
      <!-- Produce the dialect specific default behaviour, but generate it explicitly
      <enumeration value="EXPLICIT_DEFAULT"/> 
        -->
      
      <!-- Produce implicit nullability for Nullability.DEFAULT if NULL is the default for a given dialect, or explicit nullability otherwise (e.g. in both Sybase) -->
      <enumeration value="IMPLICIT_NULL"/>
      
      <!-- Produce explicit nullability for Nullability.DEFAULT, irrespective of the context (e.g. if the column is a primary key) -->
      <enumeration value="EXPLICIT_NULL"/>
    </restriction>
  </simpleType>
  
  <simpleType name="RenderOptionalKeyword">
    <restriction base="string">
    
      <!-- Optional keywords will never be generated (does not affect mandatory keywords). -->
      <enumeration value="OFF"/>

      <!-- Optional keywords will always be generated (does not affect mandatory keywords). -->
      <enumeration value="ON"/>

      <!-- The default applies for optional keywords. -->
      <enumeration value="DEFAULT"/>
    </restriction>
  </simpleType>
  
  <simpleType name="RenderImplicitWindowRange">
    <restriction base="string">
    
      <!-- Implicit RANGE clause will not be generated explicitly. The RDBMS's implicit behaviour is used -->
      <enumeration value="OFF"/>
      
      <!-- Implicit RANGE clause is generated as ROWS UNBOUNDED PRECEDING -->
      <enumeration value="ROWS_UNBOUNDED_PRECEDING"/>

      <!-- Implicit RANGE clause is generated as ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING -->
      <enumeration value="ROWS_ALL"/>

      <!-- Implicit RANGE clause is generated as RANGE UNBOUNDED PRECEDING -->
      <enumeration value="RANGE_UNBOUNDED_PRECEDING"/>

      <!-- Implicit RANGE clause is generated as RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING -->
      <enumeration value="RANGE_ALL"/>
    </restriction>
  </simpleType>
  
  <simpleType name="InterpreterNameLookupCaseSensitivity">
    <restriction base="string">
    
      <!-- The default value depending on Settings.interpreterDialect -->
      <enumeration value="DEFAULT"/>
      
      <!-- Identifiers are always case sensitive -->
      <enumeration value="ALWAYS"/>
      
      <!-- Only quoted identifiers are case sensitive -->
      <enumeration value="WHEN_QUOTED"/>
      
      <!-- Identifiers are never case sensitive -->
      <enumeration value="NEVER"/>
    </restriction>
  </simpleType>

  <simpleType name="ParseNameCase">
    <restriction base="string">

      <!-- Parse object names, as defined in the database. For instance: schema.TABLE -->
      <enumeration value="AS_IS"/>

      <!-- Force parsing object names in lower case. For instance: schema."table" -->
      <enumeration value="LOWER"/>

      <!-- Force parsing object names in lower case, if unquoted. For instance schema."TABLE" -->
      <enumeration value="LOWER_IF_UNQUOTED"/>

      <!-- Force parsing object names in upper case. For instance: SCHEMA."TABLE" -->
      <enumeration value="UPPER"/>

      <!-- Force parsing object names in upper case, if unquoted. For instance SCHEMA."table" -->
      <enumeration value="UPPER_IF_UNQUOTED"/>
      
      <!-- Apply the parse dialect specific default behaviour -->
      <enumeration value="DEFAULT"></enumeration>
    </restriction>
  </simpleType>

  <simpleType name="ParseWithMetaLookups">
    <restriction base="string">

      <!-- Meta lookups are deactivated in parser -->
      <enumeration value="OFF"/>

      <!-- Meta lookups are active in parser, but don't throw exceptions on failure -->
      <enumeration value="IGNORE_ON_FAILURE"/>

      <!-- Meta lookups are active in parser and throw exceptions on failure -->
      <enumeration value="THROW_ON_FAILURE"/>
    </restriction>
  </simpleType>

  <simpleType name="ParseUnsupportedSyntax">
    <restriction base="string">

      <!-- Fail on syntax that is supported (known) by the parser, but not the jOOQ API -->
      <enumeration value="FAIL"/>

      <!-- Ignore syntax that is supported (known) by the parser, but not the jOOQ API -->
      <enumeration value="IGNORE"/>
    </restriction>
  </simpleType>

  <simpleType name="ParseUnknownFunctions">
    <restriction base="string">

      <!-- Functions have to be known by the parser, or by the catalog -->
      <enumeration value="FAIL"/>

      <!-- Unknown functions (parser or catalog) will be passed on as plain SQL -->
      <enumeration value="IGNORE"/>
    </restriction>
  </simpleType>
  
  <simpleType name="QueryPoolable">
    <restriction base="string">
    
      <!-- Statements are poolable -->
      <enumeration value="TRUE"/>
    
      <!-- Statements are not poolable -->
      <enumeration value="FALSE"/>
    
      <!-- Statements may be poolable, according to JDBC's default behaviour -->
      <enumeration value="DEFAULT"/>
    </restriction>
  </simpleType>
  
  <simpleType name="UpdateUnchangedRecords">
    <restriction base="string">
    
      <!-- Never update unchanged records -->
      <enumeration value="NEVER"/>
    
      <!-- Update unchanged records by setting the primary key column to itself, e.g. SET id = id -->
      <enumeration value="SET_PRIMARY_KEY_TO_ITSELF"/>
    
      <!-- Update unchanged records by setting non-primary key columns to themselves, e.g. SET a = a, b = b -->
      <enumeration value="SET_NON_PRIMARY_KEY_TO_THEMSELVES"/>
    
      <!-- Update unchanged records by setting record values to the values from the record, e.g. SET a = :a, b = :b. This is the same as calling record.changed(true) prior to updating. -->
      <enumeration value="SET_NON_PRIMARY_KEY_TO_RECORD_VALUES"/>
    </restriction>
  </simpleType>
  
  <simpleType name="Transformation">
    <restriction base="string">
    
      <!-- Never apply the transformation -->
      <enumeration value="NEVER"/>
      
      <!-- Apply the transformation when needed by a dialect -->
      <enumeration value="WHEN_NEEDED"/>
      
      <!-- Always apply the transformation -->
      <enumeration value="ALWAYS"/>
    </restriction>
  </simpleType>
  
  <simpleType name="TransformUnneededArithmeticExpressions">
    <restriction base="string">
    
      <!-- Never transform unneeded arithmetic expressions -->
      <enumeration value="NEVER"/>
      
      <!-- Transform arithmetic expressions arising from jOOQ's internals -->
      <enumeration value="INTERNAL"/>
      
      <!-- Transform all arithmetic expressions -->
      <enumeration value="ALWAYS"/>
    </restriction>
  </simpleType>
  
  <simpleType name="FetchIntermediateResult">
    <restriction base="string">
    
      <!-- Always fetch intermediate results -->
      <enumeration value="ALWAYS"/>
    
      <!-- Fetch intermediate results only when explicitly requested or when execute listeners are present -->
      <enumeration value="WHEN_EXECUTE_LISTENERS_PRESENT"/>
    
      <!-- Fetch intermediate results only when explicitly requested -->
      <enumeration value="WHEN_RESULT_REQUESTED"/>
    </restriction>
  </simpleType>
  
  <simpleType name="NestedCollectionEmulation">
    <restriction base="string">
    
      <!-- Generate native LIST, SET, MULTISET syntax irrespective of support -->
      <enumeration value="NATIVE"/>
    
      <!-- Generate native LIST, SET, MULTISET syntax if supported, or the most optimal emulation, otherwise -->
      <enumeration value="DEFAULT"/>
    
      <!-- Emulate LIST, SET, MULTISET syntax using ARRAY and ROW 
      <enumeration value="ARRAY"/>
        -->
        
      <!-- Emulate LIST, SET, MULTISET syntax using XML -->
      <enumeration value="XML"/>
    
      <!-- Emulate LIST, SET, MULTISET syntax using JSON -->
      <enumeration value="JSON"/>
    
      <!-- Emulate LIST, SET, MULTISET syntax using JSONB -->
      <enumeration value="JSONB"/>
    </restriction>
  </simpleType>
  
  <simpleType name="WriteIfReadonly">
    <restriction base="string">
    
      <!-- Allow for writing to readonly fields -->
      <enumeration value="WRITE"/>
      
      <!-- Ignore writes to readonly fields -->
      <enumeration value="IGNORE"/>
      
      <!-- Throw an exception when writing to readonly fields -->
      <enumeration value="THROW"/>
    </restriction>
  </simpleType>
</schema>