jOOQ Release notes
==================

For an interactive overview, see also
http://github.com/jOOQ/jOOQ/issues

For a formatted text version, see
http://www.jooq.org/notes.php

For a text version, see
http://www.jooq.org/inc/RELEASENOTES.txt


Version 3.5.2 - February 10, 2015
================================================================================

This is a patch release with some useful fixes for the 3.5 branch

Features and improvements
-------------------------
#4019 - Add system property to remove the logo from the log output

Bug fixes
---------
#3745 - NullPointerException when <jdbc/> is not provided and <database/> <name/> isn't provided either
#3778 - PostgreSQL enum array types have to be cast with their fully qualified name
#3909 - Inefficient number to number conversion in org.jooq.tools.Convert
#3915 - Calls to Configuration.derive() create a Configuration that indirectly references the previous Configuration instance
#3919 - Bad caching of JPA-annotated getters leads to wrong mapping into POJOs that have @ConstructorProperties
#3924 - Four octects are sent to Postgres for each negative byte in a byte[]
#3932 - jooq-runtime-3.5.0.xsd declares wrong namespace
#3936 - AbstractQuery unnecessarily creates two DefaultRenderContext instances
#3946 - Replace ArrayList<ExecuteListener> by ExecuteListener[] in ExecuteListeners to avoid excessive Iterator creation
#3947 - Avoid creating unnecessary Iterators and ArrayLists in AbstractStore.getAttachables()
#3957 - java.lang.NoSuchMethodException: createARRAY when using Oracle arrays with BoneCP
#3962 - The H2 emulation of SHR might produce rounding errors
#3966 - Inefficient BIT_COUNT() function for those dialects that do not natively support SHR()
#3976 - Code generator does not apply binding to Routines
#3977 - Meta.getTables() also returns entries for indexes for PostgreSQL
#3993 - ResultQuery.fetchAny() methods Javadoc erroneously claims throwing of InvalidResultException
#3998 - Cache internal BindingGetResultSetContext instance across a single Cursor
#4000 - Avoid {ResultSet | CallableStatement | SQLInput).wasNull() calls if not necessary, as they're somewhat expensive on some JDBC drivers
#4017 - jooq-meta-3.5.0.xsd is not valid XSD 1.0
#4022 - NullPointerException when generating SQLite table with composite primary key
#4028 - Loader API's "onDuplicateKeyIgnore()" executes inefficient SELECT
#4036 - Obsolete remark in RecordListener Javadoc about batch semantics
#4041 - Bad unnesting of UDT arrays in PostgreSQL
#4052 - NullPointerException when generating source code for PostgreSQL table-valued function that returns nested arrays


Version 3.5.1 - January 03, 2015
================================================================================

This is a patch release with some useful fixes for the 3.5 branch

Bug fixes
---------
#3378 - Error when fully qualifying PostgreSQL table-valued functions in SELECT clauses
#3803 - CREATE TABLE statement does not generate NOT NULL constraint
#3811 - Potential NullPointerException in Cursor.fetchOne(RecordMapper) and other methods
#3817 - When used with set operations, ORDER BY must not contain any qualified fields
#3819 - Add Constants.XSD_META and Constants.NS_META to describe the new jooq-meta-x.x.xsd
#3822 - Invalid SQL for Postgres created with values(Row1...)
#3824 - PostgreSQL dateAdd() erroneously returns a TIMESTAMP value
#3831 - <dateAsTimestamp/> deprecation warning is displayed even if the flag is not active
#3833 - org.jooq.CreateTableAsStep.column(Field<T> field, DataType<T> type) SQLite
#3835 - SQLite's CREATE VIEW statement doesn't allow to rename columns
#3838 - Bad @Support annotations on ALTER TABLE statements, which are not supported by SQLite
#3855 - Oracle REAL and FLOAT types cause code generator to produce BigInteger instead of Double types
#3863 - CSV-Export with delimiter only does not work properly
#3880 - Cannot access private JavaGenerator.newJavaWriter() method
#3888 - Data type conversion fails when using a Binding<byte[], Serializable> and passing a byte[] as user input
#3895 - The free trial version no longer works after Jan 01, 2015


Version 3.5.0 - November 21, 2014
================================================================================

The new Binding SPI
-------------------

The main improvement of this exciting release is the new org.jooq.Binding SPI
which can be used to fully control all aspects of a user-type's JDBC interaction.
This goes much further than the existing org.jooq.Converter SPI that can be used
to map standard JDBC types to user-types. With the new Binding SPI, virtually
*ALL* vendor-specific types can be supported now. Examples include PostgreSQL's
JSON or HSTORE types, or Oracle's DATE type - which is really incorrectly
represented via java.sql.Timestamp, which is why we have retrofitted the existing
<dateAsTimestamp/> feature to use such bindings, now.

Stored procedures are everywhere
--------------------------------

Stored procedure support was generally improved in this release. This includes
lots of new little features and conveniences for use with PL/SQL or Transact-SQL.
For instance, jOOQ 3.5.0 now supports cross-schema references of PL/SQL OBJECT
and TABLE types, which allows for binding directly to Oracle Spatial. We've
blogged about this exciting improvement here:
http://blog.jooq.org/2014/11/04/painless-access-from-java-to-plsql-procedures-with-jooq/

And while we were at it, we've also added basic support for Oracle AQ, which
integrates very nicely with our OBJECT type support!

In Transact-SQL and MySQL, we now support fetching arbitrary numbers of Results
from stored procedures, and we've also implemented support for Firebird PSQL,
including Firebird's very interesting syntax for table-valued functions.

By the way, we support user-defined aggregate functions for a variety of
databases, including Oracle, PostgreSQL, and HSQLDB. Definitely something you
should look into!

SQL improvements
----------------

In this release, we've finally got support for UNION, INTERSECT, and EXCEPT
right with respect to nesting such operations, as well as combining them with
ORDER BY and LIMIT .. OFFSET.

Let's talk some more DDL
------------------------

We've continued to add support for DDL statements, including

- CREATE TABLE
- CREATE TABLE AS SELECT
- CREATE VIEW and DROP VIEW
- CREATE INDEX and DROP INDEX
- CREATE SEQUENCE and DROP SEQUENCE
- DROP .. IF EXISTS

We'll continue to add support for more DDL statements also in the future.

Code generation improvements
----------------------------

We've added support for the new XMLDatabase, a code generation configuration
that allows to read meta information from XML formats, e.g. from a standard
INFORMATION_SCHEMA.xml, or from Vertabelo's XML export format:
http://blog.jooq.org/2014/09/05/importing-your-erd-export-into-jooq/

Future versions of jOOQ will include built-in support for a variety of XML 
formats.

We've had an awesome contribution by Etienne Studer from Gradleware to help our
users integrate the jOOQ code generation with their Gradle builds.

Last but not least: Informix!
-----------------------------

Oh, and by the way, we now also support IBM's second most popular database:
Informix. Support for this database will be included in the jOOQ Enterprise
Edition.



Features and improvements
-------------------------
#561  - Add support for the Informix database
#994  - Add support for the Postgres "hstore" data type
#1341 - Add DSL.using(String url) and other methods that mimick DriverManager.getConnection()
#1380 - Generate equals(), hashCode() on POJOs
#1392 - Add formatInsert() to render insert statements from a Result
#1410 - Add support for the Postgres "DISTINCT ON" clause
#1658 - Add support for SQL standard UNION syntax. jOOQ's current understanding of UNION is just convenience
#1761 - Reference manual versions between each other
#2054 - Implement quantified comparison predicates for Row[N] row value expressions
#2155 - Add Converter support to Routines and UDTs
#2209 - Add <T1, T2, .., T[N]> Result<Record[N]<T1, T2, .., T[N]>> Result.into(Field<T1>, Field<T2>, .., Field<T[N]>) in order to transform Results / Records into another type
#2289 - Add jOOQ-flyway-example, a documentation module to show how to integrate with Flyway
#2604 - Add section to the manual explaining how asynchronous querying can be achieved
#2674 - Add support for stored procedures in MockConnection / MockDataProvider / MockExecuteContext
#2788 - Add support for the PostgreSQL "json" data type
#2886 - jooq-codegen-maven should look into project dependencies for jdbc driver
#2907 - Emulate UPDATE .. RETURNING through SELECT FROM FINAL TABLE (UPDATE ...) in DB2
#2925 - Add support for Firebird stored procedures
#3121 - Skip code re-generation when schema is known to be the same
#3151 - Add "question mark" with tool-tip to the manual to allow for jumping to the "how to read this manual" section
#3248 - Add support for Binding (i.e. "Type Providers")
#3337 - Add support for the CREATE TABLE statement
#3339 - Add support for CREATE INDEX and DROP INDEX statements
#3340 - Add support for CREATE VIEW and DROP VIEW statements
#3346 - Allow for omitting the JDBC driver property in the code generator
#3355 - Add support for CREATE SEQUENCE and DROP SEQUENCE statements
#3370 - Allow for overriding the class Javadocs for generated objects
#3375 - Add support for PostgreSQL table-valued functions
#3381 - Add support for CREATE TABLE AS statements
#3386 - Add some test cases using Java 8 Streams for functional-relational transformation
#3388 - Replace SQL Server's ROW_NUMBER() OVER(ORDER BY @@version) by ORDER BY (SELECT 0)
#3389 - Add DSLContext.currval(String) and nextval(String) for convenience
#3412 - Add List DSLContext.fetchValues(...) similar to the existing fetchValue(...) methods
#3418 - Add DSL.defaultValue(Field<T>) for convenience
#3425 - Add support for Oracle AQ
#3431 - Add support for MySQL index hints
#3435 - Add support for SQL Server's SELECT .. INTO [new table] syntax
#3442 - Implement MockResultSet.getArray() methods
#3443 - Add support for conversion of values / arrays to the JDBC Array type in Convert
#3444 - Add MockArray, a mock implementation of JDBC's Array type
#3451 - Add XMLDatabase to generate a database schema from an XML file
#3477 - Add Field.as(Field) to rename a field to another field's name
#3480 - Add XXXContext.dialect() and XXXContext.family() for convenience
#3483 - Let <forcedType/>'s <expression/> match both fully qualified column names as well as unqualified column names
#3495 - Add an example project showing how to use jOOQ's code generator with Gradle
#3496 - Log a DEBUG message when a Query is executed which returns Query.isExecutable() == false
#3501 - Add ResultQuery.fetchSet() and Result.intoSet() methods to return LinkedHashSets
#3506 - Instrument the jOOQ API during integration tests to verify correct application of @Support annotations
#3511 - Improve DISTINCT predicate emulation through INTERSECT
#3512 - Add DSL.count(Table<?>) and DSL.countDistinct(Table<?>) to support the PostgreSQL-specific COUNT() extension
#3513 - Streaming version of formatCSV/formatXML
#3519 - Document the PostgreSQL JDBC's limitations with respect to large cursors when using Connection.autoCommit = true
#3525 - Implement more verbose DEBUG logging for jOOQ-meta's include / exclude mechanism
#3532 - Add support for DROP ... IF EXISTS clauses in DDL
#3551 - Copy plain SQL query construction API to DSL from DSLContext
#3557 - Add support for PostgreSQL user-defined aggregate functions
#3558 - Add Setting to enable / disable fetching of warnings
#3559 - Propagate jOOQ-codegen's relations flag also to jOOQ-meta, to prevent (possibly expensive) queries to fetch relations
#3565 - Add XXXContext.settings() for convenience
#3566 - Add GenerationTool.generate(String) to generate code from an XML string
#3569 - The <database/> tag is no longer mandatory in the code generator configuration
#3579 - Emulate nested set operators in databases that don't support them natively
#3592 - Add Setting to enable Oracle scalar subquery caching for stored function calls
#3595 - Add MockResult<init>(Record data) convenience constructor
#3596 - Let code generator empty generated packages on a per-schema basis
#3597 - Generate table and column comments also for PostgreSQL
#3598 - If tables define their own comments, don't generate "This class is generated by jOOQ." in Javadocs
#3599 - Implement nicer formatting of @Generated annotation
#3600 - Add support for SQL standard SELECT .. WITH CHECK OPTION
#3610 - Explain the differences between keeping generated sources under version control or not
#3611 - Add a jOOQ / Nashorn example to the repository
#3612 - Add an example project showing how to import an ERD export format to the code generator
#3622 - Add support for Field.in(Result<Record1<T>>) and Row[N].in(Result<RecordN<T1, ..., TN>>)
#3623 - Add ParamType.NAMED_OR_INLINED to render named parameters only if a name is given
#3626 - Add Map<S, Result<R>> Result.intoGroups(Table<S>)
#3627 - Add simplified API for CASE WHEN [ condition ] THEN [ select ] expressions
#3628 - Add <T> Field<T> DSL.field(Select<? extends Record1<T>>)
#3633 - Add a section to the manual about jOOQ and NoSQL
#3638 - Let ResultQuery<R> extend Iterable<R>
#3644 - Enhance DSL API to work around Nashorn interoperability issue with overloading and varargs
#3661 - Log some info about the type being matched by a <forcedType/> configuration
#3667 - <types/> configuration doesn't work for Derby DATE types
#3668 - Let GenerationTool also search absolute and relative paths
#3669 - Make the code generator's <database/> element optional
#3670 - Add DSL.coerce(Object, ...<T>) for convenience
#3671 - Add alternative DSL.concat() syntax for convenience
#3672 - Add OracleDSL.toNumber()
#3677 - Add a paragraph to the manual indicating that the manual is licensed CC-BY-SA 4.0
#3678 - Add some JavaBeans-style setters to the DefaultConfiguration to simplify configuration via Spring
#3680 - Remove all unit tests that make assumptions on how exactly the SQL is rendered
#3681 - Fetch all result sets from executed stored procedures
#3688 - Remove the confusing CO_AUTHOR_ID column from the manual
#3690 - Add a manual page header indicating that a version has gone "end of life"
#3702 - Add Configuration.family() for convenience and API consistency
#3740 - Add Table.newRecord() and UDT.newRecord() to construct new records with DefaultConfiguration
#3746 - Add DSLContext.fetchExists(Select<?>)
#3752 - Make <jdbc/> element optional in code generation configuration
#3754 - Explain primitive type conversion in Convert.convert() Javadoc
#3756 - Regenerate files only if there is a difference
#3760 - Add Record.intoList()
#3769 - Add org.jooq.Converters, a chained Converter implementation
#3773 - Explain jOOQ's understanding of Configuration thread safety in the Configuration Javadoc
#3775 - Let QueryPart.toString() generate formatted SQL
#3782 - Add a method to create a org.jooq.util.Database by SQLDialect

API changes (backwards-compatible)
----------------------------------
#3345 - Deprecate org.jooq.api.annotation.State and Transition annotations
#3356 - Deprecate Select.fetchCount()
#3703 - Deprecate CastMode.SOME and RenderContext.cast()
#3770 - Deprecate <dateAsTimestamp/>

API changes (backwards-incompatible)
------------------------------------

Behavioural changes (backwards-incompatible)
--------------------------------------------

#2486 - Allow to specify precision, scale, length for type-rewrites in <forcedType/>
#3000 - Add Setting to enable MySQL backslash escaping
#3407 - DDL statements accepting String names should generate quoted names, not plain SQL
#3541 - Change DSLContext.nextval(String) and currval(String) to internally call DSL.sequenceByName() instead of DSL.sequence()

Bug fixes
---------
#2080 - Syntax error in rendered SQL when using limit().offset() with aliased projections in SQL Server
#3206 - DSL.field(Condition) doesn't correctly handle NULLs when emulating boolean fields with a CASE expression
#3347 - Field.in(T...) should defend against Collection arguments
#3353 - Manual Javadoc anchors are no longer correct with the recent changes of JDK 8 Javadocs
#3359 - store() after copy() executes an UPDATE instead of an INSERT, when Settings.updatablePrimaryKeys is set
#3360 - SQLite regression when using special characters in identifiers
#3362 - DSLContext.batchStore() executes INSERT if records are batch stores are executed two times in a row on new records, if Settings.updatablePrimaryKeys is set to true
#3363 - UpdatableRecord.store() executes UPDATE instead of INSERT after delete(), if Settings.updatablePrimaryKeys is set to true
#3369 - Render CAST(? AS DATE) for java.sql.Timestamp bind values that are bound to Oracle DATE columns
#3372 - The syntheticPrimaryKeys code generation option is currently undocumented
#3373 - The manual's page about the DUAL table does not list all the supported databases
#3382 - NOT NULL constraints and type information are incorrectly generated when using Firebird DOMAINs for data types
#3390 - Add missing documentation about the new jOOQ 3.4 transaction API
#3392 - Call setAccessible(true) only if really needed
#3400 - ALTER TABLE generates invalid syntax on Firebird when data types are nullable
#3402 - Wrong character length generated by jOOQ for Firebird
#3408 - Remove the default log4j.xml configuration file from the maven plugin again
#3413 - Oracle generated ArrayRecords cannot be constructed through reflection if deprecated flag is set to off
#3420 - NullPointerException when generating code for Oracle AQ Tables
#3427 - Internal QueryCollectorSignal exception escapes into user code when not dealt with in ExecuteListener
#3430 - JDBC escape syntax is not correctly rendered from plain SQL when plain SQL contains newlines
#3436 - Manual sections about transactions documents ctx to be a DSLContext instead of Configuration
#3437 - QualifiedField does not respect RenderContext.qualify()
#3445 - Cannot run Maven code generator with professional edition
#3450 - Backslashes in SQL comments don't get escaped
#3455 - UPDATE .. FROM statement renders incorrect SQL for derived tables or aliased tables
#3456 - Name clash in generated code when Routine argument is called "f" (functions) or "p" (procedures)
#3462 - Field<Object>.in(Object...) can be called with Select<?> arguments, accidentally
#3463 - Field.in(...) methods shouldn't return trueCondition() or falseCondition()
#3473 - java.lang.IllegalArgumentException: Field (null) is not contained in Row
#3488 - Compilation error in generated code, when a similar tables T_A and TA exist
#3489 - DefaultTransactionProvider does not call Connection.releaseSavepoint(Savepoint) after commit
#3507 - Bad @Support annotation on Select.intersect() and Select.except()
#3514 - ResultQuery.fetchLazy() ignores fetchSize()
#3520 - Duplicate column information in foreign key references for foreign keys that share the same name in different tables
#3526 - Unnecessary warning logs introduced in code generation
#3533 - Avoid using named parameters for Oracle, if not really needed
#3537 - Incorrect call to releaseSavepoint()
#3542 - Oracle DDL statements do not allow for using bind variables
#3544 - Add a DDLQuery marker interface, which all DDL Query types should extend
#3545 - Error when using qualified, case-sensitive sequence names in H2
#3547 - DSLContext.batch(String) doesn't accept bind variables
#3552 - Oracle Stored procedures using type synonyms in signatures cannot be used through jOOQ
#3556 - Generated Oracle Stored procedures do not reference types from other schemas
#3560 - Slow discovery of primary keys in very large MySQL databases
#3567 - Code generator error message refers to wrong XSD
#3577 - Don't render "empty" OFFSET 0 clauses
#3578 - Slight manual bug referring to inexistent ExecuteContext.dialect() method
#3582 - Record.from(Object) does not consider DataType.nullable() which may lead to constraint violations when inserting
#3586 - Context.paramType() is initially null instead of INDEXED
#3590 - Manual erroneously claims that the SQL standard allows SELECT without FROM
#3591 - Compilation error generated in manual's tutorial code
#3602 - Cannot INSERT into view
#3608 - Typo in documentation of transaction method
#3624 - Compilation errors when Converters are applied to generated Routines and UDTs
#3630 - ArrayOutOfBoundsException when using backslash escaping in MySQL with jOOQ plain SQL
#3634 - Record.into(Table) maps to the wrong table when passing an aliased table after a self-join
#3639 - java.lang.NoSuchMethodException: createARRAY when using Oracle arrays with Spring TransactionAwareDataSourceProxy
#3648 - Use JDBC Escape syntax for MySQL Date / Time literals to circumvent a known MySQL bug
#3650 - NullPointerException on TableRecord.insert() when primary key information is not present
#3664 - UNION ALL, ORDER BY, and LIMIT regression
#3665 - Typos in Javadocs
#3673 - OracleDSL.toChar() methods shouldn't require String types
#3682 - PostgreSQL INSERT .. RETURNING doesn't work with plain SQL table
#3696 - OutOfMemoryError with SQL Azure, caused by long-running loop of consuming further exceptions
#3705 - The jOOQ "flash log" doesn't display nicely when using java.util.logging
#3711 - Incorrect code generated for cross-schema OBJECT type references
#3718 - Exceptions on rollback hide the original exceptions causing the rollback
#3723 - Add org.jooq.Scope to unify all Configuration, Settings, and data map access in a single API
#3730 - Cannot use regex COMMENTS in <forcedType/>'s <expression/>
#3732 - Improve performance of <forcedType/> regex evaluation
#3733 - Code generator should use CHAR_LENGTH columns for Oracle, instead of DATA_LENGTH
#3741 - MySQL ResultSet streaming conflicts with internal SHOW WARNINGS call
#3758 - ExecuteListener.warning() is not listed as a method in the Javadoc
#3762 - Bad emulation of DUAL table in HSQLDB when connecting with a DBA user on a database with more than one user
#3792 - Code generator erroneously refers to "singleton instances" of tables in generated Javadoc

Version 3.4.0 - June 20, 2014
================================================================================

With this awesome new minor release version, we have finally started supporting
a couple of very important aspects of the SQL language:

- Common table expressions
- Transactions
- DDL

Common table expressions have been missing from jOOQ for a long time, and
they're now finally part of our DSL API, both for recursive or regular usage.

Transactions are handled very nicely in JavaEE or through Spring TX. But if
you're running small standalone programs with JDBC (and jOOQ) only, you have to
resort to a transaction API that is no longer contemporay. With jOOQ 3.4, we're
now shipping a Java-8 ready transaction API and a default implementation backed
by JDBC transactions. Our manual also contains an example implementation that is
backed by Spring TX. While we do not want to compete with popular transaction
models, we do want to provide a simple, functional-interface oriented API to
apply transactions in client code.

DDL is very hard to standardise across databases, and with jOOQ 3.4, we have now
started adding type safe support for some DDL statements, including thus far:

- ALTER SEQUENCE
- ALTER TABLE

We're going to be adding support for more DDL statements in jOOQ 3.5 as part of
our more general DDL support strategy.

Apart from that, there is a tremendous amount of minor improvements. See below
for details:

Features and improvements
-------------------------
#454  - Add support for CTE (Common Table Expressions / WITH-clause)
#682  - Mavenise jooq-test
#883  - Add support for DDL statements
#1061 - Support "DEFAULT" keyword in INSERT and UPDATE statements
#2573 - Generate DAOs for tables with composite primary keys
#2646 - SQL Server error "The text, ntext, and image data types cannot be
        compared or sorted" when using LIMIT with a SELECT [text, image]
        statement
#2675 - Add test to verify if jOOQ correctly binds NULL values with the right
        JDBC type in batch INSERT operations
#2694 - Unify RenderContext and BindContext traversal
#3010 - Generate POJOs for Oracle and PostgreSQL UDTs
#3016 - Adapt manual to recommend also other popular connection pools
#3030 - Add support for ALTER SEQUENCE ... RESTART [ WITH ... ]
#3075 - Add support for Oracle TEMPORARY tables
#3076 - Add ExecuteListener.warning(ExecuteContext) to allow for listening to
        SQLWarnings
#3077 - Let Sequence implement QueryPart
#3080 - Generate Interfaces for Oracle and PostgreSQL UDTs
#3081 - Let generated POJOs reference generated UDT POJOs instead of UDT Records
#3084 - SQL Server unique indexes are not loaded by jOOQ-meta
#3093 - Add code-generation configuration to treat UNIQUE keys as primary keys
        to generate UpdatableTables
#3094 - Add Relations.getUniqueKeys(SchemaDefinition), getUniqueKeys()
#3095 - Add SchemaDefinition.getTables()
#3096 - Add Constants.XSD_RUNTIME, NS_RUNTIME, XSD_CODEGEN, NS_CODEGEN
#3111 - Support multiple Converters for the same <U> type in the code generator
#3115 - Support hypothetical set function syntax (for CUME_DIST, RANK,
        DENSE_RANK, PERCENT_RANK)
#3116 - The jOOQ Scala manual examples use T_BOOK instead of BOOK
#3125 - Generate default ArrayRecord constructors that don't need a
        Configuration
#3130 - Generated UDTRecords should be more similar to generated TableRecords
#3139 - Add <T1, ..., T[N]> Result<Record[N]<T1, ..., T[N]>>
        DSLContext.newResult(Field<T1>, ..., Field<T[N]>)
#3153 - Add a paragraph to the manual explaining classpath behaviour of the
        standalone code generator
#3154 - Add code-generation configuration to generate synthetic primary keys for
        updatable views
#3169 - Add more ResultQuery.fetchAnyXXX() convenience methods
#3180 - Add a Java 8 example to the documentation
#3181 - Update external manual links to point to the JavaSE 8 Javadoc
#3189 - Add DSL.sequenceByName(String...)
#3199 - Add some Javadoc to Result.attach() and Result.detach() to explain the
        semantics
#3202 - Allow for Pattern.COMMENTS in code generation configuration's regexes
#3203 - Add DSL.not(Field<Boolean>) as a convenience for DSL.not(Condition)
        and condition(Field<Boolean>)
#3204 - Clarify what "fully qualified" means in the context of <include/> and
        <exclude/> in the code generator configuration
#3205 - Add DSL.condition(Boolean) as a convenience for
        condition(Field<Boolean>)
#3212 - Add support for value types in DefaultRecordMapper, when mapping
        Record1 types
#3229 - Add DSLContext.transaction() to implement nested transaction semantics
        through functional interfaces
#3230 - Implement TransactionProvider for use with DataSourceConnectionProvider
#3232 - Add optional <type/> configuration to <customType/> in order to specify
        different converters for the same Java type
#3233 - Add DataTypeDefinition.getConverter()
#3240 - Add DSL.sequence() methods for plain SQL sequence construction
#3252 - Relax bounds on <R> for DSLContext.batchInsert()
#3253 - Pull up TableRecord.insert()
#3264 - Use try-with-resources statements in the manual
#3265 - Add manual examples for include / exclude that explicitly use schemas
        (and other fully qualified object names)
#3275 - Use maven-plugin-annotations in jOOQ-codegen-maven instead of Javadoc
        tags
#3286 - Add MySQLDSL.encode(byte[]) and decode(byte[])
#3288 - Add DSL.date(String), DSL.time(String), and DSL.timestamp(String), as
        shortcuts for respective valueOf() methods
#3305 - Add SQLDialect.families() to access all SQLDialect families
#3307 - Change internal representation of AbstractRecord to use Object[] and
        BitSet instead of Value[]
#3319 - Update the jOOQ LIMIT .. OFFSET manual page
#3316 - Add RecordContext.recordType() to allow for introspecting record types
        when implementing RecordListeners
#3321 - Add support for Oracle's (+) JOIN syntax
#3322 - Add UpdatableRecord.store(Field<?>...), insert(Field<?>...),
        update(Field<?>...)

API changes (backwards-compatible)
----------------------------------
#3126 - Deprecate generated ArrayRecord constructors that take a Configuration
        argument
#3127 - Deprecate ArrayRecord.set(Array)
#3128 - Change ArrayRecord.setList(List<? extends E>) into
        ArrayRecord.set(Collection<? extends E>)

API changes (backwards-incompatible)
------------------------------------
#3247 - InsertSetMoreStep must not extend InsertSetStep

Behavioural changes (backwards-incompatible)
--------------------------------------------
#3131 - Query.getBindValues() should not return inlined bind values
#3132 - Quoting identifiers that contain "special characters" may lead to
        unexpected results when using RenderNameStyle.AS_IS
#3306 - Let Record.key() return a "copy record", instead of a view to the
        original record

Bug fixes
---------
#2335 - SQL syntax error when projecting two columns of the same name along with
        a LIMIT clause in Oracle
#2700 - DAO.insert() and other DAO operations do not respect DEFAULT values
#2973 - Field.in(Collection) should accept wildcard instead of T
#3011 - Routines do not propagate errors raised from T-SQL with sqljdbc_4.0
#3018 - Add <outputSchemaToDefault/> to support "default schemas" during code
        generation
#3055 - Add missing MariaDB and MS Access support to the manual
#3057 - Wrong paths in maven-install.sh and maven-install.bat
#3060 - Conversion fails for Oracle VARRAY / TABLE types, nested in UDTs
#3069 - jOOQ calls Clob.free(), which is available only in JDBC 4.0 / Java 1.6
#3090 - Bad predicates generated from nullable keys on refresh(), update(),
        delete()
#3099 - UpdatableRecord.store() executes INSERT instead of UPDATE when used
        with nullable composite primary keys
#3101 - MutablePOJOMapper doesn't work with annotated boolean getters
#3108 - Local Fields' Converters should be preferred over globally registered
        Converters
#3117 - jOOQ illegally generates covariant setters on UDTRecords and UDT Pojos
        when <pojos/> and <interfaces/> are activated
#3119 - Upgrade to JUnit 4.11 and omit using deprecated junit.framework.Assert
        in tests
#3120 - Outdated link to Spring TX in the manual
#3122 - Runtime Schema mapping doesn't work for UDT
#3131 - Query.getBindValues() should not return inlined bind values
#3133 - Code generation marks all PostgreSQL Fields as having a default value
#3143 - Bad Javadoc in the org.jooq.tools.json package: JSON tools are not
        "JSONAware"
#3147 - Field.sortAsc() and sortDesc() should generate inlined values for sort
        indirection
#3155 - Improve documentation of <forcedType>'s <types/> element
#3156 - "Column ambiguously defined" when emulating derived column lists with
        duplicate column names
#3159 - Replace BoneCP with Apache DBCP in examples and manual
#3161 - Bad XSD version number referenced from jOOQ 3.3 manual
#3162 - NullPointerException when referencing window name that was not declared
#3164 - Missing formatting when rendering formatted MERGE statement's SET clause
#3168 - Bad download link in documentation
#3176 - Don't generate "assignment-constructors" for POJOs and Records with more
        than 255 columns
#3179 - PDF manual's white-on-black code sections are hard to read with Kindle
#3183 - Add some clarification to the manual's section about the H2 MERGE
        statement
#3186 - Bad SQL rendered for FOR UPDATE clause in Firebird
#3187 - Manual section about Groovy has a couple of Scala references in them
#3191 - ResultQuery.keepStatement(true) doesn't work correctly with
        DataSourceConnectionProvider
#3194 - Avoid using deprecated Maven mojo descriptor @parameter
        expression="${property}"
#3195 - IN predicate with subquery cannot have LIMIT .. OFFSET clause in Oracle
#3200 - Converter does not work when loading CSV files
#3211 - Dead codegen example POM link in manual
#3214 - Error when inserting PostgreSQL enum array
#3217 - Manual was not updated after fixing #2910
#3218 - Fix the manual and suggest using DSL.field() instead of
        DSL.fieldByName()
#3226 - DefaultConnectionProvider shouldn't use DSL class for DEBUG logging
#3234 - Connection Leak With BatchCRUD operations
#3237 - UpdatableRecord.store() executes INSERT instead of UPDATE when nullable
        primary keys are NULL
#3241 - Cursor.iterator() does not correctly implement Iterator.next() contract
        with respect to NoSuchElementException
#3244 - InsertQuery.setDefaultValues() is not supported by the ACCESS dialect
#3249 - DSL.selectZero() and DSL.selectOne() should alias column names
#3267 - Misleading DSLContext.batch() Javadoc. It should be clear that an
        additional call to execute() is needed.
#3277 - SQLite DECIMAL(p, s) types are not correctly recognised
#3282 - inputSchema / outputSchema codegen configuration has no effect in
        Oracle, if inputSchema is lower-cased
#3293 - Bad composite foreign key references generated for H2
#3294 - DSLContext.renderNamedParameters() doesn't replace ?, ? by :1, :2 in
        plain SQL QueryParts
#3297 - Bind variables are erroneously inlined into quoted identifiers, if
        identifiers contain question marks
#3300 - UpdatableRecord.store() executes INSERT instead of UPDATE when nullable
        primary keys are NULL, and the updatablePrimaryKeys setting is active
#3309 - Don't use "deploy" as Maven <defaultGoal/>
#3328 - Re-create old DefaultConfiguration constructors for backwards-
        compatibility
#3333 - maven-compiler-plugin configuration in jooq-parent pom file uses the
        deprecated compilerArguments parameter
#3342 - Cannot INSERT into tables with Firebird BLOB types

Version 3.3.0 - February 14, 2014
================================================================================

Finally, a new awesome jOOQ release is ready for you to download! The most
important feature first:

The SEEK method
---------------

We've been blogging about keyset paging before:

- http://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/
- http://blog.jooq.org/2013/11/18/faster-sql-pagination-with-keysets-continued/

Every SQL developer should have this tool in their toolchain. And now, with
jOOQ 3.3, we natively support a synthetic SQL clause for you to express keyset
paging very easily. jOOQ is the only database software out there to do so!

Gudu Software's SQL 2 jOOQ Parser
---------------------------------

We're very happy to announce our collaboration with Gudu Software Ltd who have
implemented a very powerful SQL parser and transformer for enterprise databases.

Together with Gudu Software, we have created an Open Source SQL 2 jOOQ parser
that takes native SQL statements as input and generates jOOQ code as output.

The source code can be found here:

- https://github.com/sqlparser/sql2jooq

And our manual features a tutorial here:

- http://www.jooq.org/doc/latest/manual/tools/sql2jooq/

We will ship, test and maintain this awesome new addition with our own
deliverables. So far, SQL 2 jOOQ supports the MySQL and PostgreSQL dialects and
it is in an alpha stadium. Please, community, provide as much feedback as possible
to make this great tool rock even more!

Please take note of the fact that the sql2jooq library is Open Source, but it depends
on the commercial gsp.jar parser, whose trial licensing terms can be seen here:

- https://github.com/sqlparser/sql2jooq/blob/master/sql2jooq/LICENSE-GSQLPARSER.txt

Great new SQL Feature Support
-----------------------------

We've been looking around for SQL standard and vendor-specific features, such as
the WINDOW clause (standard!), CROSS APPLY, OUTER APPLY, LATERAL join, DEFAULTs
for inserts, and nice datetime arithmetic functions and emulations thereof.

As always, we've also blogged about all these features. See the following links
for more details:

- http://blog.jooq.org/2013/11/03/probably-the-coolest-sql-feature-window-functions/
- http://blog.jooq.org/2013/12/18/add-lateral-joins-or-cross-apply-to-your-sql-tool-chain/
- http://blog.jooq.org/2014/01/08/lesser-known-sql-features-default-values/
- http://blog.jooq.org/2014/02/06/youre-very-likely-to-have-gotten-sql-date-time-arithmetic-wrong/

Formal Spring integration support
---------------------------------

Spring is one of the most popular frameworks to handle transactions, and it does
so very well. With the help of our community, we've established new standards and
examples of how to get started very quickly with jOOQ and Spring. See the following
resources for details:

- http://www.jooq.org/doc/latest/manual/getting-started/tutorials/jooq-with-spring/
- https://github.com/jOOQ/jOOQ/tree/master/jOOQ-examples/jOOQ-spring-example

Features and improvements
-------------------------
#531  - Add support for the WINDOW clause
#845  - Add support for the T-SQL and Oracle 12c CROSS APPLY clause
#846  - Add support for the T-SQL and Oracle 12c OUTER APPLY clause
#1018 - Add support for PostgreSQL and SQL Server non-standard UPDATE .. FROM
        clause
#1070 - Add support for SQL Server table-valued functions
#1506 - Allow for inserting empty records through INSERT INTO .. DEFAULT VALUES
#2093 - Add comment functionality from DISQUS to website
#2246 - Add <T> T DSLContext.fetchValue(Select<Record1<T>>) to support more
        typesafety when fetching single values
#2576 - Integrate with Travis-CI to run automated builds
#2657 - Add support for ORDER BY .. SEEK .. LIMIT to implement the "seek method"
        for faster offsets
#2709 - Add Record[N].value1(xx), value2(xx) setter methods
#2734 - Add support for lateral derived tables
#2744 - Emulate INSERT .. RETURNING through SELECT FROM FINAL TABLE (INSERT ...)
        in DB2
#2767 - Add support for CUBRID 9.2 features
#2776 - Add support for the PostgreSQL ONLY clause
#2778 - Add detailed section to the manual about settings.xml
#2779 - Add support for LEFT(), RIGHT() functions
#2780 - Add PostgresDSL.oid(Table<?>) to produce table.oid references
#2784 - Add DSL.row(Collection<?>) to allow for interacting with collections of
        values or Fields
#2790 - Add a Context data map scoped to the current subquery
#2801 - Mention licensing options from the manual, add help message to
        jOOQ-Codegen when OSS users try using commercial databases
#2805 - Add seekAfter() and seekBefore() to allow for paging in both directions
#2806 - Add ResultQuery.fetchSize() to influence the JDBC Statement's fetch size
#2809 - Add support for MySQL's MID() function, which is a synonym for
        SUBSTRING()
#2810 - Add support for the REVERSE() function, where it is supported
#2824 - Log 500 records on TRACE level, instead of just 5
#2828 - Use a default Database for code generation, in the absence of an
        explicit database
#2829 - Enhance Loader API to allow for importing JSON data in addition to CSV
        data
#2832 - Add OracleDSL.toChar()
#2838 - Add more sophisticated CustomField example to the manual
#2840 - Add DSL.date(), DSL.time(), and DSL.timestamp() to extract date, time,
        timestamp parts from a TIMESTAMP
#2844 - Let JAXB emit more warnings when loading the code generation
        configuration
#2848 - Add support for infix-notation for bitwise operations
#2851 - Add some documentation to the manual about custom code sections in
        generated code
#2853 - Add DSLContext.fetchFromJSON()
#2854 - Add a JAX-RS (with Spring) and jOOQ example to the manual
#2860 - Add manual section about using jOOQ with Groovy
#2876 - Add some Javadoc about the fact that some SQLDialects are available in
        commercial distributions only.
#2883 - Add support for PostgreSQL COUNT(DISTINCT(a, b, ...)) through
        DSL.countDistinct()
#2885 - Generated enum values contain extra comma
#2891 - Add a jOOQ / Spring-TX example to GitHub under jOOQ-examples
#2894 - Enable automated CI on github
#2898 - Add DSL.generateSeries(int, Field<Integer>) and (Field<Integer>, int)
        overloads
#2900 - Overload MockFileDatabase constructor to allow for Readers,
        InputStreams, and Strings
#2909 - Improve manual's jOOQ syntax highlighting: Highlight SQL keywords
#2912 - Add convenience methods set(Connection), set(DataSource),
        derive(Connection), derive(DataSource) to DefaultConfiguration
#2915 - Log JDBC URL in code generator configuration log
#2921 - Add support for ad-hoc table renaming
#2931 - Add DSLContext.fetchCount(Table<?>) and fetchCount(Table<?>, Condition)
#2932 - Retry loading the GenerationTool configuration file with a / prepended
        if it fails
#2933 - Add {Result.into|ResultQuery.fetch}{Map|Group}({Field<?>|Field[]},
        RecordMapper<R, E>)
#2944 - Add support for GROUP_CONCAT in SQLite
#2945 - Deprecate the <generateInstanceFields/> code generation flag
#2946 - Add a section to the manual explaining how to programmatically
        configure the code generator
#2950 - Add Table.getComment() and Field.getComment() to access comment meta
        information from the schema
#2969 - Add support for SQL Server SOUNDEX() and DIFFERENCE() functions
#2970 - Add DSL.isnull() as a synonym for NVL() for the SQL Server dialect
#2971 - Add DSL.space() to support the SQL Server specific SPACE() function
#2976 - Add bookmarks to the PDF manual
#2979 - Add Maven install scripts (.bat and .sh) to deliverables
#2981 - Add an official Spring / Guice example
#2984 - Add <R extends Record> Table<R> table(Result<R>) to allow to fetch
        from / join / etc in-memory tables
#2985 - Add DSL.values(RowN...)
#3001 - Add VisitContext.clausesLength() and queryPartsLength() to indicate
        the depth of the currently visited QueryPart tree
#3002 - Add the BindVariableAbbreviator VisitListener example to the manual
#3009 - Add DSL.dateAdd(Field<Date>, Field<? extends Number>, DatePart) and
        timestampAdd(Field<Timestamp>, Field<? extends Number>, DatePart) for
        better cross-database datetime arithmetic
#3015 - Add support for HSQLDB user-defined aggregate functions
#3044 - Integrate SQL 2 jOOQ beta in deliverable

API changes (backwards-compatible)
----------------------------------
#2811 - Deprecate ResultQuery.fetchLazy(int) - fetchSize is now passed to
        ResultQuery.fetchSize() not only for lazy fetching
#2837 - Deprecate code generation configuration's <expressions/> in favour of
        <expression/>
#2878 - Deprecate Record.getValue() and Result.getValue() methods that take a
        defaultValue argument
#3007 - Add API guarantee to ResultQuery.fetch() methods indicating that all
        JDBC resources are freed

API changes (backwards-incompatible)
------------------------------------
#2910 - The new matchers configuration cannot be used with Maven
#3038 - Add RecordListener.exception(RecordContext) and
        RecordContext.exception()

Behavioural changes (backwards-incompatible)
--------------------------------------------
#2863 - Remove unnecessarily cached Connection in DataSourceConnectionProvider

Bug fixes
---------
#2016 - Bad parsing of MySQL ENUM literals by jooq-meta, if they contain special
        characters
#2152 - Invalid column type: 16, when binding null as java.lang.Boolean onto a
        NUMBER(..) column in Oracle
#2633 - Fix manual to link to appropriate Javadoc
#2655 - Improve ArrayIndexOutOfBoundsException: -1 error message when unknown
        field is accessed from a record
#2658 - Inefficient emulation of row value expression comparison predicates <,
        <=, >, >=. Factor out predicates for improved index usage
#2773 - Confusion of Unix vs Windows style line terminators in source code
#2781 - Disambiguate collisions between enum literals and package names
#2792 - data(Object, Object) methods do not unset the value if null is passed
#2795 - Bad Javadoc on DSLContext.fetchOne(String) method
#2798 - Inconsistent logic executed between Record.setValue(Field<T>, T) and
        BookRecord.setId(Integer) (generated)
#2816 - Manual shows wrong DefaultConfiguration constructor call for use with
        Spring
#2819 - Invalid SQL rendered for Ingres row value expression predicates
#2820 - Invalid SQL rendered for Ingres derived column lists
#2825 - IngresDatabase treats unique keys as primary keys
#2831 - Bad Javadoc formatting on MySQLDSL's and MariaDBDSL's enumType() method
#2835 - UpdatableRecord.store() and DSLContext.executeInsert() show different
        behaviour with respect to NULL value insertion
#2842 - Sybase CAST(? AS LONG VARCHAR) must not contain a length
#2845 - AbstractStoreQuery.prepare() does not apply RenderKeywordStyle when
        specifying column names for return after INSERT
#2857 - Unnecessary whitespace rendered in USING() clause
#2858 - Bad example in manual related to stored procedure call
#2864 - Check if ALL_MVIEW_COMMENTS exists before using it (e.g. against an
        Oracle 9i database)
#2866 - Wrong implementation for check if ALL_COLUMNS.DEFAULTED exists
#2869 - DefaultRecordMapper should attach resulting records according to
        Settings.attachRecords, if target type implements Attachable
#2872 - Possible StackOverflowError when using plain SQL tables with inlined
        QueryParts
#2879 - An exception in the check constraint loader can cause all constraint
        loading to fail
#2881 - Throw IllegalArgumentException when calling SelectQuery.addJoinOnKey()
        and addJoinUsing() with bad JoinType
#2887 - jooq-codegen-maven should use a target directory relative to the module
#2913 - Improve code generator compatibility with PostgreSQL 8.x by removing the
        selection of INFORMATION_SCHEMA.COLUMNS.IDENTITY_GENERATION
#2916 - Improve code generator compatibility with PostgreSQL 8.x by avoiding the
        use of window functions
#2917 - Improve code generator compatibility with PostgreSQL 8.x by avoiding
        casting to enum types
#2922 - Manual Bug: SQL Builder example does not compile
#2923 - Manual Bug: It is not clear where FK_BOOK_AUTHOR is imported from
#2926 - Add code-generation support for the MySQL / MariaDB TINYTEXT data type
#2937 - Fix trailing whitespaces in generated code
#2942 - Error in the manual: Wrong class linked
#2956 - Field.isFalse() / isTrue() result in extra parameters
#2958 - Error when the code-generation database user has insufficient grants to
        read the "mysql" meta schema
#2963 - Lower log level for warnings about unknown SQL data types from
        MetaDataFieldProvider (plain SQL)
#2977 - Missing parent pom.xml file in deliverables
#2982 - Variable binding doesn't work in vendor-specific UPDATE t1 JOIN t2
        queries, when joined tables are subqueries with bind values
#2987 - Bind values are not debug-logged for standalone stored procedure or
        function calls
#2989 - Inherit complete Record state when calling Record.into(Class<? extends
        Record>)
#2994 - Manual Bug: The jOOQ 2.x Table.getFields() method is used, which doesn't
        exist
#3013 - The Configuration's RecordMapperProvider is not used when mapping
        UDTRecords
#3019 - Bad SQL rendered from HSQLDBDatabase when loading check constraints
#3023 - DefaultRecordMapper does not map nested UDTs onto nested POJOs
#3027 - Missing whitespace / newline on emulated multi-value INSERT
#3036 - RecordListeners don't receive "end" events when exceptions occur
#3039 - Cannot bind NULL with JDBC Types.BOOLEAN in DB2
#3042 - Work around flaws in H2's INFORMATION_SCHEMA.CONSTRAINTS.COLUMN_LIST
#3046 - UDTRecordImpl.toString() may throw NullPointerException, if custom
        RecordMapperProvider maps Record to null
#3048 - Nested UDTs are no longer attached when fetched from queries (as opposed
        to procedures)
#3050 - DefaultRecordMapperProvider should implement Serializable

Version 3.2.0 - October 9, 2013
================================================================================

With the new jOOQ 3.2, apart from introducing great new features, we are
changing quite a few things on how we operate. At Data Geekery GmbH, we believe
in Open Source. But we also believe in the creative power enabled by commercial
software. This is why we have chosen to implement a dual-licensing strategy.
Read more about this strategy here:

http://blog.jooq.org/2013/10/09/jooq-3-2-offering-commercial-licensing-and-support

But jOOQ 3.2 also ships with great new features! They include:

A new RecordListener SPI which can be hooked into the Configuration in order to
control ActiveRecord lifecycle events. This is very useful if you want to
initialise some database records prior to inserting new data, or if you want to
implement a central ID generation strategy, e.g. by generating Java UUIDs.

A new, experimental VisitListener SPI which can be hooked into the Configuration
in order to control jOOQ's complete QueryPart rendering and variable binding
lifecycle. Use this powerful SPI to perform custom SQL transformation, e.g. to
implement shared-schema multi-tenancy, or a security layer centrally preventing
access to certain data.

With this release, the Oracle and DB2 SQL dialect families will now be able to
distinguish Oracle 10g, 11g, 12c features, as well as DB2 9.x, 10.x features.
This is important as more and more databases start supporting the SQL standard
OFFSET .. FETCH clause and other clauses that are emulated by jOOQ.

The code generator has experienced a lot of improvements, mainly including a new
MatcherStrategy, which can be configured through Maven or XML code generator
configurations. This generator strategy will allow you to implement several
regular-expression based naming pattern replacements for all sorts of generated
artefacts. This is extremely useful to generate table, record, pojo class name
prefixes, suffixes in particular, or to just completely redesign the way the
jOOQ code generator generates things.

Features and improvements
-------------------------
#674  - Add <fluentSetters/> code generation flag to let generated setters
        return this
#996  - Add support for various Postgres ARRAY operations
#1079 - Add support for Oracle's FLASHBACK QUERY clause
#1171 - Add a MatcherStrategy GeneratorStrategy to allow for configurative regex
        pattern matching and replacement
#1644 - Add DSL.dual() to explicitly create a DUAL table that works with any
        dialect
#1903 - Duplicate Query construction API between DSLContext and DSL
#2010 - Add listener API to Record / UpdatableRecord
#2352 - Enhance <ForcedType/> to allow for forcing a type upon all columns /
        parameters / attributes of a given data type
#2542 - Add a Keyword type and DSL.keyword(String) to construct it
#2593 - Add Meta.getPrimaryKeys()
#2594 - Add primary key and foreign key navigation support in JDBCDatabase
#2595 - Add implicit conversions from Scala functions to RecordMapper
#2603 - Add <includeExcludeColumns/> flag to code generation configuration to
        indicate that <includes/> and <excludes/> shall also match column names
#2606 - Distinguish ORACLE10G, ORACLE11G, ORACLE12C SQLDialects within the
        ORACLE family
#2618 - Document the fact that different packages are generated for different
        schemas
#2619 - Add an example ExecuteListener to the manual, showing how UPDATE and
        DELETE statements without WHERE clause can be aborted
#2630 - Add DSL.queryPart(String, Object...) and similar methods to create
        simple plain SQL query parts
#2652 - Change tutorial to use the common AUTHOR table, instead of POSTS
#2660 - Add some documentation about jOOQ not supporting operator precedence
#2665 - Implement SPI for RenderContext listening to allow for custom SQL
        transformation
#2666 - Pull up RenderContext.sql(QueryPart) and BindContext.bind(QueryPart) to
        Context.visit(QueryPart)
#2667 - Add org.jooq.Clause and let org.jooq.Context listen on start(Clause) and
        end(Clause) events
#2676 - Add QueryPartInternal.clause() to allow for QueryParts to return Clause
        information to org.jooq.Context
#2689 - Expose a DAO's internal RecordMapper through DAO.mapper()
#2696 - Provide default implementation for CustomQueryPart.bind() (for all
        Custom QueryParts)
#2699 - Generate DEFAULT and NULL metadata information on generated DataTypes
#2701 - Document the fact that jOOQ sets changed flags to true, even if
        Record.setValue() sets the value already present in the record
#2702 - Add DataType.defaulted() and DataType.nullable()
#2706 - Generate "full" constructors in records, allowing to construct a record
        with all values set
#2713 - Add support for custom code sections in generated code
#2722 - Add DSLContext.newRecord(Field<?>...) to support the creation of custom
        record types
#2723 - Add example VisitListener implementation that prevents UPDATE, DELETE
        statement execution without explicit WHERE clause
#2724 - The default logger should log the number of affected records, if
        applicable
#2725 - Add ExecuteContext.rows() to indicate the number of affected rows in the
        last executed statement
#2726 - Add Attachable.detach()
#2729 - Emulate IS DISTINCT FROM through IS / IS NOT in SQLite
#2733 - Add the default log4j.xml configuration file to the maven plugin
#2745 - Generate default constructor and "assignment-constructor" in POJOs
#2757 - Add support for DB2 10.5
#2761 - Add some documentation to the manual showing how GeneratorStrategy SPI
        is used by jOOQ-codegen
#2764 - Let CRUD operations be able to perform UPDATEs on primary keys
#2765 - Add support for a database-agnostic GENERATE_SERIES(FROM, TO) table
        function

API changes (backwards-compatible)
----------------------------------
#2581 - Deprecate fetchLater() and FutureResult<R>
#2662 - Deprecate the internal method
        DSLContext.bind(QueryPart, PreparedStatement)
#2719 - Change various method(Collection<SortField<?>>) into
        method(Collection<? extends SortField<?>>)

Bug fixes
---------
#1908 - Compilation error in generated code when a MySQL procedure and function
        share the same name and signature
#2534 - Correctly handle Oracle BLOB and CLOB data types, when fetched through
        plain SQL
#2580 - Bad SQL rendered when combining DISTINCT with LIMIT .. OFFSET in DB2,
        SQL Server
#2584 - ORA-00904: "SYS"."ALL_PROCEDURES"."OBJECT_TYPE": invalid identifier when
        running code generation with Oracle 10gR1
#2586 - Bad SQL dialect referenced from ASE's and CUBRID's package-info.java
#2591 - Result.intoGroups() and similar methods create key Records with
        changed=true
#2592 - Qualified names created using DSL.name(String...) should not render null
        or empty string parts
#2596 - Scala tests don't run with Maven
#2597 - f1.concat(f2).toString() seems to render unnecessary cast expression
#2608 - Error in code generator when the sqlite_sequence table is missing
#2613 - The batch INSERT query example in the manual is no longer correct with
        jOOQ 3.x
#2624 - Wrong SQL Server 2012 detection in jOOQ-Meta
#2628 - Add missing Javadoc to DefaultDSLContext
#2634 - Minor documentation bug: The MockDataProvider uses toLowerCase() but
        upper-case SQL keywords
#2643 - Routine.execute(Configuration) should restore the original routine state
        after execution
#2681 - "Type NULL is not supported in dialect MYSQL" when calling
        Meta.getTables() with MySQL or MariaDB JDBC drivers
#2690 - Inaccurate runtime xsd versions in 3.1 manual
#2703 - SQLDialect.getNameLC() and getNameUC() are not NPE-safe
#2707 - PostgreSQL ENUM ordering is inconsistent with the database
#2708 - Wrong SQL rendered for CAST(x AS DECIMAL(y, z)). Precision and scale are
        lost.
#2712 - Field.equalIgnoreCase(String) method broken for SQL Server
#2714 - Documentation bug in INSERT statements. Cannot combine Field<?> with
        String arguments in VALUES() clause
#2717 - DefaultResultSet compile-time depends on Java 1.7 / JDBC 4.1
#2718 - NullPointerException in code generator when a primary key (or foreign
        key) column is excluded from code generation
#2720 - Fix the manual's claim that <includes/> accepts comma-separated regular
        expressions
#2730 - Immutable Pojo+Interface code generation produces uncompilable pojo
#2736 - Improve code generator compatibility with PostgreSQL 8.x by testing if
        pg_catalog.pg_enum and information_schema.attributes exist
#2753 - DATE_DIFF() with CURRENT_DATE() returns wrong precision in Oracle
#2755 - Incomplete @Support annotations on OrderedAggregateFunction methods
#2758 - Duplicate primary key column references generated for DB2
#2759 - DSLContext.fetchCount() fails when argument SELECT statement does not
        explicitly provide column names in SQL Server
#2760 - org.jooq.Meta should treat MySQL databases as Schema, not as Catalog
#2766 - Javadoc typo on DSLContext.batchDelete()

Version 3.1.0 - June 30, 2013
================================================================================

With this release, MariaDB is now finally officially supported by jOOQ! MariaDB
is a MySQL fork, which currently has a very similar feature set as its parent.
As such forks tend to evolve into different directions very quickly, it makes
sense to add formal support in jOOQ.

SQL Server 2012 is another SQL dialect that is now officially supported in jOOQ,
allowing to make use of the newly supported ROWS UNBOUNDED PRECEDING and similar
windowing clauses, as well as the long awaited OFFSET .. FETCH clause. From now
on, jOOQ SQLDialect.family() allows to define a super-set of SQL dialects by the
same vendors with only subtle differences.

POJO mapping is taken to the next level. jOOQ opened up its internal
DefaultRecordMapper providing useful Record to POJO mapping algorithms. But your
custom domain model might be more complex. Instead of creating the next
impedance mismatch, trying to foresee your own mapping algorithm needs, jOOQ
allows you to inject a RecordMapperProvider into your Configuration, allowing to
override record mapping with arbitrary behaviour.

This minor release is also a strong step forward towards a more unified SQL
experience, where row value expression IN predicates and comparison predicates
are simulated with an equivalent EXISTS predicate. See this blog post for more
details:
http://blog.jooq.org/2013/05/03/sql-query-transformation-fun-predicates-with-row-value-expressions

Note, that for technical reasons, jOOQ 3.0.0 could not yet be integration
tested with DB2, Ingres, and Sybase ASE. Consider using jOOQ 2.6, instead

Features and improvements
-------------------------
#552  - Add SQLDialect.family() to group several SQLDialect versions of the same
        RDBMS
#742  - Improve MySQL Stored Procedure support using MySQL 5.5's
        INFORMATION_SCHEMA.PARAMETERS dictionary table
#833  - Add integration tests for both jconn3 and jTDS JDBC drivers for Sybase
        and SQL Server
#963  - Map SQL Server TINYINT to UByte
#965  - Add support for Sybase SQL Anywhere unsigned number types
#1373 - Add <T> Field<T> DSL.coerce(Field<?>, DataType<T>) and similar methods,
        to coerce a field to a given data type (as opposed to casting it)
#1836 - Document using jOOQ with Spring for transaction support
#1885 - Add test to count opening and closing of Statements and ResultSets by
        jOOQ
#2022 - Add support for SQL Server 2012 windowing clauses in window functions
#2058 - Add support for the MariaDB database
#2095 - Document <forcedType/>'s feature of forcing a column onto a SQL type
#2235 - Add Result<?> DSLContext.fetchFromTXT() to allow for loading results
        that were exported using Result.format()
#2236 - Add DSLContext.batch(String...) and batch(String, Object[]...) to easily
        create batch statements from SQL strings
#2291 - Add DSLContext.fetchAny(Table, Condition) method and others
#2299 - Allow for setting ResultSet flags (e.g.
        ResultSet.TYPE_SCROLL_INSENSITIVE through
        ResultQuery.resultSetConcurrency(), resultSetType(),
        resultSetHoldability()
#2310 - Add DSL.using(Connection) and DSL.using(Connection, Settings) which
        auto-detect the SQLDialect from the jdbc url
#2311 - Add Configuration.recordMapperProvider() to override jOOQ's internal
        default ReflectionMapper
#2339 - Support CUBRID 9.1's new features
#2344 - Add a new ControlFlowSignal that is used to explicitly jump out of a
        control flow
#2355 - Add support for Postgres / HSQLDB's TRUNCATE [...] RESTART / CONTINUE
        IDENTITY
#2357 - Add support for Postgres' TRUNCATE [...] CASCADE statement
#2395 - Simulate row value expression IN predicate using EXISTS
#2414 - Add Setting to influence parameter rendering (indexed, named, inlined)
#2416 - Add Result.intoXML(org.xml.sax.ContentHandler) to generate a SAX event
        stream from a jOOQ result
#2423 - Add support for SQL Server 2012 native OFFSET .. FETCH clause
#2424 - Integration-test jOOQ with the SQLite xerial driver
#2426 - Add DSLContext.batch(Query, Object[]...) as a convenience for calling
        batch(Query).bind(Object...).bind(Object...)
#2427 - Add more Javadoc to ResultQuery.fetchResultSet() explaining that
        underlying PreparedStatements are closed with ResultSet.close()
#2428 - Simulate row value expression comparison predicates using EXISTS
#2430 - Add CustomQueryPart for use with plain SQL and other places
#2434 - Add Field.compare(Comparator, Select) and Field.compare(Comparator,
        QuantifiedSelect) to allow for more dynamic SQL
#2437 - Add RenderContext.paramType() and deprecate RenderContext.inline() and
        .namedParams()
#2440 - Expose the DataSource contained in the DataSourceConnectionProvider
#2441 - Add DSL.cast(Field<?>, XXX) for increased API consistency
#2446 - Add JDBCUtils.dialect(Connection) to "guess" the jOOQ SQLDialect from a
        JDBC Connection
#2466 - Add a public DefaultDSLContext implementation that can be used by users
        to override the default behaviour
#2485 - Allow for treating Field<Boolean> as Condition
#2496 - Add support for SQL Server 2012 sequences
#2499 - Add JDBCUtils.safeClose(Connection)
#2509 - Expose CHECK constraints in jOOQ-meta
#2519 - Add Record.from(Object, Field<?>...) from(Object, String...),
        from(Object, int...) to copy only a select set of values from a POJO,
        Array, Map
#2521 - Add {Row|Record}.fields(Field<?>...), {Row|Record}.fields(String...),
        {Row|Record}.fields(int...) to extract Field<?>[] from a row or record
#2527 - Add org.jooq.tools.jdbc.DefaultResultSet to provide a default ResultSet
        delegation implementation
#2531 - Add integration tests mapping binary(16) to java.util.UUID
#2532 - Let batch executions debug-log executed queries
#2535 - Convert.convert(Object, Class) should support simple casting
#2547 - Document some SQL language to jOOQ DSL API mapping rules in the manual
#2566 - Upgrade integration test jTDS version to 1.3.1
#2571 - Add a new RecordType<R extends Record> type to make up for the missing
        recursive type definition on Record

API changes (backwards-incompatible)
------------------------------------
#2468 - API bug: MergeNotMatchedSetStep.set(Field, Select) returns
        MergeMatchedSetMoreStep instead of MergeNotMatchedSetMoreStep

Bug fixes
---------
#1520 - Handle Ingres', SQLite, SQL Server's, Sybase ASE's limitations of 1024,
        999, 2100 or 2000 maximum bind values per query
#2135 - Postgres ENUM data type isn't supported correctly, if the ENUM needs
        full qualification
#2323 - NullPointerException when calling Schema.getTables() on a meta schema
        with SQLite
#2401 - Bad package name generated when <packageName/> contents are not trimmed
#2404 - Cannot combine <dateAsTimestamp/> with <forcedType/> if both match
#2412 - jOOQ Meta does not recognise non-uppercase IN, OUT, INOUT keywords in
        MySQL stored procedures
#2413 - Suppress warnings in generated code (@SuppressWarnings("all") doesn't
        suppress "rawtypes" warnings with javac)
#2418 - RenderContext.data() is not passed on to QueryParts when being rendered
#2422 - Upgrade RSyntaxTextArea to 2.0.7
#2432 - Manual refers to a package-private DefaultConfiguration constructor
#2443 - AbstractStoreQuery.execute() doesn't correctly operate on the
        Configuration's ConnectionProvider in SQLite IDENTITY fetching queries
#2445 - JDBCDatabase doesn't recognise Oracle's VARCHAR2 data type (and other
        vendor-specific data types)
#2447 - Tables collected through DSLContext.meta() return duplicate columns if
        multi-schema environments contain identical tables
#2449 - JDBCDatabase doesn't use DataType.length(), precision(), and scale()
#2450 - Cannot set precision on TINYINT, SMALLINT, INT, BIGINT data types
#2461 - Generator Encoding Error for Database-Objects with Unicode-Names
#2464 - Bad SQL rendered from DELETE statements with aliased tables
#2469 - NullPointerException in AbstractResultQuery.fetchOneMap()
#2477 - MySQL's unsigned types cannot be used in other dialects
#2478 - IngresDatabase erroneously joins IIINDEXES to get constraint columns,
        rather than using IIKEYS
#2494 - Possible null pointer passed to ConnectionProvider.release()
#2502 - Code generation fails to generate valid java for stored procedures that
        accept parameters named configuration.
#2506 - SQLDialectNotSupportedException on DSL.inline(T, Class), when jOOQ's
        internals are not (yet) properly initialised
#2515 - Compilation errors when generating code for artefacts that differ only
        by a trailing underscore(s): A and A_ and A__
#2523 - Statement.close() may be called upon previously closed statements
#2528 - Combining renderFormatted with inlined bind variables will change bind$
        values when they contain newlines
#2562 - Bad SQLDialect reference in Oracle and MySQL package-info.java
#2569 - Error when rendering SQL Server procedures with Settings.renderSchema
        == false

Version 3.0.0 - April 28, 2013
================================================================================

This major release is a great move towards better integration of SQL as a
language in Java. Unlike any other database abstraction framework, jOOQ now
formally supports the notion of "row value expressions". The jOOQ API uses
Xtend-generated API types from Row1 .. Row22, as well as Record1 .. Record22 to
bring you even more compile-time typesafety on a record-level.

In SQL, you can typesafely write

<pre class="prettyprint lang-sql">
  SELECT * FROM t WHERE (t.a, t.b) = (1, 2)
  SELECT * FROM t WHERE (t.a, t.b) OVERLAPS (date1, date2)
  SELECT * FROM t WHERE (t.a, t.b) IN (SELECT x, y FROM t2)
  UPDATE t SET (a, b) = (SELECT x, y FROM t2 WHERE ...)
  INSERT INTO t (a, b) VALUES (1, 2)
</pre>

In jOOQ, you can now (also typesafely!) write

<pre class="prettyprint lang-java">
  select().from(t).where(row(t.a, t.b).eq(1, 2));
  // Type-check here: ----------------->  ^^^^
  select().from(t).where(row(t.a, t.b).overlaps(date1, date2));
  // Type-check here: ------------------------> ^^^^^^^^^^^^
  select().from(t).where(row(t.a, t.b).in(select(t2.x, t2.y).from(t2)));
  // Type-check here: -------------------------> ^^^^^^^^^^
  update(t).set(row(t.a, t.b), select(t2.x, t2.y).where(...));
  // Type-check here: --------------> ^^^^^^^^^^
  insertInto(t, t.a, t.b).values(1, 2);
  // Type-check here: ---------> ^^^^
</pre>

This also applies for existing API, which doesn't involve row value expressions:

<pre class="prettyprint lang-java">
  select().from(t).where(t.a.eq(select(t2.x).from(t2));
  // Type-check here: ---------------> ^^^^
  select().from(t).where(t.a.eq(any(select(t2.x).from(t2)));
  // Type-check here: -------------------> ^^^^
  select().from(t).where(t.a.in(select(t2.x).from(t2));
  // Type-check here: ---------------> ^^^^
</pre>

And for UNIONs

<pre class="prettyprint lang-java">
  select(t1.a, t1.b).from(t1).union(select(t2.a, t2.b).from(t2));
  // Type-check here: -------------------> ^^^^^^^^^^
</pre>

These type-checks are preformed by your Java compiler, considering the generic
type information of your SQL statement's Record data types. These include:

- Record1<T1>
- Record2<T1, T2>
- Record3<T1, T2, T3>
- ...
- Record22<T1, T2, T3, .., T22>

The highest degree of typesafety was chosen to be 22, to match Scala's Tuple22,
Product22 and Function22 types. Higher degree records are still supported by
jOOQ, just without the additional typesafety.

This Record typesafety is applied to

- SELECT statements
- INSERT and MERGE statements: the VALUES() clause
- UPDATE statements: SET A = (SELECT...)
- UPDATE statements with row value expressions: SET (A, B) = (SELECT...)
- Quantified comparison predicates: ANY(SELECT...) and ALL(SELECT...)
- Comparison predicates: = (SELECT...)
- IN predicates: IN (SELECT...)
- BETWEEN predicates: BETWEEN (SELECT...) AND (SELECT...)
- Generated records
- The new VALUES() constructor
- Scala integration for conversion of jOOQ Record[N] to Scala's Tuple[N]

Apart from this major improvement, there had been many minor changes throughout
the jOOQ API. Here are some important ones:

- Factory has been split into DSL (static QueryPart construction) and
  DSLContext (Query execution, "attached" QueryPart construction). This greatly
  improves the overall DSL experience while allowing for more fine-grained
  Executor lifecycle control.
- A ConnectionProvider has been introduced as an abstraction of the JDBC
  Connection lifecycle. The standalone Connection and pooled DataSource modes
  are still supported, but you can now inject your own ConnectionProvider for
  more control.
- A lot of performance improvements have been implemented within the jOOQ API
  removing most of the overhead caused by jOOQ when fetching data from JDBC
- A JDBC Mock API has been added to help you create simple unit tests for your
  application built on top of jOOQ.
- A VALUES() constructor is now supported, and derived column lists to alias
  tables and columns in one go.
- The data type API has been greatly simplified. This allowed for the
  introduction of runtime precision, scale, and length information.
- CRUD has been improved through many more CRUD batch operations, explicit
  INSERT and UPDATE (in addition to store()), and explicit handling of jOOQ's
  internal changed flags.

As this is a major release, some backwards-incompatibilities were inevitable.
For those users among you, migrating from jOOQ 2.x to 3.0, here are a couple of
useful hints:
http://www.jooq.org/doc/3.0/manual/reference/migrating-to-3.0/

Note, that for technical reasons, jOOQ 3.0.0 could not yet be integration
tested with DB2, Ingres, and Sybase ASE. Consider using jOOQ 2.6, instead

Note, that further code generation and model API improvements were postponed to
a later release

Note, previous release candidates contained more features, improvements and bug
fixes. See their respective sections for details.

Features and improvements
-------------------------
#2410 - Add some more API usage examples to the section about ResultSet fetching
#2415 - Add Constants.MINOR_VERSION and Constants.FULL_VERSION for internal and
        external reuse

Bug fixes
---------
#1998 - Wrong screenshots in the manual's section about code generation.
        jooq-meta.jar is missing
#2407 - Fix bad references to pre-3.0 Factory in Javadoc

Version 3.0.0 (RC3) - April 12, 2013
================================================================================

This major release is a great move towards better integration of SQL as a
language in Java. Unlike any other database abstraction framework, jOOQ now
formally supports the notion of "row value expressions". The jOOQ API uses
Xtend-generated API types from Row1 .. Row22, as well as Record1 .. Record22 to
bring you even more compile-time typesafety on a record-level.

See release 3.0.0 for more information.

Features and improvements
-------------------------
#2195 - Remove the standalone tutorial, link to the manual
#2321 - Implement various Key.toString() methods
#2329 - Add Javadoc to Configuration.executeListenerProviders()
#2331 - Add hint to the manual about mvn eclipse:clean and eclipse:eclipse when
        building jOOQ
#2363 - Change the readme file to use Markdown
#2366 - Add org.jooq.util.example package to jOOQ-codegen with some example
        GeneratorStrategies
#2372 - Add aliases for arithmetic operators to be able to use Groovy default
        operator overloading
#2389 - Make org.jooq.impl.DefaultConfiguration public
#2392 - Add Configuration.set() methods. They should allow for modifying a
        Configuration
#2396 - Add DSL.function(Name, Class, Field...) and
        DSL.function(Name, DataType, Field...) to allow for custom,
        fully-qualified function references

API changes (backwards-compatible)
----------------------------------
#2378 - Allow for overriding getIdentity() and getReferences() in CustomTable

API changes (backwards-incompatible)
------------------------------------
#2328 - Remove UpdatableTable marker interface, pulling up methods to Table
#2342 - Change Configuration.data() to return Map<Object, Object>
#2343 - Decouple lifecycle of Configuration and ExecuteContext
#2350 - Do not statically reference a Connection from GenerationTool
#2353 - Decouple org.jooq.Context from Configuration. Choose composition over
        inheritance
#2362 - Decouple org.jooq.DSLContext from Configuration. Choose composition over
        inheritance
#2379 - Replace 3.0-RC1 Executor type by a contextual DSL type constructed from
        DSL.using()
#2380 - Rename org.jooq.impl.Factory to org.jooq.impl.DSL
#2382 - Let DAO reference a Configuration instead of a DSLContext
#2388 - Replace Configuration's List<ExecuteListener> with
        ExecuteListenerProvider[] to simplify correct and thread-safe client
        implementations
#2390 - Change Configuration API to reflect jOOQ-style getter / setter naming
#2391 - Rename dialect-specific Factories [Dialect]Factory to [Dialect]DSL
#2399 - Remove support for the USE statement

Behaviour changes (backwards-incompatible)
------------------------------------------
#2351 - Relax ConnectionProvider contract, allowing acquire() to return new
        Connections even before release() is called

Bug fixes
---------
#1868 - Cursor.close() doesn't terminate the ExecuteListener life cycle
#2325 - "HsqlException: incompatible data type in conversion" when binding a
        UUID[] to an HSQLDB prepared statement
#2327 - Compilation error in generated tables, when a table contains a UNIQUE
        key but no PRIMARY key
#2332 - Documentation example regarding DSL.concat() does not compile
#2336 - jOOQ 3.0 regression: NoClassDefFoundError caused by missing log4j
        dependency
#2338 - Tutorial example unclear: There are three artefacts in Maven, not one
#2346 - org.jooq.Meta's generated Schema and other objects are Serializable, but
        their enclosed Meta instance is not
#2347 - Let equals() implementations succeed early on identity
#2354 - Single page manual display errors on Firefox
#2361 - Inaccurate Configuration Javadoc explaining wrong ExecuteListener
        lifecycle
#2367 - SQLite identifiers that collide with keywords should be quoted
#2381 - Do not add TableFieldImpl to table in constructor of TableFieldImpl
#2385 - fetchOne() and fetchLazy() don't terminate the ExecuteListener life
        cycle when an exception occurs
#2393 - Fully qualified name not used for user-defined aggregate function

Version 3.0.0 (RC2) - March 8, 2013
================================================================================

This major release is a great move towards better integration of SQL as a
language in Java. Unlike any other database abstraction framework, jOOQ now
formally supports the notion of "row value expressions". The jOOQ API uses
Xtend-generated API types from Row1 .. Row22, as well as Record1 .. Record22 to
bring you even more compile-time typesafety on a record-level.

See subsequent release candidates or release 3.0.0 for more information.

Features and improvements
-------------------------
#2200 - Add Executor.fetchCount(Select<?>) and Select.fetchCount() to replace
        the projection by a COUNT(*) query
#2244 - Add section to the manual indicating that the jOOQ generator can only
        handle schemas of a certain size
#2255 - Add code generation option to avoid the generation of "global object
        references"
#2257 - Add List<IdentityDefinition> Database.getIdentities(SchemaDefinition)
        for convenience to jooq-meta
#2258 - Restore private and deprecated versions of the Factory constructors,
        adding some Javadoc about the changes between jOOQ 2.x and 3.0
#2270 - Add section to the manual indicating how to build jOOQ with Maven
#2272 - Add a paragraph to the manual's preface, explaining "why not just use
        SQL"?
#2281 - Add Result<Record> Executor.fetchFromStringData(List<String[]>) in order
        to reuse logic from fetchFromCSV
#2285 - Add more verbosity to the code generator, when configured badly
#2290 - Add Database.getUniqueKeys() and getForeignKeys to jOOQ-meta
#2297 - Add section to the manual indicating how the various generator flags
        depend on each other
#2308 - Do not generate "final" Tables.java, UniqueKeys.java, etc.

Bug fixes
---------
#2212 - "code size too large" in generated SchemaImpl, when the number of tables
        exceeds 15k
#2238 - Code generation runs extremely slow for large schemas (Inefficient
        DefaultRelations.getUniqueKeys() and getForeignKeys() methods)
#2239 - Code generation runs extremely slow for large schemas (Inefficient
        AbstractDatabase.filterSchema() methods)
#2252 - ArrayIndexOutOfBoundsException, when rendering plain SQL that is
        terminated by a comment
#2259 - RenderMapping has no effect, if not supplied to the Executor constructor
#2262 - RenderSchema has no effect, if not supplied to the Executor constructor
#2267 - SQLDialectNotSupportedException: Type class org.postgis.PGgeometry is
        not supported in dialect null, when binding PG* objects
#2271 - jOOQ Unit tests fail when not run in CET / CEST
#2273 - Tutorial bug, referencing wrong Maven dependency. jOOQ 3.0.0 is not yet
        released, only RC1
#2276 - Wrong MockDataProvider manual example
#2278 - Postgres (UUID and other) ARRAY types aren't correctly inlined as string
        literals
#2279 - UUIDs aren't correctly deserialised from Postgres UDTs
#2280 - Improve supported formats for MockFileDatabase
#2283 - Class loading issues in GenerationTool when called by Gradle
#2294 - Compilation errors when code generator is configured with
        <daos>true</daos> and <relations>false</relations>
#2298 - Suppress warnings in generated code (@SuppressWarnings("all") doesn't
        work with javac)
#2312 - Annotate org.jooq.Support with java.lang.annotation.Documented to make
        it part of the public API (in Javadoc)
#2314 - Outdated GenerationTool Javadoc

Version 3.0.0 (RC1) - February 16, 2013
================================================================================

This major release is a great move towards better integration of SQL as a
language in Java. Unlike any other database abstraction framework, jOOQ now
formally supports the notion of "row value expressions". The jOOQ API uses
Xtend-generated API types from Row1 .. Row22, as well as Record1 .. Record22 to
bring you even more compile-time typesafety on a record-level.

See subsequent release candidates or release 3.0.0 for more information.

Features and improvements
-------------------------
#456  - Add runtime support for PRECISION, SCALE, and LENGTH attributes
#834  - Add support for the Firebird / Postgres UPDATE .. RETURNING clause
#915  - Add <T1, T2, ..., T[N]> Table<Record[N]<T1, T2, ..., T[N]>>
        Factory.values(Row[N]<T1, T2, ..., T[N]>...), to create ad-hoc tables
        from data
#1038 - Introduce new type GroupField for cube(), rollup() and groupingSets()
        functions. Accept only GroupField... in groupBy() clauses
#1097 - Add org.jooq.Catalog, a type modelling an entity combining several
        org.jooq.Schema
#1144 - Overload Executor.fetch[One|Lazy](ResultSet, X...) with X being
        Field<?>, DataType<?>, Class<?>
#1178 - Allow for treating Condition as Field<Boolean>
#1583 - Add support for row value expressions in UPDATE statements: UPDATE ..
        SET (A, B, C) = (SELECT X, Y, Z)
#1624 - Add support for java.util.UUID as a <T> type
#1663 - Document RenderContext and make it part of the public API
#1686 - Add UpdatableRecord.insert() and update()
#1689 - Generate <E> E into(E) and <E> R from(E) methods to generated records
#1690 - Add UpdatableRecord.key() returning a Record holding PK values
#1695 - Add Factory.all() and Factory.any() to create quantified expressions
#1703 - Add Executor.batchDelete(UpdatableRecord<?>...) to mass-delete a set of
        UpdatableRecords
#1801 - Add Table.as(String, String...) to allow for creating a table aliases
        (correlation names) with derived column lists
#1874 - Add Record1, Record2, ... Record[N] similar to Row1, Row2, ... Row[N] to
        support record type-safety
#1897 - Add a section to the manual about the migration to jOOQ 3.0
#1899 - Make some JDBC-related utility methods publicly available in
        org.jooq.tools.jdbc.JDBCUtils
#1902 - Duplicate SELECT API between Executor and Factory
#1904 - Add Executor.fetch(ResultQuery), Executor.execute(Query), and similar
        methods
#1905 - Add Row[N].equal(Select<? extends Record[N]>) and similar methods
#1906 - Use Xtend to generate Row[N], Record[N] and other [N]-related API code
        artefacts
#1914 - Document the fact that SELECT * is performed by leaving the SELECT list
        empty
#1917 - Add support for CUBRID 9.0's window functions and MERGE statement
#1918 - Let generated Records implement Record[N] if applicable
#1919 - Support higher degrees of Row[N] and Record[N] types. Match Scala's max
        degree of 22
#1920 - Add more implicit defs in order to treat Record[N] as Scala's Tuple[N]
#1923 - Add Record.intoResultSet() to create a single-record JDBC ResultSet from
        a Record
#1924 - Add support for CUBRID 9.0's ENUM data type
#1932 - Generate Javadocs for Table constructors
#1934 - Improve generated Record Javadoc
#1951 - Add support for the SQL Server WITH (...) table hints
#1966 - Add Row[N].equal(Record[N]) and similar convenience methods
#1967 - Document using MySQL's SQL_CALC_FOUND_ROWS as an Oracle hint
#1968 - Add org.jooq.Meta returned from Executor.meta() to return a wrapped JDBC
        DatabaseMetaData object
#1972 - Move MySQLFactory.md5() to Factory and simulate it for Oracle
#1973 - Add Executor.fetchOne(ResultSet)
#1975 - Add Result.sort{Asc|Desc}(int) and (String) to order by field index /
        name
#1981 - Add support for DB2 CGTT and MQT
#1983 - Improve the Javadoc on Table.as() and Field.as() to hint at
        case-sensitivity and RenderNameStyle
#1984 - Add ResultQuery.fetchOneInto()
#1986 - Add Record.fromMap() as the inverse operation of Record.intoMap()
#1987 - Allow for reading data from arrays, Maps through Record.from()
#1988 - Add Record.fromArray() as the inverse operation of Record.intoArray()
#1989 - Add Record.changed(Field<?>), changed(int), changed(String) to check
        whether a single field's value has changed
#1990 - Add <T> T Record.original(Field<T>), original(int), original(String) to
        get a Field's original value
#1991 - Reflect changed flag in Result.toString() (and thus also
        Record.toString())
#1999 - Add Record.changed(boolean) changed(Field<?>, boolean)
        changed(int, boolean) changed(String, boolean) as setters for the
        changed flag
#2000 - Add Record.reset(), reset(Field<?>), reset(int), reset(String) to
        restore original values in a record
#2008 - Add elementFormDefault="qualified" to XSD specifications to allow for
        XML validation of jOOQ configuration files
#2020 - Let org.jooq.ExecuteListener extend java.util.EventListener
#2021 - Add UpdatableRecord.refresh(Field<?>...) to allow for refreshing a
        subset of the Record's values
#2027 - Document semantic versioning rules as understood by jOOQ
#2028 - Add Batch.size() to indicate the number of queries that will be executed
        by a batch operation
#2030 - Add reusable wrapper types for JDBC Connection, Statement, ResultSet,
        etc.
#2044 - Add various TableRecord.fetchParent(...), fetchChild(...) and
        fetchChildren(...) methods to follow foreign key relationships
#2049 - Add gt() / ge() / lt() / le() to Row[N] types
#2052 - Add [not]Between[Symmetric]() to Row[N] types
#2053 - Add is[Not]Null() to Row[N] types
#2066 - Add Executor.extractBindValues(QueryPart), extractParams(QueryPart) to
        extract bind values in the context of an Executor (i.e. Configuration)
#2072 - Let UDTRecordImpl and ArrayRecordImpl.toString() return a valid
        constructor expression
#2078 - Add Postgres to @Support annotation of SelectForUpdateWaitStep.wait()
#2079 - Support generation of bean validation annotations on records and
        interfaces
#2089 - Generate an "empty" DefaultSchema for those databases that do not have
        any schema (CUBRID, Firebird, SQLite)
#2094 - Add unit tests for org.jooq.tools.Convert
#2107 - Let Record implement Comparable
#2111 - Improve org.jooq.Record Javadoc, to explain the various Record subtypes
#2112 - Add Row.types() and Row.dataTypes() as a convenience
#2113 - Document Record.hashCode() and equals() through Javadoc
#2133 - Allow for mapping <outputSchema/> to "" (empty) in order to avoid the
        generation of a schema
#2156 - Add Row.type(int), type(String), dataType(int), dataType(String) for
        convenience
#2158 - Add Executor.fetchLazy(Table) and fetchLazy(Table, Condition) for
        convenience
#2159 - Let ExecuteListener extend Serializable
#2160 - Add Executor.batchUpdate(UpdatableRecord<?>...) to mass-update a set of
        UpdatableRecords
#2161 - Add Executor.batchInsert(UpdatableRecord<?>...) to mass-insert a set of
        UpdatableRecords
#2162 - Add some more Javadoc to JooqLogger
#2170 - Add 0.0 and 1.0 to Convert.FALSE_VALUES and Convert.TRUE_VALUES
#2171 - Allow for converting booleans to numbers through org.jooq.tools.Convert:
        TRUE => 1, FALSE => 0
#2172 - Add <T> set(Field<T>, Select<? extends Record1<T>>) methods to UPDATE,
        MERGE and INSERT statements
#2176 - Add hint in code generation, when an unsupported, old database version
        is being used (e.g. MS SQL Server 2000)
#2177 - Add ResultQuery.intern() and Result.intern() for string interning in
        result sets
#2179 - Add Javadoc to QueryPart.hashCode() and equals()
#2199 - Allow for INSERT and UPDATE of pre-existing records through
        SET [ Record ] clauses
#2202 - Add Mock JDBC objects for unit testing with jOOQ
#2203 - Add Executor.map(Schema) and Executor.map(Table) as a convenience to
        apply runtime schema mapping
#2204 - Add BatchBindStep.bind(Object[][]) to bind lots of bind values at a time
#2205 - Add <R> Result<R> Executor.newResult(Table<R>) to generate custom
        results

API changes (backwards-compatible)
----------------------------------
#1309 - Let Factory.val() return Param<T> instead of Field<T>
#2031 - Change union(Select<R>) and similar methods to
        union(Select<? extends R>)
#2157 - Change the bounds of various <H extends RecordHandler<R>> H
        fetchInto(H handler) methods to RecordHandler<? super R>
#2197 - Relax bounds on Factory.groupingSets(Collection<Field<?>>...) to
        Collection<? extends Field<?>>...
#2206 - Relax bounds of R on Executor.newRecord() from TableRecord<R> to Record

API changes (backwards-incompatible)
------------------------------------
#1118 - Remove support for the code generation ant task
#1254 - Move org.jooq.tools.unsigned contents to org.jooq.types (along with the
        INTERVAL types)
#1374 - Relax usage of generic <? extends T>. Replace by <T> where data types
        are involved.
#1533 - Extract Executor API from Factory. Let Factory contain only static
        QueryPart factory methods
#1549 - Externalise connection lifecycle through new ConnectionProvider
#1649 - Remove support for code generation from pre-jOOQ 2.0 .properties file
#1740 - Remove support for generated master data enums
#1875 - Add generic <R extends Record> type to SelectXXXStep DSL type hierarchy
        for increased tuple type-safety
#1887 - Remove all deprecated code
#1894 - Remove constructors from dialect-specific factories
#1907 - Remove FactoryOperations, push its API down to org.jooq.impl.Executor
#1921 - Add <T1, T2, ..., T[N]> InsertValuesStep[N]<R, T1, T2, ..., T[N]>
        Executor.insertInto(Table<R>, Field<T1>, Field<T2>, ..., Field<TN>)
#1926 - Add <T1, T2, ..., T[N]> MergeXXXStep<R, T1, T2, ..., T[N]>
        Executor.mergeInto(Table<?>, Field<T1>, Field<T2>, ..., Field<TN>)
#1977 - Remove the confusing concept of having a "main key" as opposed to a
        "primary key"
#2042 - Remove generated setters, setting foreign key values from records
#2043 - Remove generated navigation methods
#2060 - Remove redundant SimpleSelectXXX API
#2117 - Remove the FieldProvider marker interface. Simplify the FieldProvider
        API
#2119 - Rename Row.getDegree() to Row.size()

Behaviour changes (backwards-incompatible)
------------------------------------------
#1235 - SQLite BIGINT data type erroneously maps to java.math.BigInteger
#1578 - Change configuration of ExecuteListeners in Configuration. Listeners
        instances should be provided, not classes
#2076 - Stop "supporting" comma-separated regular expressions in the code
        generator configuration
#2088 - Do not treat CUBRID "owner" as schema in generated code

Bug fixes
---------
#1170 - Improve performance on jOOQ's reflection usage
#1626 - Explicitly implement hashCode() and equals() in some additional
        QueryParts
#1886 - Query.bind() has no effect when Query.keepStatement(true) and
        StatementType.STATIC_STATEMENT are combined
#1890 - Bad Postgres array serialisation when " or \ characters are contained in
        a String[]
#1938 - Improve AbstractField.hashCode() and AbstractTable.hashCode() and
        similar, as these two are called very often
#1942 - Inefficient call to String.split() in StringUtils.toCamelCase() leads to
        non-negligible performance overhead in POJO transformation calls
#1937 - Inefficient implementations of AbstractDataType.equals() and hashCode()
#1954 - Bad SQL rendered when combining ORDER BY [ some-function ] with LIMIT ..
        OFFSET in DB2, SQL Server
#1958 - Bad SQL rendered for OVER (ORDER BY [ some-function ]) for SQL Server
        and Sybase
#1974 - Optimise various Executor.fetchOne() methods, which consume the whole
        ResultSet before throwing an InvalidResultException
#1979 - Thread safety issue in org.jooq.impl.FieldList
#1982 - Change RenderNameStyle.UPPER, LOWER, AS_IS to quote literals if needed
#1992 - Bad reference to org.jooq.debug.[impl].DebugListener in the manual
#1993 - Bad code generated when the same table name exists in multiple schemas
        in SQL Server
#1995 - Record.original() values aren't updated after a Record.store() operation
#1997 - Review the manual's tutorial for integrity
#2001 - Named Params are treated as null literals on right sides of comparisons
#2007 - Bad type coercion on the right hand side of a comparison predicate, when
        the left hand side is Field<Object>
#2011 - Implement some micro-optimisations in DefaultRenderContext
#2025 - Correctly handle multiple foreign keys defined on the same column
#2045 - Bad hashCode calculation when Records contain arrays or byte[]
#2055 - MySQL's UPDATE [t1] JOIN [t2] syntax can cause syntax errors as column
        references are not fully qualified
#2057 - Cannot properly extract bind values for LIMIT .. OFFSET clause from a
        SELECT statement
#2063 - jOOQ-meta loads Firebird composite unique key columns in wrong order
#2073 - The code generator's <dateAsTimestamp/> flag doesn't affect Oracle
        VARRAY and TABLE types
#2082 - Oracle PIVOT expression doesn't bind any variables of a derived table
        being pivoted
#2085 - java.lang.NoSuchMethodError: org.apache.log4j.Logger.isTraceEnabled()Z
        when logger dependency is missing
#2086 - SQL syntax error when aliasing outcome of a relational division
#2091 - CUBRID doesn't really have a NVARCHAR data type
#2098 - NullPointerException when org.jooq.impl.EnumConverter converts null
#2104 - SQLite code generation treats multi-column primary keys like multiple
        single-column unique keys
#2108 - SQLite returns NULL for val(new Date(0)).add(-1) and some other date
        time arithmetic expressions
#2128 - Misleading Javadoc in Factory / Executor.selectCount()
#2137 - Failure to assign a value to a record pojo for a column with a
        composite type when using select into.
#2139 - batchStore with Postgres composite types incorrectly reuses values from
        the first record.
#2140 - No table java mapping generated using maven plugin - missing inputSchema
        in postgres
#2143 - UnsupportedOperationException when binding UDTRecord in batchStore() for
        Oracle
#2144 - Improve AbstractField.equals() and AbstractTable.equals() and similar,
        as these two are called very often
#2145 - Improve QueryPartList.removeNulls() as this is called very often
#2154 - Generated Records should access values by index, not by field, for
        performance reasons
#2165 - Add H2 database definitions to the jOOQ-scala module (to prevent
        compilation errors)
#2167 - Convert.convert("xx", boolean.class) returns null, instead of false
#2178 - Improve FieldList. Avoid creating excessive array lists, where simple
        (immutable) Field<?>[] are sufficient
#2180 - Optimise DAOImpl by using the new ReflectionMapper instead of calling
        Record.into() all the time
#2187 - Change all Javadoc <h3/> tags to <h5/> (To fix Java 7 standard Javadoc
        style layout issues)
#2210 - Executor.fetchFromCSV() shouldn't mark resulting records as "changed"
#2215 - Improve example in the "jOOQ for CRUD" section. Use only columns from
        the sample database
#2223 - SQL injection is possible in org.jooq.impl.Val, if client code doesn't
        correctly enforce generic typesafety, and bind variables are inlined
#2227 - Field.in(T...) doesn't convert argument values to the Field's type

Version 2.6.0 - October 26, 2012
================================================================================

This release has a new main feature: the type-safe support for row value
expressions also known as tuples - up to a degree of 8. The API is formed in a
similar way as pre-existing tuple support in languages like C# or Scala.

jOOQ's Scala integration has also been improved through the new jOOQ-Scala
module, which provides some useful implicit defs for operator overloading.
Future versions of jOOQ-Scala may experiment with Scala 2.10's Macros

This release also ships with a lot of new deprecation to help you prepare for
the upcoming major release.

Minor feature improvements include:

- Lots of new fetchGroups() and intoGroups() methods, thanks to Ivan Dugic
- JDBC execution control support, such as cancel(), maxRows(), queryTimeout()
- Allowing for re-using JDBC PreparedStatement between Query executions
- Support for the SQL standard OVERLAPS predicate
- A new RecordMapper, similar to the existing RecordHandler

Features and improvements
-------------------------
#385  - Allow for keeping open statements in a Query
#600  - Add support for Oracle / SQL Standard linear regression functions
#1058 - Add <T1, T2, .. TN> Factory.row(T1, T2, .. TN) and Factory.row(
        Field<T1>, Field<T2> ... Field<TN>) to allow for creating tuples / rows
#1077 - Add support for the SQL standard OVERLAPS predicate
#1245 - Improve formatting for DECIMAL data types in Result.format(). Nicely
        align the decimal point and reserve space on both sides
#1484 - Let XJC-generated artefacts implement Cloneable
#1527 - Support for converting String to java.net.URL, java.net.URI, and
        java.io.File
#1674 - Export data types with Result.formatXML() and Result.formatJSON()
        exports
#1679 - Add Factory.table(String, QueryPart...)
#1708 - Add <T, E> Map<T, List<E>> ResultQuery.fetchGroups(Field<T>, Class<E>)
#1709 - Add Map<Record, Result<R>> ResultQuery.fetchGroups(Field<?>[])
#1710 - Add <E> Map<Record, List<E>>
        ResultQuery.fetchGroups(Field<?>[], Class<E>)
#1719 - Make logic from ResultQuery.fetchArray() available in Result.intoArray()
#1728 - Add support for the MySQL COUNT(DISTINCT expr, expr...) aggregate
        function syntax
#1744 - Add support for the CUBRID DECR() function
#1756 - Add RecordMapper<E>, similar to RecordHandler<R>, mapping records to
        custom types
#1762 - Add package-info.java to add Javadoc documentation to all packages
#1766 - Simulate row comparisons where they are not supported
#1773 - Add a new jOOQ-Scala project and jooq-scala artefactId,  to contain jOOQ
        extensions in the Scala language
#1782 - Move JAXB bindings out of XSD, in order to support more advanced
        bindings
#1783 - Generate @SuppressWarnings("all") in jOOQ-generated artefacts
#1784 - Enhance the BETWEEN predicate, introducing the AND keyword
#1810 - Add <T, E> Map<T, E> ResultQuery.fetchMap(Field<T>, Class<E>) and
        Result.intoMap(Field<T>, Class<E>)
#1816 - Add support for materialized views in Oracle's code generator
#1828 - Reduce log level for Factory deserialisation to TRACE
#1837 - Add support for @java.beans.ConstructorProperties when fetching into
        immutable POJOs
#1841 - Add SortField Field.sort(SortOrder) to allow for dynamic sorting
#1842 - Add Condition Field.compare(Comparator, Field<T>) to allow for dynamic
        comparisons
#1844 - Add Table<Record> Table.join(TableLike<?>, JoinType) to allow for
        dynamic joining
#1845 - Add Factory.schemaByName(String) for plain SQL schemata
#1848 - Add Record.changed() to indicate whether a Record  contains "dirty"
        values
#1849 - Add Record.original() to obtain the originally fetched  values from a
        Record
#1854 - Add ResultQuery.maxRows(int) to limit the number of  actually fetched
        records
#1855 - Add Query.cancel() to support for interrupting statements prematurely
#1856 - Add Query.queryTimeout(int) to support for JDBC's
        Statement.setQueryTimeout()

API changes (backwards-compatible)
----------------------------------
#1800 - Deprecate AliasProvider
#1807 - Result.intoArray() declares "throws MappingException", which isn't true
#1839 - Deprecate the various Result.getValuesAs[Type] and
        Record.getValueAs[Type] methods
#1840 - Deprecate org.jooq.Store
#1866 - Deprecate [Schema-Name]Factory, remove reference to it from the
        tutorials
#1869 - Deprecate org.jooq.NamedQueryPart
#1870 - Deprecate org.jooq.NamedTypeProviderQueryPart
#1872 - Improve jOOQ's RenderContext pretty printing behaviour
#1881 - Deprecate ConditionProvider, OrderProvider, LockProvider types

Bug fixes
---------
#1593 - Factory.field("{1} + {0} + {0}", val(1), val(2)) doesn't work. Cannot
        re-use / re-order placeholders
#1720 - Improve performance by using Record.getValue(int) instead of
        Record.getValue(Field) internally, where more than one value is
        retrieved from a record
#1751 - Result.intoResultSet() generates wrong ResultSetMetaData if runtime
        schema mapping is applied
#1764 - Add missing @Support({ ... FIREBIRD ... }) annotations
#1768 - NullPointerException when DAO.fetchOne() returns no record
#1774 - QueryPart.toString() does not load default settings from classpath
#1786 - Fix SEQUENCE support for Firebird
#1791 - Log a table's input/output names, and PK name when generating code
#1792 - Factory.fieldByName() and tableByName() do not correctly escape quotes
#1797 - SQL syntax errors when plain SQL contains comments with question marks
        and SQL is executed as StatementType.STATIC_STATEMENT
#1802 - Result.into(Table) doesn't work correctly, if the same field name
        appears twice in Result
#1806 - Let Record.toString() wrap the record in a temporary Result and call
        Result.toString() instead
#1819 - MappingException in Record.into(Class), when POJO setters have
        applicable names but non-applicable argument types
#1820 - Cannot fetch into non-public POJO classes. Their members / getters /
        setters should be made accessible
#1829 - Factory.execute(String) may cause errors when plain SQL returns results
#1830 - Allow for passing null or empty arrays to intoMap(Field[]) and
        intoGroups(Field[])
#1850 - Record.equals() returns true as soon as both records hold a "null" value
        for a given field
#1860 - Bad Results returned from plain SQL "select *" queries, if several
        selected columns share the same name
#1876 - NULL constraint violation when storing a copied record

Version 2.5.0 - August 26, 2012
================================================================================

Welcome to another great database integration in jOOQ: Firebird! This is one of
the more popular open source SQL databases out there, with a rich feature set,
including the SQL standard MERGE statement.

Apart from this, the main new features are:

- Optimistic locking. jOOQ's UpdatableRecord API transparently implements
  optimistic locking on its store() and delete() methods. By default, the
  in-memory record is compared with the one in the database at write time. But
  you can also let jOOQ handle incremented VERSION or TIMESTAMP columns for you.
- Oracle feature increment. Many nice Oracle features are now supported:
  user-defined aggregates, regular expressions, Oracle Text, CONNECT_BY_ROOT and
  ORDER SIBLINGS BY clausess, partitioned outer joins and more
- jOOQ's convenience API has been greatly enhanced. This includes many improved
  fetch methods and new short forms for equal=eq, notEqual=ne, greaterThan=gt,
  etc. to better align jOOQ with JPA, XSL, QueryDSL and many other tools that
  abbreviate these keywords
- Many types and methods have been deprecated to help you foresee the upcoming
  changes in jOOQ 3.0

Please consider also the updated manual with its new, more user-friendly
structure

Features and improvements
-------------------------
#430  - Add support for the Firebird database
#457  - Add support for Oracle user-defined AGGREGATE functions
#620  - Add support for the SQL:2008 standard LIKE_REGEX operator
#722  - Remove casting of bind values in Ingres
#727  - Simulate RPAD and LPAD in SQLite
#816  - Add support for Oracle Text functions
#1339 - Add option to generate immutable pojos
#1547 - Support "optimistic locking" in UpdatableRecord.store() and delete()
#1552 - Generate fetchBy[ColumnName] methods in generated DAO classes
#1553 - Add some Javadoc to document the difference between using a Factory with
        a Connection or with a DataSource
#1556 - Add javax.validation API to full deliverable
#1565 - Add Factory.connectByRoot(Field<?>) to support the Oracle
        CONNECT_BY_ROOT pseudo column
#1570 - Add Factory.condition(String, QueryPart...) similar to
        Factory.field(String, QueryPart...)
#1582 - Add support for Oracle's ORDER SIBLINGS BY clause, in combination with
        CONNECT BY
#1586 - Add missing constructors taking DataSource to dialect-specific factories
#1587 - Generate missing constructors taking DataSource in schema-specific
        factories
#1595 - Simulate REPEAT() in SQLite
#1596 - Add support for optimistic locking using generated information about
        "timestamp" or "version" columns
#1627 - Handle NULL in CSV imports/exports
#1645 - Add support for Oracle's PARTITION BY clause in OUTER JOINs
#1657 - Reorganise the manual
#1664 - By default, activate <relations/> in the code generator
#1665 - Add support for the empty GROUP BY () clause
#1675 - Add support for the SQL standard IS [NOT] DISTINCT FROM predicate
#1680 - Overload all plain SQL DSL methods to also accept QueryPart arguments
#1681 - Simulate empty GROUP BY () clause in Sybase ASE and Ingres, joining a
        dummy table and grouping by a constant field
#1684 - Add <attachRecords/> Setting to indicate that fetched records shouldn't
        be automatically "attached"
#1685 - Improve Javadoc of Attachable.attach(). Document how "detaching" works
#1688 - Add <E> E Record.into(E) as a complement to <E> E Record.into(Class<E>)
#1692 - Replace Factory.executeInsert(), Factory.executeUpdate() and similar
        methods with more succinct variants
#1696 - Add short versions of comparison predicate methods, such as eq, ne, gt,
        ge, lt, le
#1698 - Add support for the SQL standard BETWEEN SYMMETRIC predicate
#1701 - Add Factory.not(Condition) as a synonym for Condition.not()
#1704 - Document the behaviour of Factory.newRecord(Table<?>, Object) and
        Record.from(Object) with respect to UpdatableRecord.store()
#1707 - Add <K> Map<K, Result<R>> ResultQuery.fetchGroups(Field<K>) and
        Result.intoGroups(Field<K>)
#1712 - Add <T extends Comparable<? super T>> Result.sortAsc .sortDesc(Field<T>)
#1713 - Add <T> Result.sortAsc, .sortDesc(Field<T>, Comparator<? super T>)
#1714 - Add Result.sortAsc, .sortDesc(Comparator<? super R>)
#1718 - Document usage of InvalidResultException on the ResultQuery.fetchXXX()
        Javadocs
#1721 - Add <K, V> Map<K, List<V>> ResultQuery.fetchGroups(Field<K>, Field<V>)
        and Result.intoGroups(Field<K>, Field<V>)
#1722 - ResultQuery.fetchArray(int) and .fetchArray(String) should return a
        typed array, even if this cannot be checked by the compiler
#1723 - Add Factory.fetchLazy(ResultSet)

API changes (backwards-compatible)
----------------------------------
#1544 - Remove Attachable interface from QueryPart hierarchy
#1579 - Deprecate org.jooq.Type
#1580 - Deprecate org.jooq.SchemaProvider
#1638 - Deprecate org.jooq.ArrayRecord.createArray()
#1639 - Deprecate org.jooq.Adapter
#1687 - Let Cursor.fetchInto(Table<Z>) return Result<Z> instead of List<Z>
#1736 - Deprecate TableRecord.{store|refresh|delete}Using() methods as being
        part of jOOQ's internal API
#1741 - Deprecate org.jooq.MasterDataType

Bug fixes
---------
#1572 - Use Thread.currentThread().getContextClassLoader() to load
        ExecuteListener classes as a workaround for experienced class loading
        problems when using OSGi
#1584 - Code generation error with Oracle UDT static functions
#1632 - Improve the performance of various DefaultRenderContext methods, by
        locally caching Settings values
#1633 - Improve the performance of CursorImpl.CursorIterator by setting Record
        values by index rather than by Field
#1635 - Improve the performance of Factory.fetch(ResultSet) by caching data type
        normalisation regex in FieldTypeHelper
#1650 - jOOR Fix #16: Can't call Reflect.create(A, B, null)
#1660 - Factory.renderContext().castMode(CastMode.NEVER).render(query) doesn't
        work. CastMode is not applied
#1667 - Bad variable binding when NULLS FIRST, NULLS LAST is simulated in SQL
        Server and other databases
#1673 - Result.formatXML() and Result.intoXML() do not render namespaces
        correctly
#1683 - Oracle code generation regression for 10g. No such column
        ALL_PROCEDURES.OBJECT_ID
#1693 - Cannot bind UDT values from other schemata to stored procedures
#1730 - Compilation errors in SQLite generated code when flag <instanceFields/>
        is set to true

Version 2.4.0 - July 8, 2012
================================================================================

This release's main new feature is jOOQ's added convenience in
Factory initialisation for those users who get their database
connectivity through JDBC DataSources. If supplied with a
DataSource, a jOOQ Factory will handle the Connection lifecycle
internally, closing the Connection when no longer needed.

The H2 MERGE statement syntax is now supported and simulated in
other databases, for those users that prefer its more intuitive
syntax over the SQL standard.

The code generator now also allows for generating interfaces and
DAOs per table. DAO generation was previous discussed on the user
group and seen in a competitor product called OneWebSQL.

The jOOQ Console now supports breakpoints for even more effective
SQL development

Features and improvements
-------------------------
#1141 - Add Result.intoResultSet() to wrap a Result in a JDBC
        ResultSet
#1253 - Avoid JDBC escape syntax for date/time literals
#1280 - Generate DAO classes and interfaces for POJOs
#1404 - Document the lifecycle of an ExecuteListener in the
        Javadoc
#1411 - Add support for Postgres "any" data type (with quotes!).
        This seems to map well to java.lang.Object
#1418 - Support case-insensitive schema names in code generation
#1419 - Add some WARN-level logging when the source-code
        generator doesn't generate any artefacts
#1423 - Add Field.likeIgnoreCase() to support Postgres' ILIKE
        operator
#1424 - Add Factory(DataSource) and similar constructors
#1427 - Add Factory.batchStore(Collection<? extends
        UpdatableRecord<?>>) for convenience
#1428 - Add DataType.convert(Object...) and
        DataType.convert(Collection<?>) for convenience
#1431 - Add org.jooq.Name Factory.name(String) to contruct
        QueryParts that are escaped according to
        Settings.getRenderNameStyle()
#1432 - Add Factory.fetch(String, QueryPart...) and
        Factory.execute(String, QueryPart...) and similar methods
        to support arbitrary QueryParts in plain SQL
#1434 - Add UniqueKeyDefinition.isPrimaryKey() for completeness
#1438 - Add Result<Record> Factory.fetchFromCSV(String)
#1440 - Add top-level pom.xml for jooq-parent artefact (GitHub
        Issue #14)
#1446 - Converting arbitrary strings to Number / Date should
        return null, instead of throwing an exception
#1449 - Generate some meaningful Javadoc into the generated
        [schema-name]Factory classes
#1454 - Add line breaks to generated Javadoc where appropriate
#1463 - Add option to let generated Record / POJO objects
        implement a common generated interface
#1470 - Support interface types in ResultQuery.fetchInto(Class),
        Result.into(Class), and Record.into(Class) methods,
        returning a proxy
#1471 - Upgrade internal jOOR dependency to jOOR 0.9.4
#1473 - Add IdentityDefinition to jooq-meta
#1501 - Add support for conversion of String to
        java.sql.{Date, Time, Timestamp}. GitHub issue #22
#1504 - Document behaviour of fetch() and fetchOne() in case jOOQ
        cannot fetch actual records
#1509 - Minor improvements in the generator source code. GitHub
        pull request #23
#1510 - Generate additional setters for foreign keys, accepting
        records as arguments
#1521 - Expose Connection methods, such as commit(), rollback()
        and similar transaction-related methods in Factory
#1523 - Support ROW_NUMBER() OVER() for the latest version of
        Derby and H2, which support it
#1524 - Simulate ROW_NUMBER() OVER() in HSQLDB using ROWNUM()
#1528 - Let generated interfaces extend Serializable
#1532 - Clarify the lifecycle of Configuration.data in the
        Javadoc
#1534 - Generate more meaningful Javadoc where "an uncommented
        item" stands now
#1536 - Add documentation to the FOR UPDATE OF clause, indicating
        that DB2 may have stricter requirements regarding
        updatability of fields
#1541 - Add support for the H2 MERGE syntax - GitHub Issue #18
#1542 - Simulate the H2 MERGE syntax in other dialects supporting
        the SQL standard MERGE statement - GitHub Issue #18
#1545 - Website and Documentation anchors should be links to
        themselves, visually recognisable

Features and improvements (jOOQ Console)
----------------------------------------
#1398 - Allow for adding breakpoints in jOOQ Console

API changes (backwards-compatible)
----------------------------------
#1408 - Relax bounds of <R> in Factory.truncate() to Record,
        instead of TableRecord
#1429 - Change Convert.convert(List, XXX) to accept Collection
        instead of List

Bug fixes
---------
#1020 - Improve Oracle's LIMIT .. OFFSET clause simulation.
        GitHub Issue #16
#1358 - Compilation errors in generated source code when Oracle
        overloaded procedures collide with procedures that end
        with numbers
#1437 - Error in Javadoc of FactoryOperations.fetchOne(). This
        method may return null
#1441 - Performance issue with AbstractDataType.convert(Object).
        Avoid conversions when they're obviously unneeded
#1448 - Handle String to Enum conversion (when Java Enums are
        stored as Strings in the database) - GitHub issue #15
#1459 - Generated Keys.java static class too large (static
        initialiser can become bigger than 64kb)
#1460 - Table.getReferencesTo(Table) doesn't work correctly for
        aliased tables
#1461 - Exception when rendering of {fn datetimeadd(...)} for
        HSQLDB and Derby
#1462 - Document missing GeneratorStrategy features, such as
        getJavaClassImplements()
#1465 - Custom generator strategy's printImplements() is called
        with Mode == RECORD for tables
#1478 - Caching SQLDialect in AbstractDatabase heavily improves
        code generation performance
#1483 - Inefficient cloning of default settings using JAXB
        unmarshalling leads to non-negligible overall overhead.
        Use serialisation instead (short of a useful XJC clone
        plugin)
#1489 - Fix manual where it claims to throw SQLExceptions
#1490 - Compilation error when a SQL Server stored procedure has
        a parameter named "value"
#1493 - Bad syntax for SELECT /*+hint*/ DISTINCT ... in Oracle
#1498 - jOOQ does not compile using JDK 7 / JDBC 4.1. GitHub
        Issue #24
#1499 - Generated members of Tables.java are not final
#1505 - Bad exception message when ON DUPLICATE KEY IGNORE cannot
        be simulated
#1515 - Splitting of large NOT IN conditions is wrong. The parts
        should be connected with AND, not with OR
#1522 - fetch().into(Table) doesn't initialise records correctly,
        such that subsequent calls to store() will execute an
        INSERT, rather than an UPDATE
#1525 - Generate missing Javadoc to getters for procedure OUT
        parameters
#1529 - Factory.batchStore() logs all single statements to DEBUG
        output. Find a more accurate log output
#1537 - Factory.batchStore() renders bad SQL for Postgres. The
        RETURNING clause is not allowed in batch INSERTs

Version 2.3.1 - May 11, 2012
================================================================================
This is an important patch release fixing some regressions in the
code generator for the Postgres dialect. With 2.3.0, it was no
longer possible to generate schemata of which the database user
was not the owner.

Bug fixes
---------
#1334 - Fix inaccurate simulation of TRUNC(number, decimals) for
        Derby
#1403 - Documentation bug: ctx.statement() can be replaced in
        executeStart(). This is not documented
#1406 - Compilation errors in generated source code when Postgres
        stored procedure parameter is called "NAME"
#1407 - Compilation errors in generated source code when Postgres
        data-type is "any" (with quotes!)
#1409 - Postgres code generation broken when not connecting with
        the owner of a schema

Version 2.3.0 - May 6, 2012
================================================================================

This is a minor feature increment release, featuring many useful
API enhancements, some new functions, some new syntax support
elements, improved source code generation and a lot of
improvements on the jOOQ Console, thanks to Christopher Deckers.

The updated jOOQ Console now allows for filtering incoming
statements directly on the server side, using regular expression
filters on statement text and other features. These improvements
are a part of a general strategy to introduce breakpoints and
more sophisticated debugging capability to the jOOQ Console.

Features and improvements
-------------------------
#597  - Add support for Oracle KEEP (DENSE_RANK FIRST...)
        aggregate function clause
#910  - Add ExecuteListener extension to allow for overriding
        exception translator to handle vendor-specific error
        codes
#1286 - Add "renderSchema" flag to Settings, to completely
        disable rendering of schema names
#1293 - Generate setter methods for JAXB annotated configuration
        properties
#1295 - Add support for MySQL's INSERT IGNORE clause
#1296 - Simulate the FOR UPDATE clause for SQL Server, CUBRID,
        using JDBC's ResultSet.CONCUR_UPDATABLE
#1302 - Add Factory.inline() to allow for flagging inline-only
        "bind values"
#1303 - Add connection-less Factory constructors for convenience,
        when jOOQ is only used as a SQL query builder
#1304 - Add option to generate JSR-303 @NotNull and @Size
        annotations to generated POJO's
#1307 - Let HSQLDB dialect render NVL2() as NVL2() instead of
        CASE expression
#1312 - Allow for omitting <inputSchema/>, and generate all
        available schemata in that case
#1315 - Let generated factories use their associated Schema as
        the Settings' RenderMapping's defaultSchema
#1319 - Move jooq-spring's FactoryProxy to the core jooq project
#1322 - Add Factory.dateAdd() and timestampAdd() for convenience
#1327 - Add DataType.isLob()
#1328 - Add Field<String> inline(char), inline(Character),
        inline(CharSequence) for convenience
#1333 - Add support for the Oracle TRUNC function, for numeric
        arithmetic
#1336 - Let Record.into(Class<?>) and similar methods accept
        "immutable" classes, i.e. setter-less classes that take
        several constructor arguments
#1340 - Use Constructor.setAccessible(true), if no default
        constructor is available on the target type of
        Record.into(Class<?>)
#1342 - Improve Javadoc on Factory.function(). Document arguments
#1349 - Add support for the CUBRID Click-Counter INCR()
#1352 - Allow for creating syntax-error and SQL-injection safe
        qualifiers for org.jooq.Field and org.jooq.Table
#1361 - Add Factory.batchStore(TableRecord<?>...), to allow for
        batch UPDATE/INSERTs of many records
#1367 - Make configured ExecuteListeners default constructors
        accessible
#1366 - Let org.jooq.Batch extend Serializable
#1378 - Upgrade internal jOOR dependency to jOOR 0.9.3
#1379 - Upgrade internal jOOU dependency to jOOU 0.9.1
#1390 - Add RenderContext.qualify() to indicate whether
        QueryParts should render qualified versions of themselves
        or not

Features and improvements (jOOQ Console)
----------------------------------------
#1242 - Upgrade jOOQ Console dependency on RSyntaxTextArea from
        1.5 to 2.0.2
#1249 - Allow for filtering incoming statements in jOOQ Console
#1393 - Implement a communication protocol between Console server
        types and Console client types to allow for more
        sophisticated functionality

API changes (backwards-compatible)
----------------------------------
#1310 - Deprecate Factory.literal() in favor of Factory.inline(),
        and Factory.field()
#1368 - Promote AbstractQuery.isExecutable() to the public API

Bug fixes
---------
#989  - INSERT and UPDATE statements always render non-qualified,
        escaped field names. This may cause trouble when using
        plain SQL fields
#1109 - Standalone TABLE or VARRAY types are not correctly
        initialised before referencing tables load them
#1279 - NullPointerException when leaving <inputSchema/> empty
#1283 - The LIKE escape character needs escaping, too, in
        contains(), startsWith(), endsWith()
#1306 - Add missing INTERVAL data types to HSQLDBDataType
#1308 - Oracle's DataTypeDefinition reports the length of a BLOB
        / CLOB data type to be 4000
#1313 - <includes/> and <excludes/> match only table names, not
        fully qualified names
#1323 - Add support for byte[] in Postgres UDTs
#1324 - Code generation error in Oracle 10g when generating
        stored procedures
#1326 - Error when deserialising BLOBs from Oracle UDTs
#1329 - NullPointerException when passing null to
        timestampDiff(Field, Field)
#1343 - Regression in insertInto(...).values(...). Cannot pass
        Field<?> to values()
#1344 - Initialise Result ArrayLists to their expected size, if
        that size is known.
#1360 - jOOR issue 12: "Don't reset the accessible flag to false,
        if setting it to true is required, to avoid race
        conditions in concurrency contexts"
#1371 - Missing conversion when using unsafe Field<?> types in
        BATCH statements
#1376 - Oracle UDTs in REF CURSORs are not deserialised correctly
        from procedure OUT parameters
#1377 - Oracle UDTs are not deserialised correctly when the same
        UDT name is present in multiple schemata
#1394 - NullPointerException when omitting <generate/> element in
        code generation configuration

Version 2.2.1 - April 12, 2012
================================================================================

This is a minor patch release, fixing some issues related to the
code generation of the new CUBRID integration as well as other,
minor issues. Upgrade if you're using CUBRID

Bug fixes
---------
#1287 - Remove oracle.sql dependency also from OSGi information
        in pom.xml
#1288 - SQL syntax errors from sequences when using RenderMapping
        with defaultSchema
#1289 - DefaultBindContext logs as Util.class
#1297 - Compilation error in CUBRID generated artefacts
        referencing OBJECT types
#1298 - Avoid source code generation errors when generating code
        for unknown, dialect-specific data types

Version 2.2.0 - April 09, 2012
================================================================================

Finally, jOOQ has added support for another database, and a very
promising one, that is. http://www.cubrid.org is a surprisingly
original mixture of a relational and object-oriented database
where tables and classes are synonyms, so are records and
instances. The CUBRID database has a high level of compatibility
with MySQL and is aimed at MySQL users wanting more performance
for their web applications. For details, see the slides here:

http://www.slideshare.net/cubrid/growing-in-the-wild-the-story-by-cubrid-database-developers

jOOQ is proud to have become a CUBRID partner, looking forward
to further cooperation with CUBRID in the near future.

Apart from that, jOOQ now fully supports SQL standard INTERVAL
data types. With JDBC and JPA lacking official support for this,
jOOQ aims for becoming the tool of choice for vendor-specific
date time arithmetic. True INTERVAL data type support is given in
HSQLDB, Ingres, Oracle, Postgres databases. Besides that, CUBRID
and MySQL support INTERVAL data type arguments in functions. In
other dialects, jOOQ simulates DATEADD(), TIMESTAMPADD(),
DATEDIFF(), TIMESTAMPDIFF().

For jOOQ's OLAP friends, there is now also support for the Oracle
LISTAGG function (LIST() in Sybase, XMLAGG() in DB2, STRING_AGG()
in Postgres, GROUP_CONCAT() in CUBRID, H2, HSQLDB, MySQL).
LISTAGG is an "ordered aggregate function", meaning that the
aggregation is done using a specific ordering. Keep an eye out
for more such function support in future versions.

Features and improvements
-------------------------
#566  - Add support for INTERVAL data types
#585  - Add support for DATE, TIME and INTERVAL arithmetic
#1183 - Add support for DEFAULT values in Oracle stored procedure
        parameters
#1243 - Let generated POJOs (and Records) extend base classes
        and implement interfaces
#1252 - Avoid JDBC escape syntax for Oracle stored procedure
        calls. Generate PL/SQL syntax, instead
#1255 - Let generated Tables contain a public default constructor
        to be able to extend those classes - Github issue #12
#1257 - Add CUBRID support
#1268 - Add Factory.field(String, QueryPart...) to generate
        custom clauses
#1269 - Add YEAR(), MONTH(), DAY(), HOUR(), MINUTE(), SECOND()
        function support as shortcuts for EXTRACT()
#1273 - Simulate GROUP_CONCAT() aggregate function using Oracle's
        LISTAGG() function, where available
#1274 - Add support for the Oracle LISTAGG(...) WITHIN GROUP
        (ORDER BY ..) [ OVER (..) ] aggregate / analytic function
#1275 - Simulate Sybase LIST() aggregate function using Oracle's
        LISTAGG() function
#1276 - Simulate Oracle's LISTAGG() in DB2 using XMLAGG(),
        SUBSTR() and CONCAT()
#1278 - DEBUG log both executed SQL and SQL with inlined bind
        values

API changes (backwards-compatible)
----------------------------------
#1262 - Pull up OracleFactory.prior() and other CONNECT BY
        related methods to Factory

Bug fixes
---------
#1241 - Wrong variable binding when comparing CHAR columns in
        Derby and DB2 without explicit casting to VARCHAR
#1244 - Cannot override class name in GeneratorStrategy in
        Mode.POJO
#1248 - Setting both <records>false</records> and
        <relations>true</relations> leads to compilation errors
#1256 - Fixed code generation issue with H2 user defined
        functions returning VARCHAR
#1263 - Pass fetchsizes <= 0 to the JDBC driver (for vendor-
        specific MySQL compatibility)
#1270 - Most databases allow for multiple identical foreign keys.
        This leads to compilation errors in generated source code

Version 2.1.0 - March 18, 2012
================================================================================

With this version, jOOQ attempts to follow versioning rules
imposed by semantic versioning: http://semver.org/
There will be 1 minor release per month, and a couple of patch
releases per year, depending on popular demand

The main improvements for this release include

- The possibility of providing jOOQ with a custom type mapping.
  You can now define your own Converter types that are used by
  jOOQ to map a database's SQLDataTypes to your custom types.
  This is particularly useful for Java's enums. Read more about
  custom converters in the manual:
  http://www.jooq.org/manual/ADVANCED/CustomTypes/

- There are a lot of new runtime configuration options to control
  the SQL style of SQL rendered by jOOQ. You can now specify
  whether table/column names should be quoted / capitalised /
  lower-cased, whether SQL keywords should be capitalised or not,
  etc...

- The handling of NULL has been improved in favour of using jOOQ
  as a SQL builder library (e.g. along with Spring for execution)
  NULL is no longer inlined, but bound as a variable.

- jOOQ now supports simulation of the relational division
  operation using an intuitive syntax. Read more about the
  relational division here:
  http://en.wikipedia.org/wiki/Relational_algebra#Division

Features and improvements
-------------------------
#161  - Add runtime configuration to pretty print rendered SQL
#349  - Add SQLite relations support
#491  - Add runtime configuration for SQL keyword style (upper
        case, lower case)
#521  - Add runtime configuration for SQL reference style (upper
        case, lower case, as-is, quoted)
#1150 - Add code generation option to disable generation of
        records
#1181 - Add support for SQL Server data types timestamp and
        rowversion
#1188 - Load default Settings from the classpath at
        /jooq-settings.xml, or from -Dorg.jooq.settings
#1193 - Specify main-class in jOOQ Console's manifest.mf and
        include dependency in jar file
#1194 - Add ColumnDefinition.isNullable()
#1202 - Add support for the relational division operation:
        A.divideBy(B).on(A.ID.equal(B.A_ID)).returning(A.X, ...)
#1207 - Add Factory.batch(Collection<? extends Query>) for
        convenience
#1208 - Render @javax.persistence.Column(nullable = false)
        property, if available
#1209 - Render @javax.persistence.Column(length, precision,
        scale) properties, if available
#1215 - Add org.jooq.Converter<T, U> for custom type mapping
#1216 - Overload Record, Result.getValue() and .setValue()
        methods to accept a Converter
#1217 - Add EnumConverter as a base type for custom enum
        converters
#1218 - Add code generation options to generate <customTypes/>
        referencing a Java type and a Converter
#1224 - Add DataTypeDefinition.getLength() to jooq-meta's type
        system
#1233 - Support custom JDBC properties for jooq-codegen
#1234 - Add Database.getTable(SchemaDefinition, String, boolean)
        to fetch tables case-insensitively
#1239 - Add Factory.fetchLazy(String, Object...)

API changes (backwards-compatible)
----------------------------------
#1191 - Deprecate ConfigurationRegistry and replace by equivalent
        ExecuteListener feature
#1219 - API Bug: Cannot use LIMIT .. OFFSET along with FOR UPDATE

Bug fixes
---------
#625  - Remove dependency from generated Routines to the
        generator's SQLDialect
#1128 - NULL is inlined in INSERT statement instead of binding it
        as a variable. This can cause issues when using jOOQ with
        Spring
#1137 - Exclude MySQL column-level enum types when that column is
        overridden by a <forcedType/>
#1158 - Derby cannot handle inlined NULL literals in some
        contexts
#1180 - Execute BatchMultiple (multi-query batch query), when
        executing BatchSimple (single-query, multi-bind-value
        query) with StatementType == STATIC_STATEMENT
#1189 - TableMapping regression for SQLite database
#1190 - Cannot store SQLite records when using
        StatementType.STATIC_STATEMENT
#1199 - Table.getFields() returns an internal representation of a
        table's field list. Make generated tables immutable!
#1200 - Internal API leak exposed through covariance in
        AbstractType.getFields()
#1211 - Enforce method name disambiguation also when using custom
        strategies in jooq-codegen
#1212 - Enforce identifier disambiguation also when using custom
        strategies in jooq-codegen
#1221 - Incorrect ExecuteListener invocation for INSERT ..
        RETURNING. executeStart() and executeEnd() are omitted
#1223 - Cache ExecuteListener classes for performance
#1225 - Bind NULL byte[] as java.sql.Types.BINARY instead of
        BLOB in Postgres, to avoid errors
#1226 - Bind NULL UDTs with their associated type name in Oracle
#1232 - SQLException when Factory.fetch() does not return a
        ResultSet
#1237 - Don't generate enum classes for columns in MySQL tables
        that are excluded from code generation

Version 2.0.5 - February 26, 2012
================================================================================

This release finally introduced basic runtime configuration
features for the jOOQ Factory. This configuration now includes:

- Execute listener and SQL tracing support. jOOQ allows you to
  hook your own listeners into jOOQ's query execution engine to
  be notified of all sorts of events
- The existing SchemaMapping features. They are now part of the
  runtime configuration
- StatementType settings. Specify whether a Factory should
  execute java.sql.PreparedStatements (with bind variables) or
  static java.sql.Statements with inlined variables.

The runtime configuration is documented here:

http://www.jooq.org/manual/JOOQ/Factory/

The listener and tracing support has been requested by
Christopher Deckers, a new jOOQ user who has had the courtesy to
contribute the new jOOQ Console, which is documented here:

http://www.jooq.org/manual/ADVANCED/ExecuteListener/

Apart from that, another long-requested feature is now fully
implemented: The GeneratorStrategy, allowing for custom naming
strategies in generated source code. This will allow for
generating custom table / record class name prefixes / suffixes,
as well as overriding the default behaviour for rendering UPPER,
lower and CamelCase artefacts. See the manual for details:

http://www.jooq.org/manual/META/Configuration/

Features and improvements
-------------------------
#93   - Add Field.equalIgnoreCase(), Field.notEqualIgnoreCase()
#408  - Add class prefixes, suffixes and other options to the
        code generator
#492  - Add runtime configuration
#1107 - Let Field.contains() support the Postgres ARRAY @> ARRAY
        operator
#1140 - Add ResultQuery.fetchResultSet() to return the underlying
        JDBC result set
#1143 - Add Result.isNotEmpty() for convenience
#1145 - Add runtime configuration to specify whether jOOQ should
        execute java.sql.PreparedStatement (with bind variables)
        or a java.sql.Statement (with inlined parameters)
#1146 - Add Query.getSQL(boolean) to indicate that bind values
        should be inlined (as a convenience for
        Factory.renderInlined(QueryPart))
#1148 - Add Cursor.resultSet() to expose the underlying ResultSet
#1149 - Allow for optional
        "http://www.jooq.org/xsd/jooq-codegen-2.0.4.xsd"
        namespace in jooq-codegen configuration
#1152 - Add <E extends java.lang.Enum<E> & org.jooq.EnumType>
        E MySQLFactory.enumType(Class<E>, int) for enum reverse
        lookups of MySQL-specific enums
#1159 - Support matching numbers with LIKE, e.g. ID LIKE '%33%'
#1160 - Implement Field.contains(), .startsWith(), .endsWith()
        for numeric values, too
#1161 - Use reflection to remove compile-time dependency on
        ojdbc for creating ARRAYs
#1162 - Integrate jOOR into jOOQ for simpler reflection
#1164 - Distinguish between Definition.getInputName(),
        .getOutputName()
#1165 - Add constraint name to generated javadoc
#1167 - Trivial issue with org.jooq.Factory.exists Javadoc -
        GitHub issue #10
#1169 - Add Configuration.setData(), getData() to convey custom
        data in a configuration's lifecycle
#1172 - Add runtime configuration to deactivate JooqLogger
#1177 - Add jOOQ-Console module to jOOQ
#1184 - Add DataType.isArray()

API changes (backwards-compatible)
----------------------------------
#1142 - Rename Result.exportXML() to Result.intoXML() to stay
        more consistent
#1151 - Deprecate SchemaMapping in favour of new runtime
        configuration

Bug fixes
---------
#978  - Schema.getTables() and similar methods return empty lists
        when Schema is mapped with SchemaMapping
#1153 - Bad inlining of booleans in Sybase ASE / DB2 / Oracle
        SQL Server / SQLite
#1154 - Bad inlining of byte[] in most dialects
#1155 - byte[] are erroneously converted to String when using
        Record.intoArray()
#1156 - Bad inlining of DATE / TIME / TIMESTAMP data types in
        Ingres (and other dialects, when the setting differs from
        the default)
#1166 - Some generated Javadoc uses naming strategy or plain
        output name, instead of qualified output name
#1168 - Oracle packages are generated as static, instead of
        static final
#1175 - Factory.use() seems to render SQL with the Schema name
        still present
#1179 - Oracle-generated ArrayRecords need a reference to
        org.jooq.Schema to read TABLE of OBJECT from stored
        procedures

Test cases
----------
#1147 - Add integration tests for executing SQL generated using
        Factory.renderInlined()

Version 2.0.4 - February 12, 2012
================================================================================

This release introduced many improvements to source code
generation. These improvements include:

- Maven and standalone code generation now use the same XML
  configuration, which is read by jOOQ-codegen using JAXB. This
  allows for more complex configuration elements in the future
- jOOQ-codegen can now handle multi-schema databases and generate
  code for tables referencing tables from other schemata. This
  is integration tested against the SQL Server AdventureWorks
  database
- jOOQ now allows to generate simple POJOs in addition to Records
  and to annotate both POJOs and Records with JPA annotations
  such as @Entity, @Table, @Id, @Column, @UniqueConstraint, etc.

You can migrate your existing .properties configuration by running
> org.jooq.util.GenerationTool /your.properties migrate

Besides that, there is a lot of ongoing work to improve the
integration of Oracle's TABLE and VARRAY types.

Features and improvements
-------------------------
#8    - Add JPA annotations to generated POJOs / Records
#282  - Add support for multi-schema databases
#287  - Add support for Oracle TABLE types
#395  - Use XML configuration file instead of properties file
#1089 - Add Field.contains(), .startsWith(), .endsWith() as a
        convenience for Field.like() (including escaping)
#1092 - Move master data table configuration from
        generator.generate to generator.database namespace
#1093 - Add support for generator.strategy in Maven source code
        generation
#1094 - Add support for generator.database.date-as-timestamp in
        Maven source code generation
#1095 - Move generator.generate.unsigned-types to
        generator.database namespace
#1096 - Add support for generator.generate.unsigned-types in
        Maven source code generation
#1103 - Add support for SQL Server data type uniqueidentifier
#1106 - Add Factory.escape(Field<String>, char) for use with LIKE
#1108 - Add support for multi-schema databases using Maven code
        generation
#1115 - Add support for Oracle VARRAY/TABLE of OBJECT types
#1127 - Add support for POJO classes generation
#1129 - Allow for using Param in LIMIT .. OFFSET clauses
#1132 - Add RenderContext.castMode() to allow for avoiding casts
        where this is not really needed
#1136 - Add generation option to enable/disable generating
        navigation methods

Bug fixes
---------
#1099 - Derby generated artefacts are not sorted alphabetically
#1101 - Internal API leak exposed through covariance in
        AbstractTable.joinXXX() methods
#1110 - VARRAY element type information is lost when unnesting
        VARRAY's in Oracle
#1111 - VARRAY element type information is lost when unnesting
        VARRAY's returned from functions in Oracle
#1114 - Syntax error when unnesting TABLE of OBJECT in Oracle.
        The unnested table contains several columns but jOOQ only
        unnests "COLUMN_VALUE"
#1117 - NullPointerException when passing an ArrayRecord
        containing a null array to a stored function in Oracle
#1125 - Postgres needs casting for date time data types in
        queries like SELECT ? FROM DUAL
#1131 - DB2: [Noauthorized routine named "LIKE" of type
        "FUNCTION" having compatible arguments was found] when
        using Field.like(concat(x, y))
#1133 - Compilation errors in generated source code if the same
        constraint name exists in several schemata
#1134 - NullPointerException in code generation when a foreign
        key constraint references a table from another schema
        that is not being generated
#1135 - Generated Javadoc references inputSchema instead of
        outputSchema

Test cases
----------
#1009 - Add more integration tests for proper handling of
        java.sql.Date, Time, Timestamp
#1090 - Run jOOQ tests against AdventureWorks SQL Server sample
        database
#1105 - Add integration tests for multi-schema source code
        generation and querying
#1122 - The 10k lines of integration test code are too heavy for
        the compiler. Create test modules with fewer lines of
        code, each.

Version 2.0.3 - January 29, 2012
================================================================================

This release focuses on increased compatibility between various
SQL dialect integrations as far as ARRAY and JOIN support is
concerned:

- ARRAY types are only available in H2, HSQLDB, Oracle, Postgres.
  Nevertheless, they can be somewhat simulated in other dialects
  using nested selects with UNION ALL. Increased compatibility
  leads to a nicer API, where ARRAYs are used along with ALL/ANY
  quantifiers, for instance.

- JOIN syntaxes can be quite powerful in SQL. Apart from
  simulating NATURAL JOIN, JOIN USING clauses, as well as a
  synthetic "KEY JOIN" syntax, jOOQ now also supports nesting
  JOIN expressions to create more complex table sources. See a
  recent blog post on the subject here:

http://blog.jooq.org/2012/01/15/lets-revise-the-sql-from-clause/

Features and improvements
-------------------------
#578  - Add KEY JOIN syntax to simulate joining using generated
        foreign keys
#577  - Simulate NATURAL JOIN syntax, where this is unavailable
#582  - Simulate JOIN USING syntax, where this is unavailable
#671  - Allow for nesting JOIN clauses
#676  - Add Table.join() methods to create more flexible table
        sources
#993  - Add Field.equalAny(T[]), .equalAny(Field<T[]>) methods
#1048 - Simulate <op> <quantifier> (array) syntax for dialects
        that do not support arrays
#1051 - Add Factory.execute(String, Object...) as a convenience
        method for Factory.query(...).execute()
#1055 - Simulate Factory.table(Object[]) and table(List<?>) using
        UNION ALL in dialects that do not support arrays
#1060 - Improve debug logging of H2 arrays. The syntax is not
        ARRAY[1, 2], but (1, 2)
#1065 - Add OracleFactory.sysContext(String, String) to support
        Oracle's SYS_CONTEXT function
#1069 - Add support for INSERT INTO table(field1, field2, ...)
        SELECT syntax - as opposed to the existing INSERT INTO
        table SELECT
#1072 - Add support for LIKE .. ESCAPE .. syntax
#1074 - Add Field.notBetween(T, T) for convenience
#1080 - Add support for JDBC's Statement.setFetchSize() in
        ResultQuery.fetchLazy()
#1082 - Add some more DEBUG logging in AbstractResultQuery

API changes (backwards-compatible)
----------------------------------
#1059 - Change SelectFromStep.from(Collection<TableLike<?>>) to
        from(Collection<? extends TableLike<?>>)

API changes (backwards-incompatible)
------------------------------------
#1087 - Change the NTILE function to return Field<Integer>
        instead of Field<BigDecimal>

Bug fixes
---------
#1071 - Make Sequence Serializable
#1081 - Derby error in NULL handling when simulating unnested
        arrays that contain NULL values
#1084 - Bind index mismatch in val(null).equal(null) and in
        val(null).notEqual(null)
#1091 - Add missing @Support annotations on Table.crossJoin()
        methods

Test cases
----------
#1026 - Add integration tests for NTILE window function and
        document compatibility
#1073 - Add integration tests for NOT IN queries holding NULL
        arguments

Version 2.0.2 - January 8, 2012
================================================================================

This is a maintenance release for jOOQ 2.0. The main improvements
include

- The whole jOOQ API is now annotated with a new org.jooq.Support
  annotation to help you assess whether a certain SQL clause is
  available in your database or not. This is particularly useful
  when your application should support several databases at once
  (e.g. MySQL, Postgres, Oracle)
- The Oracle PIVOT clause is now formally supported for advanced
  statistical queries in Oracle. This clause will be simulated in
  other dialects in the future.
- The DATE data type can be mapped to TIMESTAMP. This important
  when you query a legacy Oracle database, where DATE columns
  can also contain time information
- Several convenience methods have been added for more fluent
  syntax, when using plain SQL result queries, subqueries as
  tables, or when unnesting arrays in ANY() and ALL() quantifiers

Further type mapping support is still experimental. An official
cooperation with MinuteProject for source code generation is
being analysed. With MinuteProject, many source code generation
issues could be addressed centrally, as MinuteProject specialises
in source code generation:

http://minuteproject.wikispaces.com/

Features and improvements
-------------------------
#595  - Add support for Oracle's PIVOT clause
#869  - Add support for using ANY, ALL with arrays, not just with
        subselects
#1007 - Formally document the API methods to indicate whether
        something is supported by any given SQL dialect
#1011 - Add code generation configuration parameter to avoid
        generating @Generated annotation
#1019 - Render LIMIT x OFFSET y also for MySQL, instead of
        LIMIT y, x
#1022 - Add missing Sybase ASE implementation for Factory.use()
#1024 - Add Factory.resultQuery(String, Object...) to allow for
        arbitrary execution modes of plain SQL queries (lazy,
        later, into, array, etc)
#1025 - Add missing SQLite implementation for Factory.deg() and
        Factory.rad()
#1033 - Generate table comments into generated Tables.java as
        Javadoc
#1040 - Add Object[][] Result.intoArray() and
        Object[] Record.intoArray() for convenience. Let
        <E> E Record.into(Class<E>) also support array types.
#1041 - Add <R> Table<R> Factory.table(Select<R>) convenience
        method for more fluency
#1042 - Add support for DISTINCT keyword in SUM, AVG, MIN, MAX
        aggregate functions
#1046 - Generate Ingres table and column comments in generated
        source code (only Ingres 10)

API changes (backwards-compatible)
----------------------------------
#1050 - Deprecate usage of SOME quantifier in predicates, such as
        equalSome()

API changes (backwards-incompatible)
------------------------------------
#1036 - Fixed API typo in
        WindowsRowsStep.rowsBetweenUnboundedFollwing()
#1037 - The fluent API allows for JOIN clauses without FROM
        clause

Bug fixes
---------
#1010 - The MERGE INTO .. WHEN NOT MATCHED THEN INSERT .. syntax
        may cause type-safety issues in some databases. VALUES
        should be converted before binding
#1014 - FindBugs: Latent risk of infinite recursion due to typo
        in QueryPartList.retainAll();
#1015 - FindBugs: 7 occurrences of "Bad attempt to compute
        absolute value of signed 32-bit hashcode". In extreme
        cases, this could lead to SQL syntax errors
#1016 - The Oracle CONNECT BY cond1 AND cond2 syntax erroneously
        creates a WHERE cond2 CONNECT BY cond1 statement
#1028 - Syntax errors when using untyped param() in HSQLDB (and
        other strongly typed dialects)
#1029 - Postgres can't bind NULL values in cases, where bind type
        is Object.class and bind value was created with
        Factory.param()
#1030 - UnsupportedOperationException when calling
        Query.bind(int, Object) on a query containing plain SQL
        fields
#1031 - Incorrect debug logging when plain SQL QueryParts like
        field("?") bind null values
#1032 - Incorrect debug logging when plain SQL QueryParts contain
        String literals, such as 'Hello? Anyobody out there?'
#1047 - Field.notEqualAny() erroneously renders <> ALL()

Test cases
----------
#1021 - Add explicit integration tests for
        LEFT|RIGHT|FULL OUTER JOIN

Version 2.0.1 - December 23, 2011
================================================================================

This is a maintenance release for jOOQ 2.0. The main improvements
include

- Better integration for using jOOQ with Spring Data. This
  includes support for named parameters, as well as allowing to
  change bind values on previously constructed Query objects
- The MERGE statement has been enhanced for better integration
  with Oracle.
- jOOQ is now ready to use with Scala / Groovy

For more information about using jOOQ with Scala, see this blog
post:
http://blog.jooq.org/2011/12/11/the-ultimate-sql-dsl-jooq-in-scala/

There is now also experimental support for a custom type mapping.
This mapping allows to rewrite data types at code generation time
as well as to specify custom enum data types (e.g. boolean Y/N).
Not all integration tests run smoothly for custom data types,
hence, this feature is not yet fully supported.

Features and improvements
-------------------------
#691  - Add support for Oracle CURSOR REF IN / INOUT parameters
#677  - Add type-mapping configuration, enforcing types for
        columns
#947  - Add custom type mapping support (experimental)
#968  - Allow for custom enum types, configured in the code
        generator (experimental)
#974  - Add Schema.getTable(String), getSequence(String),
        getUDT(String) for better runtime Schema meta-navigation
#975  - Add Sequence.getName(), getSchema(), getDataType()
#980  - Add support for named parameters, to better interact with
        Spring
#991  - Add Query.bind(String, Object) and bind(int, Object) to
        easily modify existing bind values
#992  - Document thrown DataTypeException in Convert methods
#998  - Enhance MERGE statement for Oracle extensions:
        WHEN MATCHED THEN UPDATE .. WHERE .. DELETE WHERE ..
        WHEN NOT MATCHED THEN INSERT .. WHERE ..
#1000 - Add support for MySQL's INSERT INTO .. SET .. syntax in
        MERGE statement's WHEN NOT MATCHED THEN INSERT clause

API changes (backwards-compatible)
----------------------------------
#981  - Cannot insertInto(table("my_table")), as plain SQL tables
        return Table<Record>, not Table<TableRecord>. Relax
        bound on R
#988  - Change Factory.field(String) to return Field<Object>
        instead of Field<?>
#999  - Make MERGE's WHEN MATCHED .. and WHEN NOT MATCHED ..
        clauses optional
#1001 - Identity.getField() should return TableField<R, T>
        instead of Field<T>
#1006 - Add Factory.value(...) as a synonym for Factory.val(...)
        for increased Scala / Groovy compatibility

Bug fixes
---------
#973  - EnumType renders name() instead of getLiteral() in
        formatXXX() methods
#977  - EnumType renders name() instead of getLiteral() in
        Convert.convert() method
#979  - Record.from() sets all changed flags to true. That's not
        necessarily correct in the event of storing the record
        back to the DB
#985  - AbstractRecord.equals() does not correctly compare
        arrays. Compare them using Arrays.asList()
#986  - Postgres / DB2 / Sybase ASE foreign-key namespace is
        unique-per-table. jOOQ forces all foreign keys from all
        tables into the same namespace
#990  - Problems when encoding arbitrary byte[] as String(byte[])
        in inlined SQL. This can cause issues when DEBUG-level
        logging is activated
#995  - Routines don't respect SchemaMapping - Github issue #8
#1002 - TableRecord.storeUsing() doesn't update IDENTITY column
        values, if the column is not part of the main unique key
#1003 - Sybase / SQL Server / MySQL / Ingres / H2 / Derby's
        INSERT .. RETURNING simulation returns null if a table
        has an IDENTITY column, but no primary/unique key
#1005 - The INSERT INTO .. VALUES .. syntax may cause type-safety
        issues in some databases. VALUES should be converted
        before binding

Test cases
----------
#984  - Detach IDENTITY column tests from UNIQUE KEY tests,
        create a dedicated test suite instead

Version 2.0.0 - November 25, 2011
================================================================================
This release is a fresh start in many areas of jOOQ, adressing
issues that have been requested by users for a long time. These
release notes docment the most important changes, a detailed
upgrade guide, as well as the detailed list of improvements.

Most important changes
----------------------
- The API became more static. This applies to many Factory
  methods, such as val(), literal(), as well as to many Field
  methods that have been moved over to the Factory. For example,
  when before, you wrote this using "postfix function notation":

    <pre>NAME.replace(" ", "_").trim()</pre>

  you will now write (just as in SQL):

    <pre>trim(replace(NAME, " ", "_"))</pre>

  Using static imports of Factory.*, jOOQ makes SQL look even
  more like SQL. The current "postfix notation" is maintained for
  backwards compatibility.
- By default, jooq-codegen will now generate a "dynamic" meta
  model as opposed to the existing static one. Generated tables
  covariantly override the as(String) aliasing method, leading
  to a much more convenient aliasing style. When before, you
  wrote:

<pre>
Table<TRecord> parent = T.as("parent");
Table<TRecord> child  = T.as("child");
Condition join =
  parent.getField("ID").equal(child.getField("PARENT_ID"))
</pre>

  You can now write:

<pre>
T parent = T.as("parent");
T child  = T.as("child");
Condition join = parent.ID.equal(child.PARENT_ID)
</pre>

  Of course, the existing notation still works

- Exceptions are no longer checked. When previously, the DB's
  SQLException was propagated to client code, there is now an
  unchecked DataAccessException hierarchy, similar to that of
  Spring. This will eventually give way to a standardised error
  handling abstraction, in future developments.
- Window functions are now constructed from their underlying
  aggregate functions just like in SQL. For example:

<pre>
sum(AMOUNT)
sum(AMOUNT).over().partitionBy(ACCOUNT)
</pre>

  This makes for a more concise API, especially when considering
  future extensions, such as Oracle's KEEP (DENSE_RANK FIRST...)
  syntax.
- More type safety has been introduced regarding various places
  where generic <R extends Record> and <T> types are involved.
  This is especially true for INSERT / UPDATE / DELETE statements
- Sequences now also have a <T> type
- Unsigned number types are now supported in those databases that
  use them. Unsigned numbers are implemented in jOOU, a spin-off
  open source project. For convenience, this library is
  "internalised" into jOOQ, to avoid adding a dependency

http://code.google.com/p/joou/

Upgrade instructions:
---------------------
Various of the above changes are incompatible with jOOQ 1.x. In
order to upgrade, please be aware of the following pitfalls:

- The schema needs to be re-generated.
- Much of the post-fix function notation is replaced by static
  methods in the Factory. Today's org.jooq.Field API is
  maintained in jOOQ 2.0, for backwards compatibility. It will
  be removed, eventually, though. Expect some incompatible
  changes, where window functions are involved
- Some Factory instance methods (such as val(), literal()) are
  now static. They are compatible, but may cause compiler
  warnings.
- The meta model is now an instance model by default. If you
  prefer the static meta model, you can configure this in your
  jooq-codegen configuration.
- The additional typesafety involving <R> and <T> types may cause
  compiler warnings and errors.
- SQLException is no longer part of the API. This can cause
  compiler issues, in particular when extending jOOQ
- Some utility classes have moved to org.jooq.tools

Should these incompatibilities be too significant for your
project, you can still stay on the 1.x branch, which will be
maintained for a while. Be aware that upgrading might be more
difficult, later, though.

Features and improvements
-------------------------
#55  - Implement improved exception handling
#117 - Improve DSL support for field and table aliasing (decrease
       verbosity)
#519 - Add support for MySQL UNSIGNED numeric types
#626 - Create static function access
#661 - Add support for bitwise operators
#718 - Sequences should be mapped to appropriate type (e.g.
       SMALLINT, INT, BIGINT, etc)
#734 - Add support for Oracle / SQL Server CUBE() and ROLLUP()
       grouping functions
#751 - Add support for Oracle / SQL Server GROUPING SETS()
       function
#799 - Add support for Oracle PL/SQL's object-oriented MEMBER
       PROCEDURES and MEMBER FUNCTIONS
#804 - Add <R extends Record> to Insert, Update, Delete
#835 - Review API typesafety for <T> InsertSetMoreStep
       set(Field<T>, T) and similar methods
#890 - Add Factory.selectCount() convenience method
#891 - Let min() max(), etc functions return a new type
       AggregateFunction. This type can then be used as an entry-
       point for window functions
#892 - Add support for Oracle / SQL Server GROUPING() and
       GROUPING_ID() functions to be used along with CUBE() and
       ROLLUP()
#893 - Simulate ROLLUP() function for MySQL, using the WITH
       ROLLUP grouping modifier
#894 - Move functions from Field<?> to org.jooq.impl.Factory
       and make them static
#895 - Add power(..., Field<? extends Number>)
#897 - Add (experimental) Spring integration project
#898 - Replace usage of checked SQLException by an unchecked
       DataAccessException, similar to that of Spring
#899 - Build jOOQ .jar files as bundles to be deployed into OSGI
       environments
#900 - Purge deprecated API - Prior to 2.0
#901 - Introduce InvalidResultException as a subtype of
       DataAccessException for integrity checks in methods like
       ResultQuery#fetchOne(), ResultQuery#fetchMap(), etc.
#902 - Make AggregateFunction the base type for constructing
       window functions
#904 - Move SQLDialectNotSupportedException into
       org.jooq.exception package
#905 - Introduce MappingException as a subtype of
       DataAccessException for integrity checks in methods like
       ResultQuery#fetchInto(), etc.
#907 - Add missing Field.like(Field<T>), notLike(Field<T>)
       methods to overload the existing Field.like(T), notLike(T)
#908 - Change rpad / lpad functions to accept String instead of
       char
#912 - Add <R extends Record> R newRecord(Table<R>, Object) as
       the inverse of various into(Class<?>) methods
#916 - Add <R extends TableRecord<R>> {Record.into(Table<R>) |
       Result.into(Table<R>) | ResultQuery.fetchInto(Table<R>) |
       Cursor.fetchInto(Table<R>)}
#917 - Add various Cursor.fetchOneInto() convenience methods
#918 - Add CustomTable, CustomRecord as base classes for more
       convenience when used with various into(Table) methods
#919 - Allow for accessing non-public constructors of Record
       subtypes
#923 - Move some utilities to org.jooq.tools
#924 - Generate a reference to every table in a new Tables.java
       class for improved static access
#928 - Add DataTypeException extending DataAccessException in
       case something went wrong when converting data types
#930 - Support converting date time types to java.util.Calendar.
       This applies to various into(Class<?>) methods, as well as
       Result.getValue(xx, Class<?>)
#931 - Allow for conversion between Long and date/time types, and
       vice versa
#932 - Let the bound of R in TableRecord extend TableRecord<R>,
       in UpdatableRecord to extend UpdatableRecord<R>
#933 - Add support for type Character in Record.into(Class<?>)
       methods and similar
#936 - Accept primitive types, such as int.class for type
       conversion
#938 - CODEGEN: Add static/instance table field configuration
#939 - Include license.txt and readme.txt in .jar files' META-INF
       directory
#953 - Make DefaultGeneratorStrategy methods non-final to allow
       for overriding
#954 - Add examples for source code generation of multiple
       schemata with Maven
#955 - Generate a reference to every type in a new UDTs.java
       class
#957 - Add <R> R Factory.newRecord(UDT<R>) for constructing
       attached UDTRecords
#958 - CODEGEN: Add generation-time schema mapping, allowing for
       re-writing schemata in jooq-codegen
#960 - CODEGEN: Add code generation configuration parameter to
       avoid using the new UByte, UShort, UInteger, ULong wrappers
       for UNSIGNED number types
#961 - Use Oracle's SYS.ALL_SEQUENCES.MAX_VALUE to determine the
       type of a sequence.
#969 - Add <T> List<T> ResultQuery.fetch(Field<?>,
       Class<? extends T>) convenience method

Bug fixes
---------
#686 - Reduce the internal API leak by preventing access to
       TableFieldImpl, UDTFieldImpl, ParameterImpl
#903 - lag(Field, int, T) erroneously delegates to lead()
#906 - Add more NullPointerException safety to API
#913 - NoClassDefFoundError in JooqUtil.isJPAAvailable()
#920 - Generic type is lost in Cursor.fetchInto(RecordHandler)
#925 - SelectConditionStep should extend SelectConnectByStep, not
       SelectGroupByStep
#926 - AbstractRecord.into() fails to convert java.sql.Date into
       java.util.Date
#934 - Don't consider static members in reflection utilities when
       used with Record.into(Class<?>) and similar methods
#935 - Don't consider final member fields in reflection utilities
       when used with Record.into(Class<?>) and similar methods
#937 - In the event of name clash (same name for table and field)
       generated code has errors
#945 - Calling UpdatableRecord.setValue() twice with the same
       argument causes the changed flag to be reset to false
#948 - Always set the changed flag to true in Record.setValue()
#959 - Compilation errors in generated source code if MySQL enum
       values match Java reserved words, such as 'true', 'false',
       'new', etc...
#962 - Postgres ordering of generated enum literals is unstable
#967 - Better document type conversion

Version 1.7.0 - November 25, 2011
================================================================================
This is a maintenance release for the 1.x branch. Some important
bug fixes are merged from version 2.0. These include:

Bug fixes
---------
#925 - SelectConditionStep should extend SelectConnectByStep, not
       SelectGroupByStep
#926 - AbstractRecord.into() fails to convert java.sql.Date into
       java.util.Date
#937 - In the event of name clash (same name for table and field)
       generated code has errors
#945 - Calling UpdatableRecord.setValue() twice with the same
       argument causes the changed flag to be reset to false
#948 - Always set the changed flag to true in Record.setValue()
#951 - Empty Password for jooq-codegen-maven causes NPE

Version 1.6.9 - November 7, 2011
================================================================================
This is a maintenance release for the 1.x branch. Developments
on this branch will stop after version 1.6.9. Only important bug
fixes are merged to this branch. Developments for release 2.0
have started.

The most important functionality in release 1.6.9 is the newly
added support for JDBC batch operations. You can now batch
execute several queries.

See the official blog for more information:
http://blog.jooq.org/2011/10/25/jdbc-batch-operations-with-jooq/

Features and improvements
-------------------------
#621 - Add support for JDBC batch operations
#794 - Add support for ORDER BY [int value] in order to reference
       a column index for sorting
#882 - Optimise Field.isTrue() and isFalse(). Take Field's data
       type into consideration.
#885 - Add support for INSERT INTO .. VALUES (..) syntax,
       omitting explicit field declarations
#887 - Add <E> List<E> Cursor.fetchInto(Class<E>)

Bug fixes
---------
#748 - H2 regression in 1.3.158 regarding stored functions, which
       return a ResultSet (this was fixed in H2)
#859 - Derby casting of numeric types to BOOLEAN doesn't work
#886 - Regression in date extract function when used in a
       subselect
#888 - Derby casting of VARCHAR to FLOAT (and similar) doesn't
       work

Version 1.6.8 - October 22, 2011
================================================================================
The main improvement of this release is the re-design of the
stored procedure / function API. With 12 supported RDBMS, which
all have their own idea about what is a stored procedure and what
is a stored function, it has proven to be a better design, to
unite them in one single type: org.jooq.Routine. A routine can
have a return value as well as OUT parameters. It can be embedded
in SQL and used as a field or a table.

This means, you will need to re-generate your database schema,
when upgrading to jOOQ 1.6.8. After re-generation, you'll need to
fix your client code. These are the package changes:

- [generated.package].procedures > [generated.package].routines
- [generated.package].functions  > [generated.package].routines
- [generated.package].Procedures > [generated.package].Routines
- [generated.package].Functions  > [generated.package].Routines

Oracle generated packages are not re-located. With these
improvements, using stored procedures and functions becomes even
more reliable, especially when cursor types are involved. Read
more about the rationale behind this change:

http://blog.jooq.org/2011/10/17/what-are-procedures-and-functions-after-all/

Apart from that, important improvements have been made in the
area of plain SQL tables. Also, consider a demo integration of
jOOQ with Google Cloud SQL:

http://blog.jooq.org/2011/10/22/jooq-and-google-cloud-sql-example/

Features and improvements
-------------------------
#271 - Don't pre-fetch table meta data when selecting from plain
       SQL tables
#489 - Add support for SELECT * (i.e. render SELECT * where
       applicable)
#596 - Add support for VARIANCE() and STDDEV() OVER() window
       functions
#608 - Add jOOQ version number in generated source code
#670 - Add more Javadoc to Field.xxx() functions
#692 - Add support for ResultSet type returned from HSQLDB
       stored functions
#850 - Use http://www.jooq.org as URL for the @Generated
       annotation
#854 - Add convenience methods Fields.isTrue(), isFalse() for
       conversion of "Y", "YES", "1", "true", "on", etc into a
       boolean condition
#870 - Add support for MEDIAN aggregate function
#872 - Add support for STDDEV_POP(), STDDEV_SAMP(), VAR_POP(),
       VAR_SAMP() aggregate functions
#874 - Reduce the number of internal classes for dialect-specific
       function aliases
#878 - Implement DataType.equals() and hashCode()

API changes (backwards-compatible)
----------------------------------
#851 - Change Field.{sortAsc|sortDesc}(List<T> sortList) into
       Field.{sortAsc|sortDesc}(Collection<T> sortList)

API changes (backwards-incompatible)
------------------------------------
#848 - Purge deprecated API - Prior to 1.6.1
#849 - Replace Cursor.fetchResult() by Cursor.fetch()
#852 - Review stored procedures / functions concept. Merge them
       all into a single "Routine" type

Bug fixes
---------
#756 - Error when aliasing HSQLDB and Postgres unnested tables
#761 - Exception when TRACE logging execution with plain SQL
       tables involved
#773 - Execute standalone stored functions as CallableStatement
       to prevent issues with transactions
#847 - Query.getSQL() doesn't render dialect-specific SQL when
       Query is constructed using the fluent API
#853 - DB2 generated convenience methods for stored functions
       have unstable ordering
#857 - Derby casting of numeric types to String / VARCHAR does
       not work
#858 - SQLDataType.getSQLDataType() should return itself, instead
       of null
#860 - SQLite CEIL function is incorrectly simulated. CEIL(2.0)
       returns 3.0 instead of 2.0
#861 - Field.replace(String) generates bad SQL for various RDBMS.
       Field.replace(String, String) works, though
#863 - Ingres integration generates illegal SQL when selecting
       things like SELECT 1 WHERE 1 = 1
#866 - Sybase ASE Field.replace(String) function incorrectly
       removes the argument string
#873 - Error when selecting two times the same aggregate field
#877 - Compilation error in generated source code when a table
       without a primary key has an identity column
#879 - Add Google Cloud SQL Example
#880 - Query.getSQL() does not consider SchemaMapping

Test cases
----------
#811 - Loader integration tests fail for SQLite
#812 - CSV Loader test leaves Postgres JDBC connection in an
       inconsistent transactional state on error
#856 - Add integration tests for Field.abs()
#865 - Add integration tests for Field.ascii()
#867 - Add integration tests for Field.sum(), avg(), max(), min()
#881 - Re-design H2 stored functions to be pre-compiled, in order
       to speed up integration tests

Version 1.6.7 - September 25, 2011
================================================================================

This release coincides with the launch of the new website at
http://www.jooq.org. Hence, it ships with little additions to the
deliverable itself.

Apart from new convenience methods, the main addition is a Maven
plugin for jooq-codegen contributed by Sander Plas.

Features and improvements
-------------------------
#797 - Create Maven plugin for source code generation
#825 - Add List<Result<Record>> Factory.fetchMany(String) to
       allow for fetching several result sets from stored
       procedures, such as Sybase ASE's "sp_help"
#838 - Implement MetaDataFieldProvider.toString()
#841 - Add <T> List<T> Result.getValues(Field<?>, Class<T>)
#842 - Add Query.getBindValues() method to allow for extracting
       bind values in the correct order
#843 - Add Factory.fetch(ResultSet) to transform a JDBC ResultSet
       into a jOOQ Result

API changes (backwards-compatible)
----------------------------------
#837 - Avoid final keyword on Object methods, such as .equals(),
       .hashCode(), etc

Bug fixes
---------
#836 - Bad syntax when selecting from aliased plain SQL tables
#839 - Boolean conversion in getValueAsBoolean() should trim
       String values first
#840 - Numeric conversions in getValueAsXXX() should trim String
       values first
#844 - NullPointerException when selecting a column from a Result,
       that does not exist

Version 1.6.6 - September 11, 2011
================================================================================

Finally, support for another RDBMS has been added. Sybase's other
important product Sybase Adaptive Server Enterprise (or simply
Sybase ASE) is now officially supported by jOOQ

Apart from this, there had been important improvements with the
recently added INSERT .. RETURNING clause, as well as some fixes
related to DECIMAL / NUMERIC data types

Features and improvements
-------------------------
#796 - Complete missing public org.jooq.impl Javadoc
#800 - Add support for Sybase Adaptive Server Enterprise
#808 - Add support for INSERT .. RETURNING for Ingres
#809 - Add support for INSERT .. RETURNING for Sybase SQL
       Anywhere using SELECT @@identity
#810 - Add support for INSERT .. RETURNING for SQLite using
       last_inserted_rowid()
#813 - Add DSL support for INSERT .. RETURNING
#814 - Change TableRecord to reload its trigger-initialised main
       key in Oracle and other RDBMS that don't support IDENTITY
       columns
#818 - Add SQLiteFactory.rowid()
#819 - Support SQLite AUTOINCREMENT columns as IDENTITY
#820 - Add Factory.fetchOne(String) for executing plain SQL
       queries that return single records
#826 - Allow for returning several records in the INSERT ..
       RETURNING clause. This now works for DB2, HSQLDB, MySQL,
       and Postgres
#827 - Support Sybase SQL Anywhere's TOP n START AT m clause
       instead of simulating it with nested SELECT's

API changes (previous API now deprecated)
-----------------------------------------
#817 - Deprecate Factory.lastID(Identity)

Bug fixes
---------
#815 - SQL Server fetching of IDENTITY value is broken
#821 - Optimise ResultQuery.fetchAny() executing fetchLazy()
       internally, and only fetching one record from the cursor
#822 - Let Constant cast to more precise NUMERIC/DECIMAL types
       in those RDBMS where casting is necessary
#823 - Cannot bind SQLite BigDecimal, BigInteger types - bind
       them as String instead
#824 - BigInteger values cannot be bound in DB2, Derby
#828 - Document inefficient implementation for GREATEST and LEAST
       in some RDBMS

Version 1.6.5 - August 28, 2011
================================================================================

This release finally adds a loader for CSV data to jOOQ. You can
now load CSV data using a simple fluent API, configuring error
handling, duplicate behaviour and transaction handling, as well
as various CSV parameters.

This release also changes the way generated keys are retrieved
after INSERT's. Instead of (potentially inconsistently) running
SELECT MAX(pk) immediately after the INSERT, Postgres' INSERT..
RETURNING clause is used (or simulated), in a single statement.

Features and improvements
-------------------------
#784 - Add Result.exportXML() to retrieve a DOM document similar
       to that of .formatXML()
#792 - Add support for loading of CSV data into tables
#795 - Add <T> List<T> fetch(int, Class<T>) and
       fetch(String, Class<T>) convenience methods
#803 - Add support for INSERT .. RETURNING or simulate it where
       not available
#805 - Add <T> T[] fetchArray(int, Class<T>) and
       fetchArray(String, Class<T>) convenience methods
#806 - Add <T> T fetchOne(int, Class<T>) and
       fetchOne(String, Class<T>) convenience methods

Bug fixes
---------
#798 - Oracle IN (...) clause with more than 1000 arguments does
       not work
#802 - Use "INSERT .. RETURNING" instead of "SELECT MAX(pk)"
       to retrieve the primary key of a new record

Version 1.6.4 - August 07, 2011
================================================================================

This release ships with a couple of useful concepts inspired by
other frameworks. These are:

- selecting into custom POJO's. Results can be mapped to POJO's
  by convention or using JPA @Column annotations
- selecting into custom callbacks. This is already a wide-spread
  practice in Spring JdbcTemplates.
- selecting long-running queries asynchronously. This idea has
  been inspired by the Avaje Ebean framework

Apart from these changes and some bugfixes, the internal API has
been completely re-designed. The idea here is that query
rendering and variable binding are even faster (less String
objects), more extensible and more accurate. This is a pre-
requisite for many future developments with even more complex SQL
statements, such as for instance CTE's (Common Table Expressions)

Features and improvements
-------------------------
#137 - Add support for asynchronous query execution using
       FutureResult<R> ResultQuery.fetchLater() similar to
       Avaje Ebean
#198 - Add SELECT INTO functionality into POJO's using
       <T> T ResultQuery.fetchInto(Class<T>) similar to JPA
       CriteriaQuery
#728 - Add .fetchInto(RecordHandler<R>) to ResultQuery, Result,
       and Cursor to allow for callbacks similar to Spring's
       JdbcTemplate/Ollin Framework
#774 - Add more TRACE logging to .fetchLazy()
#777 - CURSOR: Add function alias: UNNEST for TABLE
#781 - Add E function (Euler number)
#782 - Add <T> T Record.getValue(..., Class<? extends T>) methods
       for convenient type conversion
#785 - Allow for storing TableRecord with a provided Field<?>[]
       indicating the primary key
#786 - Document thread-safety facts in Factory Javadoc
#788 - Add Key.getFieldsArray() convenience method
#793 - Add support for Oracle's SYS_CONNECT_BY_PATH function

API changes (backwards-incompatible)
------------------------------------
#758 - Change internal QueryPart rendering and binding API to use
       Configuration and Context as callback parameters. If you
       use CustomField or CustomCondition, please correct your
       implementations accordingly. Other parts of the API should
       not be affected
#778 - Purge deprecated API, deprecation prior to jOOQ 1.5.7
#790 - Purge deprecated generated code, deprecation prior to
       jOOQ 1.5.7

API changes (previous API now deprecated)
-----------------------------------------
#776 - Deprecate QueryPart.getSQL(), add Query.getSQL()
#789 - Deprecate Record constructors with Configuration
       parameter

Test cases
----------
#636 - Add integration tests for more advanced CONNECT BY
       example
#772 - Add integration tests for selecting cartesian products
       (several tables in FROM clause)

Bug fixes
---------
#730 - Sybase cannot bind null values in plain SQL
#759 - Omit the TOP 100 PERCENT clause in SQL Server ordered
       top-level queries
#767 - An empty Java package is generated for PL/SQL packages
       containing underscores
#771 - Some exotic literals are not properly escaped with quotes
       yet, e.g. UDT identifiers, VARRAY types, etc.
#775 - Automatic re-attaching after deserialisation does not work
       when used with .fetchLazy()
#787 - The UpdatableRecord's internal changed flags are not
       updated after INSERTs / UPDATEs

Version 1.6.3 - July 31, 2011
================================================================================

This is mainly a maintenance release with lots of bugfixes,
mostly around code generation, plain SQL tables, and data types.
Please note that generated source code may contain incompatible
changes due to #639 (see below for details)!

Apart from that, project CURSOR is advancing and it is now
possible to unnest arrays into tables. See this article for
details about where jOOQ is heading with project CURSOR:

http://blog.jooq.org/2011/07/24/the-power-of-ref-cursor-types/

Features and improvements
-------------------------
#679 - Improve H2 NVL2 support as of H2 1.3.156
#680 - Improve H2 ROUND support as of H2 1.3.156
#735 - Add README documentation to GitHub
#736 - Add more info regarding number of generated artefacts in
       jooq-codegen logging
#750 - Add DataType.isNumeric(), .isString(), .isTemporal(),
       .isBinary()
#754 - Log query as executed by JDBC PreparedStatement when
       TRACE logging (without inlining variables)
#752 - CURSOR: Add support for selecting from ARRAY types
#762 - Use H2's native support of NVL, instead of COALESCE
#764 - CURSOR: Add support for selecting from ARRAY types
       returned from stored functions

API changes (backwards-incompatible)
------------------------------------
#639 - Map DECIMAL(n, 0) and NUMBER/NUMERIC(n, 0) data types
       to Byte/Short/Integer/Long/BigInteger instead of
       BigDecimal in generated source code. Re-generated code
       will not be compatible!

API changes (previous API now deprecated)
-----------------------------------------
#731 - Inconsistent API with Field.lessOrEqualToXXX(). Removed
       "To" from method name
#757 - Deprecate Factory.constant() methods

Test cases
----------
#731 - Add missing integration tests for equalAll(), equalSome()
       and similar methods
#747 - Upgrade H2 to 1.3.158

Bug fixes
---------
#632 - Sybase error : column @p0 not found in nested SELECT
#700 - Restore HSQLDB ARRAY support with INFORMATION_SCHEMA
       change in HSQLDB 2.2.3, and some fixes in 2.2.5
#725 - Cannot insert byte[] data with plain SQL
#733 - H2 changed JDBC type for ResultSet/CURSOR from 0 to -10,
       like Oracle
#737 - Compilation errors in generated source code if table
       fields contain spaces
#738 - Compilation errors in generated source code if MySQL
       procedure parameter type contains two comma-separated
       arguments (like DECIMAL(10,2))
#739 - Postgres navigator methods and keys are not re-generated
       in the same order
#740 - Formatting is broken on Result.format() with some special
       newline characters
#743 - Make SQL Server INFORMATION_SCHEMA independent from
       HSQLDB again, to prevent incompatibility issues
#744 - Ingres REAL and FLOAT4 types are generated as FLOAT/FLOAT8
       which maps to java.lang.Double, instead of java.lang.Float
#753 - Postgres error when binding array that contains null
       values
#755 - NullPointerException when converting an array containing
       a null value
#766 - Bad decoding of JDBC Types BIGINT (to BigInteger instead
       of Long) and REAL (to BigDecimal instead of Float) when
       plain SQL tables are involved

Version 1.6.2 - July 10, 2011
================================================================================

This release mainly introduces three new projects.

Project CURSOR where jOOQ finally supports various RDBMS's TABLE,
CURSOR, and REF CURSOR data types. This is especially useful when
those types are returned from stored procedures and functions.
Cursors are simply mapped to jOOQ Result<Record> types and can
thus be used like regular table results

Project EXPORT aims at exporting data from the database in
various serialisable formats, such as XML, CSV, HTML, Text, JSON.
This project will be continued in the future, to also
deserialise from (some of) these data streams. This will allow
for easy transport of jOOQ Result<?> types over the net.

Project CODEGEN has finally been started. Many improvements
suggested by jOOQ users will be implemented in the next releases.
In this release, important fixes have been made to prevent
compilation errors in generated artefacts.

Features and improvements
-------------------------
#61  - EXPORT: Add Result.formatXML()
#166 - CURSOR: Add support for ResultSet type returned from
       Oracle stored procedures / functions
#411 - Allow for fetching Map<String, Object> (instead of Record)
       and List<Map<String, Object>> (instead of Result)
#549 - Add Factory.function() for plain SQL functions
#611 - Simulate RPAD and LPAD in SQL Server, Sybase
#627 - Add support for Postgres FOR UPDATE OF [table-name] clause
#628 - Add support for REPEAT (SQL Server: REPLICATE) function
#637 - Nicely format time in StopWatch logging output
#640 - Simulate Postgres FOR UPDATE OF [table-name] clause in
       other dialects
#649 - CURSOR: Add Cursor.fetch(int) .fetchOne()
       .fetchResult(int) .fetchResult()
#653 - Add support for MySQL encryption and compression functions
#660 - Clarify Javadoc of UpdatableRecord to explain its
       behaviour when changing the main unique key
#669 - EXPORT: Add Result.formatHTML()
#672 - Add convenience method UpdatableRecord.copy() in order to
       reset primary key values for a subsequent INSERT
#675 - EXPORT: Add Result.formatCSV()
#683 - Implement ResultImpl.equals() and .hashCode()
#684 - Implement AbstractStore.equals() and .hashCode()
#685 - Add Store.size() to indicate the maximum index of the
       Store
#687 - EXPORT: Add result.formatJSON()
#689 - Create separate builds: jooq-core.zip and
       jooq-with-dependencies.zip
#690 - CURSOR: Add support for ResultSet type returned from H2
       stored functions
#695 - CURSOR: Add support for ResultSet type returned from
       Postgres stored functions
#697 - Add Factory.fetch(String) for executing plain SQL queries
       that return results
#701 - Add ResultQuery.fetchArray() and .fetchOneArray to return
       Object[][] and Object[]
#704 - Always add top and bottom line in Result.format()
#705 - Right-align numeric values in Result.format()
#716 - Add SUBSTRING function Field.substring(Field, Field)
       taking fields as arguments
#719 - Document risk of SQL injection in plain SQL and literal
       factory methods
#726 - Add LENGTH function as a synonym for CHAR_LENGTH

API changes (backwards-compatible)
----------------------------------
#698 - Inconsistent API with Factory.fetch(Table<R> [,Condition])
       Let method return Result<R> instead of List<R>
#699 - Let Result<R extends Record> extend List<R>

API changes (previous API now deprecated)
-----------------------------------------
#656 - Decrease verbosity of plain SQL methods. They will just be
       called Factory.field() .condition() .table() .query()

Test cases
----------
#643 - Add integration test for code generation of invalid and
       incomplete types in Oracle
#654 - Add integration tests for master data tables with PK types
       other than NUMBER/INT
#655 - Add missing integration tests for TRIM function

Bug fixes
---------
#450 - Improve plain SQL integrity checks for bind variables
#610 - CODEGEN: Compilation error in generated source code for
       databases with table named 'system'
#646 - An empty Java package is generated for an empty PL/SQL
       package. This is unnecessary
#651 - CODEGEN: Avoid importing datatypes in generated source
       code to prevent collisions
#657 - NullPointerException when creating a Factory with a null
       SchemaMapping
#658 - Master data table code generation is broken for tables
       with more or less than 3 columns
#662 - Add support for the missing Postgres data type "bpchar"
#663 - Add support for the missing Sybase data type "int"
#664 - Ingres INTEGER data types are not correctly generated
#665 - HSQLDB Datatype CLOB and BLOB are not supported, when
       selecting from plain SQL tables
#666 - The evil bug: Ingres TRIM function only executes RTRIM
#673 - UpdatableRecord.store() doesn't work if called after
       .delete()
#702 - Add support for the missing SQLite data type "NULL"
#706 - CURSOR: Ensure that Query.execute() runs in a single
       transaction when Postgres refcursor is involved in the
       query (this fixes a Postgres JDBC driver flaw)
#724 - NullPointerException when passing a single literal null
       bind value to plain SQL methods without casting to Object
#729 - DB2, Derby, Ingres, Oracle cannot bind null values in
       plain SQL

Version 1.6.1 - June 19, 2011
================================================================================

In this release, the PORTABILITY project has been implemented.
Finally, the SQLDialect has been removed from most generated
artefacts (Schema, Table, Field, Sequence, etc). Also, the
constructing Factory is not referenced by its created QueryParts
anymore, unless this is really necessary (Query objects, UDT's,
ARRAY types). This leads to higher compatibility between schemata
of different databases, e.g. if users want to use an HSQLDB
development and Oracle productive database.

Unfortunately, this means that the way stored procedures are
called had to be changed. This is an API break that could not be
avoided. The pre-1.6.1 StoredObject.execute(Connection) method
is deprecated and will be removed in the future. It has been
replaced by StoredObject.execute(Configuration)

In addition to this project, many more window functions are now
supported, as well as the Oracle-specific CONNECT BY clause for
recursive queries.

Features
--------
#351 - Add support for Oracle ROWID data type
#452 - PORTABILITY: Create a super-set of RDBMS data types
#453 - PORTABILITY: Don't create dialect-specific QueryParts
#455 - Add support for the Oracle CONNECT BY clause
#587 - Add optional OFFSET clause to form LIMIT .. OFFSET
       constructs
#589 - Add extended FOR UDPATE [OF ...] [{WAIT n | NOWAIT | SKIP
       LOCKED }] support
#591 - Add support for LEAD() OVER() and LAG() OVER() window
       functions
#592 - Add support for the CUME_DIST() OVER() window function
#601 - Add Factory.literal() convenience methods
#602 - Add Factory.val() methods to decrease .constant()
       verbosity
#604 - Add support for RESPECT NULLS clause in some window
       functions
#605 - Add Factory.use(String) for non-generated schemata
#613 - Add PI function
#616 - Add Factory.two() literal convenience method
#630 - Add support for Oracle CONNECT BY pseudo-columns LEVEL,
       CONNECT_BY_ISCYCLE, CONNECT_BY_ISLEAF

API changes
-----------
#299 - PORTABILITY: Create a dialect-independent meta-model
#588 - Add OVER() keyword to FIRST_VALUE() and LAST_VALUE() API

Test cases
----------
#368 - Add integration test for use with schema mapping
#586 - Upgrade H2 to 1.3.155
#607 - Add integration tests for CRUD / SP's / UDT's / ARRAY's
       with SchemaMapping
#612 - Add integration tests for LPAD and RPAD functions
#624 - Add integration test for code generation of invalid/
       incomplete views in Oracle
#631 - PORTABILITY: Add integration tests for using Oracle-
       generated schema against an HSQLDB database
#638 - Add missing integration test for DECIMAL data type

Bugfixes
--------
#176 - Stored procedures / functions in EQUIVALENT schemata
       cannot be called
#493 - Bind variable mismatch when constructing bad SQL
#594 - Confusing Javadoc in SELECT DSL API
#603 - Fix DB2 'IGNORE NULLS' clause
#619 - SUBSTRING() function is broken in DB2, Ingres, SQL Server
#623 - SQL syntax error for some MERGE queries in SQL Server and
       Sybase
#633 - SchemaMapping is not applied to sequences
#634 - Sequences are not escaped in generated SQL

Version 1.6.0 - June 05, 2011
================================================================================

Apart from supporting various additional standard and non-
standard JOIN constructs, there is now also full support for the
SQL standard MERGE statement and MySQL's ON DUPLICATE KEY variant
thereof. A great number of API enhancements have been added,
which improve the usability of jOOQ. The Ingres database is now
also supported.

Features
--------
#301 - Add support for Oracle execution hints
#409 - Add support for NATURAL JOIN syntax, where RDBMS allows it
#415 - Make fluent API's underlying SelectQuery objects publicly
       available
#429 - Add Ingres support
#475 - Document class-level generic types <R> and <T> in Javadoc
#486 - Add support for SQL MERGE clause
#494 - Allow for omitting schema name in generated SQL
#496 - Automatically update IDENTITY values in UpdatableRecord,
       after storing them
#520 - Add support for JOIN ... USING syntax
#524 - Upgrade HSQLDB to 2.2
#533 - Add ORDER BY [Map] or BY [List] functionality
#534 - Add Result.isEmpty()
#535 - Call upon ConfigurationRegistry.provideFor() before
       throwing a DetachedException
#536 - Simulate CASE [value] WHEN [value] THEN [result] END
       syntax in Derby
#538 - Add some logging to ConfigurationProvider
#539 - Add possibility to negate numeric values with Field.neg()
#541 - Add support for MySQL ON DUPLICATE KEY clause
#542 - Allow for Collection arguments in INSERT's DSL API
#543 - Allow for creating FUNCTION() OVER() without PARTITION BY
       or ORDER BY clause
#546 - Add Factory.use(Schema)
#548 - Add new internal type FieldMap
#550 - Simulate ON DUPLICATE KEY INSERT clause in dialects other
       than MySQL
#551 - Add TableMapping, similar to SchemaMapping for mapping
       tables
#553 - Add Factory.plainSQLQuery
#554 - Add Factory.plainSQLField with a DataType parameter
#555 - Add UpdateXXX.set(Map) convenience methods to DSL API
#557 - Enhance INSERT DSL API to allow for adding VALUES clause
       with InsertXXX.set() syntax
#570 - Add support for the RAND() function
#567 - Add support for Ingres Sequences
#572 - Add support for the ATAN2() function
#573 - Add possibility for additional select() clauses for
       convenience
#575 - Add support for the FULL OUTER JOIN syntax, where RDBMS
       supports it
#576 - Add support for the CROSS JOIN syntax, where RDBMS
       supports it
#581 - Enhance API and allow Collection<? extends Field<?>>
       instead of Collection<Field<?>>

API changes
-----------
#397 - Purge deprecated API

Bugfixes
--------
#481 - Handle case where an empty record is stored
#522 - Misleading Javadoc in generated stored procedures and
       function constructors
#532 - Restore Postgres INFORMATION_SCHEMA
#537 - Prevent null from being added to QueryPartList
#540 - Error when TRACE logging Limit
#544 - Aliased elements are not bound correctly when rendered
       with toSQLReference()
#559 - Loosen type safety on overloaded methods to prevent
       compilation errors with javac/Netbeans
#560 - HSQLDB DataType REAL is configured incorrectly
#565 - Add integration tests for current_user() function
#569 - ORA-01427 when generating foreign key relations
#571 - Field.trim() not correctly implemented for SQL Server
#583 - Accelerate integration tests: Reset schema only if
       necessary

Version 1.5.9 - May 15, 2011
================================================================================

This version ships with lots of new functionality. Finally, the
DSL-style API has been extended to CRUD operations (INSERT,
UPDATE, DELETE)! Also, support for the TRUNCATE TABLE statement
has been added.

The most important new features include the support for SQL:2003
standard window functions, which are available in most major
RDBMS. Additionally, basic function support has been widely
extended.

Features
--------
#148 - Added support for window functions
#204 - Add support for multi-record INSERT's
#416 - Added support for retrieval of IDENTITY values
#433 - Use bind variables for LIMIT and OFFSET
#441 - Added foreign key relationship meta information to the
       generated source code
#446 - Beautify ResultImpl.toString() method
#461 - Automatically cast CONCAT parameters to Field<String> if
       necessary
#463 - Added support for trigonometric functions
#471 - Added support for the sign function
#472 - Added support for GREATEST/LEAST functions
#474 - Added support for "hyperbolic" functions SINH, COSH, TANH,
       and COTH
#482 - Added DSL API for INSERT statements
#483 - Added DSL API for UPDATE statements
#484 - Added DSL API for DELETE statements
#485 - Added "Registry" for client code to provide Configurations
       to jOOQ Attachables
#490 - Added support for the TRUNCATE TABLE statement
#495 - Generate source code for IDENTITY columns
#501 - Added support for boolean conversion to Result, Record,
       and Store
#503 - Allow for schema navigation via generated artefacts
#518 - Let stored procedures reference owner package
       if applicable
#525 - Added NULLS {FIRST | LAST} clause to ORDER BY constructs
#528 - Added Factory.getDataType() convenience method
#530 - Added Factory.zero() and Factory.one() convenience methods

API changes (jooq)
------------------
#527 - Weakened type-safety on Field.nvl2()
#529 - Deprecated Factory.select(Object...), added .selectOne()
       and .selectZero() instead

API changes (jooq-meta)
-----------------------
#30  - Add ParameterDefinition for stored procedures, instead of
       reusing ColumnDefinition
#499 - Add reference to TableDefinition in ColumnDefinition
#500 - Add AttributeDefinition for UDTDefinition, instead of
       reusing ColumnDefinition

Bug fixes
---------
#369 - Adapt H2 relations generation to H2's correction of
       information_schema.cross_references
#435 - Added integration tests for NESTED SELECTs holding LIMIT
       clauses
#460 - Syntax error when using a field with a reserved name
#462 - Fixed Javadoc broken links
#473 - Don't cast when cast is unnecessary
#479 - INSERT statement should not set all fields for a table
#497 - Derby referential code generation is broken, for named
       foreign keys
#498 - Oracle package content is generated in arbitrary order
#502 - Syntax error when creating an empty IN condition
#526 - Corrected Javadoc in Field.coalesce()

Version 1.5.8 - April 29, 2011
================================================================================

Finally, jOOQ now supports two important new RDBMS:
SQL Server and Sybase!

Apart from this great enhancement, there is now also full support
for the non-SQL standard LIMIT clause, even in dialects where the
LIMIT clause is not supported natively (especially Oracle, but
also DB2, SQL Server and Sybase, which have limitations). jOOQ
simulates LIMITs by rendering nested selects filtering on ROWNUM
(Oracle) or on ROW_NUMBER() (DB2, SQL Server and Sybase).

Other interesting additions are an increasing support for native
mathematical functions. More function support will be added in
future versions.

Features
--------
#16  - Added support for SQL Server
#21  - Uniform implementation of the LIMIT clause. Implemented
       LIMIT clause simulation through analytic functions, where
       LIMIT is not supported natively
#97  - Added support for Sybase
#418 - Measure time of various steps in source code generation
#420 - Added support for proprietary SQL extensions "FOR UPDATE"
       and "FOR SHARE"
#431 - Added additional statistics to generation log files
#432 - Unified the various "standard" ANSI INFORMATION_SCHEMA
       implementations in the jooq-meta artefact
#436 - Added support for the modulo function
#438 - Added floor and ceil functions
#439 - Added support for mathematical functions (logarithms,
       exponentials, sqrt)
#447 - Enhanced Field.add() and Field.subtract() to work for date
       time fields, also


API changes
-----------
#428 - Created new Maven artefact jooq-meta to cleanly separate
       database meta-data navigation from code generation
#458 - Decreased DSL verbosity for arithmetic operations and for
       ordering

Bug fixes
---------
#417 - Restored warning when unknown column type is encountered
       in source code generation
#419 - Corrected misleading Select.fetchOne(...) Javadoc
#421 - Optimised AbstractRecord's memory consumption
#448 - Corrected some Javadoc @see links
#449 - Changed Field.concatenate() to accept Field<?> parameters
       to avoid generic varargs warnings

Version 1.5.7 - April 17, 2011
================================================================================

This is the first release built with support of Maven thanks to
the help of some jOOQ users!

The main new features in this release are the improved support
for serialisation/deserialisation of jOOQ objects through use of
the newly introduced "Attachable" interface.

If using log4j or the newly supported slf4j logging framework
in debug/trace mode, there is the possibility to log query
building/execution time statistics.

Apart from these new features, fixes were mainly done in the
fields of type casting, HSQLDB 2.1 upgrade support, stored
procedures with OUT, IN/OUT parameters. Please upgrade, if you
are using any of those features.

If you extend jOOQ as a base implementation for source code
generation, be aware of the fact, that the jOOQ-codegen is
currently undergoing major changes. Expect the code generation
API to stabilise again in one of the next releases.

Features
--------
#104 - Added maven dependency
#248 - Integrate UDT types with ARRAYs
#295 - Allow for attaching/detaching UpdatableRecords to/from
       Configurations
#359 - Added statistics measurement to Query execution for debug
       log level
#362 - Added deprecation configuration flag
#364 - Document unknown type in generated source code
#373 - Improve exception handling in code generation
#378 - Added support for Oracle stored functions with OUT
       parameters
#382 - Added Factory.attach() methods to re-attach deserialised
       Attachables
#394 - Add logging support for SLF4J
#398 - Allow to provide a DataType in Factory.constant()
#399 - Provide access to TypeUtils.convert() methods via DataType
#404 - Added trace logging for measuring the speed of various
       query execution steps

API changes
-----------
#358 - Enhanced DSL API to allow for HAVING clauses without
       GROUP BY clauses
#367 - Make Store, Result, QueryPart "Attachable"
#374 - Introduce strategy pattern to code generation for future
       support for advanced naming schemes
#375 - Decouple Database from Generator
#381 - Made DataType Serializable
#384 - Deprecated singleton QueryParts
#388 - Unify "internal" API using an Adapter pattern

Bug fixes
---------
#187 - Protect generated Record navigation methods against name
       clashes
#266 - Added more thorough integration tests for dialect-specific
       casting (including some fixes related to varchar types)
#360 - Added more integration tests for the DISTINCT clause
#361 - Add more checks in testInsertUpdateDelete()
#366 - Warn only once per ColumnDefinition, if a data type is
       unknown
#377 - NullPointerException when generating invalid stored
       function
#380 - Added integration tests to check for proper
       serialisability
#386 - Fixed incompatibilities with HSQLDB 2.1.0
#387 - Fixed unnecessary imports in some Oracle generated
       Records
#389 - Fixed javac compiler warning in AbstractStoredObject
#391 - Cannot properly call stored procedures when IN/OUT
       parameter is bound to NULL
#392 - Procedures with several OUT parameters may not register
       OUT parameters correctly
#410 - Passing null VARRAY values to Oracle stored procedures
       causes issues
#412 - limit(int) sets default offset incorrectly in some
       dialects

Version 1.5.6 - March 31, 2011
================================================================================

This release consists mainly of code generation bug fixes and
minor API improvements and enhancements.

The most important improvement is ticket #90, by which lazy
fetching and iteration over data is now supported. jOOQ lets you
keep a reference to a Cursor that has an open JDBC ResultSet, to
fetch data from on-the-fly.

A few major code generation bugs were reported where the
generated code may cause ambiguity due to an inconsistent API.
This means that you will have to re-generate your schema after
upgrading to version 1.5.6. Some of your code may not compile
anymore, after this upgrade.

Features
--------
#90  - Added possibility for lazy fetching of data
#208 - Added convenience methods for direct invocation of
       sequences' currval() and nextval() attributes
#212 - Created one factory per dialect for better separation of
       dialect-specific support
#213 - Generate a factory for each schema
#251 - Opened up base implementations for Field<?> and Condition
       to allow for custom implementations by client code
#274 - Integrate H2 ARRAY types with stored procedures
#292 - Documented usage of log4j and java.util.logging
#306 - Added support for the NULLIF function
#319 - Added Field.between(Field<T>, Field<T>) method
#320 - Added trace logging for variable binding and SQL
       generation methods
#323 - Added Field.in(Field<?>...) method
#325 - Include release version number in delivered .jar files
#328 - Improved configuration setup documentation page
#333 - Let Result implement Serializable
#334 - Added fetchMap() convenience methods
#335 - Added more functions and aggregate functions examples to
       documentation
#338 - Visually improve code generation logging
#339 - Removed skipping of unreferenced UDT's, ENUM's and ARRAY's
#342 - Improved generated referential code by using fetch() and
       fetchOne() API
#356 - Let UpdatableRecord.store() and delete() return an int
       to indicate whether the record was actually modified

API changes
-----------
#233 - Allow for joining TableLike instead of Table
#337 - Added generic type <R extends TableRecord<R>> to
       InsertSelectQuery
#341 - Fixed API flaw where SelectOnConditionStep.and() methods
       and similar ones returned SelectConditionStep, instead of
       SelectOnConditionStep

Bugfixes
--------
#69  - Corrected referential code generation for foreign keys
       that reference non-primary unique keys
#85  - Corrected referential code generation for multi-field
       foreign keys
#121 - Covered more Factory.executeXXX() methods with integration
       tests
#318 - Fixed NullPointerException when executing SELECT * from
       aliased tables
#321 - BetweenCondition does not bind left hand side Field
       correctly
#322 - InCondition does not bind left hand side Field correctly
#326 - Avoid method overloading where binding <T> to Object
       may lead to compile-time ambiguities (with javac)
#343 - Add more foreign key navigation method integration tests
#347 - Add explicit integration tests for schema artefacts
       excluded from code generation
#350 - Disambiguate navigation methods if several foreign keys
       reference the same entity
#352 - Disambiguate navigation methods if a table ending on S
       references itself
#353 - Added integration test for compilation of generated
       artefacts with javac (as opposed to the Eclipse compiler)
#355 - Error when storing an UpdatableRecord that has no changed
       values

Version 1.5.5.2 - March 15, 2011
================================================================================

A critical bug was reported from the 1.5 release stream where
stored functions did not render their parameters in correct order

Features
--------
#302 - Map Oracle's NUMBER data type to java.lang.Number in
       stored procedures, stored functions

Bugfixes
--------
#317 - StoredFunctionImpl.asField() renders parameters in wrong
       order

Version 1.5.5.1 - March 13, 2011
================================================================================

In version 1.5.5, there was a fatal bug breaking Derby source code generation.
Only the Derby dialect is affected. Please update immediately, if you are using
jOOQ's Derby integration

Bugfixes
--------
#315 - Generated master data records are not sorted by PK
#316 - Derby code generation fatally broken

Version 1.5.5 - March 12, 2011
================================================================================

This version is released early as there are some important bugfixes. Additional
improvements include:

- Improved DSL related to conditions in HAVING and JOIN clauses
- Support for Oracle-style functions, such as NVL, NVL2, COALESCE
  DECODE, etc

Features
--------
#304 - Add support for Oracle NVL function
#305 - Add support for COALESCE function
#308 - Add support for Oracle NVL2 function
#311 - Add support for Oracle DECODE function

API changes
-----------
#223 - Enhance DSL to accept and(), or() and similar methods in JOIN steps
#224 - Enhance DSL to accept and(), or() and similar methods in HAVING steps

Bugfixes
--------
#297 - Fixed Factory.concatenate() function
#298 - Added integration tests for nested selects in HAVING clause
#300 - Added integration tests for nested selects in JOIN clause
#303 - Javadoc correction
#307 - Accelerated integration tests
#309 - Fixed JDBC variable binding issue related to Conditions where the lhs is
       a function (e.g. stored function) and the rhs is a constant
#310 - Fixed issue where fetchOne() methods throw NullPointerException if no
       result record is available
#312 - Fixed issue where Field.equal(...) methods rendered unexpected SQL when
       rhs null is cast to a type
#313 - Fixed Derby cast type for VARCHAR
#304 - Let the DerbyDataType default for java.lang.String be VARCHAR, not LONG
       VARCHAR

Version 1.5.4 - March 04, 2011
================================================================================

Feature #243 required a minor API change in the base classes of generated source
code. This means you have to re-generate all your jOOQ artifacts in order to
migrate to 1.5.4. The artifacts themselves should be regenerated in a compatible
way, such that your client code should not be affected. If this is not the case,
please report a ticket here:

  https://sourceforge.net/apps/trac/jooq/newticket

Apart from the Derby RDMBS and some new data type support, there have been many
new convenience methods added all over the API. For instance, if type-safety is
not really a requirement, there are lots of possibilities to use plain SQL
directly in the DSL. In that case, data can be accessed from Record, Results,
not only through Field<?>, but also through field names or indexes.

Check out the updated documentation (soon) here:

  https://sourceforge.net/apps/trac/jooq/wiki/Examples

- Support for the Derby RDBMS
- Support for casting. This allows for even greater flexibility
  in cases where jOOQ cannot 100% ensure type-safety
- Support for ARRAY types. Oracle, Postgres, HSQLDB and H2 ARRAY
  types are now supported natively as regular <T> bindings in
  jOOQ's Field<T>
- Support for dialect-specific data types. CHAR, VARCHAR, CLOB
  are no longer treated equally as java.lang.String. Their
  type heritage is also generated
- More sequence support
- Lots and lots of bug fixes

Features
--------
#95  - Support for the Derby RDMBS
#163 - Add support for JDBC type ARRAY (with Postgres)
#209 - Add support for DB2 sequences
#210 - Add support for H2 sequences
#211 - Add support for HSQLDB sequences
#215 - Support for SQL casting using <T> as cast type
#246 - Support for SQL casting using dialect-specific data types
#254 - Add HSQLDB support for ARRAY types
#256 - Add Oracle support for VARRAY types
#257 - Integrate ARRAY types with stored procedures
#261 - Add a global type mapping to the generated Schema object
#267 - Add DataTypeDefinition for further abstraction of data types in code
       generation
#269 - Add H2 support for ARRAY types
#290 - If log4j is not on the classpath, use java.util.logging instead, as
       fallback

API Changes
-----------
#156 - Allow for results to be accessed by index, not by field
#218 - Corrected bad method signature: Record.getValueAsLong(Field<?>, Integer)
#219 - Extended Result and Select API's to be more similar to that of Record
#232 - Add more convenience plain SQL support to the API
#235 - Add convenience methods to Record, Result and Select for access of data
       via field name
#243 - Refactor DataType implementations in order to allow for the use of
       generics
#259 - Add field type to database meta data (ColumnDefinition)
#260 - Add field type to database meta data (Field<?>)
#262 - Add default behaviour for Record.getValue(Field<?>)
#276 - Add Javadoc as a ZIP file to the jOOQ distribution

Bugfixes
--------
#125 - Add more plain SQL integration tests
#191 - Add more integration tests for nested unions
#205 - Implemented workaround for handling Postgres stored functions with UDT
       OUT parameters
#214 - Fixed NPE when generating a stored function with an unknown parameter
       type
#216 - Fixed some cases where binding of BigInteger is not done correctly
#220 - Syntax error when using select statement in a CASE clause
#221 - Corrected integration tests for combined update and select statements
#222 - Added integration test for INSERT statements having nested SELECT
       statements for their fields
#225 - Correctly cast array types in Postgres
#230 - Potential misuse of Blob and Clob in H2's JDBC types
#239 - Factory.fetchAny() is not implemented for SQLite
#244 - Fixed peculiar MySQL casting support where cast types do not match any
       data types
#245 - Fixed NPE when reading null dates in SQLite
#249 - Added ARRAY type integration tests
#255 - Stored procedure bind variables get mixed up when any argument is null
#263 - Correctly handle Postgres function overloading
#264 - Ambiguous funciton calls when calling overloaded functions with null
       parameter
#281 - Handle compilation errors when generating stored procedures with > 254
       parameters
#283 - Fixed compilation errors in generated source code for Oracle's UDT table
       type
#284 - Fixed compilation errors in generated source code for Oracle procedures
       in packages, when they have no parameters
#285 - Fixed compilation errors in generated source code for Oracle tables with
       the same name in different schemata
#286 - Fixed name collisions in generated objects with the java.lang.* package
#288 - Prevent the creation of UNION queries with bad syntax in MySQL
#289 - Correctly alias fields within UNION queries for some dialects, which then
       only require the "AS" keyword
#291 - Cannot create an aliased field called "year" in Postgres

Version 1.5.3 - January 13, 2011
================================================================================

- Lots of stored procedure support was implemented
- Support for sequences was added
- The final decision to postpone support for DB2 UDT's was made
- Some code generation bugfixes

Features
--------
#36  - Added stored procedure / stored function support for HSQLDB
#140 - Added support for Oracle sequences
#147 - Added support for H2 stored functions
#162 - Correctly integrate UDTs with stored procedures
#170 - Added support for Postgres stored functions
#186 - Added support for more Oracle PL/SQL simple data types
#193 - Simulate support for H2 "stored procedures"
#195 - Simulate support for Postgres "stored procedures"
#206 - Added support for Postgres sequences

API changes
-----------
#180 - Improved DSL for constant values
#181 - Allow for referencing Field<?> in function argument list
#189 - Renamed convenience methods in org.jooq.Record
#207 - Add fetchOne(Field) method to org.jooq.Select API

Bugfixes
--------
#182 - Protected generated Record classes against clashes with inherited methods
#183 - Fixed NullPointerException, when generating master data tables with
       NULL fields
#184 - Fixed IllegalArgumentException, when a data type is present in the
       schema, but unavailable in code generation logic
#185 - Code generation should not fail when single elements cannot be generated
#188 - Improved integration tests for stored procedures / functions / packages
#196 - Increase RDMBS version compatibility by avoiding "SELECT *" in code
       generation logic
#199 - Added integration tests for stored procedures in RDBMS that do not
       support OUT parameters
#201 - Fixed issue in DB2 where stored procedures without parameters were not
       generated.
#202 - Added integration tests for stored procedures / functions without
       parameters

Version 1.5.2 - December 27, 2010
================================================================================

- Improved support for stored procedures, also in packages
- A minor API change was inevitable to implement #173. The API change only
  concerns the INTERNAL API. Deprecation marks are added and deprecated items
  will be removed in 1.6.0
- Experimental SQLite database support
- Some important bug fixes

Features
--------
#25  - Added support for Oracle packages
#114 - Added support for Oracle UDTs
#145 - Added support for the SQLite database
#150 - Generate static convenience methods for stored procedures / functions
#151 - Generate static convenience methods for stored function fields
#152 - Generate meaningful serialVersionUID in generated classes
#173 - Added support for EQUIVALENT schemata

API changes
-----------
#159 - Added convenience method List<T> getValues(Field) to Result
#165 - Added convenience methods for creating EXISTS clauses
#169 - Improved DSL for WHERE clauses

Bugfixes
--------
#68  - Prevent issues originating from overloaded stored procedure names,
       generating identical Java class names
#153 - Fixed issue with generated code for DB2 stored functions
#154 - Fixed issue with generated code for DB2 stored functions
#155 - Fixed issues with database NULL not being mapped correctly to Java NULL
       when selecting values that have a primitive type (int, long, etc)
#158 - Potential ClassCastException when using Field<BigInteger>
#171 - Corrected issue related to selection of default schema in DB2
#177 - Fixed issue related to generated code for tables or UDTs without columns


Version 1.5.1 - December 13, 2010
================================================================================

- H2 database support thanks to Espen Stromsnes
- Improved stored procedure support

Features
--------
#96  - Added H2 database support
#101 - Added stored procedure / stored function support for Oracle
#138 - Added stored procedure support for DB2
#146 - Added support for DB2 functions

API changes
-----------
#143 - Added convenience methods to Record

Bugfixes
--------
#84  - Implemented referential code generation for foreign keys that do not
       match their primary keys' types
#141 - Encoding problem in generated master data classes

Version 1.5.0 - November 22, 2010
================================================================================

- A big one. Major API changes / improvements
- Added lots of convenience methods
- UDT support
- Enum support
- DB2 support thanks to Espen Stromsnes
- "Light" dependency to log4j added. jOOQ will still run without it

Features
--------
#1   - Create support for UDTs (so far only for PostgreSQL)
#15  - Added DB2 support
#60  - Added support for nested selects in INSERT and UPDATE statements
#83  - Added log4j logging to code generation and runtime
#87  - Add support for arithmetic expressions
#105 - Added support for ENUM data types, where applicable (MySQL and PostgreSQL
       so far)
#110 - Added execute and fetch convenience methods
#111 - Added missing "select distinct" support
#122 - Annotate generated classes with javax.annotation.Generated
#123 - Generate user enum fields from data values (master data)
#124 - Added PlainSQLTable
#127 - Added not() operator to Condition
#135 - Added convenience methods andNot() and orNot() in Condition

API changes
-----------
#89  - Removed support for DataSource. jOOQ is not a transaction manager
#92  - Added SortField type to be used for sorting
#99  - Provide better access to functions (No more FunctionFactory)
#116 - Merge Manager functionality into Factory
#118 - Improve API of org.jooq.Field
#119 - Improve subquery condition API
#132 - Reduced much of the select query API
#134 - Better separation of SelectQuery and SimpleSelectQuery

Bugfixes
--------
#109 - Error when executing select * if generated schema does not match actual
       schema
#115 - Fix various "null" pseudo field issues
#126 - Error when selecting a single field from a union nested select
#129 - Fixed performance issue in Oracle code generation for very large
       databases


Version 1.4.4 - November 22, 2010
================================================================================

Unreleased version, fixes included in 1.5.0

Bugfixes
--------

#133 - JoinCondition does not take comparison operator

Version 1.4.3 - October 25, 2010
================================================================================

Some more bugfixes

Bugfixes
--------

#71 - Generated code does not compile, when foreign key and primary key have a
      data type mismatch
#73 - In Oracle generated code, multi-field foreign keys may generated bad
      relations code
#82 - Conversion of literals to camelcase fails if numbers are involved

Version 1.4.2 - October 22, 2010
================================================================================

Various bugfixes and minor improvements

Features
--------
#66 - Add support for CASE or DECODE expression

API changes
-----------
#77 - Functions should not extend FieldImpl, but a new AbstractField
#78 - QueryPart pollutes declared method space of its implementations. Hide it
      by indirection

Bugfixes
--------
#64 - Code generation fails when foreign key references a unique key that is not
      the primary key. Code generation for these cases is omitted
#67 - When loading properties files, a leading / seems to be mandatory. This is
      preventing users from correctly setting up jOOQ the first time
#70 - Add support for Oracle datatype TIMESTAMP(6)
#72 - Name clashes in generated Tables
#75 - Constant does not bind its values.
#76 - Constant should not render strings all the time
#79 - Constants are not properly escaped
#80 - Position function does not bind any variables
#81 - Add cast function to Constants in HSQL

Version 1.4.1 - October 18, 2010
================================================================================

Oracle patch release

Features
--------
#63 - Generate referential functionality for Oracle

Version 1.4.0 - October 17, 2010
================================================================================

Support for PostGreSQL was added.
Added lots of OR-mapping functionality.
There is a general API change due to various new features.

Features
--------
#14 - Add PostGreSQL support
#40 - Resolve foreign keys. Allow for navigation between objects.
#42 - Add PlainSQLField
#45 - Add "dirty" flag to Record's values. This allows for updating only
      relevant data.
#47 - Complete implementation for UPDATE, INSERT, DELETE statements. Added some
      missing functionality.
#48 - Add more support for Date, Time, Timestamp fields.
#51 - Add a org.jooq.impl.Manager class that provides common utility methods for
      CRUD operations

API changes
-----------
#10 - Add second generic type <R extends Record>. This is a prerequisite for
      many OR-mapping features
#18 - Use org.jooq.Record in InsertQuery and UpdateQuery
#46 - Create UpdatableRecords as a prerequisite for JPA and true OR-mapping.
      These records support store() and delete() methods
#52 - Add default constructor in generated Records.
#53 - Add refresh functionality to UpdatableRecords. See also #46
#54 - Add a state to the factory class
#56 - Reduce API, remove unnecessary Condition subinterfaces
#57 - Reduce API, remove unnecessary QueryPart interfaces

Bugfixes
--------
#49 - NullPointerException when generating relations on schema subset
#58 - Count function renders bad SQL in various dialects
#59 - Exception when selecting unaliased functions in queries

Version 1.3.0 - August 24, 2010
================================================================================

Support for HSQLDB was added.
There is a major API change due to #44.

Features
--------
#29 - Generate primary keys and foreign keys in Oracle code generation
#34 - Add support for HSQLDB
#39 - Generate primary keys and foreign keys in HSQLDB code generation
#41 - Add documentation to QueryFactory and Functions

API changes
-----------
#23 - Add support for more advanced joins
#32 - Merge SelectQuery and ResultProviderQuery interfaces
#44 - Let Query methods return "this"

Bugfixes
--------
#35 - Add unit tests for HSQLDB support
#37 - Syntax error in combined select queries! The usage of combined queries in
      MySQL may still be a bit awkward. Keep an eye out for further fixes
#43 - Join with aliased tables doesn't work

Version 1.2.0 - August 21, 2010
================================================================================

The added Oracle support is now unit tested and more stable. The Oracle NUMBER
data type is mapped more precisely to Java types.

Features
--------
#12 - Model primary keys and foreign keys in generated code
#22 - Improve mapping of Oracle NUMBER data type
#26 - Add Plain SQL QueryParts
#27 - Add support for HAVING clause

Bugfixes
--------
#24 - Add Unit tests for oracle database (and fixed bugs)
#31 - Pull up addOrderBy() methods from SelectQuery to ResultProviderQuery

Version 1.1.0 - August 17, 2010
================================================================================

The main new feature is the Oracle support. Wait for Version 1.1.1 for that
support to be stabilised, as there are no Oracle unit tests running against an
Oracle database yet.

Features
--------

#2  - Add support for inner / nested selects
#3  - Add more function support
#4  - Implement filtering functionality for code generation
#6  - Add Oracle Support
#9  - Create true POJO's (implementing org.jooq.Record) with getters and setters
#17 - Make org.jooq.impl.Parameter independent of Field

Bugfixes
--------

#11 - Code generation does not remove files

Version 1.0.1 - August 14, 2010
================================================================================

Features
--------

#5 - Prevent code regeneration, if no changes were made
#7 - Implement ant task for code generation

Version 1.0.0 - August 14, 2010
================================================================================
Initial Release
