<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual. Multiple Pages</title>
		<content>
			<h2>Overview</h2>
			<p>This manual is divided into four main sections:</p>
			<ul>
				<li>
					<reference id="JOOQ"/>
					<p>
						See these chapters for an overview of the jOOQ internal architecture
						and all types that are involved with jOOQ's query creation and
						execution. This is the important part for you, also, if you wish to
						extend jOOQ
					</p>
				</li>
				<li>
					<reference id="META"/>
					<p>
						See these chapters to understand how you can use jOOQ as a source code
						generator, and what type of artefacts are generated by jOOQ
					</p>
				</li>
				<li>
					<reference id="DSL"/>
					<p>
						See these chapters to learn about how to use jOOQ in every day's work. The
						jOOQ DSL is the main way to create and execute jOOQ queries almost as
						if SQL was embedded in Java directly
					</p>
				</li>
				<li>
					<reference id="ADVANCED"/>
					<p>
						Some advanced topics including not-everyday functionality
					</p>
				</li>
			</ul>
		</content>


		<sections>
			<section id="JOOQ">
				<title>jOOQ classes and their usage</title>
				<content>
					<h3>Overview</h3>
					<p>jOOQ essentially has two packages:</p>
					<ul>
						<li>org.jooq: the jOOQ API. Here you will find interfaces for all
							SQL concepts
						</li>
						<li>org.jooq.impl: the jOOQ implementation and factories. Most
							implementation classes are package private, you can only access
							them using the <reference id="Factory" title="org.jooq.impl.Factory"/>
						</li>
					</ul>
					<p>
						This section is about the main jOOQ classes and the global
						architecture. Most of the time, however, you will be using the
						<reference id="DSL" />
						in order to create queries
						the way you're used to in SQL
					</p>
				</content>


				<sections>
					<section id="ExampleDatabase">
						<title>The example database</title>
						<content>
							<h3>Example CREATE TABLE statements</h3>
							<p>
							For the examples in this manual, the same database will always be
							referred to. It essentially consists of these entities created using
							the Oracle dialect
							</p>
<sql>CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)</sql>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc),
								stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>


					<section id="Factory">
						<title>The Factory class</title>
						<content>
							<h3>The Factory and the jOOQ API</h3>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts
								from client code. The reasons for this are:
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/>
								class is the main class from where you will create all jOOQ objects.
								The Factory implements <reference class="org.jooq.Configuration"/>
								and needs to be instanciated with the Configuration's properties:
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> :
								The dialect of your database. This may be any of the currently
								supported database types</li>
								<li><reference class="java.sql.Connection"/> :
								An optional JDBC Connection that will be re-used for the whole
    							lifecycle of your Factory</li>
    							<li><reference class="org.jooq.conf.Settings"/> :
    							An optional runtime configuration.</li>
							</ul>
							<p>If you are planning on using several RDBMS (= SQLDialects) or
								several distinct JDBC Connections in your software, this will mean
								that you have to create a new Factory every time. </p>

							<h3>Factory settings</h3>
							<p>
								The jOOQ Factory allows for some optional configuration elements to be used by advanced users.
								The <reference class="org.jooq.conf.Settings" title="Settings"/> class is a JAXB-annotated
								type, that can be provided to a Factory in several ways:
							</p>
							<ul>
								<li>In the constructor. This will override default settings below</li>
								<li>From a location specified by a JVM parameter: -Dorg.jooq.settings</li>
								<li>From the classpath at /jooq-settings.xml</li>
								<li>From the settings defaults, as specified in
								    <a href="http://www.jooq.org/xsd/jooq-runtime-2.1.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.1.0.xsd</a>
								</li>
							</ul>
							<p>
								Subsequent sections of the manual contain some more in-depth explanations about these settings:
							</p>
							<ul>
								<li>
     								<reference id="SchemaMapping" title="Runtime schema and table mapping"/>
   								</li>
     							<li>
     								<reference id="ExecuteListener" title="Execute listeners and SQL tracing"/>
     							</li>
   							</ul>
							<p>
								Please refer to the jOOQ runtime configuration XSD for more details:<br/>
								<a href="http://www.jooq.org/xsd/jooq-runtime-2.1.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.1.0.xsd</a>
							</p>

							<h3>Factory subclasses</h3>
							<p>
								There are a couple of subclasses for the general Factory. Each SQL
								dialect has its own dialect-specific factory. For instance, if you're
								only using the MySQL dialect, you can choose to create a new Factory
								using any of the following types:
							</p>
<java>// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</java>
							<p>
								The advantage of using a dialect-specific Factory lies in the fact,
								that you have access to more proprietary RDMBS functionality. This may
								include:
							</p>
							<ul>
								<li>Oracle's <reference id="CONNECTBY" title="CONNECT BY"/>
								    pseudo columns and functions</li>
    							<li>MySQL's encryption functions</li>
    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
							</ul>
							<p>
								Another type of Factory subclasses are each generated schema's
								factories. If you generate your schema TEST, then you will have access
								to a TestFactory. This will be useful in the future, when access to
								schema artefacts will be unified. Currently, this has no use.
							</p>

							<h3>Static Factory methods</h3>
							<p>
								With jOOQ 2.0, static factory methods have been introduced in order to
								make your code look more like SQL. Ideally, when working with jOOQ, you
								will simply static import all methods from the Factory class:
							</p>
							<java>import static org.jooq.impl.Factory.*;</java>
							<p>
								This will allow to access functions even more fluently:
							</p>

<java>concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</java>
							<p>
								Objects created statically from the Factory do not need a reference to
								any factory, as they can be constructed independently from your Configuration
								(connection, dialect, schema mapping). They will access that information at
								render / bind time. See
								<reference id="QueryPart" title="more details on the QueryParts' internals"/>
							</p>

							<h3>Potential problems</h3>
							<p>
								The jOOQ Factory expects its underlying
								<reference class="java.sql.Connection" />
								to be <strong>open and ready</strong>
								for
								<reference class="java.sql.PreparedStatement" />
								creation. You are responsible yourself for the
								lifecycle dependency between Factory and Connection. This means:
							</p>
							<ul>
								<li>jOOQ will never close the Connection.</li>
								<li>jOOQ will never commit or rollback on the Connection
									(Except for CSV-imports, if explicitly configured in the <reference id="Import" title="Import API"/>)</li>
								<li>jOOQ will never start any transactions.</li>
								<li>
									jOOQ does not know the concept of a session as for instance
									<a href="http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/architecture.html#architecture-current-session">Hibernate</a>
								</li>
								<li>jOOQ does not know the concept of a second-level cache. SQL is
									executed directly on the underlying RDBMS.</li>
								<li>jOOQ does not make assumptions about the origin of the Connection.
									If it is container managed, that is fine.</li>
							</ul>
							<p>
								So if you want your queries to run in separate transactions, if you
								want to roll back a transaction, if you want to close a Connection and
								return it to your container, you will have to take care of that
								yourself. jOOQ's Factory will always expect its Connection to be in a
								ready state for creating new PreparedStatements. If it is not, you have
								to create a new Factory.
							</p>
							<p>
								Please keep in mind that many jOOQ objects will reference your Factory
								for their whole lifecycle. This is especially interesting, when dealing
								with <reference id="UpdatableRecord" title="Updatable Records"/>,
								that can perform CRUD operations on the
								Factory's underlying Connection.
							</p>
						</content>
					</section>


					<section id="Table">
						<title>Tables and Fields</title>
						<content>
							<h3>The Table</h3>
							<p>Tables represent any entity in your underlying RDBMS, that holds
							  data for selection, insertion, updates, and deletion. In other
							  words, views are also considered tables by jOOQ. </p>
							<p>The formal definition of a <reference class="org.jooq.Table"/> starts with </p>
							<java>public interface Table&lt;R extends Record&gt; // [...]</java>
							<p>
								This means that every table is associated with a subtype of the
								<reference class="org.jooq.Record" />
								class (see also
								<reference id="Result" title="Results and Records" />
								). For anonymous or ad-hoc tables,
								&lt;R&gt; will always bind to Record itself.
							</p>
							<p>
								Unlike in the
								<a href="http://download.oracle.com/javaee/6/tutorial/doc/gjitv.html"
									title="Tutorial about JPA CriteriaQuery">JPA CriteriaQuery API</a>,
								this generic type
								&lt;R&gt;
								is not given so much importance as far as
								type-safety is concerned.
								SQL itself is highly typesafe. You have
								incredible flexibility of creating anonymous or ad-hoc
								types and
								reusing them from
								<reference id="NESTED" title="NESTED SELECT statements" />
								or from many other
								use-cases. There is no way that this typesafety can be
								mapped to the Java world in a convenient way. If
								&lt;R&gt; would play a role as important
								as in JPA, jOOQ would suffer from the same verbosity, or inflexibility
								that JPA CriteriaQueries may have.
							</p>

							<h3>The Field</h3>
							<p>The formal definition of a Field starts with </p>
							<java>public interface Field&lt;T&gt; // [...]</java>
							<p>
								Fields are generically parameterised with a Java type
								&lt;T&gt;
								that reflects the closest match to the RDMBS's underlying datatype for that
								field. For instance, if you have a VARCHAR2 type Field in Oracle,
								&lt;T&gt;
								would bind to
								<reference class="java.lang.String" />
								for that Field in jOOQ. Oracle's NUMBER(7) would
								let
								&lt;T&gt;
								bind to
								<reference class="java.lang.Integer" />,
								etc. This generic type is useful for two purposes:
							</p>
							<ul>
								<li>It allows you to write type safe queries. For instance, you cannot
									compare Field
									&lt;String&gt;
									with Field
									&lt;Integer&gt;</li>

								<li>It
									allows you to fetch correctly cast and converted values from
									your database result set. This is especially useful when &lt;T&gt; binds
									to
									advanced data types, such as
									<reference id="UDT" title="UDT's, ARRAY or ENUM types" />
									, where jOOQ
									does the difficult non-standardised JDBC data type conversions for you.
								</li>
							</ul>

							<h3>Fields and tables put into action</h3>
							<p>The Field itself is a very broad concept. Other tools, or databases
								refer to it as expression or column. When you just want to </p>

							<sql>SELECT 1 FROM DUAL</sql>
							<p>
								Then 1 is considered a Field or more explicitly, a
								<reference class="org.jooq.impl.Constant" />,
								which implements Field, and DUAL is considered a Table or more explicitly
								<reference class="org.jooq.impl.Dual"/>, which implements Table
							</p>
							<p>
								More advanced uses become clear quickly, when you do things like
							</p>
							<sql>SELECT 1 + 1 FROM DUAL</sql>
							<p>
								Where 1 + 1 itself is a Field or more explicitly, an
								<reference class="org.jooq.impl.Expression"/>
								joining two Constants together.
							</p>
							<p>
								See some details about how to create these queries in the
								<reference id="Query" title="Query section"/> of the manual
							</p>

							<h3>TableFields</h3>
							<p>
								A specific type of field is the
								<reference class="org.jooq.TableField" />,
								which represents a physical
								Field in a physical Table. Both the
								TableField and its referenced Table
								know each other. The physical aspect
								of their nature is represented in
								jOOQ by
								<reference id="TABLE" title="meta model code generation" />,
								where every entity in your database
								schema will be generated into a
								corresponding Java class.
							</p>
							<p>
								TableFields join both &lt;R&gt; and &lt;T&gt; generic parameters into their specification:
							</p>
							<java>public interface TableField&lt;R extends Record, T&gt; // [...]</java>
							<p>
								This can be used for additional type safety in the future, or by client code.
							</p>
						</content>
					</section>


					<section id="Result">
						<title>Results, Cursors and Records</title>
						<content>
							<h3>The Result</h3>
							<p>
								The
								<reference class="org.jooq.Result" title="Result" />&lt;R extends <reference class="org.jooq.Record" title="Record" />&gt;
								is essentially a wrapper for a List&lt;R extends Record&gt;
								providing
								many convenience methods for accessing single elements in
								the result
								set. Depending on the type of SELECT statement,
								&lt;R&gt; can be bound
								to a sub-type of Record, for instance to an
								<reference class="org.jooq.UpdatableRecord" />.
								See the section on
								<reference id="UpdatableRecord" title="Updatable Records" />
								for further details.
							</p>

							<h3>The Cursor</h3>
							<p>
								A similar object is the
								<reference class="org.jooq.Cursor" title="Cursor"/>&lt;R extends Record&gt;.
								Unlike the Result, the cursor has not fetched all data from the database yet.
								This means, you save memory (and potentially speed), but you can only access
								data sequentially and you have to keep a JDBC ResultSet alive. Cursors behave
								very much like the <reference class="java.util.Iterator"/>,
								by providing a very simple API. Some sample methods are:
							</p>
<java>// Check whether there are any more records to be fetched
boolean hasNext() throws SQLException;

// Fetch the next record from the underlying JDBC ResultSet
R fetchOne() throws SQLException;

// Close the underlying JDBC ResultSet. Don't forget to call this, before disposing the Cursor.
void close() throws SQLException;</java>

							<h3>The Record</h3>
							<p>
								The Record itself holds all the data from your selected tuple. If it is
								a <reference class="org.jooq.TableRecord"/>, then it corresponds exactly to the type of one of your
								physical tables in your database. But any anonymous or ad-hoc tuple can
								be represented by the plain Record. A record mainly provides access to
								its data and adds convenience methods for data type conversion. These
								are the main access ways:
							</p>
<java>// If you can keep a reference of the selected field, then you can get the corresponding value type-safely
&lt;T&gt; T getValue(Field&lt;T&gt; field);

// If you know the name of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(String fieldName);

// If you know the index of the selected field within the tuple,
// then you can get its value without any type information
Object getValue(int index);</java>
							<p>
								In some cases, you will not be able to reference the selected Fields
								both when you create the SELECT statement and when you fetch data from
								Records. Then you might use field names or indexes, as with JDBC.
								However, of course, the type information will then be lost as well. If
								you know what type you want to get, you can always use the Record's
								convenience methods for type conversion, however. Some examples:
							</p>
<java>// These methods will try to convert a value to a BigDecimal.
// This will work for all numeric types and for CHAR/VARCHAR types, if they contain numeric values:
BigDecimal getValueAsBigDecimal(String fieldName);
BigDecimal getValueAsBigDecimal(int fieldIndex);

// This method can perform arbitrary conversions
&lt;T&gt; T getValue(String fieldName, Class&lt;? extends T&gt; type);
&lt;T&gt; T getValue(int fieldIndex, Class&lt;? extends T&gt; type);</java>

							<p>
								For more information about the type conversions that are supported by
								jOOQ, read the Javadoc on
								<reference class="org.jooq.tools.Convert"/>
							</p>
						</content>
					</section>


					<section id="UpdatableRecord">
						<title>CRUD and Updatable Records</title>
						<content>
							<h3>CRUD Operations with UpdatableRecords</h3>
							<p>
								UpdatableRecords are a specific subtype of TableRecord that have
								primary key information associated with them.
							</p>
							<p>As of jOOQ 1.5, the UpdatableRecord essentially contains three additional
							 methods <a href="http://de.wikipedia.org/wiki/CRUD">CRUD</a>
							 (Create Read Update Delete) operations: </p>
<java>// Store any changes made to this record to the database.
// The record executes an INSERT if the PRIMARY KEY is NULL or has been changed. Otherwise, an UPDATE is performed.
int store();

// Deletes the record from the database.
int delete();

// Reflects changes made in the database to this Record
void refresh();</java>
							<p>An example lifecycle of a book can be implemented as such:</p>
<java>// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.store();

// Update it with new values
book.setPublishedIn(2010);
book.store();

// Delete it
book.delete();</java>
							<p>These operations are very simple utilities. They do not
							reflect the functionality offered by <a href="http://www.hibernate.org/">Hibernate</a>
							or other persistence managers. </p>

							<h3>Performing CRUD on non-updatable records</h3>
							<p>
								If the jOOQ code-generator cannot detect any PRIMARY KEY, or UNIQUE KEY
								on your tables, then the generated artefacts implement TableRecord,
								instead of UpdatableRecord. A TableRecord can perform the same CRUD
								operations as we have seen before, if you provide it with the necessary
								key fields. The API looks like this:
							</p>

<java>// INSERT or UPDATE the record using the provided keys
int storeUsing(TableField&lt;R, ?&gt;... keys)

// DELETE a record using the provided keys
int deleteUsing(TableField&lt;R, ?&gt;... keys);

// Reflects changes made in the database to this Record
void refreshUsing(TableField&lt;R, ?&gt;... keys);</java>

							<p>
								This is useful if your RDBMS does not support referential constraints (e.g. MySQL's
								<a href="http://en.wikipedia.org/wiki/MyISAM">MyISAM</a>), or if you want to
								store records to an unconstrained view. An example lifecycle of a book without
								any keys can then be implemented as such:
							</p>
<java>// Create a new record and insert it into the database
TBookRecord book = create.newRecord(T_BOOK);
book.setTitle("My first book");
book.storeUsing(TBook.ID);

// Update it with new values
book.setPublishedIn(2010);
book.storeUsing(TBook.ID);

// Delete it
book.deleteUsing(TBook.ID);</java>
						</content>
					</section>


					<section id="Query">
						<title>The Query and its various subtypes</title>
						<content>
							<h3>SELECT statements</h3>
							<p>
								There are essentially two ways of creating SELECT statements in jOOQ.
								For historical reasons, you can create
								<reference class="org.jooq.SimpleSelectQuery"/> or
								<reference class="org.jooq.SelectQuery"/>
								objects and add additional query clauses, such as
								<reference class="org.jooq.Condition" title="Conditions"/> or
								<reference class="org.jooq.SortField" title="SortFields"/> to it.
								Since jOOQ 1.3, there is also the possibility to
								create SELECT statements using jOOQ's
								<reference id="DSL" title="DSL API"/> in a much more intuitive
								and SQL-like way.
							</p>
							<p>Use the DSL API when: </p>
							<ul>
								<li>You want your code to look like SQL</li>
								<li>You want your IDE to help you with auto-completion (you will not be able to write select .. order by .. where .. join or any of that stuff) </li>
							</ul>
							<p>Use the regular API when: </p>
							<ul>
								<li>You want to create your query step-by-step, creating query parts one-by-one</li>
							    <li>You need to assemble your query from various places, passing the query around, adding new conditions and joins on the way </li>
							</ul>
							<p>In any case, all API's will construct the same underlying
								implementation object, and in many cases, you can combine the two
								approaches. Let's check out the various SELECT statement types: </p>

							<ul>
								<li><reference class="org.jooq.Select"/>:
								    This Query subtype stands for a general type of SELECT statement.
								    It is also the main Select type for the
								    <reference id="DSL" title="DSL API"/>. When executed, this object
								    will hold a <reference id="Result" title="Result containing the resulting Records"/>.
								    This type is further subtyped for the various uses of a SELECT statement as such:</li>
								<li><reference class="org.jooq.SimpleSelectQuery"/>:
									This Query will allow for selecting from single physical Tables only.
									It therefore has access to the Table's generic type parameter
									&lt;R extends Record&gt; and will provide a matching Result&lt;R&gt;.
									This is especially useful if &lt;R&gt; is a subtype of
									<reference id="UpdatableRecord" title="UpdatableRecord"/>.
									Then you will be able to perform updates on your result set immediately.</li>
								<li><reference class="org.jooq.SelectQuery"/>:
									This Query will allow for selecting a subset of Fields from several
									Tables. Because the results of such a query are considered of an anonymous
									or ad-hoc type, this Query will bind &lt;R&gt; to the general type Record
									itself. The purpose of this Query type is to allow for full SQL support,
									including SELECT, JOIN and GROUP BY clauses. </li>
							</ul>

							<h3>Example: SQL query and DSL query</h3>
							<code-pair>
<sql>-- Select all books by authors born after 1920, named "Paulo"
-- from a catalogue consisting of authors and books:


SELECT *
  FROM t_author
  JOIN t_book
    ON t_author.id = t_book.author_id
 WHERE t_author.year_of_birth &gt; 1920
   AND t_author.first_name = 'Paulo'
 ORDER BY t_book.title</sql>
<java>// Instanciate your factory using a JDBC connection.
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Execute the query "on a single line"
Result&lt;Record&gt; result = create.select()
    .from(T_AUTHOR)
    .join(T_BOOK)
    .on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
    .where(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920)
    .and(T_AUTHOR.FIRST_NAME.equal("Paulo")))
    .orderBy(T_BOOK.TITLE).fetch();</java>
    						</code-pair>

							<p>
								In the above example, some generated artefacts are used for querying.
								In this case, T_AUTHOR and T_BOOK are instances of types
								<reference class="org.jooq.test.oracle.generatedclasses.test.tables.TAuthor" title="TAuthor"/> and
								<reference class="org.jooq.test.oracle.generatedclasses.test.tables.TBook" title="TBook"/> respectively.
								Their full qualification would read TAuthor.T_AUTHOR and TBook.T_BOOK, but in many cases,
								it's useful to static import elements involved with queries, in order to decrease verbosity:
								<java>import static com.example.jooq.Tables.*;</java>
							</p>

							<p>
								Apart from the singleton Table instances TAuthor.T_AUTHOR and
								TBook.T_BOOK, these generated classes also contain one member
								for every physical field, such as TAuthor.ID or TBook.TAUTHOR_ID, etc.
								Depending on your configuration, those members can be static members
								(better for static imports) or instance members (better for aliasing)
							</p>

							<ul>
								<li>For more information about code generation, check out the manual's section about
									<reference id="META" title="Meta model source code generation"/>.</li>
    							<li>For more DSL examples, please consider the manual's section about the
    								<reference id="DSL" title="DSL API"/>.</li>
							</ul>

							<h3>Example: Non-DSL query</h3>
							<p>
								If you choose not to use the DSL API (for instance, because you don't
								want to add Query parts in the order SQL expects them), you can use
								this syntax:
							</p>
<java>// Re-use the factory to create a SelectQuery. This example will not make use of static imports...
SelectQuery q = create.selectQuery();
q.addFrom(T_AUTHOR);

// This example shows some "mixed" API usage, where the JOIN is added with the standard API, and the
// Condition is created using the DSL API
q.addJoin(T_BOOK, T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID));

// The AND operator between Conditions is implicit here
q.addConditions(T_AUTHOR.YEAR_OF_BIRTH.greaterThan(1920));
q.addConditions(T_AUTHOR.FIRST_NAME.equal("Paulo"));
q.addOrderBy(T_BOOK.TITLE);</java>

							<h3>Fetching data</h3>
							<p>
								The <reference class="org.jooq.Select"/> interface extends
								<reference class="org.jooq.ResultQuery"/>,
								which provides a range of methods to fetch data from the database.
								Once you have constructed your SELECT query (see examples above), you
								may choose to either simply execute() it, or use a variety of convenience
								fetchXXX() methods.
							</p>
							<p>
								See the manual's
								<reference id="ResultQuery" title="section on the ResultQuery"/>
								for more details.
							</p>


							<h3>INSERT Statements</h3>
							<p>jOOQ supports two modes for INSERT statements.
							The INSERT VALUES and the INSERT SELECT syntax</p>

							<h3>Example: SQL query and DSL query</h3>
							<code-pair>
<sql>INSERT INTO T_AUTHOR
    (ID, FIRST_NAME, LAST_NAME)
VALUES
    (100, 'Hermann', 'Hesse'),
    (101, 'Alfred', 'Döblin');</sql>
<java>create.insertInto(T_AUTHOR,
        T_AUTHOR.ID, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Döblin")
      .execute();</java></code-pair>

							<p>The DSL syntax tries to stay close to actual SQL. In detail,
								however, Java is limited in its possibilities. That's why the
								.values() clause is repeated for every record in multi-record inserts.
								Some RDBMS support
								inserting several records at the same time. This is also supported in
								jOOQ, and simulated using UNION clauses for those RDBMS that don't
								support this syntax.
								<sql>INSERT INTO .. SELECT .. UNION ALL SELECT ..</sql>
							</p>
							<p>Note: Just like in SQL itself, you can have syntax errors when you
								don't have matching numbers of fields/values. Also, you can run into
								runtime problems, if your field/value types don't match. </p>

							<h3>Example: DSL Query, alternative syntax</h3>
							<p>MySQL (and some other RDBMS) allow for using an UPDATE-like syntax
								for INSERT statements. This is also supported in jOOQ, should you
								prefer that syntax. The above INSERT statement can also be expressed
								as follows: </p>
<java>create.insertInto(T_AUTHOR)
      .set(T_AUTHOR.ID, 100)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .newRecord()
      .set(T_AUTHOR.ID, 101)
      .set(T_AUTHOR.FIRST_NAME, "Alfred")
      .set(T_AUTHOR.LAST_NAME, "Döblin")
      .execute();</java>
							<p>As you can see, this syntax is a bit more verbose, but also more
								type-safe, as every field can be matched with its value.</p>

							<h3>Example: ON DUPLICATE KEY UPDATE clause</h3>
							<p>The MySQL database supports a very convenient way to INSERT or
								UPDATE a record. This is a non-standard extension to the SQL syntax,
								which is supported by jOOQ and simulated in other RDBMS, where this is
								possible. Here is an example how to use the ON DUPLICATE KEY UPDATE
								clause: </p>
<java>// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(T_AUTHOR, T_AUTHOR.ID, T_AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(T_AUTHOR.LAST_NAME, "Koontz")
      .execute();</java>

							<h3>Example: ON DUPLICATE KEY IGNORE clause</h3>
							<p>The MySQL database also supports an INSERT IGNORE INTO clause.
							    This is supported by jOOQ using the more convenient SQL
							    syntax variant of ON DUPLICATE KEY IGNORE, which can be equally
							    simulated in other databases using a MERGE statement: </p>
<java>// Add a new author called "Koontz" with ID 3.
// If that ID is already present, ignore the INSERT statement
create.insertInto(T_AUTHOR, T_AUTHOR.ID, T_AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyIgnore()
      .execute();</java>

      						<h3>Example: INSERT .. RETURNING clause</h3>
							<p>The Postgres database has native support for an INSERT .. RETURNING
								clause. This is a very powerful concept that is simulated for all
								other dialects using JDBC's
								<reference class="java.sql.Statement" anchor="#getGeneratedKeys()" title="getGeneratedKeys()"/>
								method. Take this example:</p>

<java>// Add another author, with a generated ID
Record&lt;?&gt; record =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(T_AUTHOR.ID)
      .fetchOne();

System.out.println(record.getValue(T_AUTHOR.ID));

// For some RDBMS, this also works when inserting several values
// The following should return a 2x2 table
Result&lt;?&gt; result =
create.insertInto(T_AUTHOR, T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(T_AUTHOR.ID, T_AUTHOR.CREATION_DATE)
      .fetch();</java>

      						<p>
      							Be aware though, that this can lead to race-conditions
      							in those databases that cannot properly return generated
      							ID values.
      						</p>

      						<h3>Example: Non-DSL Query</h3>
      						<p>You can always use the more verbose regular syntax of the InsertQuery, if you need more control: </p>
<java>// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, 100);
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");

i.newRecord();
i.addValue(T_AUTHOR.ID, 101);
i.addValue(T_AUTHOR.FIRST_NAME, "Alfred");
i.addValue(T_AUTHOR.LAST_NAME, "Döblin");
i.execute();</java>

							<h3>Example: INSERT Query combined with SELECT statements</h3>
							<p>The InsertQuery.addValue() method is overloaded, such that you can
								also provide a Field, potentially containing an expression: </p>
<java>// Insert a new author into the T_AUTHOR table
InsertQuery&lt;TAuthorRecord&gt; i = create.insertQuery(T_AUTHOR);
i.addValue(T_AUTHOR.ID, create.select(max(T_AUTHOR.ID).add(1)).from(T_AUTHOR).asField())
i.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
i.addValue(T_AUTHOR.LAST_NAME, "Hesse");
i.execute();</java>
							<p>Note that especially MySQL (and some other RDBMS) has some
								limitations regarding that syntax. You may not be able to
								select from the same table you're inserting into</p>

							<h3>Example: INSERT SELECT syntax support</h3>
							<p>In some occasions, you may prefer the INSERT SELECT syntax, for instance, when
								you copy records from one table to another: </p>
<java>Insert i = create.insertInto(T_AUTHOR_ARCHIVE)
                 .select(create.selectFrom(T_AUTHOR).where(T_AUTHOR.DECEASED.isTrue()));
i.execute();</java>


							<h3>UPDATE Statements</h3>
							<p>UPDATE statements are only possible on single tables. Support for
							multi-table updates will be implemented in the near future. </p>

							<h3>Example: SQL query and DSL query</h3>
							<code-pair>
<sql>UPDATE T_AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;
 </sql>
<java>create.update(T_AUTHOR)
      .set(T_AUTHOR.FIRST_NAME, "Hermann")
      .set(T_AUTHOR.LAST_NAME, "Hesse")
      .where(T_AUTHOR.ID.equal(3))
      .execute();</java></code-pair>

							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.UpdateQuery"/> class,
							this is how you could express an UPDATE statement:</p>
<java>UpdateQuery&lt;TAuthorRecord&gt; u = create.updateQuery(T_AUTHOR);
u.addValue(T_AUTHOR.FIRST_NAME, "Hermann");
u.addValue(T_AUTHOR.FIRST_NAME, "Hesse");
u.addConditions(T_AUTHOR.ID.equal(3));
u.execute();</java>


							<h3>DELETE Statements</h3>
							<p>DELETE statements are only possible on single tables. Support for
							multi-table deletes will be implemented in the near future. </p>

							<h3>Example: SQL query and DSL query</h3>
							<code-pair>
<sql>DELETE T_AUTHOR
 WHERE ID = 100;
 </sql>
<java>create.delete(T_AUTHOR)
      .where(T_AUTHOR.ID.equal(100))
      .execute();</java></code-pair>

							<h3>Example: Non-DSL Query</h3>
							<p>Using the <reference class="org.jooq.DeleteQuery"/> class,
							this is how you could express a DELETE statement: </p>
<java>DeleteQuery&lt;TAuthorRecord&gt; d = create.deleteQuery(T_AUTHOR);
d.addConditions(T_AUTHOR.ID.equal(100));
d.execute();</java>


							<h3>MERGE Statement</h3>
							<p>
								The MERGE statement is one of the most advanced standardised SQL
								constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and
								Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE
								construct. H2's MERGE variant is currently not supported.)
							</p>
							<p>
								The point of the standard MERGE statement is to take a TARGET table, and
								merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle,
								SQL Server and Sybase also allow for DELETING some data and for adding
								many additional clauses. With jOOQ 2.0.1, only Oracle's MERGE extensions are supported.
								Here is an example:
							</p>

							<code-pair>
<sql>-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO T_AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME)
                      VALUES ('Hitchcock')</sql>
<java>create.mergeInto(T_AUTHOR)
      .using(create().selectOne())
      .on(T_AUTHOR.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(T_AUTHOR.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(T_AUTHOR.LAST_NAME)
      .values("Hitchcock")
      .execute();

</java></code-pair>


							<h3>TRUNCATE Statement</h3>
							<p>
								The syntax is trivial:
							</p>

							<code-pair>
								<sql>TRUNCATE TABLE T_AUTHOR;</sql>
								<java>create.truncate(T_AUTHOR).execute();</java>
							</code-pair>
							<p>This is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM
								T_AUTHOR statement instead. </p>
						</content>
					</section>



					<section id="ResultQuery">
						<title>ResultQuery and fetch() methods</title>
						<content>
							<h3>The ResultQuery and its convenience methods</h3>
							<p>
							    Data fetching is one of the great hassles in JDBC and JPA.
							    With jOOQ, you will be able to specify exactly, what kind of
							    data you want to fetch from any given query, as well as how
							    you want to fetch that data. This doesn't just mean distinguishing
							    between fetching one record at a time, or the whole resultset,
							    between fetching one column at a time, or the whole resultset.
							    This also means transforming your result (a list) into a map,
							    into arrays, into custom types, into JPA-annotated types, into
							    a call-back, or simply fetching it asynchronously
							</p>
							<p>These methods allow for fetching a jOOQ Result or parts of it.</p>

<java><![CDATA[// Fetch the whole result
Result<R> fetch();

// Fetch a single field from the result
<T> List<T> fetch(Field<T> field);
    List<?> fetch(int fieldIndex);
<T> List<T> fetch(int fieldIndex, Class<? extends T> type);
    List<?> fetch(String fieldName);
<T> List<T> fetch(String fieldName, Class<? extends T> type);

// Fetch the first Record
R fetchAny();

// Fetch exactly one Record
R fetchOne();

// Fetch a single field of exactly one Record
<T> T  fetchOne(Field<T> field);
Object fetchOne(int fieldIndex);
<T> T  fetchOne(int fieldIndex, Class<? extends T> type);
Object fetchOne(String fieldName);
<T> T  fetchOne(String fieldName, Class<? extends T> type);]]></java>

							<p>These methods transform the result into another form, if org.jooq.Result is not optimal</p>

<java><![CDATA[// Fetch the resulting records as Maps
List<Map<String, Object>> fetchMaps();
     Map<String, Object>  fetchOneMap();

// Fetch the result as a Map
<K>    Map<K, R> fetchMap(Field<K> key);
<K, V> Map<K, V> fetchMap(Field<K> key, Field<V> value);

// Fetch the resulting records as arrays
Object[][] fetchArrays();
Object[]   fetchOneArray();

// Fetch a single field as an array
<T>  T[] fetchArray(Field<T> field);
Object[] fetchArray(int fieldIndex);
<T>  T[] fetchArray(int fieldIndex, Class<? extends T> type);
Object[] fetchArray(String fieldName);
<T>  T[] fetchArray(String fieldName, Class<? extends T> type);]]></java>

							<p>These methods transform the result into a user-defined form, if org.jooq.Result is not optimal</p>

<java><![CDATA[// Fetch the resulting records into a custom POJO
// type, which may or may not be JPA-annotated
// Use the generator's <pojos>true</pojos> and <jpaAnnotation>true</jpaAnnotation>
// configurations to generate such POJOs with jOOQ
<E> List<E> fetchInto(Class<? extends E> type);

// Fetch the resulting records into a custom
// record handler, similar to how Spring JdbcTemplate's
// RowMapper or the Ollin Framework works.
<H extends RecordHandler<R>> H fetchInto(H handler);

// These change the behaviour of fetching itself,
// especially, when not all data should be
// fetched at once
// ----------------------------------------------

// Fetch a Cursor for lazy iteration
Cursor<R> fetchLazy();

// Or a JDBC ResultSet, if you prefer that
ResultSet fetchResultSet();

// Fetch data asynchronously and let client code
// decide, when the data must be available.
// This makes use of the java.util.concurrent API,
// Similar to how Avajé Ebean works.
FutureResult<R> fetchLater();
FutureResult<R> fetchLater(ExecutorService executor);]]></java>
						</content>
					</section>


					<section id="BindValues">
						<title>Bind values and parameters</title>
						<content>
							<h3>Bind values</h3>
							<p>
								Bind values are used in SQL / JDBC for various reasons. Among the most
								obvious ones are:
							</p>
							<ul>
								<li>
									Protection against SQL injection. Instead of inlining values
									possibly originating from user input, you bind those values to
									your prepared statement and let the JDBC driver / database take
									care of handling security aspects.
								</li>
								<li>
									Increased speed. Advanced databases such as Oracle can keep
									execution plans of similar queries in a dedicated cache to prevent
									hard-parsing your query again and again. In many cases, the actual
									value of a bind variable does not influence the execution plan, hence
									it can be reused. Preparing a statement will thus be faster
								</li>
								<li>
									On a JDBC level, you can also reuse the SQL string and prepared statement
									object instead of constructing it again, as you can bind new values to
									the prepared statement. This is currently not supported by jOOQ, though
								</li>
							</ul>

							<h3>Ways to introduce bind values with jOOQ</h3>
							<p>
								Bind values are omni-present in jOOQ. Whenever you create a condition,
								you're actually also adding a bind value:
							</p>
<java>// In jOOQ, "Poe" will be the bind value bound to the condition
LAST_NAME.equal("Poe");</java>


							<p>
								The above notation is actually convenient way to explicitly create
								a bind value for "Poe". You could also write this, instead:
							</p>
<java>// The Factory allows for explicitly creating bind values
LAST_NAME.equal(Factory.val("Poe"));

// Or, when static importing Factory.val:
LAST_NAME.equal(val("Poe"))</java>

							<p>
								Once created, bind values are part of the query's syntax tree (see
								<reference id="QueryPart" title="the manual's section about jOOQ's architecture"/>
							    for more information about jOOQ's internals),
								and cannot be modified directly anymore. If you wish to reuse a query and
								modify bind values between subsequent query executions, you can access them again
								through the <reference class="org.jooq.Query"/> interface:
							</p>

<java><![CDATA[// Access the first bind value from a query. Indexes are counted from 1, just as with JDBC
Query query = create.select().from(T_AUTHOR).where(LAST_NAME.equal("Poe"));
Param<?> param = query.getParam("1");

// You could now modify the Query's underlying bind value:
if ("Poe".equal(param.getValue())) {
    param.setConverted("Orwell");
}]]></java>

							<p>
								The <reference class="org.jooq.Param"/> type can also be named explicitly
								using the Factory's param() methods:
							</p>
<java><![CDATA[// Create a query with a named parameter. You can then use that name for accessing the parameter again
Query query1 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
Param<?> param1 = query.getParam("lastName");

// Or, keep a reference to the typed parameter in order not to lose the <T> type information:
Param<String> param2 = param("lastName", "Poe");
Query query2 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param2));

// You can now change the bind value directly on the Param reference:
param2.setValue("Orwell");
]]></java>

							<p>
								The <reference class="org.jooq.Query"/> interface also allows for
								setting new bind values directly, without accessing the Param type:
							</p>

<java>Query query1 = create.select().from(T_AUTHOR).where(LAST_NAME.equal("Poe"));
query1.bind(1, "Orwell");

// Or, with named parameters
Query query2 = create.select().from(T_AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
query2.bind("lastName", "Orwell");</java>

							<p>
								NOTE: Should you wish to use jOOQ only as a query builder and execute
								queries with another tool, such as Spring Data instead, you can also
								use the Factory's renderNamedParams() method, to actually render named
								parameter names in generated SQL:
							</p>

							<code-pair>
<java>create.renderNamedParams(
    create.select()
          .from(T_AUTHOR)
          .where(LAST_NAME.equal(
                 param("lastName", "Poe"))));</java>
<sql>-- The named bind variable can be rendered

SELECT *
FROM T_AUTHOR
WHERE LAST_NAME = :lastName
</sql>
							</code-pair>

							<h3>Inlining bind values</h3>

							<p>
								Sometimes, you may wish to avoid rendering bind
								variables while still using custom values in SQL.
								jOOQ refers to that as "inlined" bind values.
								When bind values are inlined, they render the
								actual value in SQL rather than a JDBC question mark.
								Bind value inlining can be achieved in two ways:
							</p>

							<ol>
								<li>
									By using the settings and setting the
									<reference class="org.jooq.conf.StatementType"/>
									to STATIC_STATEMENT. This will inline all
									bind values for SQL statements rendered from
									such a Factory.
								</li>
								<li>
									By using Factory.inline() methods.
								</li>
							</ol>

							<p>
								In both cases, your inlined bind values will be
								properly escaped to avoid SQL syntax errors and
								SQL injection.
								Some examples:
							</p>

<java><![CDATA[
// Use dedicated calls to inline() in order to specify
// single bind values to be rendered as inline values
// --------------------------------------------------
create.select()
      .from(T_AUTHOR)
      .where(LAST_NAME.equal(inline("Poe")));

// Or render the whole query with inlined values
// --------------------------------------------------
Settings settings = new Settings()
    .withStatementType(StatementType.STATIC_STATEMENT);

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries that omit rendering schema names
create.select()
      .from(T_AUTHOR)
      .where(LAST_NAME.equal("Poe"));]]></java>
						</content>
					</section>


					<section id="QueryPart">
						<title>QueryParts and the global architecture</title>
						<content>
							<h3>Everything is a QueryPart</h3>
							<p>
								A
								<reference class="org.jooq.Query" />
								and all its contained objects is a
								<reference class="org.jooq.QueryPart" />.
								QueryParts essentially provide this functionality:
							</p>
							<ul>
								<li>they can render SQL using the toSQL(RenderContext) method</li>
								<li>they can bind variables using the bind(BindContext) method</li>
							</ul>

							<p>Both of these methods are contained in jOOQ's internal API's
							   <reference class="org.jooq.QueryPartInternal"/>, which is
							   internally implemented by every QueryPart. QueryPart internals are best
							   illustrated with an example.</p>

						   <h3>Example: CompareCondition</h3>
						   <p>A simple example can be provided by checking out jOOQ's internal
								representation of a
								<reference class="org.jooq.impl.CompareCondition"/>.
								It is used for any condition
								comparing two fields as for example the T_AUTHOR.ID = T_BOOK.AUTHOR_ID
								condition here: </p>
<sql>-- [...]
FROM T_AUTHOR
JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
-- [...]</sql>

							<p>This is how jOOQ implements such a condition: </p>

<java><![CDATA[@Override
public final void bind(BindContext context) throws SQLException {
    // The CompareCondition itself does not bind any variables.
    // But the two fields involved in the condition might do so...
    context.bind(field1).bind(field2);
}

@Override
public final void toSQL(RenderContext context) {
    // The CompareCondition delegates rendering of the Fields to the Fields
    // themselves and connects them using the Condition's comparator operator:
    context.sql(field1)
           .sql(" ");

    // If the second field is null, some convenience behaviour can be
    // implemented here
    if (field2.isNullLiteral()) {
        switch (comparator) {
            case EQUALS:
                context.sql("is null");
                break;

            case NOT_EQUALS:
                context.sql("is not null");
                break;

            default:
                throw new IllegalStateException("Cannot compare null with " + comparator);
        }
    }

    // By default, also delegate the right hand side's SQL rendering to the
    // underlying field
    else {
        context.sql(comparator.toSQL())
               .sql(" ")
               .sql(field2);
    }
}
]]></java>
							<p>For more complex examples, please refer to the codebase, directly</p>
						</content>
					</section>


					<section id="Serializability">
						<title>Serializability of jOOQ objects</title>
						<content>
							<h3>Attaching QueryParts</h3>
							<p>
								The only transient element in any jOOQ object is the
								<reference id="Factory"/>'s
								underlying
								<reference class="java.sql.Connection"/>. When you want to execute queries after
								de-serialisation, or when you want to store/refresh/delete
								<reference id="UpdatableRecord" title="Updatable Records"/>,
								you will have to "import" or "re-attach" them to a Factory
							</p>
<java>// Deserialise a SELECT statement
ObjectInputStream in = new ObjectInputStream(...);
Select&lt;?&gt; select = (Select&lt;?&gt;) in.readObject();

// This will throw a DetachedException:
select.execute();

// In order to execute the above select, attach it first
Factory create = new Factory(connection, SQLDialect.ORACLE);
create.attach(select);</java>


							<h3>Automatically attaching QueryParts</h3>
							<p>
								Note, this functionality is deprecated with jOOQ 2.1.0.
								Please use the <reference id="ExecuteListener" title="ExecuteListener"/> API
								instead, to provide jOOQ queries with a
								<reference class="java.sql.Connection"/> before
								execution.
							</p>
							<p>In simple cases, you can register a ConfigurationProvider in jOOQ's ConfigurationRegistry</p>
<java>// Create your own custom ConfigurationProvider that will make
// your default Factory available to jOOQ
ConfigurationProvider provider = new CustomConfigurationProvider();

// Statically register the provider to jOOQ's ConfigurationRegistry
ConfigurationRegistry.setProvider(provider);</java>

							<p>Once you have executed these steps, all subsequent deserialisations
								will try to access a Configuration (containing a JDBC Connection) from
								your ConfigurationProvider. This may be useful when </p>
							<ul>
								<li>transporting jOOQ QueryParts or Records via TCP/IP, RMI, etc (e.g.
									between client and server), before immediately executing queries,
									storing UpdatableRecords</li>
								<li>
									Using automatic mechanisms as known in
									<a href="http://wicket.apache.org/">Wicket</a>
								</li>
							</ul>
						</content>
					</section>


					<section id="Extend">
						<title>Extend jOOQ with custom types</title>
						<content>
							<h3>Write your own QueryPart implementations</h3>
							<p>If a SQL clause is too complex to express with jOOQ, you can extend
								either one of the following types for use directly in a jOOQ query:</p>
<java>public abstract class CustomField&lt;T&gt; extends AbstractField&lt;T&gt; {
  // [...]
}
public abstract class CustomCondition extends AbstractCondition {
  // [...]
}</java>

							<p>These two classes are declared public and covered by integration
								tests. When you extend these classes, you will have to provide your
								own implementations for the <reference id="QueryPart" title="QueryParts"/>'
								bind(<reference class="org.jooq.BindContext" title="BindContext"/>) and
								toSQL(<reference class="org.jooq.RenderContext" title="RenderContext"/>) methods:</p>
<java>// This method must produce valid SQL. If your QueryPart contains other QueryParts, you may delegate SQL code generation to them
// in the correct order, passing the render context.
//
// If context.inline() is true, you must inline all bind variables
// If context.inline() is false, you must generate ? for your bind variables
public void toSQL(RenderContext context);

// This method must bind all bind variables to a PreparedStatement. If your QueryPart contains other QueryParts, you may delegate
// variable binding to them in the correct order, passing the bind context.
//
// Every QueryPart must ensure, that it starts binding its variables at context.nextIndex().
public void bind(BindContext context) throws DataAccessException;</java>

							<p>The above contract may be a bit tricky to understand at first. The
								best thing is to check out jOOQ source code and have a look at a
								couple of QueryParts, to see how it's done.</p>
							<h3>Plain SQL as an alternative</h3>
							<p>If you don't need integration of rather complex QueryParts into
								jOOQ, then you might be safer using simple
								<reference id="SQL" title="Plain SQL"/> functionality,
								where you can provide jOOQ with a simple String representation of your
								embedded SQL. </p>
						</content>
					</section>
				</sections>
			</section>




			<section id="META">
				<title>Meta model code generation</title>
				<content>
					<h3>Overview</h3>
					<p>
						In the previous chapter, we have seen how to use the
						<reference id="Factory" title="Factory"/> in order to create
						<reference id="Query" title="Queries"/> and fetch data in
						<reference id="Result" title="Results"/>. The strength of jOOQ not
						only lies in its object-oriented
						<reference id="QueryPart" title="Query model"/>,
						but also in the fact
						that Java source code is generated from your database schema into the
						META data model. jOOQ follows the paradigm, that your database comes
						first (see also <a href="&lt;?=$root?&gt;/">home page</a>).
						This means that you should not modify
						generated source code, but only adapt entities in your database. Every
						change in your database is reflected in a corresponding change in your
						generated meta-model.
					</p>
					<p>
						Artefacts, such as tables, views, user defined types, sequences, stored
						procedures, packages have a corresponding artefact in Java.
					</p>
				</content>


				<sections>
					<section id="Configuration">
						<title>Configuration and setup of the generator</title>
						<content>
							<h3>The deliverables</h3>
							<p>
								There are three binaries available with jOOQ, to be downloaded from
								<a href="https://sourceforge.net/projects/jooq/">SourceForge</a>
								or from Maven central:
							</p>
							<ul>
								<li>
									<strong>jOOQ.jar</strong>
									<br />
									The main library that you will include in your application to run jOOQ
								</li>
								<li>
									<strong>jOOQ-meta.jar</strong>
									<br />
									The utility that you will include in your build to navigate your
									database schema for code generation. This can be used as a schema
									crawler as well.
								</li>
								<li>
									<strong>jOOQ-codegen.jar</strong>
									<br />
									The utility that you will include in your build to generate your
									database schema
								</li>
							</ul>

							<h3>Dependencies</h3>
							<p>All of jOOQ's dependencies are "optional", i.e. you can run
								jOOQ without any of those libraries.
								For instance, jOOQ maintains an "optional" dependency on log4j and slf4j.
								This means, that jOOQ tries to find log4j (and /log4j.xml) or slf4j on the
								classpath. If they are not present, then java.util.logging.Logger is
								used instead.
							</p>
							<p>
								Other optional dependencies are the JPA API, and the Oracle JDBC driver,
								which is needed for Oracle's advanced data types, only
							</p>


							<h3>Configure jOOQ's code generator</h3>
							<p>You need to tell jOOQ some things about your database connection.
								Here's an example of how to do it for an Oracle database </p>
<xml><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<configuration>
  <!-- Configure the database connection here -->
  <jdbc>
    <driver>oracle.jdbc.OracleDriver</driver>
    <url>jdbc:oracle:thin:@[your jdbc connection parameters]</url>
    <user>[your database user]</user>
    <password>[your database password]</password>
    <!-- You can also pass user/password and other JDBC properties in the optional properties tag: -->
    <properties>
      <property><key>user</key><value>[db-user]</value></property>
      <property><key>password</key><value>[db-password]</value></property>
    </properties>
  </jdbc>

  <generator>
    <database>
      <!-- The database dialect from jooq-meta. Available dialects are
           named org.util.[database].[database]Database. Known values are:

           org.jooq.util.ase.ASEDatabase
           org.jooq.util.cubrid.CUBRIDDatabase
           org.jooq.util.db2.DB2Database
           org.jooq.util.derby.DerbyDatabase
           org.jooq.util.h2.H2Database
           org.jooq.util.hsqldb.HSQLDBDatabase
           org.jooq.util.ingres.IngresDatabase
           org.jooq.util.mysql.MySQLDatabase
           org.jooq.util.oracle.OracleDatabase
           org.jooq.util.postgres.PostgresDatabase
           org.jooq.util.sqlite.SQLiteDatabaes
           org.jooq.util.sqlserver.SQLServerDatabase
           org.jooq.util.sybase.SybaseDatabase

           You can also provide your own org.jooq.util.Database implementation
           here, if your database is currently not supported -->
      <name>org.jooq.util.oracle.OracleDatabase</name>

      <!-- All elements that are generated from your schema (several Java
           regular expressions, separated by comma) Watch out for
           case-sensitivity. Depending on your database, this might be
           important! You can create case-insensitive regular expressions
           using this syntax: (?i:expr)A comma-separated list of regular
           expressions -->
      <includes>.*</includes>

      <!-- All elements that are excluded from your schema (several Java
           regular expressions, separated by comma). Excludes match before
           includes -->
      <excludes></excludes>

      <!-- The schema that is used locally as a source for meta information.
           This could be your development schema or the production schema, etc
           This cannot be combined with the schemata element.

           If left empty, jOOQ will generate all available schemata. See the
           manual's next section to learn how to generate several schemata -->
      <inputSchema>[your database schema / owner / name]</inputSchema>
    </database>

    <generate>
      <!-- See advanced configuration properties -->
    </generate>

    <target>
      <!-- The destination package of your generated classes (within the
           destination directory) -->
      <packageName>[org.jooq.your.packagename]</packageName>

      <!-- The destination directory of your generated classes -->
      <directory>[/path/to/your/dir]</directory>
    </target>
  </generator>
</configuration>]]></xml>

							<p>
								There are also lots of advanced configuration parameters, which will be
								treated in the <reference id="AdvancedConfiguration" title="manual's next section"/>
								Note, you can find the official XSD file at
							   <a href="http://www.jooq.org/xsd/jooq-codegen-2.1.0.xsd" title="The jOOQ-codegen configuration XSD">http://www.jooq.org/xsd/jooq-codegen-2.1.0.xsd</a>
							   for a formal specification</p>

							<h3>Run jOOQ code generation</h3>
							<p>Code generation works by calling this class with the above property file as argument.</p>
							<config>org.jooq.util.GenerationTool /jooq-config.xml</config>
							<p>Be sure that these elements are located on the classpath: </p>
							<ul>
								<li>The property file</li>
								<li>jooq.jar, jooq-meta.jar, jooq-codegen.jar</li>
								<li>The JDBC driver you configured</li>
							</ul>

							<h3>A command-line example (For Windows, unix/linux/etc will be similar)</h3>
							<ul>
								<li>Put the property file, jooq*.jar and the JDBC driver into
									a directory, e.g. C:\temp\jooq</li>
							    <li>Go to C:\temp\jooq</li>
							    <li>Run java -cp jooq.jar;jooq-meta.jar;jooq-codegen.jar;[JDBC-driver].jar;. org.jooq.util.GenerationTool /[property file] </li>
							</ul>
							<p>Note that the property file must be passed as a classpath resource</p>

							<h3>Run code generation from Eclipse</h3>
							<p>Of course, you can also run code generation from your IDE. In
								Eclipse, set up a project like this. Note that this example uses
								jOOQ's log4j support by adding log4j.xml and log4j.jar to the project
								classpath: </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-01.png" alt="Eclipse configuration"/>
							</div>

							<p>Once the project is set up correctly with all required artefacts on
								the classpath, you can configure an Eclipse Run Configuration for
								org.jooq.util.GenerationTool. </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-02.png" alt="Eclipse configuration"/>
							</div>

							<p>With the properties file as an argument </p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-03.png" alt="Eclipse configuration"/>
							</div>

							<p>And the classpath set up correctly</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-04.png" alt="Eclipse configuration"/>
							</div>

							<p>Finally, run the code generation and see your generated artefacts</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-05.png" alt="Eclipse configuration"/>
							</div>

							<h3>Run generation with ant</h3>
							<p>
								You can also use an ant task to generate your classes. As a rule of thumb,
								remove the dots "." and dashes "-" from the .properties file's property names to get the
								ant task's arguments:
							</p>
<xml><![CDATA[<!-- Task definition -->
<taskdef name="generate-classes" classname="org.jooq.util.GenerationTask">
  <classpath>
    <fileset dir="${path.to.jooq.distribution}">
      <include name="jOOQ.jar"/>
      <include name="jOOQ-meta.jar"/>
      <include name="jOOQ-codegen.jar"/>
    </fileset>
    <fileset dir="${path.to.mysql.driver}">
      <include name="${mysql.driver}.jar"/>
    </fileset>
  </classpath>
</taskdef>

<!-- Run the code generation task -->
<target name="generate-test-classes">
  <generate-classes
      jdbcurl="jdbc:mysql://localhost/test"
      jdbcuser="root"
      jdbcpassword=""
      generatordatabaseinputschema="test"
      generatortargetpackage="org.jooq.test.generatedclasses"
      generatortargetdirectory="${basedir}/src"/>
</target>]]></xml>

							<p>
								Note that when running code generation with ant's &lt;java/&gt; task,
								you may have to set fork="true":
							</p>

<xml><![CDATA[<!-- Run the code generation task -->
<target name="generate-test-classes">
  <java fork="true" classname="org.jooq.util.GenerationTool">
    [...]
  </java>
</target>
]]></xml>
							<h3>Integrate generation with Maven</h3>
							<p>Using the official jOOQ-codegen-maven plugin, you can integrate
								source code generation in your Maven build process: </p>

<xml><![CDATA[<plugin>

  <!-- Specify the maven code generator plugin -->
  <groupId>org.jooq</groupId>
  <artifactId>jooq-codegen-maven</artifactId>
  <version>1.6.7</version>

  <!-- The plugin should hook into the generate goal -->
  <executions>
    <execution>
      <goals>
        <goal>generate</goal>
      </goals>
    </execution>
  </executions>

  <!-- Manage the plugin's dependency. In this example, we'll use a Postgres database -->
  <dependencies>
    <dependency>
      <groupId>postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>8.4-702.jdbc4</version>
    </dependency>
  </dependencies>

  <!-- Specify the plugin configuration -->
  <configuration>

    <!-- JDBC connection parameters -->
    <jdbc>
      <driver>org.postgresql.Driver</driver>
      <url>jdbc:postgresql:postgres</url>
      <user>postgres</user>
      <password>test</password>
    </jdbc>

    <!-- Generator parameters -->
    <generator>
      <name>org.jooq.util.DefaultGenerator</name>
      <database>
        <name>org.jooq.util.postgres.PostgresDatabase</name>
        <includes>.*</includes>
        <excludes></excludes>
        <inputSchema>public</inputSchema>
      </database>
      <generate>
        <relations>true</relations>
        <deprecated>false</deprecated>
      </generate>
      <target>
        <packageName>org.jooq.util.maven.example</packageName>
        <directory>target/generated-sources/jooq</directory>
      </target>
    </generator>
  </configuration>
</plugin>
]]></xml>
							<p>See the full example of a pom.xml including the jOOQ-codegen artefact here:
							<a href="https://github.com/jOOQ/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml" title="jOOQ-codegen-maven example pom.xml file">https://github.com/jOOQ/jOOQ/blob/master/jOOQ-codegen-maven-example/pom.xml</a></p>

                            <h3>Migrate properties files from jOOQ 1.7, early versions of jOOQ 2.0.x:</h3>
                            <p>
                                Before jOOQ 2.0.4, the code generator was configured using properties files
                                These files are still supported for source code generation, but their syntax
                                won't be maintained any longer. If you wish to migrate to XML, you can
                                migrate the file using this command on the command line
                            </p>
							<config>org.jooq.util.GenerationTool /jooq-config.properties migrate</config>
							<p>
								Using the migrate flag, jOOQ will read the properties file and output
								a corresponding XML file on system out
							</p>

							<h3>Use jOOQ generated classes in your application</h3>
							<p>Be sure, both jOOQ.jar and your generated package (see
								configuration) are located on your classpath. Once this is done, you
								can execute SQL statements with your generated classes.</p>
						</content>
					</section>


					<section id="AdvancedConfiguration">
					    <title>Advanced generator configuration</title>
						<content>
							<h3>Code generation</h3>
							<p>
								In the <reference id="Configuration" title="previous section"/>
								we have seen how jOOQ's source code generator is configured and
								run within a few steps. In this chapter we'll treat some advanced
								settings
							</p>

<xml><![CDATA[<!-- These properties can be added directly to the generator element: -->
<generator>
  <!-- The default code generator. You can override this one, to generate your own code style
       Defaults to org.jooq.util.DefaultGenerator -->
  <name>org.jooq.util.DefaultGenerator</name>

  <!-- The naming strategy used for class and field names.
       You may override this with your custom naming strategy. Some examples follow
       Defaults to org.jooq.util.DefaultGeneratorStrategy -->
  <strategy>
    <name>org.jooq.util.DefaultGeneratorStrategy</name>
  </strategy>
</generator>]]></xml>

							<p>
								The following example shows how you can override the
								DefaultGeneratorStrategy to render table and column names the way
								they are defined in the database, rather than switching them to
								camel case:
							</p>

<java><![CDATA[/**
 * It is recommended that you extend the DefaultGeneratorStrategy. Most of the
 * GeneratorStrategy API is already declared final. You only need to override any
 * of the following methods, for whatever generation behaviour you'd like to achieve
 *
 * Beware that most methods also receive a "Mode" object, to tell you whether a
 * TableDefinition is being rendered as a Table, Record, POJO, etc. Depending on
 * that information, you can add a suffix only for TableRecords, not for Tables
 */
public class AsInDatabaseStrategy extends DefaultGeneratorStrategy {

    /**
     * Override this to specifiy what identifiers in Java should look like.
     * This will just take the identifier as defined in the database.
     */
    @Override
    public String getJavaIdentifier(Definition definition) {
        return definition.getOutputName();
    }

    /**
     * Override these to specify what a setter in Java should look like. Setters
     * are used in TableRecords, UDTRecords, and POJOs. This example will name
     * setters "set[NAME_IN_DATABASE]"
     */
    @Override
    public String getJavaSetterName(Definition definition, Mode mode) {
        return "set" + definition.getOutputName();
    }

    /**
     * Just like setters...
     */
    @Override
    public String getJavaGetterName(Definition definition, Mode mode) {
        return "get" + definition.getOutputName();
    }

    /**
     * Override this method to define what a Java method generated from a database
     * Definition should look like. This is used mostly for convenience methods
     * when calling stored procedures and functions. This example shows how to
     * set a prefix to a CamelCase version of your procedure
     */
    @Override
    public String getJavaMethodName(Definition definition, Mode mode) {
        return "call" + org.jooq.tools.StringUtils.toCamelCase(definition.getOutputName());
    }

    /**
     * Override this method to define how your Java classes and Java files should
     * be named. This example applies no custom setting and uses CamelCase versions
     * instead
     */
    @Override
    public String getJavaClassName(Definition definition, Mode mode) {
        return super.getJavaClassName(definition, mode);
    }

    /**
     * Override this method to re-define the package names of your generated
     * artefacts.
     */
    @Override
    public String getJavaPackageName(Definition definition, Mode mode) {
        return super.getJavaPackageName(definition, mode);
    }

    /**
     * Override this method to define how Java members should be named. This is
     * used for POJOs and method arguments
     */
    @Override
    public String getJavaMemberName(Definition definition, Mode mode) {
        return definition.getOutputName();
    }

    /**
     * Override this method to define the base class for those artefacts that
     * allow for custom base classes
     */
    @Override
    public String getJavaClassExtends(Definition definition, Mode mode) {
        return Object.class.getName();
    }

    /**
     * Override this method to define the interfaces to be implemented by those
     * artefacts that allow for custom interface implementation
     */
    @Override
    public List<String> getJavaClassImplements(Definition definition, Mode mode) {
        return Arrays.asList(Serializable.class.getName(), Cloneable.class.getName());
    }

    /**
     * Override this method to define the suffix to apply to routines when
     * they are overloaded.
     *
     * Use this to resolve compile-time conflicts in generated source code, in
     * case you make heavy use of procedure overloading
     */
    @Override
    public String getOverloadSuffix(Definition definition, Mode mode, String overloadIndex) {
        return "_OverloadIndex_" + overloadIndex;
    }
}]]></java>

                            <h3>jooq-meta configuration</h3>
							<p>
								Within the &lt;generator/&gt; element, there are other configuration elements:
							</p>

<xml><![CDATA[<!-- These properties can be added to the database element: -->
<database>
  <!-- Generate java.sql.Timestamp fields for DATE columns. This is
       particularly useful for Oracle databases.
       Defaults to false -->
  <dateAsTimestamp>false</dateAsTimestamp>

  <!-- Generate jOOU data types for your unsigned data types, which are
       not natively supported in Java.
       Defaults to true -->
  <unsignedTypes>true</unsignedTypes>

  <!-- The schema that is used in generated source code. This will be the
       production schema. Use this to override your local development
       schema name for source code generation. If not specified, this
       will be the same as the input-schema. -->
  <outputSchema>[your database schema / owner / name]</outputSchema>

  <!-- A configuration element to configure several input and/or output
       schemata for jooq-meta, in case you're using jooq-meta in a multi-
       schema environment.
       This cannot be combined with the above inputSchema / outputSchema -->
  <schemata>
    <schema>
      <inputSchema>...</inputSchema>
      <outputSchema>...</outputSchema>
    </schema>
    [ <schema>...</schema> ... ]
  </schemata>

  <!-- A configuration element to configure master data table enum classes -->
  <masterDataTables>...</masterDataTables>

  <!-- A configuration element to configure custom data types -->
  <customTypes>...</customTypes>

  <!-- A configuration element to configure type overrides for generated
       artefacts (e.g. in combination with customTypes) -->
  <forcedTypes>...</forcedTypes>
</database>]]></xml>

							<p>
								Check out the some of the manual's "advanced" sections
								to find out more about the advanced configuration parameters.
							</p>
							<ul>
								<li><reference id="SchemaMapping" title="Schema mapping"/></li>
								<li><reference id="MasterData" title="Master data types"/></li>
								<li><reference id="CustomTypes" title="Custom types"/></li>
							</ul>

							<h3>jooq-codegen configuration</h3>
                            <p>Also, you can add some optional advanced configuration parameters for the generator: </p>

<xml><![CDATA[<!-- These properties can be added to the generate element: -->
<generate>
  <!-- Primary key / foreign key relations should be generated and used.
       This is a prerequisite for various advanced features.
       Defaults to false -->
  <relations>false</relations>

  <!-- Generate navigation methods to navigate foreign key relationships
       directly from Record classes. This is only relevant if relations
       is set to true, too.
       Defaults to true -->
  <navigationMethods>true</navigationMethods>

  <!-- Generate deprecated code for backwards compatibility
       Defaults to true -->
  <deprecated>true</deprecated>

  <!-- Generate instance fields in your tables, as opposed to static
       fields. This simplifies aliasing.
       Defaults to true -->
  <instanceFields>true</instanceFields>

  <!-- Generate the javax.annotation.Generated annotation to indicate
       jOOQ version used for source code.
       Defaults to true -->
  <generatedAnnotation>true</generatedAnnotation>

  <!-- Generate jOOQ Record classes for type-safe querying. You can
       turn this off, if you don't need "active records" for CRUD
       Defaults to true -->
  <records>true</records>

  <!-- Generate POJOs in addition to Record classes for usage of the
       ResultQuery.fetchInto(Class) API
       Defaults to false -->
  <pojos>false</pojos>

  <!-- Generate interfaces that will be implemented by records and/or pojos
       Defaults to false -->
  <interfaces>false</interfaces>

  <!-- Annotate POJOs and Records with JPA annotations for increased
       compatibility and better integration with JPA/Hibernate, etc
       Defaults to false -->
  <jpaAnnotations>false</jpaAnnotations>

  <!-- Annotate POJOs and Records with JSR-303 validation annotations
       Defaults to false -->
  <validationAnnotations>false</validationAnnotations>
</generate>]]></xml>
						</content>
					</section>


					<section id="SCHEMA">
						<title>The schema, top-level generated artefact</title>
						<content>
							<h3>The Schema</h3>
							<p>
								As of jOOQ 1.5, the top-level generated object is the
								<reference class="org.jooq.Schema" />.
								The Schema itself has no relevant functionality, except for holding
								the schema name for all dependent generated artefacts. jOOQ queries try
								to always fully qualify an entity within the database using that Schema
							</p>

							<p>
								Currently, it is not possible to link generated artefacts from various
								schemata. If you have a stored function from Schema A, which returns a
								UDT from Schema B, the types cannot be linked. This enhancement is on
								the roadmap, though: <reference ticket="282"/>.
							</p>

							<p>
								When you have several schemata that are logically equivalent (i.e. they
								contain identical entities, but the schemata stand for different
								users/customers/clients, etc), there is a solution for that. Check out
								the manual's section on support for
								<reference id="SchemaMapping" title="multiple equivalent schemata"/>
							</p>

							<h3>Schema contents</h3>
							<p>The schema can be used to dynamically discover generate database
								artefacts. Tables, sequences, and other items are accessible from the
								schema. For example:</p>
<java>public final java.util.List&lt;org.jooq.Sequence&lt;?&gt;&gt; getSequences();
public final java.util.List&lt;org.jooq.Table&lt;?&gt;&gt; getTables();</java>
						</content>
					</section>


					<section id="TABLE">
						<title>Tables, views and their records</title>
						<content>
							<h3>Tables and TableRecords</h3>
							<p>
								The most important generated artefacts are
								<reference class="org.jooq.Table" title="Tables"/> and
								<reference class="org.jooq.TableRecord" title="TableRecords"/>. As
								discussed in previous chapters about
								<reference id="Table" title="Tables"/> and
								<reference id="Result" title="Results"/>, jOOQ uses the
								Table class to model entities (both tables and views) in your database
								Schema. Every Table has a Record type associated with it that models a
								single tuple of that entity: Table&lt;R extends Record&gt;. This
								couple of Table&lt;R&gt; and R are generated as such:
							</p>
							<p>
								Suppose we have the tables as defined in the
								<reference id="ExampleDatabase" title="example database"/>.
								Then, using a
								default configuration, these (simplified for the example) classes will
								be generated:
							</p>

							<h3>The Table as an entity meta model</h3>
<java>public class TAuthor extends UpdatableTableImpl&lt;TAuthorRecord&gt; {

    // The singleton instance of the Table
    public static final TAuthor T_AUTHOR = new TAuthor();

    // The Table's fields.
    // Depending on your jooq-codegen configuraiton, they can also be static
    public final TableField&lt;TAuthorRecord, Integer&gt; ID =            // [...]
    public final TableField&lt;TAuthorRecord, String&gt; FIRST_NAME =     // [...]
    public final TableField&lt;TAuthorRecord, String&gt; LAST_NAME =      // [...]
    public final TableField&lt;TAuthorRecord, Date&gt; DATE_OF_BIRTH =    // [...]
    public final TableField&lt;TAuthorRecord, Integer&gt; YEAR_OF_BIRTH = // [...]

    // When you don't choose the static meta model, you can typesafely alias your tables.
    // Aliased tables will then hold references to the above final fields, too
    public TAuthor as(String alias) {
      // [...]
    }
}</java>

							<h3>The Table's associated TableRecord</h3>
							<p>If you use the
								<reference id="Query" title="SimpleSelectQuery"/>
								 syntax (both in standard and DSL
								mode), then your SELECT statement will return the single Table&lt;R
								extends Record&gt;'s associated Record type &lt;R&gt;. In the case of
								the above TAuthor Table, this will be a TAuthorRecord. </p>

<java>public class TAuthorRecord extends UpdatableRecordImpl&lt;TAuthorRecord&gt; {

    // Getters and setters for the various fields
    public void setId(Integer value) {       // [...]
    public Integer getId() {                 // [...]
    public void setFirstName(String value) { // [...]
    public String getFirstName() {           // [...]
    public void setLastName(String value) {  // [...]
    public String getLastName() {            // [...]
    public void setDateOfBirth(Date value) { // [...]
    public Date getDateOfBirth() {           // [...]

    // Navigation methods for foreign keys
    public List&lt;TBookRecord&gt; fetchTBooks() { // [...]
}</java>


							<h3>Generated or custom POJO's instead of jOOQ's Records</h3>
							<p>
								If you're using jOOQ along with Hibernate / JPA, or if you
								want to use your own, custom domain-model instead of jOOQ's
								Record type-hierarchy, you can choose to select values into
								POJOs. Let's say you defined a POJO for authors:
							</p>

<java><![CDATA[package com.example;

import javax.persistence.Column;
import javax.persistence.Entity;

@Entity
public class MyAuthor {
    // Some fields may be public
    @Column(name = "ID")
    public int id;

    // Others are private and have associated getters / setters:
    private String firstName;
    private String lastName;

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    @Column(name = "FIRST_NAME")
    public String getFirstName() {
        return firstName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @Column(name = "LAST_NAME")
    public String getLastName() {
        return lastName;
    }
}]]></java>

                            <p>
                            	The above could be your custom POJO or a POJO generated
                            	by jooq-codegen (see
                            	<reference id="AdvancedConfiguration" title="the manual's section about advanced codegen configuration"/>
                            	for more details). Also, JPA-annotations are not necessary
                            	if you wish to let jOOQ map record columns onto your POJO
                            	attributes by convention. Instead of fetching records normally,
                            	you can now let jOOQ fetch records "into" your custom type:
                            </p>

<java><![CDATA[List<MyAuthor> results = create.select().from(TAuthor.T_AUTHOR).fetchInto(MyAuthor.class);]]></java>

							<p>
								Read the javadoc for
								<a href="http://www.jooq.org/javadoc/latest/org/jooq/Record.html#into%28java.lang.Class%29" title="Record.into() javadoc, explaining about how to map jOOQ Records onto custom types">Record.into()</a>
								for more details.
							</p>
						</content>
					</section>


					<section id="PROCEDURE">
						<title>Procedures and packages</title>
						<content>
							<h3>Stored procedures in modern RDBMS</h3>
							<p>This is one of the most important reasons why you should consider
								jOOQ. Read also my
								<a href="http://java.dzone.com/articles/2011-great-year-stored" title="Article on stored procedures and how to use them with jOOQ">article on dzone</a>
								about why stored procedures become
								more and more important in future versions of RDMBS. In this section
								of the manual, we will learn how jOOQ handles stored procedures in
								code generation. Especially before
								<reference id="UDT" title="UDT and ARRAY support"/> was
								introduced to major RDBMS, these procedures tend to have dozens of
								parameters, with IN, OUT, IN OUT parameters mixed in all variations.
								JDBC only knows very basic, low-level support for those constructs.
								jOOQ heavily facilitates the use of stored procedures and functions
								via its source code generation. Essentially, it comes down to this:
							</p>

							<h3>"Standalone" stored procedures and functions</h3>
							<p>Let's say you have these stored procedures and functions in your Oracle database </p>
<sql>-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2) RETURN NUMBER;

-- Check whether there is an author in T_AUTHOR by that name
CREATE OR REPLACE PROCEDURE p_author_exists (author_name VARCHAR2, result OUT NUMBER);

-- Check whether there is an author in T_AUTHOR by that name and get his ID
CREATE OR REPLACE PROCEDURE p_author_exists_2 (author_name VARCHAR2, result OUT NUMBER, id OUT NUMBER);</sql>

							<p>jOOQ will essentially generate two artefacts for every procedure/function: </p>
							<ul>
								<li>A class holding a formal Java representation of the procedure/function</li>
    							<li>Some convenience methods to facilitate calling that procedure/function </li>
							</ul>
							<p>Let's see what these things look like, in Java. The classes (simplified for the example): </p>

<java>// The function has a generic type parameter &lt;T&gt; bound to its return value
public class FAuthorExists extends org.jooq.impl.AbstractRoutine&lt;BigDecimal&gt; {

    // Much like Tables, functions have static parameter definitions
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]

    // And much like TableRecords, they have setters for their parameters
    public void setAuthorName(String value) { // [...]
    public void setAuthorName(Field&lt;String&gt; value) { // [...]
}

public class PAuthorExists extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {

    // In procedures, IN, OUT, IN OUT parameters are all represented
    // as static parameter definitions as well
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]

    // IN and IN OUT parameters have generated setters
    public void setAuthorName(String value) { // [...]

    // OUT and IN OUT parameters have generated getters
    public BigDecimal getResult() { // [...]
}

public class PAuthorExists_2 extends org.jooq.impl.AbstractRoutine&lt;java.lang.Void&gt; {
    public static final Parameter&lt;String&gt; AUTHOR_NAME = // [...]
    public static final Parameter&lt;BigDecimal&gt; RESULT = // [...]
    public static final Parameter&lt;BigDecimal&gt; ID = // [...]

    // the setters...
    public void setAuthorName(String value) { // [...]

    // the getters...
    public BigDecimal getResult() { // [...]
    public BigDecimal getId() { // [...]
}</java>

							<p>An example invocation of such a stored procedure might look like this: </p>

<java>PAuthorExists p = new PAuthorExists();
p.setAuthorName("Paulo");
p.execute(configuration);
assertEquals(BigDecimal.ONE, p.getResult());</java>

							<p>
								The above configuration is a
								<reference id="Factory" title="Factory"/>,
								holding a reference to a JDBC connection, as discussed in a previous section.

								If you use the generated convenience methods, however, things are much simpler, still:
							</p>
<java>// Every schema has a single Routines class with convenience methods
public final class Routines {

    // Convenience method to directly call the stored function
    public static BigDecimal fAuthorExists(Configuration configuration, String authorName) { // [...]

    // Convenience methods to transform the stored function into a
    // Field&lt;BigDecimal&gt;, such that it can be used in SQL
    public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]
    public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]

    // Procedures with 0 OUT parameters create void methods
    // Procedures with 1 OUT parameter create methods as such:
    public static BigDecimal pAuthorExists(Configuration configuration, String authorName) { // [...]

    // Procedures with more than 1 OUT parameter return the procedure
    // object (see above example)
    public static PAuthorExists_2 pAuthorExists_2(Configuration configuration, String authorName) { // [...]
}</java>

							<p>An sample invocation, equivalent to the previous example:</p>
<java>assertEquals(BigDecimal.ONE, Procedures.pAuthorExists(configuration, "Paulo"));</java>


							<h3>jOOQ's understanding of procedures vs functions</h3>
							<p>
								jOOQ does not formally distinguish procedures from functions.
								jOOQ only knows about routines, which can have return values
								and/or OUT parameters. This is the best option to handle the
								variety of stored procedure / function support across the
								various supported RDBMS. For more details, read on about this
								topic, here:
							</p>
							<p>
								<a href="http://blog.jooq.org/2011/10/17/what-are-procedures-and-functions-after-all/" title="Blog post about the difference between procedures and functions in various RDBMS">blog.jooq.org/2011/10/17/what-are-procedures-and-functions-after-all/</a>
							</p>

							<h3>Packages in Oracle</h3>
							<p>
								Oracle uses the concept of a PACKAGE to group several
								procedures/functions into a sort of namespace. The
								<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt"
									title="SQL 92 standard">SQL standard</a>
								talks about "modules", to represent this concept, even if this is
								rarely implemented. This is reflected in jOOQ by the use of Java
								sub-packages in the source code generation destination package. Every
								Oracle package will be reflected by
							</p>
							<ul>
								<li>A Java package holding classes for formal Java representations of
									the procedure/function in that package
								</li>
								<li>A Java class holding convenience methods to facilitate calling
									those procedures/functions
								</li>
							</ul>
							<p>
								Apart from this, the generated source code looks exactly like the
								one for
								standalone procedures/functions.
							</p>

							<h3>Member functions and procedures in Oracle</h3>
							<p>
								Oracle UDT's can have object-oriented structures including member functions
								and procedures. With Oracle, you can do things like this:
							</p>
<sql>CREATE OR REPLACE TYPE u_author_type AS OBJECT (
  id NUMBER(7),
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),

  MEMBER PROCEDURE LOAD,
  MEMBER FUNCTION count_books RETURN NUMBER
)

-- The type body is omitted for the example
</sql>

							<p>
								These member functions and procedures can simply be mapped to Java
								methods:
							</p>

<java>
// Create an empty, attached UDT record from the Factory
UAuthorType author = create.newRecord(U_AUTHOR_TYPE);

// Set the author ID and load the record using the LOAD procedure
author.setId(1);
author.load();

// The record is now updated with the LOAD implementation's content
assertNotNull(author.getFirstName());
assertNotNull(author.getLastName());</java>

							<p>For more details about UDT's see the Manual's section on
							<reference id="UDT" title="User Defined Types"/></p>

						</content>
					</section>


					<section id="UDT">
						<title>UDT's including ARRAY and ENUM types</title>
						<content>
							<h3>Increased RDBMS support for UDT's</h3>
							<p>
								In recent years, most RDBMS have started to implement some support for
								advanced data types. This support has not been adopted very well by
								database users in the Java world, for several reasons:
							</p>
							<ul>
								<li>They are usually orthogonal to relational concepts. It is not easy
									to modify a UDT once it is referenced by a table column.</li>
								<li>There is little standard support of accessing them from JDBC (and
									probably other database connectivity standards). </li>
							</ul>
							<p>
								On the other hand, especially with stored procedures, these data types
								are likely to become more and more useful in the future. If you have a
								look at Postgres' capabilities of dealing with advanced data types
								(<a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">ENUMs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">ARRAYs</a>,
								<a href="http://www.postgresql.org/docs/9.0/interactive/rowtypes.html">UDT's</a>),
								 this becomes more and more obvious.
							</p>
							<p>It is a central strategy for jOOQ, to standardise access to these
								kinds of types (as well as to
								<reference id="PROCEDURE" title="stored procedures"/>, of course) across all
								RDBMS, where these types are supported. </p>

							<h3>UDT types</h3>
							<p>User Defined Types (UDT) are helpful in major RDMBS with lots
							of proprietary functionality. The biggest player is clearly Oracle.
							Currently, jOOQ provides UDT support for only two databases: </p>
							<ul>
								<li>Oracle</li>
								<li>Postgres</li>
							</ul>
							<p>Apart from that, </p>
							<ul>
								<li>
									DB2 UDT's are not supported as they are very tough to
									serialise/deserialise. We don't think that this is a big enough
									requirement to put more effort in those, right now (see also the
									developers' discussion on
									<reference ticket="164" />)
								</li>
							</ul>

							<p>In Oracle, you would define UDTs like this: </p>
<sql>CREATE TYPE u_street_type AS OBJECT (
  street VARCHAR2(100),
  no VARCHAR2(30)
)

CREATE TYPE u_address_type AS OBJECT (
  street u_street_type,
  zip VARCHAR2(50),
  city VARCHAR2(50),
  country VARCHAR2(50),
  since DATE,
  code NUMBER(7)
)</sql>

							<p>These types could then be used in tables and/or stored procedures like such: </p>
<sql>CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  -- [...]
  address u_address_type
)

CREATE OR REPLACE PROCEDURE p_check_address (address IN OUT u_address_type);</sql>

							<p>
								Standard JDBC UDT support encourages JDBC-driver developers to implement
								interfaces such as
								<reference class="java.sql.SQLData"/>,
								<reference class="java.sql.SQLInput"/> and
								<reference class="java.sql.SQLOutput"/>.
								Those interfaces are non-trivial to implement, or
								to hook into. Also access to
								<reference class="java.sql.Struct"/>
								is not really simple. Due
								to the lack of a well-defined JDBC standard, Oracle's JDBC driver
								rolls their own proprietary methods of dealing with these types. jOOQ
								goes a different way, it hides those facts from you entirely. With
								jOOQ, the above UDT's will be generated in simple
								<reference class="org.jooq.UDT" title="UDT meta-model classes"/> and
								<reference class="org.jooq.UDTRecord" title="UDT record classes"/> as such:
							</p>
<java>// There is an analogy between UDT/Table and UDTRecord/TableRecord...
public class UAddressType extends UDTImpl&lt;UAddressTypeRecord&gt; {

    // The UDT meta-model singleton instance
    public static final UAddressType U_ADDRESS_TYPE = new UAddressType();

    // UDT attributes are modeled as static members. Nested UDT's
    // behave similarly
    public static final UDTField&lt;UAddressTypeRecord, UStreetTypeRecord&gt; STREET = // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; ZIP =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; CITY =              // [...]
    public static final UDTField&lt;UAddressTypeRecord, String&gt; COUNTRY =           // [...]
    public static final UDTField&lt;UAddressTypeRecord, Date&gt; SINCE =               // [...]
    public static final UDTField&lt;UAddressTypeRecord, Integer&gt; CODE =             // [...]
}</java>

							<p>Now, when you interact with entities or procedures that hold UDT's, that's very simple as well. Here is an example: </p>
<java>// Fetch any author from the T_AUTHOR table
TAuthorRecord author = create.selectFrom(T_AUTHOR).fetchAny();

// Print out the author's address's house number
System.out.println(author.getAddress().getStreet().getNo());</java>

							<p>A similar thing can be achieved when interacting with the example stored procedure: </p>
<java>// Create a new UDTRecord of type U_ADDRESS_TYPE
UAddressTypeRecord address = new UAddressTypeRecord();
address.setCountry("Switzerland");

// Call the stored procedure with IN OUT parameter of type U_ADDRESS_TYPE
address = Procedures.pCheckAddress(connection, address);</java>


							<h3>ARRAY types</h3>
							<p>
								The notion of ARRAY types in RDBMS is not standardised at all. Very
								modern databases (especially the Java-based ones) have implemented
								ARRAY types exactly as what they are. "ARRAYs of something". In other
								words, an ARRAY OF VARCHAR would be something very similar to Java's
								notion of String[]. An ARRAY OF ARRAY OF VARCHAR would then be a
								String[][] in Java. Some RDMBS, however, enforce stronger typing and
								need the explicit creation of types for every ARRAY as well. These are
								example String[] ARRAY types in various SQL dialects supported by jOOQ
								1.5.4:
							</p>
							<ul>
								<li>Oracle: VARRAY OF VARCHAR2. A strongly typed object encapsulating an ARRAY of a given type. See the <a href="http://download.oracle.com/docs/cd/B19306_01/appdev.102/b14261/collection_definition.htm">documentation.</a></li>
								<li>Postgres: text[]. Any data type can be turned into an array by suffixing it with []. See the <a href="http://www.postgresql.org/docs/9.0/interactive/arrays.html">documentation</a></li>
								<li>HSQLDB: VARCHAR ARRAY. Any data type can be turned into an array by suffixing it with ARRAY. See the <a href="http://hsqldb.org/doc/2.0/guide/sqlgeneral-chapt.html#N1070F">documentation</a></li>
								<li>H2: ARRAY. H2 does not know of typed arrays. All ARRAYs are mapped to Object[]. See the <a href="http://www.h2database.com/html/datatypes.html#array_type">documentation</a></li>
							</ul>
							<p>Soon to be supported: </p>
							<ul>
								<li>DB2: Knows a similar strongly-typed ARRAY type, like Oracle </li>
							</ul>
							<p>
								From jOOQ's perspective, the ARRAY types fit in just like any other
								type wherever the
								&lt;T&gt; generic type parameter is existent. It integrates well with tables
									and stored procedures.
							</p>

							<h3>Example: General ARRAY types</h3>
							<p>An example usage of ARRAYs is given here for the Postgres dialect </p>

<sql>CREATE TABLE t_arrays (
  id integer not null primary key,
  string_array VARCHAR(20)[],
  number_array INTEGER[]
)

CREATE FUNCTION f_arrays(in_array IN text[]) RETURNS text[]</sql>

							<p>When generating source code from the above entities, these artefacts will be created in Java: </p>
<java>public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {

    // The generic type parameter &lt;T&gt; is bound to an array of a matching type
    public static final TableField&lt;TArraysRecord, String[]&gt; STRING_ARRAY =  // [...]
    public static final TableField&lt;TArraysRecord, Integer[]&gt; NUMBER_ARRAY = // [...]
}

// The convenience class is enhanced with these methods
public final class Functions {
    public static String[] fArrays(Connection connection, String[] inArray) { // [...]
    public static Field&lt;String[]&gt; fArrays(String[] inArray) {                                     // [...]
    public static Field&lt;String[]&gt; fArrays(Field&lt;String[]&gt; inArray) {                              // [...]
}</java>

							<h3>Example: Oracle VARRAY types</h3>
							<p>In Oracle, a VARRAY type is something slightly different than in
								other RDMBS. It is a type that encapsules the actual ARRAY and creates
								a new type from it. While all text[] types are equal and thus
								compatible in Postgres, this does not apply for all VARRAY OF VARCHAR2
								types. Hence, it is important to provide access to VARRAY types and
								generated objects from those types as well. The example above would
								read like this in Oracle: </p>

<sql>CREATE TYPE u_string_array AS VARRAY(4) OF VARCHAR2(20)
CREATE TYPE u_number_array AS VARRAY(4) OF NUMBER(7)

CREATE TABLE t_arrays (
  id NUMBER(7) not null primary key,
  string_array u_string_array,
  number_array u_number_array
)

CREATE OR REPLACE FUNCTION f_arrays (in_array u_string_array)
RETURN u_string_array</sql>

							<p>Note that it becomes clear immediately, that a mapping from
								U_STRING_ARRAY to String[] is obvious. But a mapping from String[] to
								U_STRING_ARRAY is not. These are the generated
								<reference class="org.jooq.ArrayRecord" /> and other
								artefacts in Oracle: </p>

<java>public class UStringArrayRecord extends ArrayRecordImpl&lt;String&gt; {  // [...]
public class UNumberArrayRecord extends ArrayRecordImpl&lt;Integer&gt; { // [...]

public class TArrays extends UpdatableTableImpl&lt;TArraysRecord&gt; {
    public static final TableField&lt;TArraysRecord, UStringArrayRecord&gt; STRING_ARRAY = // [...]
    public static final TableField&lt;TArraysRecord, UNumberArrayRecord&gt; NUMBER_ARRAY = // [...]
}

public final class Functions {
    public static UStringArrayRecord fArrays3(Connection connection, UStringArrayRecord inArray) { // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(UStringArrayRecord inArray) {                 // [...]
    public static Field&lt;UStringArrayRecord&gt; fArrays3(Field&lt;UStringArrayRecord&gt; inArray) {          // [...]
}</java>


							<h3>ENUM types</h3>
							<p>True ENUM types are a rare species in the RDBMS world. Currently,
								MySQL and Postgres are the only RDMBS supported by jOOQ, that provide
								ENUM types. </p>

							<ul>
								<li>In MySQL, an ENUM type is declared directly upon a column. It cannot be reused as a type. See the <a href="http://dev.mysql.com/doc/refman/5.5/en/enum.html">documentation.</a> </li>
								<li>In Postgres, the ENUM type is declared independently and can be reused among tables, functions, etc. See the <a href="http://www.postgresql.org/docs/9.0/interactive/datatype-enum.html">documentation.</a> </li>
								<li>Other RDMBS know about "ENUM constraints", such as the Oracle CHECK constraint. These are not true ENUMS, however. jOOQ refrains from using their information for source code generation </li>
							</ul>

							<p>Some examples: </p>
<sql>-- An example enum type
CREATE TYPE u_book_status AS ENUM ('SOLD OUT', 'ON STOCK', 'ORDERED')

-- An example useage of that enum type
CREATE TABLE t_book (
  id INTEGER NOT NULL PRIMARY KEY,

  -- [...]
  status u_book_status
)</sql>

							<p>The above Postgres ENUM type will be generated as </p>
<java>public enum UBookStatus implements EnumType {
    ORDERED("ORDERED"),
    ON_STOCK("ON STOCK"),
    SOLD_OUT("SOLD OUT");

    // [...]
}</java>
							<p>Intuitively, the generated classes for the T_BOOK table in Postgres would look like this: </p>
<sql>// The meta-model class
public class TBook extends UpdatableTableImpl&lt;TBookRecord&gt; {

    // The TableField STATUS binds &lt;T&gt; to UBookStatus
    public static final TableField&lt;TBookRecord, UBookStatus&gt; STATUS = // [...]

    // [...]
}

// The record class
public class TBookRecord extends UpdatableRecordImpl&lt;TBookRecord&gt; {

    // Corresponding to the Table meta-model, also setters and getters
    // deal with the generated UBookStatus
    public void setStatus(UBookStatus value) { // [...]
    public UBookStatus getStatus() {           // [...]
}</sql>

							<p>Note that jOOQ allows you to simulate ENUM types where this makes
								sense in your data model. See the section on
								<reference id="MasterData" title="master data"/> for more
								details. </p>
						</content>
					</section>


					<section id="SEQUENCE">
						<title>Sequences and Serials</title>
						<content>
							<h3>Sequences as a source for identity values</h3>
							<p> Sequences implement the
							<reference class="org.jooq.Sequence"/> interface, providing essentially this functionality:</p>

<java>// Get a field for the CURRVAL sequence property
Field&lt;T&gt; currval();

// Get a field for the NEXTVAL sequence property
Field&lt;T&gt; nextval();</java>
							<p>So if you have a sequence like this in Oracle: </p>
							<sql>CREATE SEQUENCE s_author_id</sql>
							<p>This is what jOOQ will generate: </p>
<java>public final class Sequences {

    // A static sequence instance
    public static final Sequence&lt;BigInteger&gt; S_AUTHOR_ID = // [...]
}</java>

							<p>Which you can use in a select statement as such: </p>
<java>Field&lt;BigInteger&gt; s = Sequences.S_AUTHOR_ID.nextval();
BigInteger nextID   = create.select(s).fetchOne(s);</java>

							<p>Or directly fetch currval() and nextval() from the sequence using the Factory: </p>
<java>BigInteger currval = create.currval(Sequences.S_AUTHOR_ID);
BigInteger nextval = create.nextval(Sequences.S_AUTHOR_ID);</java>
						</content>
					</section>
				</sections>
			</section>




			<section id="DSL">
				<title>DSL or fluent API. Where SQL meets Java</title>
				<content>
					<h3>Overview</h3>
					<p>jOOQ ships with its own DSL (or
						<a href="http://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">Domain Specific Language</a>) that
						simulates SQL as good as possible in Java. This means, that you can
						write SQL statements almost as if Java natively supported that syntax
						just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a></p>

					<p>Here is an example to show you what that means. When you want to write a query like this in SQL: </p>
					<code-pair>
<sql>-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:
SELECT *
  FROM t_author a
  JOIN t_book b ON a.id = b.author_id
 WHERE a.year_of_birth &gt; 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title</sql>
<java>Result&lt;Record&gt; result =
create.select()
      .from(T_AUTHOR.as("a"))
      .join(T_BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();</java></code-pair>

					<p>
						You couldn't come much closer to SQL itself in Java, without re-writing the compiler.
						We'll see how the aliasing works later in the section about
						<reference id="ALIAS" title="aliasing"/>
					</p>
				</content>


				<sections>
					<section id="SELECT">
						<title>Complete SELECT syntax</title>
						<content>
							<h3>SELECT from anonymous or ad-hoc types</h3>
							<p>When you don't just perform CRUD (i.e. SELECT * FROM your_table WHERE ID = ?),
							you're usually generating new types using custom projections. With jOOQ, this is
							as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus
							some extensions, is provided by a query like this:
							</p>

<sql>-- get all authors' first and last names, and the number
-- of books they've written in German, if they have written
-- more than five books in German in the last three years
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, COUNT(*)
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = T_BOOK.AUTHOR_ID
   WHERE T_BOOK.LANGUAGE = 'DE'
     AND T_BOOK.PUBLISHED > '2008-01-01'
GROUP BY T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY T_AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2
  OFFSET 1
     FOR UPDATE</sql>

     						<p>So that's daily business. How to do it with jOOQ: When you first create a SELECT statement using the Factory's select() methods </p>
<java>SelectFromStep select(Field&lt;?&gt;... fields);

// Example:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count());</java>

							<p>
								jOOQ will return an "intermediary" type to you, representing the
								SELECT statement about to be created (by the way, check out the
								section on <reference id="FUNCTIONS" title="aggregate operators"/>
								 to learn more about the COUNT(*)
								function). This type is the
								<reference class="org.jooq.SelectFromStep"/>.
								When you have a reference
								to this type, you may add a FROM clause, although that clause is
								optional. This is reflected by the fact, that the SelectFromStep type
								extends
								<reference class="org.jooq.SelectJoinStep"/>,
								which allows for adding the subsequent
								clauses. Let's say you do decide to add a FROM clause, then you can
								use this method for instance:
							</p>
<java>SelectJoinStep from(TableLike&lt;?&gt;... table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR);</java>

							<p>After adding the table-like structures (mostly just Tables) to
								select from, you may optionally choose to add a JOIN clause, as the
								type returned by jOOQ is the step where you can add JOINs. Again,
								adding these clauses is optional, as the
								<reference class="org.jooq.SelectJoinStep"/> extends
								<reference class="org.jooq.SelectWhereStep"/>.
								But let's say we add a JOIN: </p>
<java>// These join types are supported
SelectOnStep                    join(Table&lt;?&gt; table);
SelectOnStep           leftOuterJoin(Table&lt;?&gt; table);
SelectOnStep          rightOuterJoin(Table&lt;?&gt; table);
SelectOnStep           fullOuterJoin(Table&lt;?&gt; table);
SelectJoinStep             crossJoin(Table&lt;?&gt; table);
SelectJoinStep           naturalJoin(Table&lt;?&gt; table);
SelectJoinStep  naturalLeftOuterJoin(Table&lt;?&gt; table);
SelectJoinStep naturalRightOuterJoin(Table&lt;?&gt; table);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK);</java>

							<p>Now, if you do add a JOIN clause, you have to specify the JOIN .. ON
								condition before you can add more clauses. That's not an optional step
								for some JOIN types. This is reflected by the fact that
								<reference class="org.jooq.SelectOnStep"/>
								is a top-level interface. </p>

<java><![CDATA[// These join conditions are supported
SelectJoinStep    on(Condition... conditions);
SelectJoinStep onKey();
SelectJoinStep onKey(TableField<?, ?>... keyFields);
SelectJoinStep onKey(ForeignKey<?, ?> key);
SelectJoinStep using(Field<?>... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID));]]></java>

							<p>
								See the section about
								<reference id="CONDITION" title="conditions"/>
								to learn more about the many ways
								to create Conditions in jOOQ.
								See also the section about
								<reference id="TABLESOURCE" title="table sources"/>
								to learn more about the various ways of creating JOIN
								expressions
							</p>
							<p>
								Now we're half way through. As you can
								see above, we're back to the SelectJoinStep. This means, we can
								re-iterate and add another JOIN clause, just like in SQL. Or we go on
								to the next step, adding conditions in the
								<reference class="org.jooq.SelectWhereStep"/>: </p>
<java>SelectConditionStep where(Condition... conditions);

// The example, continued:
create.select(TAuthor.FIRST_NAME, TAuthor.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"));</java>

							<p>Now the returned type
								<reference class="org.jooq.SelectConditionStep"/> is a special one, where
								you can add more conditions to the already existing WHERE clause.
								Every time you add a condition, you will return to that
								SelectConditionStep, as the number of additional conditions is
								unlimited. Note that of course you can also just add a single combined
								condition, if that is more readable or suitable for your use-case.
								Here's how we add another condition: </p>
<java>SelectConditionStep and(Condition condition);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')));</java>

							<p>Let's assume we have that method parseDate() creating a
								<reference class="java.sql.Date"/> for us.
								Then we'll continue adding the GROUP BY clause
							</p>
<java>SelectHavingStep groupBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME);</java>

      						<p>and the HAVING clause: </p>
<java>SelectOrderByStep having(Condition... conditions);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5));</java>

							<p>and the ORDER BY clause. Some RDBMS support NULLS FIRST and NULLS
								LAST extensions to the ORDER BY clause. If this is not supported by
								the RDBMS, then the behaviour is simulated with an additional CASE
								WHEN ... IS NULL THEN 1 ELSE 0 END clause. </p>
<java>SelectLimitStep orderBy(Field&lt;?&gt;... fields);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst());</java>

							<p>and finally the LIMIT clause. Most dialects have a means of limiting
								the number of result records (except Oracle). Some even support having
								an OFFSET to the LIMIT clause. Even if your RDBMS does not support the
								full LIMIT ... OFFSET ... (or TOP ... START AT ..., or FETCH FIRST ... ROWS ONLY, etc)
								clause, jOOQ will simulate the LIMIT clause using nested selects and filtering on
								ROWNUM (for Oracle), or on ROW_NUMBER() (for DB2 and SQL
								Server): </p>
<java>SelectFinalStep limit(int offset, int numberOfRows);

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2);</java>

							<p>In the final step, there are some proprietary extensions available
								only in some RDBMS. One of those extensions are the FOR UPDATE
								(supported in most RDBMS) and FOR SHARE clauses (supported only in
								MySQL and Postgres): </p>
<java>SelectFinalStep forUpdate();

// The example, continued:
create.select(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME, count())
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
      .where(T_BOOK.LANGUAGE.equal("DE"))
      .and(T_BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(T_AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1, 2)
      .forUpdate();</java>

							<p>
								Now the most relevant super-type of the object we have just created is
								<reference class="org.jooq.Select"/>.
								This type can be reused in various expressions such as in the
								<reference id="UNION" title="UNION and other set operations"/>,
								<reference id="EXISTS" title="Nested select statements using the EXISTS operator"/>,
								etc. If you just want to execute this select
								statement, you can choose any of these methods as discussed in the
								section about the <reference id="ResultQuery" title="ResultQuery"/>:
							</p>

<java>// Just execute the query.
int execute();

// Execute the query and retrieve the results
Result&lt;Record&gt; fetch();

// Execute the query and retrieve the first Record
Record fetchAny();

// Execute the query and retrieve the single Record
// An Exception is thrown if more records were available
Record fetchOne();

// [...]</java>


							<h3>SELECT from single physical tables</h3>
							<p>A very similar, but limited API is available, if you want to select from single
								physical tables in order to retrieve TableRecords or even
								UpdatableRecords (see also the manual's section on
								<reference id="Query" title="SelectQuery vs SimpleSelectQuery"/>).
								The decision, which type of select to create is
								already made at the very first step, when you create the SELECT
								statement with the Factory: </p>

							<java>public &lt;R extends Record&gt; SimpleSelectWhereStep&lt;R&gt; selectFrom(Table&lt;R&gt; table);</java>
							<p>As you can see, there is no way to further restrict/project the selected
								fields. This just selects all known TableFields in the supplied Table,
								and it also binds &lt;R extends Record&gt; to your Table's associated
								Record. An example of such a Query would then be: </p>
<java>TBook book = create.selectFrom(T_BOOK)
                   .where(TBook.LANGUAGE.equal("DE"))
                   .orderBy(TBook.TITLE)
                   .fetchAny();</java>
						</content>
					</section>


					<section id="TABLESOURCE">
						<title>Table sources</title>
						<content>
							<h3>Create complex and nested table sources</h3>
							<p>
								In the <a href="http://en.wikipedia.org/wiki/Relational_model" title="The Relational Data Model">relational data model</a>,
								there are many operations performed on entities, i.e. tables in order to join them together
								before applying predicates, renaming operations and projections. Apart from the convenience
								methods for joining table sources in the
								<reference id="SELECT" title="manual's section about the full SELECT syntax"/>,
								the <reference class="org.jooq.Table" title="Table"/> type itself provides a
								rich API for creating joined table sources. See an extract of the Table API:
							</p>
<java><![CDATA[// These are the various supported JOIN clauses. These JOIN types
// are followed by an additional ON / ON KEY / USING clause
TableOnStep join(TableLike<?> table);
TableOnStep join(String sql);
TableOnStep join(String sql, Object... bindings);

// All other JOIN types are equally overloaded with "String sql" convenience methods...
TableOnStep  leftOuterJoin(TableLike<?> table);
TableOnStep rightOuterJoin(TableLike<?> table);
TableOnStep  fullOuterJoin(TableLike<?> table);

// These JOIN types don't take any additional clause
Table<Record>             crossJoin(TableLike<?> table);
Table<Record>           naturalJoin(TableLike<?> table);
Table<Record>  naturalLeftOuterJoin(TableLike<?> table);
Table<Record> naturalRightOuterJoin(TableLike<?> table);

// Oracle and SQL Server also know PIVOT / UNPIVOT clauses for transforming a
// table into another one using a list of PIVOT values
PivotForStep pivot(Field<?>... aggregateFunctions);
PivotForStep pivot(Collection<? extends Field<?>> aggregateFunctions);

// Relational division can be applied to a table, transforming it into a
// "quotient" using an intuitive syntax
DivideByOnStep divideBy(Table<?> divisor);]]></java>

							<p>
								The <reference class="org.jooq.TableOnStep" title="TableOnStep"/> type
								contains methods for constructing the ON / ON KEY / USING clauses
							</p>

<java><![CDATA[// The ON clause is the most widely used JOIN condition. Provide arbitrary conditions as arguments
TableOnConditionStep on(Condition... conditions);
TableOnConditionStep on(String sql);
TableOnConditionStep on(String sql, Object... bindings);

// The USING clause is also part of the SQL standard. Use this if joined tables contain identical field names.
// The USING clause is simulated in databases that do not support it.
Table<Record> using(Field<?>... fields);
Table<Record> using(Collection<? extends Field<?>> fields);

// The ON KEY clause is a "synthetic" clause that does not exist in any SQL dialect. jOOQ usually has all
// foreign key relationship information to dynamically render "ON [ condition ... ]" clauses
TableOnConditionStep onKey() throws DataAccessException;
TableOnConditionStep onKey(TableField<?, ?>... keyFields) throws DataAccessException;
TableOnConditionStep onKey(ForeignKey<?, ?> key);]]></java>

							<ul>
							<li>
								For more details about the PIVOT clause, see the
								<reference id="PIVOT" title="manual's section about the Oracle PIVOT syntax"/>
							</li>
							<li>
								For more details about the DIVIDE BY clause, see the
								<reference id="DIVISION" title="manual's section about the relational division syntax"/>
							</li>
							</ul>
						</content>
					</section>


					<section id="CONDITION">
						<title>Conditions</title>
						<content>
							<h3>Conditions are the SELECT's core business</h3>
							<p>In your average application, you will typically have 3-4 SQL queries
								that have quite a long list of predicates (and possibly JOINs), such
								that you start to lose track over the overall boolean expression that
								you're trying to apply.</p>
							<p>In jOOQ, most Conditions can be created and combined almost as
								easily as in SQL itself. The two main participants for creating
								Conditions are the <reference class="org.jooq.Field" title="Field"/>,
								which is typically a participant of a
								condition, and the <reference class="org.jooq.Condition" title="Condition"/>
								itself: </p>
<java>public interface Condition {
    Condition and(Condition other);
    Condition and(String sql);
    Condition and(String sql, Object... bindings);
    Condition andNot(Condition other);
    Condition andExists(Select&lt;?&gt; select);
    Condition andNotExists(Select&lt;?&gt; select);
    Condition or(Condition other);
    Condition or(String sql);
    Condition or(String sql, Object... bindings);
    Condition orNot(Condition other);
    Condition orExists(Select&lt;?&gt; select);
    Condition orNotExists(Select&lt;?&gt; select);
    Condition not();
}</java>

							<p>The above example describes the essence of boolean logic in jOOQ. As
								soon as you have a Condition object, you can connect that to other
								Conditions, which will then give you a combined condition with exactly
								the same properties. There are also convenience methods to create an
								EXISTS clause and connect it to an existing condition. In order to
								create a new Condition you are going to depart from a Field in most
								cases. Here are some important API elements in the Field interface:
							</p>

<java><![CDATA[public interface Field<T> {
    Condition isNull();
    Condition isNotNull();
    Condition like(T value);
    Condition notLike(T value);
    Condition in(T... values);
    Condition in(Select<?> query);
    Condition notIn(Collection<T> values);
    Condition notIn(T... values);
    Condition notIn(Select<?> query);
    Condition in(Collection<T> values);
    Condition between(T minValue, T maxValue);
    Condition contains(T value);
    Condition contains(Field<T> value);
    Condition equal(T value);
    Condition equal(Field<T> field);
    Condition equal(Select<?> query);
    Condition equalAny(Select<?> query);
    Condition equalAny(T... array);
    Condition equalAny(Field<T[]> array);
    Condition equalAll(Select<?> query);
    Condition equalAll(T... array);
    Condition equalAll(Field<T[]> array);
    Condition equalIgnoreCase(String value);
    Condition equalIgnoreCase(Field<String> value);
    Condition notEqual(T value);
    Condition notEqual(Field<T> field);
    Condition notEqual(Select<?> query);
    Condition notEqualAny(Select<?> query);
    Condition notEqualAny(T... array);
    Condition notEqualAny(Field<T[]> array);
    Condition notEqualAll(Select<?> query);
    Condition notEqualAll(T... array);
    Condition notEqualAll(Field<T[]> array);

    // Subselects, ANY and ALL quantifiers are also supported for these:
    Condition lessThan(T value);
    Condition lessOrEqual(T value);
    Condition greaterThan(T value);
    Condition greaterOrEqual(T value);
}]]></java>

							<p>As you see in the partially displayed API above, you can compare a
								Field either with other Fields, with constant values (which is a
								shortcut for calling Factory.val(T value)), or with a nested SELECT
								statement. See some more
								<reference id="NESTED" title="Examples of nested SELECTs"/>. </p>
							<p>Combining the API of Field and Condition you can express complex predicates like this: </p>

<sql>(T_BOOK.TYPE_CODE IN (1, 2, 5, 8, 13, 21)       AND T_BOOK.LANGUAGE = 'DE') OR
(T_BOOK.TYPE_CODE IN (2, 3, 5, 7, 11, 13)       AND T_BOOK.LANGUAGE = 'FR') OR
(T_BOOK.TYPE_CODE IN (SELECT CODE FROM T_TYPES) AND T_BOOK.LANGUAGE = 'EN')</sql>

							<p>Just write: </p>
<java>T_BOOK.TYPE_CODE.in(1, 2, 5, 8, 13, 21)                       .and(T_BOOK.LANGUAGE.equal("DE")).or(
T_BOOK.TYPE_CODE.in(2, 3, 5, 7, 11, 13)                       .and(T_BOOK.LANGUAGE.equal("FR")).or(
T_BOOK.TYPE_CODE.in(create.select(T_TYPES.CODE).from(T_TYPES)).and(T_BOOK.LANGUAGE.equal("EN"))));</java>
						</content>
					</section>


					<section id="ALIAS">
						<title>Aliased tables and fields</title>
						<content>
							<h3>Aliasing Tables</h3>
							<p>A typical example of what you might want to do in SQL is this: </p>
<sql>SELECT a.ID, b.ID
  FROM T_AUTHOR a
  JOIN T_BOOK b on a.ID = b.AUTHOR_ID</sql>

  							<p>
  								In this example, we are aliasing Tables, calling them a and b.
  								The way aliasing works depends on how you generate your meta model
  								using jooq-codegen (see the manual's section about
  								<reference id="TABLE" title="generating tables"/>). Things become
  								simpler when you choose the instance/dynamic model, instead of the
  								static one.
  								Here is how you can create Table aliases in jOOQ:
  							</p>

<java>Table&lt;TBookRecord&gt; book = T_BOOK.as("b");
Table&lt;TAuthorRecord&gt; author = T_AUTHOR.as("a");

// If you choose not to generate a static meta model, this becomes even better
TBook book = T_BOOK.as("b");
TAuthor author = T_AUTHOR.as("a");</java>

							<p>Now, if you want to reference any fields from those Tables, you may
								not use the original T_BOOK or T_AUTHOR meta-model objects anymore.
								Instead, you have to get the fields from the new book and author Table
								aliases: </p>

<java><![CDATA[Field<Integer> bookID = book.getField(TBook.ID);
Field<Integer> authorID = author.getField(TAuthor.ID);

// Or with the instance field model:
Field<Integer> bookID = book.ID;
Field<Integer> authorID = author.ID;]]></java>

							<p>
								So this is how the above SQL statement would read in jOOQ:
							</p>
<java>create.select(authorID, bookID)
      .from(author)
      .join(book).on(authorID.equal(book.getField(T_BOOK.AUTHOR_ID)));

// Or with the instance field model:
create.select(author.ID, book.ID)
      .from(author)
      .join(book).on(author.ID.equal(book.AUTHOR_ID))</java>


      						<h3>Aliasing nested selects as tables</h3>
							<p>There is an interesting, more advanced example of how you can select
								from an aliased nested select in the manual's section about
								<reference id="NESTED" title="nested selects"/></p>


							<h3>Aliasing fields</h3>
							<p>Fields can also be aliased independently from Tables. Most often,
								this is done when using functions or aggregate operators. Here is an
								example: </p>
<sql>  SELECT FIRST_NAME || ' ' || LAST_NAME author, COUNT(*) books
    FROM T_AUTHOR
    JOIN T_BOOK ON T_AUTHOR.ID = AUTHOR_ID
GROUP BY FIRST_NAME, LAST_NAME;</sql>
							<p>Here is how it's done with jOOQ: </p>
<java>Record record = create.select(
         concat(T_AUTHOR.FIRST_NAME, " ", T_AUTHOR.LAST_NAME).as("author"),
         count().as("books"))
      .from(T_AUTHOR)
      .join(T_BOOK).on(T_AUTHOR.ID.equal(T_BOOK.AUTHOR_ID))
      .groupBy(T_AUTHOR.FIRST_NAME, T_AUTHOR.LAST_NAME).fetchAny();</java>
      						<p>When you alias Fields like above, you can access those Fields' values using the alias name: </p>
<java>System.out.println("Author : " + record.getValue("author"));
System.out.println("Books  : " + record.getValue("books"));</java>
						</content>
					</section>


					<section id="IN">
						<title>Nested SELECT using the IN operator</title>
						<content>
							<h3>The IN operator for use in semi-joins or anti-joins</h3>
							<p>
								In addition to a list of constant values, the IN operator in
								<reference class="org.jooq.Field"/>
								also supports a
								<reference class="org.jooq.Select"/> as an argument.
								This can be any type of select as
								discussed in the manual's section about
								<reference id="Query" title="Query types"/>.
								However, you must
								ensure yourself, that the provided Select will only select a single
								Field.
							</p>
							<p>Let's say you want to select books by authors born in 1920. Of
								course, this is possible with a plain JOIN as well, but let's say we
								want to use the IN operator. Then you have two possibilities: </p>

							<code-pair>
<sql>SELECT *
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID IN (
           SELECT ID FROM T_AUTHOR
            WHERE T_AUTHOR.BORN = 1920)

-- OR:

SELECT T_BOOK.*
  FROM T_BOOK
  JOIN T_AUTHOR ON (T_BOOK.AUTHOR_ID = T_AUTHOR.ID
                AND T_AUTHOR.BORN    = 1920)</sql>
<java>create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.in(
          create.select(T_AUTHOR.ID).from(T_AUTHOR)
                .where(T_AUTHOR.BORN.equal(1920))));

// OR:

create.select(T_BOOK.getFields())
      .from(T_BOOK)
      .join(T_AUTHOR).on(T_BOOK.AUTHOR_ID.equal(TAuthor.ID)
                     .and(T_AUTHOR.BORN.equal(1920)));</java></code-pair>
						</content>
					</section>


					<section id="EXISTS">
						<title>Nested SELECT using the EXISTS operator</title>
						<content>
							<h3>The EXISTS operator for use in semi-joins or anti-joins</h3>
							<p>The EXISTS operator is rather independent and can stand any place
								where there may be a new condition: </p>
							<ul>
								<li>It may be placed right after a WHERE keyword </li>
								<li>It may be the right-hand-side of a boolean operator</li>
								<li>It may be placed right after a ON or HAVING keyword (although, this is less likely to be done...) </li>
							</ul>

							<p>This is reflected by the fact that an EXISTS clause is usually
								created directly from the Factory: </p>

<java>Condition exists(Select&lt;?&gt; query);
Condition notExists(Select&lt;?&gt; query);</java>

							<p>When you create such a Condition, it can then be connected to any
								other condition using AND, OR operators (see also the manual's section
								on
								<reference id="CONDITION" title="Conditions"/>). There are also quite a few
								convenience methods, where they might be useful. For instance in the
								<reference class="org.jooq.Condition"/> itself: </p>

<java>Condition andExists(Select&lt;?&gt; select);
Condition andNotExists(Select&lt;?&gt; select);
Condition orExists(Select&lt;?&gt; select);
Condition orNotExists(Select&lt;?&gt; select);</java>

							<p>Or in the <reference class="org.jooq.SelectWhereStep"/>:</p>

<java>SelectConditionStep whereExists(Select&lt;?&gt; select);
SelectConditionStep whereNotExists(Select&lt;?&gt; select);</java>

							<p>Or in the <reference class="org.jooq.SelectConditionStep"/>: </p>

<java>SelectConditionStep andExists(Select&lt;?&gt; select);
SelectConditionStep andNotExists(Select&lt;?&gt; select);
SelectConditionStep orExists(Select&lt;?&gt; select);
SelectConditionStep orNotExists(Select&lt;?&gt; select);</java>

							<p>An example of how to use it is quickly given. Get all authors that haven't written any books: </p>
							<code-pair>
<sql>SELECT *
  FROM T_AUTHOR
 WHERE NOT EXISTS (SELECT 1
                     FROM T_BOOK
                    WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID)</sql>
<java>create.select()
      .from(T_AUTHOR)
      .whereNotExists(create.selectOne()
            .from(T_BOOK)
            .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID)));</java>
							</code-pair>
						</content>
					</section>


					<section id="NESTED">
						<title>Other types of nested SELECT</title>
						<content>
							<h3>Comparison with single-field SELECT clause</h3>
							<p>If you can ensure that a nested SELECT will only return one Record
								with one Field, then you can test for equality. This is how it is done
								in SQL: </p>

							<code-pair>
<sql>SELECT *
  FROM T_BOOK
 WHERE T_BOOK.AUTHOR_ID = (
 		SELECT ID
          FROM T_AUTHOR
         WHERE LAST_NAME = 'Orwell')</sql>
<java>create.select()
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(create
             .select(T_AUTHOR.ID)
             .from(T_AUTHOR)
             .where(T_AUTHOR.LAST_NAME.equal("Orwell"))));</java>
                            </code-pair>

                            <p>More examples like the above can be guessed from the
                            <reference class="org.jooq.Field"/> API, as documented in the manual's section about
                            <reference id="CONDITION" title="Conditions"/>. For the = operator, the available comparisons are these:</p>

<java>Condition equal(Select&lt;?&gt; query);
Condition equalAny(Select&lt;?&gt; query);
Condition equalAll(Select&lt;?&gt; query);</java>


                            <h3>Selecting from a SELECT - SELECT acts as a Table</h3>
							<p>Often, you need to nest a SELECT statement simply because SQL is
								limited in power. For instance, if you want to find out which author
								has written the most books, then you cannot do this: </p>

<sql>  SELECT AUTHOR_ID, count(*) books
    FROM T_BOOK
GROUP BY AUTHOR_ID
ORDER BY books DESC</sql>

							<p>Instead, you have to do this (or something similar). For jOOQ, this
								is an excellent example, combining various SQL features into a single
								statement. Here's how to do it: </p>

							<code-pair>
<sql>SELECT nested.* FROM (
      SELECT AUTHOR_ID, count(*) books
        FROM T_BOOK
    GROUP BY AUTHOR_ID
) nested
ORDER BY nested.books DESC


</sql>
<java>Table&lt;Record&gt; nested =
    create.select(T_BOOK.AUTHOR_ID, count().as("books"))
          .from(T_BOOK)
          .groupBy(T_BOOK.AUTHOR_ID).asTable("nested");

create.select(nested.getFields())
      .from(nested)
      .orderBy(nested.getField("books"));</java>
							</code-pair>

							<p>You'll notice how some verbosity seems inevitable when you combine nested SELECT statements with aliasing. </p>

	                    	<h3>Selecting a SELECT - SELECT acts as a Field</h3>
							<p>Now SQL is even more powerful than that. You can also have SELECT
								statements, wherever you can have Fields. It get's harder and harder
								to find good examples, because there is always an easier way to
								express the same thing. But why not just count the number of books the
								really hard way? :-) But then again, maybe you want to take advantage
								of <a href="http://blog.jooq.org/2011/09/02/oracle-scalar-subquery-caching/" title="Oracle Scalar Subquery Caching with jOOQ">Oracle Scalar Subquery Caching</a></p>

							<code-pair>
<sql>  SELECT LAST_NAME, (
      SELECT COUNT(*)
       FROM T_BOOK
      WHERE T_BOOK.AUTHOR_ID = T_AUTHOR.ID) books
    FROM T_AUTHOR
ORDER BY books DESC



</sql>
<java>// The type of books cannot be inferred from the Select&lt;?&gt;
Field&lt;Object&gt; books =
    create.selectCount()
          .from(T_BOOK)
          .where(T_BOOK.AUTHOR_ID.equal(T_AUTHOR.ID))
          .asField("books");
create.select(T_AUTHOR.ID, books)
      .from(T_AUTHOR)
      .orderBy(books, T_AUTHOR.ID));</java>
							</code-pair>
                    	</content>
					</section>


					<section id="UNION">
						<title>UNION and other set operations</title>
						<content>
							<h3>jOOQ's set operation API</h3>
							<p>The
								<reference class="org.jooq.Select"/> API directly supports the UNION
								syntax for all types of Select as discussed in the manual's section about
								<reference id="Query" title="Queries and Query subtypes"/>.
								It consists of these methods: </p>

<java>public interface Select&lt;R extends Record&gt; {
    Select&lt;R&gt; union(Select&lt;R&gt; select);
    Select&lt;R&gt; unionAll(Select&lt;R&gt; select);
    Select&lt;R&gt; except(Select&lt;R&gt; select);
    Select&lt;R&gt; intersect(Select&lt;R&gt; select);
}</java>

							<p>Hence, this is how you can write a simple UNION with jOOQ:</p>
							<code-pair>
<sql>SELECT TITLE
  FROM T_BOOK
 WHERE PUBLISHED_IN &gt; 1945
UNION
SELECT TITLE
  FROM T_BOOK
 WHERE AUTHOR_ID = 1</sql>
<java>create.select(TBook.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.PUBLISHED_IN.greaterThan(1945))
      .union(
create.select(T_BOOK.TITLE)
      .from(T_BOOK)
      .where(T_BOOK.AUTHOR_ID.equal(1)));</java>
							</code-pair>

							<h3>Nested UNIONs</h3>
							<p>In some SQL dialects, you can arbitrarily nest UNIONs to several
								levels. Be aware, though, that SQLite, Derby and MySQL have serious
								syntax limitations. jOOQ tries to render correct UNION SQL statements,
								but unfortunately, you can create situations that will cause syntax
								errors in the aforementioned dialects. </p>

							<p>An example of advanced UNION usage is the following statement in jOOQ: </p>
<java>// Create a UNION of several types of books
Select&lt;?&gt; union =
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.PUBLISHED_IN.greaterThan(1945)).union(
    create.select(T_BOOK.TITLE, T_BOOK.AUTHOR_ID).from(T_BOOK).where(T_BOOK.AUTHOR_ID.equal(1)));

// Now, re-use the above UNION and order it by author
create.select(union.getField(T_BOOK.TITLE))
      .from(union)
      .orderBy(union.getField(T_BOOK.AUTHOR_ID).descending());</java>

							<p>This example does not seem surprising, when you have read the
								previous chapters about
								<reference id="NESTED" title="nested SELECT statements"/>.
								But when you check
								out the rendered SQL: </p>

<sql>-- alias_38173 is an example of a generated alias,
-- generated by jOOQ for union queries
SELECT alias_38173.TITLE FROM (
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.PUBLISHED_IN > 1945
  UNION
  SELECT T_BOOK.TITLE, T_BOOK.AUTHOR_ID FROM T_BOOK WHERE T_BOOK.AUTHOR_ID = 1
) alias_38173
ORDER BY alias_38173.AUTHOR_ID DESC</sql>

							<p>You can see that jOOQ takes care of many syntax pitfalls, when
								you're not used to the various dialects' unique requirements. The
								above automatic aliasing was added in order to be compliant with
								MySQL's requirements about aliasing nested selects. </p>

							<h3>Several UNIONs</h3>
							<p>It is no problem either for you to create SQL statements with several unions. Just write: </p>
<java>Select&lt;?&gt; part1;
Select&lt;?&gt; part2;
Select&lt;?&gt; part3;
Select&lt;?&gt; part4;

// [...]

part1.union(part2).union(part3).union(part4);</java>

							<h3>UNION and the ORDER BY clause</h3>
							<p>
								Strictly speaking, in SQL, you cannot order a subselect that is part
								of a UNION operation. You can only order the whole set. In set theory,
								or relational algebra, it wouldn't make sense to order subselects
								anyway, as a set operation cannot guarantee order correctness. Often,
								you still want to do it, because you apply a LIMIT to every subselect.
								Let's say, you want to find the employees with the highest salary in
								every department in Postgres syntax:
							</p>
							<code-pair>
<sql>SELECT * FROM (
  SELECT * FROM emp WHERE dept = 'IT'
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'Marketing'
  ORDER BY salary LIMIT 1
) UNION (
  SELECT * FROM emp WHERE dept = 'R&amp;D'
  ORDER BY salary LIMIT 1
)</sql>
<java>create.selectFrom(EMP).where(DEPT.equal("IT"))
      .orderBy(SALARY).limit(1)
      .union(
create.selectFrom(EMP).where(DEPT.equal("Marketing"))
      .orderBy(SALARY).limit(1))
      .union(
create.selectFrom(EMP).where(DEPT.equal("R&amp;D")
      .orderBy(SALARY).limit(1)))


</java>
							</code-pair>

							<p>There is a subtle difference between the above two queries.
								In SQL, every UNION subselect is in fact a
							<reference id="NESTED" title="nested SELECT"/>, wrapped in parentheses.
							In this example, the notion of "nested SELECT" and "subselect" are slightly
							different.</p>
						</content>
					</section>


					<section id="FUNCTIONS">
						<title>Functions and aggregate operators</title>
						<content>
							<h3>Supporting for vendor-specific functions</h3>
							<p>jOOQ allows you to access native functions from your RDBMS. jOOQ
								follows two strategies: </p>
							<ul>
								<li>Implement all SQL-92, SQL:1999, SQL:2003, and SQL:2008 standard
									functions, aggregate operators, and window functions. Standard
									functions could be
									<a href="http://oreilly.com/catalog/sqlnut/chapter/ch04.html" title="O'Reilly listing of SQL-92 standard functions and deviations thereof">these functions as listed by O'Reilly</a>. </li>
								<li>Take the most useful of vendor-specific functions and simulate
									them for other RDBMS, where they may not be supported. An example for
									this are
									<a href="http://psoug.org/reference/analytic_functions.html" title="An example listing of Oracle Analytic Functions">Oracle Analytic Functions</a></li>
							</ul>

							<h3>Functions </h3>
							<p>These are just a few functions in the Factory, so you get the idea: </p>

<java><![CDATA[Field<String> rpad(Field<String> field, Field<? extends Number> length);
Field<String> rpad(Field<String> field, int length);
Field<String> rpad(Field<String> field, Field<? extends Number> length, Field<String> c);
Field<String> rpad(Field<String> field, int length, char c);
Field<String> lpad(Field<String> field, Field<? extends Number> length);
Field<String> lpad(Field<String> field, int length);
Field<String> lpad(Field<String> field, Field<? extends Number> length, Field<String> c);
Field<String> lpad(Field<String> field, int length, char c);
Field<String> replace(Field<String> field, Field<String> search);
Field<String> replace(Field<String> field, String search);
Field<String> replace(Field<String> field, Field<String> search, Field<String> replace);
Field<String> replace(Field<String> field, String search, String replace);
Field<Integer> position(Field<String> field, String search);
Field<Integer> position(Field<String> field, Field<String> search);]]></java>

							<h3>Aggregate functions</h3>
							<p>Aggregate functions work just like functions, even if they have a
								slightly different semantics. Here are some examples from
								Factory: </p>

<java><![CDATA[// Every-day, SQL standard aggregate functions
AggregateFunction<Integer> count(Field<?> field);
AggregateFunction<T> max(Field<T> field);
AggregateFunction<T> min(Field<T> field);
AggregateFunction<BigDecimal> sum(Field<? extends Number> field);
AggregateFunction<BigDecimal> avg(Field<? extends Number> field);


// DISTINCT keyword in aggregate functions
AggregateFunction<Integer> countDistinct(Field<?> field);
AggregateFunction<T> maxDistinct(Field<T> field);
AggregateFunction<T> minDistinct(Field<T> field);
AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field);
AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field);

// String aggregate functions
AggregateFunction<String> groupConcat(Field<?> field);
AggregateFunction<String> groupConcatDistinct(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field, String separator);

// Statistical functions
AggregateFunction<BigDecimal> median(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field);
AggregateFunction<BigDecimal> varPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field);
]]></java>

							<p>A typical example of how to use an aggregate operator is when
								generating the next key on insertion of an ID. When you want to
								achieve something like this </p>

							<code-pair>
<sql>SELECT MAX(ID) + 1 AS next_id
  FROM T_AUTHOR</sql>
<java>create.select(max(ID).add(1).as("next_id"))
      .from(T_AUTHOR);</java>
							</code-pair>

							<p>See also the section about
								<reference id="ARITHMETIC" title="Arithmetic operations"/></p>

                            <h3>Ordered aggregate functions</h3>
                            <p>Oracle and some other databases support ordered
                               aggregate functions. This means you can provide
                               an ORDER BY clause to an aggregate function, which will
                               be taken into consideration when aggregating. The best example
                               for this is LISTAGG() (also known as GROUP_CONCAT in other dialects).
                               The following query groups by authors and concatenates
                               their books' titles</p>
							<code-pair>
<sql>SELECT   LISTAGG(TITLE, ', ')
         WITHIN GROUP (ORDER BY TITLE)
FROM     BOOK
GROUP BY AUTHOR_ID</sql>
<java>create.select(listAgg(BOOK.TITLE, ", ")
      .withinGroupOrderBy(BOOK.TITLE))
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID)</java>
							</code-pair>


							<h3>Window functions</h3>
							<p>Most major RDBMS support the concept of window functions. jOOQ knows
								of implementations in DB2, Oracle, Postgres, SQL Server, and Sybase
								SQL Anywhere,
								and supports most of their specific syntaxes. Window functions can be
								used for things like calculating a "running total". The following example
								fetches transactions and the running total for every transaction going
								back to the beginning of the transaction table (ordered by booked_at).

								They are accessible from the previously seen AggregateFunction type using
								the over() method:
							</p>

							<code-pair>
<sql>SELECT booked_at, amount,
   SUM(amount) OVER (PARTITION BY 1
                     ORDER BY booked_at
                     ROWS BETWEEN UNBOUNDED PRECEDING
                     AND CURRENT ROW) AS total
  FROM transactions</sql>
<java>create.select(t.BOOKED_AT, t.AMOUNT,
         sum(t.AMOUNT).over().partitionByOne()
                      .orderBy(t.BOOKED_AT)
                      .rowsBetweenUnboundedPreceding()
                      .andCurrentRow().as("total")
      .from(TRANSACTIONS.as("t"));</java>
							</code-pair>
						</content>
					</section>


					<section id="PROCEDURES">
						<title>Stored procedures and functions</title>
						<content>
							<h3>Interaction with stored procedures</h3>
							<p>
								The full power of your database's vendor-specific extensions can hardly
								be obtained outside of the
								database itself. Most modern RDBMS support
								their own procedural language. With jOOQ, stored procedures are
								integrated easily
							</p>

							<p>The main way to interact with your RDBMS's stored procedures and
								functions is by using the generated artefacts. See the manual's
								section about
								<reference id="PROCEDURE" title="generating procedures and packages"/>
							    for more details
								about the source code generation for stored procedures and functions.
							</p>

							<h3>Stored functions</h3>
							<p>When it comes to DSL, stored functions can be very handy in SQL
								statements as well. Every stored function (this also applies to
								FUNCTIONS in Oracle PACKAGES) can generate a Field representing a call
								to that function. Typically, if you have this type of function in your
								database: </p>

<sql>CREATE OR REPLACE FUNCTION f_author_exists (author_name VARCHAR2)
RETURN NUMBER;</sql>

							<p>Then convenience methods like these are generated: </p>
<java>// Create a field representing a function with another field as parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(Field&lt;String&gt; authorName) { // [...]

// Create a field representing a function with a constant parameter
public static Field&lt;BigDecimal&gt; fAuthorExists(String authorName) { // [...]</java>

							<p>Let's say, you have a T_PERSON table with persons' names in it, and
								you want to know whether there exists an author with precisely that
								name, you can reuse the above stored function in a SQL query: </p>

							<code-pair>
<sql>SELECT T_PERSON.NAME, F_AUTHOR_EXISTS(T_PERSON.NAME)
  FROM T_PERSON

-- OR:

SELECT T_PERSON.NAME
  FROM T_PERSON
 WHERE F_AUTHOR_EXISTS(T_PERSON.NAME) = 1</sql>
 <java>create.select(T_PERSON.NAME, Functions.fAuthorExists(T_PERSON.NAME))
      .from(T_PERSON);

// OR: Note, the static import of Functions.*
create.select(T_PERSON.NAME)
      .from(T_PERSON)
      .where(fAuthorExists(T_PERSON.NAME));</java>
							</code-pair>

							<h3>Stored procedures</h3>
							<p>The notion of a stored procedure is implemented in most RDBMS by the
								fact, that the procedure has no RETURN VALUE (like void in Java), but
								it may well have OUT parameters. Since there is not a standard way how
								to embed stored procedures in SQL, they cannot be integrated in jOOQ's
								DSL either. </p>
						</content>
					</section>


					<section id="ARITHMETIC">
						<title>Arithmetic operations and concatenation</title>
						<content>
							<h3>Mathematical operations</h3>
							<p>
								Your database can do the math for you. Most arithmetic operations are
								supported, but also string concatenation can be very efficient if done
								already in the database.
							</p>
							<p>Arithmetic operations are implemented just like
								<reference id="FUNCTIONS" title="functions"/>, with
								similar limitations as far as type restrictions are concerned. You can
								use any of these operators: </p>

							<config>  +  -  *  /  %</config>

							<p>In order to express a SQL query like this one: </p>
							<sql>SELECT ((1 + 2) * (5 - 3) / 2) % 10 FROM DUAL</sql>
							<p>You can write something like this in jOOQ: </p>
							<java>create.select(val(1).add(2).mul(val(5).sub(3)).div(2).mod(10));	</java>

							<h3>Datetime arithmetic</h3>
							<p>jOOQ also supports the Oracle-style syntax for adding days to a Field&lt;? extends java.util.Date&gt; </p>
							<code-pair>
								<sql>SELECT SYSDATE + 3 FROM DUAL;</sql>
								<java>create.select(currentTimestamp().add(3));</java>
							</code-pair>

							<p>
								For more advanced datetime arithmetic, use the Factory's timestampDiff() and dateDiff() functions,
								as well as jOOQ's built-in SQL standard INTERVAL data type support:
							</p>
							<ul>
								<li>INTERVAL YEAR TO MONTH: <reference class="org.jooq.types.YearToMonth"/></li>
								<li>INTERVAL DAY TO SECOND: <reference class="org.jooq.types.DayToSecond"/></li>
							</ul>

							<h3>String concatenation</h3>
							<p>This is not really an arithmetic expression, but it's still an
								expression with operators: The string concatenation. jOOQ
								provides you with the Field's concat() method:</p>
							<code-pair>
<sql>SELECT 'A' || 'B' || 'C' FROM DUAL

-- Or in MySQL:
SELECT concat('A', 'B', 'C')</sql>
<java>&#160;
// For all RDBMS, including MySQL:
create.select(concat("A", "B", "C"));

</java>
							</code-pair>
						</content>
					</section>


					<section id="CASE">
						<title>The CASE clause</title>
						<content>
							<h3>The two flavours of CASE</h3>
							<p>The CASE clause is part of the standard SQL syntax. While some RDBMS
								also offer an IF clause, or a DECODE function, you can always rely on
								the two types of CASE syntax: </p>

							<code-pair>
<sql>CASE WHEN T_AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN T_AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                         ELSE 'unknown'
END

-- OR:

CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END </sql>
<java>create.decode()
      .when(T_AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(T_AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(T_AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");</java>
							</code-pair>

							<p>
								In jOOQ, both syntaxes are supported (although, Derby only knows the
								first one, which is more general). Unfortunately, both case and else
								are reserved words in Java. jOOQ chose to use decode() from the Oracle
								DECODE function, and otherwise(), which means the same as else. Please
								note that in the above examples, all values were always constants. You
								can of course also use Field instead of the various constants.
							</p>
							<p>A CASE clause can be used anywhere where you can place a Field. For
								instance, you can SELECT the above expression, if you're selecting
								from T_AUTHOR: </p>
<sql>SELECT T_AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM T_AUTHOR</sql>


  							<h3>CASE clauses in an ORDER BY clause</h3>
							<p>Sort indirection is often implemented with a CASE clause of a
								SELECT's ORDER BY clause. In SQL, this reads: </p>

<sql>SELECT *
FROM T_AUTHOR
ORDER BY CASE FIRST_NAME WHEN 'Paulo'  THEN 1
                         WHEN 'George' THEN 2
                                       ELSE null
         END</sql>

							<p>This will order your authors such that all 'Paulo' come first, then
								all 'George' and everyone else last (depending on your RDBMS' handling
								of NULL values in sorting). This is a very common task, such that jOOQ
								simplifies its use: </p>
<java>create.select()
      .from(T_AUTHOR)
      .orderBy(T_AUTHOR.FIRST_NAME.sortAsc("Paulo", "George"))
      .execute();</java>
						</content>
					</section>


					<section id="CAST">
						<title>Type casting</title>
						<content>
							<h3>Enforcing a specific type when you need it</h3>
							<p>jOOQ's source code generator tries to find the most accurate type
								mapping between your vendor-specific data types and a matching Java
								type. For instance, most VARCHAR, CHAR, CLOB types will map to String.
								Most BINARY, BYTEA, BLOB types will map to byte[]. NUMERIC types will
								default to java.math.BigDecimal, but can also be any of
								java.math.BigInteger, Long, Integer, Short, Byte, Double, Float. </p>
							<p>Sometimes, this automatic mapping might not be what you needed, or
								jOOQ cannot know the type of a field (because you created it from a
								<reference id="NESTED" title="nested select"/>).
								In those cases you would write SQL type CASTs like
								this: </p>
<sql>-- Let's say, your Postgres column LAST_NAME was VARCHAR(30)
-- Then you could do this:
SELECT CAST(T_AUTHOR.LAST_NAME AS TEXT) FROM DUAL</sql>
							<p>in jOOQ, you can write something like that: </p>
							<java>create.select(TAuthor.LAST_NAME.cast(PostgresDataType.TEXT));</java>
							<p>The same thing can be achieved by casting a Field directly to
								String.class, as TEXT is the default data type in Postgres to map to
								Java's String</p>
							<java>create.select(TAuthor.LAST_NAME.cast(String.class));</java>
							<p>The complete CAST API in Field consists of these three methods: </p>
<java>public interface Field&lt;T&gt; {
    &lt;Z&gt; Field&lt;Z&gt; cast(Field&lt;Z&gt; field);
    &lt;Z&gt; Field&lt;Z&gt; cast(DataType&lt;Z&gt; type);
    &lt;Z&gt; Field&lt;Z&gt; cast(Class&lt;? extends Z&gt; type);
}

// And additional convenience methods in the Factory:
public class Factory {
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; cast(Object object, Class&lt;? extends T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Field&lt;T&gt; field);
    &lt;T&gt; Field&lt;T&gt; castNull(DataType&lt;T&gt; type);
    &lt;T&gt; Field&lt;T&gt; castNull(Class&lt;? extends T&gt; type);
}</java>
						</content>
					</section>


					<section id="SQL">
						<title>When it's just easier: Plain SQL</title>
						<content>
							<h3>Plain SQL in jOOQ</h3>
							<p>A DSL is a nice thing to have, it feels "fluent" and "natural",
								especially if it models a well-known language, such as SQL. But a DSL
								is always expressed in another language (Java in this case), which was
								not made for exactly that DSL. If it were, then jOOQ would be
								implemented on a compiler-level, similar to Linq in .NET. But it's
								not, and so, the DSL is limited. We have seen many functionalities
								where the DSL becomes verbose. This can be especially true for: </p>
							<ul>
								<li><reference id="ALIAS" title="aliasing"/></li>
								<li><reference id="NESTED" title="nested selects"/></li>
								<li><reference id="ARITHMETIC" title="arithmetic expressions"/></li>
								<li><reference id="CAST" title="casting"/></li>
							</ul>
							<p>You'll probably find other examples. If verbosity scares you off,
								don't worry. The verbose use-cases for jOOQ are rather rare, and when
								they come up, you do have an option. Just write SQL the way you're
								used to! </p>
							<p>jOOQ allows you to embed SQL as a String in these contexts: </p>
							<ul>
								<li>Plain SQL as a condition </li>
								<li>Plain SQL as a field </li>
								<li>Plain SQL as a function </li>
								<li>Plain SQL as a table </li>
								<li>Plain SQL as a query </li>
							</ul>

							<p>To construct artefacts wrapping plain SQL, you should use any of
								these methods from the Factory class: </p>

<java><![CDATA[// A condition
Condition condition(String sql);
Condition condition(String sql, Object... bindings);

// A field with an unknown data type
Field<Object> field(String sql);
Field<Object> field(String sql, Object... bindings);

// A field with a known data type
<T> Field<T> field(String sql, Class<T> type);
<T> Field<T> field(String sql, Class<T> type, Object... bindings);
<T> Field<T> field(String sql, DataType<T> type);
<T> Field<T> field(String sql, DataType<T> type, Object... bindings);

// A field with a known name (properly escaped)
Field<Object> fieldByName(String... fieldName);
<T> Field<T> fieldByName(Class<T> type, String... fieldName);
<T> Field<T> fieldByName(DataType<T> type, String... fieldName)

// A function
<T> Field<T> function(String name, Class<T> type, Field<?>... arguments);
<T> Field<T> function(String name, DataType<T> type, Field<?>... arguments);

// A table
Table<?> table(String sql);
Table<?> table(String sql, Object... bindings);

// A query without results (update, insert, etc)
Query query(String sql);
Query query(String sql, Object... bindings);

// A query with results
ResultQuery<Record> resultQuery(String sql);
ResultQuery<Record> resultQuery(String sql, Object... bindings);

// A query with results. This is the same as resultQuery(...).fetch();
Result<Record> fetch(String sql);
Result<Record> fetch(String sql, Object... bindings);]]></java>

							<p>Apart from the general factory methods, plain SQL is useful also in
								various other contexts. For instance, when adding a .where("a = b")
								clause to a query. Hence, there exist several convenience methods
								where plain SQL can be inserted usefully. This is an example
								displaying all various use-cases in one single query: </p>
<java><![CDATA[// You can use your table aliases in plain SQL fields
// As long as that will produce syntactically correct SQL
Field<?> LAST_NAME    = create.field("a.LAST_NAME");

// You can alias your plain SQL fields
Field<?> COUNT1       = create.field("count(*) x");

// If you know a reasonable Java type for your field, you
// can also provide jOOQ with that type
Field<Integer> COUNT2 = create.field("count(*) y", Integer.class);

       // Use plain SQL as select fields
create.select(LAST_NAME, COUNT1, COUNT2)

       // Use plain SQL as aliased tables (be aware of syntax!)
      .from("t_author a")
      .join("t_book b")

       // Use plain SQL for conditions both in JOIN and WHERE clauses
      .on("a.id = b.author_id")

       // Bind a variable in plain SQL
      .where("b.title != ?", "Brida")

       // Use plain SQL again as fields in GROUP BY and ORDER BY clauses
      .groupBy(LAST_NAME)
      .orderBy(LAST_NAME);]]></java>

							<p>There are some important things to keep in mind when using plain
								SQL: </p>
							<ul>
								<li>jOOQ doesn't know what you're doing. You're on your own again!
								</li>
								<li>You have to provide something that will be syntactically correct.
									If it's not, then jOOQ won't know. Only your JDBC driver or your
									RDBMS will detect the syntax error. </li>
								<li>You have to provide consistency when you use variable binding. The
									number of ? must match the number of variables </li>
								<li>Your SQL is inserted into jOOQ queries without further checks.
									Hence, jOOQ can't prevent SQL injection. </li>
							</ul>
						</content>
					</section>
				</sections>
			</section>



			<section id="ADVANCED">
				<title>Advanced topics</title>
				<content>
					<h3>Overview</h3>
					<p>This section covers some advanced topics and features that don't fit into any other section. </p>
				</content>


				<sections>
					<section id="MasterData">
						<title>Master data and enumeration tables</title>
						<content>
							<h3>Enumeration tables</h3>
							<p>Only MySQL and Postgres databases support true ENUM types natively.
								Some other RDBMS allow you to map the concept of an ENUM data type to
								a CHECK constraint, but those constraints can contain arbitrary SQL.
								 With jOOQ, you
								can "simulate" ENUM types by declaring a table as a "master data
								table" in the configuration. At code-generation time, this table will
								be treated specially, and a Java enum type is generated from its data.
							</p>

							<h3>Configure master data tables</h3>
							<p>As previously discussed in the
							  <reference id="Configuration" title="configuration and setup"/>
							   section, you can configure master data tables as follows: </p>
<xml><![CDATA[<!-- These properties can be added to the database element: -->
<database>
  <masterDataTables>
    <masterDataTable>
      <!-- The name of a master data table -->
      <name>[a table name]</name>

      <!-- The column used for enum literals -->
      <literal>[a column name]</literal>

      <!-- The column used for documentation -->
      <description>[a column name]</description>
    </masterDataTable>

    [ <masterDataTable>...</masterDataTable> ... ]
  </masterDataTables>
 </database>]]></xml>

							<p>The results of this will be a Java enum that looks similar to this: </p>
<java><![CDATA[public enum TLanguage implements MasterDataType<Integer> {

  /**
   * English
   */
  en(1, "en", "English"),

  /**
   * Deutsch
   */
  de(2, "de", "Deutsch"),

  /**
   * Français
   */
  fr(3, "fr", "Français"),

  /**
   * null
   */
  pt(4, "pt", null),
  ;

  private final Integer id;
  private final String cd;
  private final String description;

  // [ ... constructor and getters for the above properties ]
}]]></java>

							<p>In the above example, you can see how the configured primary key is
								mapped to the id member, the configured literal column is mapped to
								the cd member and the configured description member is mapped to the
								description member and output as Javadoc. In other words, T_LANGUAGE
								is a table with 4 rows and at least three columns. </p>
							<p>The general contract (with jOOQ 1.6.2+) is that there must be </p>
							<ul>
								<li> A single-column primary key column of character or integer type
								</li>
								<li>An optional unique literal column of character or integer type
									(otherwise, the primary key is used as enum literal) </li>
								<li>An optional description column of any type </li>
							</ul>

							<h3>Using MasterDataTypes</h3>
							<p>The point of MasterDataTypes in jOOQ is that they behave exactly
								like true ENUM types. When the above T_LANGUAGE table is referenced by
								T_BOOK, instead of generating foreign key navigation methods and a
								LANGUAGE_ID Field&lt;Integer&gt;, a Field&lt;TLanguage&gt; is
								generated: </p>

<java><![CDATA[public class TBook extends UpdatableTableImpl<TBookRecord> {

  // [...]
  public static final TableField<TBookRecord, TLanguage> LANGUAGE_ID =
                  new TableFieldImpl<TBookRecord, TLanguage>( /* ... */ );
}]]></java>

							<p>Which can then be used in the TBookRecord directly: </p>
<java><![CDATA[public class TBookRecord extends UpdatableRecordImpl<TBookRecord> {

  // [...]
  public TLanguage getLanguageId() { // [...]
  public void setLanguageId(TLanguage value) { // [...]
}]]></java>

							<h3>When to use MasterDataTypes</h3>
							<p>You can use master data types when you're actually mapping master
								data to a Java enum. When the underlying table changes frequently,
								those updates will not be reflected by the statically generated code.
								Also, be aware that it will be difficult to perform actual JOIN
								operations on the underlying table with jOOQ, once the master data
								type is generated. </p>
						</content>
					</section>


					<section id="CustomTypes">
						<title>Custom data types and type conversion</title>
						<content>
							<h3>Your custom type and its associated Converter</h3>
							<p>
								When using a custom type in jOOQ, you need to let jOOQ know about
								its associated <reference class="org.jooq.Converter"/>.
								A converter essentially has two generic type parameters:
							</p>
							<ul>
								<li>&lt;U&gt;: The user-defined Java type. This could be <reference class="java.util.GregorianCalendar"/>, for instance.</li>
								<li>&lt;T&gt;: The database / SQL type. This could be <reference class="java.sql.Timestamp"/>, for instance.</li>
							</ul>
							<p>
								The above conversion implies that you may want to use a GregorianCalendar for
								SQL timestamps, rather than the timestamp type itself. You could then write
								a Converter like this:
							</p>

<java><![CDATA[package com.example;

import java.sql.Timestamp;
import java.util.Calendar;
import java.util.GregorianCalendar;

import org.jooq.Converter;

// Bind T to Timestamp and U to Gregorian calendar, here
public class CalendarConverter implements Converter<Timestamp, GregorianCalendar> {

    // Provide jOOQ with Class<?> objects of <U> and <T>. These are used by
    // jOOQ to discover your converter based on your custom type
    // --------------------------------------------------------------------
    @Override
    public Class<Timestamp> fromType() {
        return Timestamp.class;
    }

    @Override
    public Class<GregorianCalendar> toType() {
        return GregorianCalendar.class;
    }

    // Implement the type conversion methods. Convert your user-defined type
    // "from" the SQL type when reading "from" the database, or "to" the SQL
    // type when writing "to" the database.
    @Override
    public GregorianCalendar from(Timestamp databaseObject) {
        GregorianCalendar calendar = (GregorianCalendar) Calendar.getInstance();
        calendar.setTimeInMillis(databaseObject.getTime());
        return calendar;
    }

    @Override
    public Timestamp to(GregorianCalendar userObject) {
        return new Timestamp(userObject.getTime().getTime());
    }
}
]]></java>

							<p>
								Such a Converter can now be used in various places of the jOOQ
								API, especially when reading data from the database:
							</p>

<java><![CDATA[List<GregorianCalendar> result =
create.select(T_AUTHOR.DATE_OF_BIRTH)
      .from(T_AUTHOR)
      .fetch(0, new CalendarConverter());]]></java>

      						<h3>Using Converters in generated code</h3>
      						<p>
								A more common use-case, however, is to let jOOQ know about custom
								types at code generation time. Use the following configuration elements
								to specify, that you'd like to use GregorianCalendar for all database
								fields that start with DATE_OF_
      						</p>

<xml><![CDATA[<database>
  <!-- First, register your custom types here -->
  <customTypes>
    <customType>
      <!-- Specify the fully-qualified class name of your custom type -->
      <name>java.util.GregorianCalendar</name>

      <!-- Associate that custom type with your converter. Note, a
           custom type can only have one converter in jOOQ -->
      <converter>com.example.CalendarConverter</converter>
    </customType>
  </customTypes>

  <!-- Then, associate custom types with database columns -->
  <forcedTypes>
    <forcedType>
      <!-- Specify again he fully-qualified class name of your custom type -->
      <name>java.util.GregorianCalendar</name>

      <!-- Add a list of comma-separated regular expressions matching columns -->
      <expressions>.*\.DATE_OF_.*</expressions>
    </forcedType>
  </forcedTypes>
</database>]]></xml>

                            <p>
                            	The above configuration will lead to T_AUTHOR.DATE_OF_BIRTH
                            	being generated like this:
                            </p>

<java>public class TAuthor extends UpdatableTableImpl&lt;TAuthorRecord&gt; {

    // [...]
    public final TableField&lt;TAuthorRecord, GregorianCalendar&gt; DATE_OF_BIRTH =    // [...]
    // [...]

}</java>

                            <p>
                            	This means that the bound of &lt;T&gt; will be GregorianCalendar,
                            	wherever you reference DATE_OF_BIRTH. jOOQ will use your custom
                            	converter when binding variables and when fetching data from
                            	<reference class="java.util.ResultSet"/>:
                            </p>

<java><![CDATA[// Get all date of births of authors born after 1980
List<GregorianCalendar> result =
create.selectFrom(T_AUTHOR)
      .where(T_AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
      .fetch(T_AUTHOR.DATE_OF_BIRTH);]]></java>

      						<p>
      						    Read more about advanced code generation configuration in
      						    <reference id="AdvancedConfiguration" title="the manual's section about advanced code generation configuration"/>.
      						</p>

      						<h3>Using Converters for enum types</h3>
      						<p>
      							Java's Enum types can be very useful in SQL too.
      							Some databases support enumeration types natively (MySQL, Postgres).
      							In other cases, you can use the above custom type configuration
      							also to provide jOOQ with Converters for your custom Enum types.
      							Instead of implementing <reference class="org.jooq.Converter"/>,
      							you may choose to extend <reference class="org.jooq.impl.EnumConverter"/>
      							instead, which provides some enum-specific default behaviour.
      						</p>
						</content>
					</section>


					<section id="SchemaMapping">
						<title>Mapping generated schemata and tables</title>
						<content>
							<h3>Mapping your DEV schema to a productive environment</h3>
							<p>You may wish to design your database in a way that you have several
								instances of your schema. This is useful when you want to cleanly
								separate data belonging to several customers / organisation units /
								branches / users and put each of those entities' data in a separate
								database or schema. </p>
							<p>In our T_AUTHOR example this would mean that you provide a book
								reference database to several companies, such as My Book World and
								Books R Us. In that case, you'll probably have a schema setup like
								this: </p>
							<ul>
								<li>DEV: Your development schema. This will be the schema that you
									base code generation upon, with jOOQ </li>
								<li>MY_BOOK_WORLD: The schema instance for My Book World </li>
								<li>BOOKS_R_US: The schema instance for Books R Us </li>
							</ul>


							<h3>Mapping DEV to MY_BOOK_WORLD with jOOQ</h3>
							<p>When a user from My Book World logs in, you want them to access the
								MY_BOOK_WORLD schema using classes generated from DEV. This can be
								achieved with the
								<reference class="org.jooq.conf.RenderMapping"/>
								class, that you can equip your Factory's settings
								with. Take the following example: </p>

<java>Settings settings = new Settings()
    .withRenderMapping(new RenderMapping()
    .withSchemata(
        new MappedSchema().withInput("DEV")
                          .withOutput("MY_BOOK_WORLD")));

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</java>

							<p>The query executed with a Factory equipped with the above mapping
								will in fact produce this SQL statement: </p>
							<sql>SELECT * FROM MY_BOOK_WORLD.T_AUTHOR</sql>
							<p>Even if T_AUTHOR was generated from DEV. </p>

							<h3>Mapping several schemata</h3>
							<p>Your development database may not be restricted to hold only one DEV
								schema. You may also have a LOG schema and a MASTER schema. Let's say
								the MASTER schema is shared among all customers, but each customer has
								their own LOG schema instance. Then you can enhance your RenderMapping
								like this (e.g. using an XML configuration file): </p>

<xml><![CDATA[<settings xmlns="http://www.jooq.org/xsd/jooq-runtime-2.1.0.xsd">
  <renderMapping>
    <schemata>
      <schema>
        <input>DEV</input>
        <output>MY_BOOK_WORLD</output>
      </schema>
      <schema>
        <input>LOG</input>
        <output>MY_BOOK_WORLD_LOG</output>
      </schema>
    </schemata>
  </renderMapping>
</settings>]]></xml>

                            <p>Note, you can load the above XML file like this:</p>

<java>Settings settings = JAXB.unmarshal(new File("jooq-runtime.xml"), Settings.class);</java>

							<p>This will map generated classes from DEV to MY_BOOK_WORLD, from LOG
								to MY_BOOK_WORLD_LOG, but leave the MASTER schema alone. Whenever you
								want to change your mapping configuration, you will have to create a
								new Factory</p>


							<h3>Using a default schema</h3>
							<p>Another option to switch schema names is to use a default schema for
								the Factory's underlying Connection. Many RDBMS support a USE or SET
								SCHEMA command, which you can call like this: </p>

<java>// Set the default schema
Schema MY_BOOK_WORLD = ...
create.use(MY_BOOK_WORLD);

// Run queries with factory having a default schema
create.selectFrom(T_AUTHOR).fetch();</java>
							<p>Queries generated from the above Factory will produce this kind of SQL statement: </p>

<sql>-- the schema name is omitted from all SQL constructs.
SELECT * FROM T_AUTHOR</sql>

                            <p>If you wish not to render any schema name at all, use the
                                following Settings property for this:</p>


<java>Settings settings = new Settings()
    .withRenderSchema(false);

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries that omit rendering schema names
create.selectFrom(T_AUTHOR).fetch();</java>

							<h3>Mapping of tables</h3>
							<p>Not only schemata can be mapped, but also tables. If you are not the
								owner of the database your application connects to, you might need to
								install your schema with some sort of prefix to every table. In our
								examples, this might mean that you will have to map DEV.T_AUTHOR to
								something MY_BOOK_WORLD.MY_APP__T_AUTHOR, where MY_APP__ is a prefix
								applied to all of your tables. This can be achieved by creating the
								following mapping: </p>

<java>Settings settings = new Settings()
    .withRenderMapping(new RenderMapping()
    .withSchemata(
        new MappedSchema().withInput("DEV")
                          .withOutput("MY_BOOK_WORLD")
                          .withTables(
         new MappedTable().withInput("T_AUTHOR")
                          .withOutput("MY_APP__T_AUTHOR"))));

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries with the "mapped" factory
create.selectFrom(T_AUTHOR).fetch();</java>

							<p>The query executed with a Factory equipped with the above mapping will in fact produce this SQL statement: </p>
<sql>SELECT * FROM MY_BOOK_WORLD.MY_APP__T_AUTHOR</sql>

							<h3>Mapping at code generation time</h3>
							<p>
								Note that you can also hard-wire schema mapping in generated artefacts
								at code generation time, e.g. when you have 5 developers with their own
								dedicated developer databases, and a common integration database. In the
								code generation configuration, you would then write.
							</p>
<xml><![CDATA[<schemata>
  <schema>
    <!-- Use this as the developer's schema: -->
    <inputSchema>LUKAS_DEV_SCHEMA</inputSchema>

    <!-- Use this as the integration / production database: -->
    <outputSchema>PROD</outputSchema>
  </schema>
</schemata>]]></xml>
							<p>
								See the manual's section about
								<reference id="META" title="jooq-codegen configuration"/>
								for more details
							</p>
						</content>
					</section>


					<section id="ExecuteListener">
						<title>Execute listeners and the jOOQ Console</title>
						<content>
							<h3>ExecuteListener</h3>
							<p>
								The <reference id="Factory" title="jOOQ Factory Settings"/>
								let you specify a list of <reference class="org.jooq.ExecuteListener"/> classes.
								The ExecuteListener is essentially an event listener for
								Query, Routine, or ResultSet render, prepare, bind, execute, fetch steps. It is a
								base type for loggers, debuggers, profilers, data collectors. Advanced ExecuteListeners
								can also provide custom implementations of Connection, PreparedStatement and ResultSet
								to jOOQ in apropriate methods. For convenience, consider extending
								<reference class="org.jooq.impl.DefaultExecuteListener"/>
								instead of implementing this interface.
							</p>
							<p>
								Here is a sample implementation of an ExecuteListener, that is simply counting
								the number of queries per type that are being executed using jOOQ:
							</p>

<java><![CDATA[package com.example;

public class StatisticsListener extends DefaultExecuteListener {
    public static Map<ExecuteType, Integer> STATISTICS = new HashMap<ExecuteType, Integer>();

    // Count "start" events for every type of query executed by jOOQ
    @Override
    public void start(ExecuteContext ctx) {
        Integer count = STATISTICS.get(ctx.type());

        if (count == null) {
            count = 0;
        }

        STATISTICS.put(ctx.type(), count + 1);
    }
}]]></java>

							<p>
								Now, configure jOOQ's runtime to load your listener
							</p>

<xml><![CDATA[<settings>
  <executeListeners>
    <executeListener>com.example.StatisticsListener</executeListener>
  </executeListeners>
</settings>]]></xml>

							<p>
								And log results any time with a snippet like this:
							</p>

<java><![CDATA[log.info("STATISTICS");
log.info("----------");

for (ExecuteType type : ExecuteType.values()) {
    log.info(type.name(), StatisticsListener.STATISTICS.get(type) + " executions");
}]]></java>
                            <p>
                            	This may result in the following log output:
                            </p>

<config>15:16:52,982  INFO - TEST STATISTICS
15:16:52,982  INFO - ---------------
15:16:52,983  INFO - READ                     : 919 executions
15:16:52,983  INFO - WRITE                    : 117 executions
15:16:52,983  INFO - DDL                      : 2 executions
15:16:52,983  INFO - BATCH                    : 4 executions
15:16:52,983  INFO - ROUTINE                  : 21 executions
15:16:52,983  INFO - OTHER                    : 30 executions</config>
							<p>
								Please read the
								<a href="http://www.jooq.org/javadoc/latest/org/jooq/ExecuteListener.html" title="ExecuteListener Javadoc">ExecuteListener Javadoc</a>
								for more details
							</p>

							<h3>jOOQ Console</h3>
							<p>
							    The ExecuteListener API was driven by a feature request by Christopher Deckers, who has
							    had the courtesy to contribute the jOOQ Console, a sample application interfacing
							    with jOOQ's ExecuteListeners. The jOOQ Console logs all queries executed by jOOQ and
							    displays them nicely in a Swing application. With the jOOQ Console's logger, you can:
						    </p>
						    <ul>
						    	<li>Activate the console's DebugListener anytime (in-process or if the remote server is active).</li>
						    	<li>View simple and batch queries and their parameters.</li>
						    	<li>Reformat queries along with syntax highlighting for better readability.</li>
						    	<li>View stack trace of originator of the call.</li>
						    	<li>Dump the stack to stdout when in an IDE, to directly navigate to relevant classes.</li>
						    	<li>Track execution time, binding time, parsing time, rows read, fields read.</li>
						    	<li>Show/hide queries depending on their type (SELECT, UPDATE, etc.).</li>
						    	<li>Sort any column (timing columns, queries, types, etc.)</li>
						    	<li>Easy copy paste of rows/columns to Spreadsheet editors.</li>
						    </ul>

						    <p>
						    	A short overview of such a debugging session can be seen here:
						    </p>
   							<div class="screenshot">
								<img class="screenshot" src="&lt;?=$root?&gt;/img/jooq-console-01.png" alt="jOOQ Console example"/>
							</div>
						    <p>
							    Please note that the jOOQ Console is still experimental.
							    Any feedback is very welcome on
							    <a href="http://groups.google.com/group/jooq-user" title="the jooq-user group">the jooq-user group</a>
							</p>
							<h3>jOOQ Console operation modes</h3>
							<p>
								The jOOQ Console can be run in two different modes:
							</p>
							<ul>
								<li>In-process mode: running in the same process as the queries you're analysing</li>
								<li>"headless" mode: running remotely</li>
							</ul>

							<p>
								Both modes will require that you set the
								<reference class="org.jooq.debug.DebugListener"/>
								in the Factory's settings. When using XML settings:
							</p>

<xml><![CDATA[<settings>
  <executeListeners>
    <executeListener>org.jooq.debug.DebugListener</executeListener>
  </executeListeners>
</settings>]]></xml>

							<p>
								Or when using programmatic settings:
							</p>
<java><![CDATA[Settings settings = new Settings()
    .getExecuteListeners().add("org.jooq.debug.DebugListener");
Factory factory = new Factory(connection, dialect, settings);]]></java>

							<h3>In-process mode</h3>
							<p>
								The in-process mode is useful for Swing applications or other,
								locally run Java programs accessing the database via jOOQ.
								In order to launch the jOOQ Console "in-process", specify the
								previously documented settings and launch the Console as follows:
							</p>

<java><![CDATA[// Define a DatabaseDescriptor for the "in-process" mode
// It is needed for the "Editor" tab
DatabaseDescriptor descriptor = new DatabaseDescriptor() {

    // Return your generated schema. This is used by the console
    // to introspect your schema data
    @Override
    public Schema getSchema() {
        return com.example.MySchema.MY_SCHEMA;
    }

    // Return the SQL dialect that you're using
    @Override
    public SQLDialect getSQLDialect() {
        return SQLDialect.ORACLE;
    }

    // Return a connection
    @Override
    public Connection createConnection() {
        try {
            return DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "test", "test");
        }
        catch (Exception ignore) {}
    }
};

// Now pass this database descriptor to the Console and make it visible
try {

    // Use this for a nicer look-and-feel
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());

    // Create a new Console
    Console console = new Console(descriptor, true);
    console.setLoggingActive(true);
    console.setVisible(true);
}
catch (Exception ignore) {}
]]></java>

							<p>
								Only in the in-process mode, you can execute ad-hoc queries directly
								from the console, if you provide it with proper DatabaseDescriptor.
								These queries are executed from the Editor pane which features:
							</p>
							<ul>
								<li>SQL editing within the console.</li>
								<li>Incremental search on tables.</li>
								<li>Simple code completion with tables/columns/SQL keywords.</li>
								<li>Syntax highlighting and formatting capabilities.</li>
								<li>Results shown in one or several tabs.</li>
								<li>Easy analysis of Logger output by copy/pasting/running queries in the Editor.</li>
							</ul>
   							<div class="screenshot">
								<img class="screenshot" src="&lt;?=$root?&gt;/img/jooq-console-02.png" alt="jOOQ Console example"/>
							</div>

                            <h3>"Headless" mode</h3>
							<p>
								In J2EE or other server/client environments, you may not be able
								to run the console in the same process as your application. You
								can then run the jOOQ Console in "headless" mode. In addition to
								the previously documented settings, you'll have to start a
								debugger server in your application process, that the console can
								connect to:
							</p>

<java>// Create a new RemoteDebuggerServer in your application that listens to
// incoming connections on a given port
SERVER = new RemoteDebuggerServer(DEBUGGER_PORT);</java>

							<p>
								Now start your application along with the debugger server
								and launch the console with this command:
							</p>

<config>java -jar jooq-console-2.1.0.jar [host] [port]</config>

							<p>
								Depending on your distribution, you may have to manually add
								rsyntaxtextarea-1.5.0.jar and jOOQ artefacts on your classpath.
							</p>
						</content>
					</section>


					<section id="OracleHints">
						<title>Adding Oracle hints to queries</title>
						<content>
							<h3>How to embed Oracle hints in SELECT</h3>
							<p>If you are closely coupling your application to an Oracle (or CUBRID) database,
								you might need to be able to pass hints of the form /*+HINT*/ with
								your SQL statements to the Oracle database. For example: </p>
<sql>SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM T_AUTHOR</sql>

  							<p>This can be done in jOOQ using the .hint() clause in your SELECT statement: </p>
<java>create.select(FIRST_NAME, LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(T_AUTHOR);</java>

							<p>Note that you can pass any string in the .hint() clause. If you use
								that clause, the passed string will always be put in between the
								SELECT [DISTINCT] keywords and the actual projection list </p>
						</content>
					</section>


					<section id="CONNECTBY">
						<title>The Oracle CONNECT BY clause</title>
						<content>
							<h3>CONNECT BY .. STARTS WITH</h3>
							<p>If you are closely coupling your application to an Oracle (or CUBRID) database,
								you can take advantage of some Oracle-specific features, such as the
								CONNECT BY clause, used for hierarchical queries. The formal syntax
								definition is as follows: </p>

<sql>--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</sql>
							<p>This can be done in jOOQ using the .connectBy(Condition) clauses in your SELECT statement: </p>
<java>// Some Oracle-specific features are only available
// from the OracleFactory
OracleFactory create = new OracleFactory(connection);

// Get a table with elements 1, 2, 3, 4, 5
create.select(create.rownum())
      .connectBy(create.level().lessOrEqual(5))
      .fetch();</java>

							<p>Here's a more complex example where you can recursively fetch
								directories in your database, and concatenate them to a path:</p>
<java><![CDATA[ OracleFactory ora = new OracleFactory(connection);

 List<?> paths =
 ora.select(ora.sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
    .from(DIRECTORY)
    .connectBy(ora.prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
    .startWith(DIRECTORY.PARENT_ID.isNull())
    .orderBy(ora.literal(1))
    .fetch(0);]]></java>

    						<p>The output might then look like this</p>
<text>+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</text>
						</content>
					</section>


				    <section id="PIVOT">
				    	<title>The Oracle 11g PIVOT clause</title>
						<content>
							<h3>PIVOT (aggregate FOR column IN (columns))</h3>
							<p>If you are closely coupling your application to an Oracle database,
								you can take advantage of some Oracle-specific features, such as the
								PIVOT clause, used for statistical analyses. The formal syntax
								definition is as follows: </p>
<sql>-- SELECT ..
     FROM table PIVOT (aggregateFunction [, aggregateFunction] FOR column IN (expression [, expression]))
--  WHERE ..</sql>

							<p>
								The PIVOT clause is available from the
								<reference class="org.jooq.Table"/>
								type, as pivoting is done directly on a table.
								Currently, only Oracle's PIVOT clause is supported. Support for SQL Server's
								PIVOT clause will be added later. Also, jOOQ may simulate PIVOT for other
								dialects in the future.
							</p>
						</content>
				    </section>


				    <section id="DIVISION">
				    	<title>jOOQ's relational division syntax</title>
						<content>
							<h3>Relational division</h3>
							<p>
							    There is one operation in relational algebra that is not given
							    a lot of attention, because it is rarely used in real-world
							    applications. It is the relational division, the opposite operation
							    of the cross product (or, relational multiplication).
								The following is an approximate definition of a relational division:
							</p>

<config>Assume the following cross join / cartesian product
C = A × B

Then it can be said that
A = C ÷ B
B = C ÷ A</config>


							<p>
							   With jOOQ, you can simplify using relational divisions
							   by using the following syntax:
							</p>

<java>C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT)</java>

							<p>The above roughly translates to</p>

<sql>SELECT DISTINCT C.TEXT FROM C "c1"
WHERE NOT EXISTS (
  SELECT 1 FROM B
  WHERE NOT EXISTS (
    SELECT 1 FROM C "c2"
    WHERE "c2".TEXT = "c1".TEXT
    AND "c2".ID = B.C_ID
  )
)</sql>

							<p>
								Or in plain text: Find those TEXT values in C
								whose ID's correspond to all ID's in B. Note
								that from the above SQL statement, it is immediately
								clear that proper indexing is of the essence.
								Be sure to have indexes on all columns referenced
								from the on(...) and returning(...) clauses.
							</p>

							<p>
								For more information about relational division
								and some nice, real-life examples, see
							</p>

							<ul>
								<li>
									<a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" title="Wikipedia article on relational division">http://en.wikipedia.org/wiki/Relational_algebra#Division</a>
								</li>
								<li>
									<a href="http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" title="A nice summary of what relational division is and how it is best implemented in SQL">http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a>
								</li>
							</ul>
						</content>
				    </section>


					<section id="Export">
						<title>Exporting to XML, CSV, JSON, HTML, Text</title>
						<content>
							<h3>Exporting with jOOQ</h3>
							<p>If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's exporting
								functionality (see also importing functionality). You can export any
								Result&lt;Record&gt; into any of these formats: </p>

							<h3>XML</h3>
							<p>Export your results as XML: </p>
<java>// Fetch books and format them as XML
String xml = create.selectFrom(T_BOOK).fetch().formatXML();</java>

							<p>The above query will result in an XML document looking like the following one: </p>
<xml><![CDATA[<!-- Find the XSD definition on www.jooq.org: -->
<jooq-export:result xmlns:jooq-export="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">
  <fields>
    <field name="ID"/>
    <field name="AUTHOR_ID"/>
    <field name="TITLE"/>
  </fields>
  <records>
    <record>
      <value field="ID">1</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">1984</value>
    </record>
    <record>
      <value field="ID">2</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">Animal Farm</value>
    </record>
  </records>
</jooq-export:result>]]></xml>

							<h3>CSV</h3>
							<p>Export your results as CSV: </p>
<java>// Fetch books and format them as CSV
String csv = create.selectFrom(T_BOOK).fetch().formatCSV();</java>

							<p>The above query will result in a CSV document looking like the following one: </p>
<text>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</text>


							<h3>JSON</h3>
							<p>Export your results as JSON: </p>

<java>// Fetch books and format them as JSON
String json = create.selectFrom(T_BOOK).fetch().formatJSON();</java>
							<p>The above query will result in a JSON document looking like the following one: </p>
<text>{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</text>

 							<h3>HTML </h3>
 							<p>Export your results as HTML: </p>
<java>// Fetch books and format them as HTML
String html = create.selectFrom(T_BOOK).fetch().formatHTML();</java>
							<p>The above query will result in an HTML document looking like the following one: </p>
<xml><![CDATA[<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>AUTHOR_ID</th>
      <th>TITLE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1984</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>Animal Farm</td>
    </tr>
  </tbody>
</table>]]></xml>

							<h3>Text</h3>
							<p>Export your results as text: </p>
<java>// Fetch books and format them as text
String text = create.selectFrom(T_BOOK).fetch().format();</java>

							<p>The above query will result in a text document looking like the following one: </p>
<text>+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</text>
						</content>
					</section>


					<section id="Import">
						<title>Importing data from XML, CSV</title>
						<content>
							<h3>Importing with jOOQ</h3>
							<p>If you are using jOOQ for scripting purposes or in a slim, unlayered
								application server, you might be interested in using jOOQ's importing
								functionality (see also exporting functionality). You can import data
								directly into a table from any of these formats: </p>

							<h3>CSV</h3>
							<p>The below CSV data represents two author records that may have been
								exported previously, by jOOQ's exporting functionality, and then
								modified in Microsoft Excel or any other spreadsheet tool: </p>

<text>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</text>

							<p>With jOOQ, you can load this data using various parameters from the
								loader API. A simple load may look like this: </p>

<java>Factory create = new Factory(connection, SQLDialect.ORACLE);

// Load data into the T_AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</java>

      						<p>Here are various other examples: </p>
<java>// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(T_AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(T_AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</java>

							<p>Any of the above configuration methods can be combined to achieve
								the type of load you need. Please refer to the API's Javadoc to learn
								about more details. Errors that occur during the load are reported by
								the execute method's result: </p>

<java><![CDATA[Loader<TAuthor> loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();

// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();

// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();

// The errors that may have occurred during loading
List<LoaderError> errors = loader.errors();
LoaderError error = errors.get(0);

// The exception that caused the error
SQLException exception = error.exception();

// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();

// The query that caused the error
Query query = error.query();]]></java>

							<h3>XML </h3>
							<p>This will be implemented soon... </p>
						</content>
					</section>


					<section id="Batch">
						<title>Using JDBC batch operations</title>
						<content>
							<h3>JDBC batch operations</h3>
							<p>With JDBC, you can easily execute several statements at once using
								the addBatch() method. Essentially, there are two modes in JDBC</p>

							<ol>
								<li>Execute several queries without bind values</li>
								<li>Execute one query several times with bind values</li>
							</ol>

							<p>In code, this looks like the following snippet:</p>
<java><![CDATA[// 1. several queries
// ------------------
Statement stmt = connection.createStatement();
stmt.addBatch("INSERT INTO author VALUES (1, 'Erich Gamma')");
stmt.addBatch("INSERT INTO author VALUES (2, 'Richard Helm')");
stmt.addBatch("INSERT INTO author VALUES (3, 'Ralph Johnson')");
stmt.addBatch("INSERT INTO author VALUES (4, 'John Vlissides')");
int[] result = stmt.executeBatch();

// 2. a single query
// -----------------
PreparedStatement stmt = connection.prepareStatement("INSERT INTO autho VALUES (?, ?)");
stmt.setInt(1, 1);
stmt.setString(2, "Erich Gamma");
stmt.addBatch();

stmt.setInt(1, 2);
stmt.setString(2, "Richard Helm");
stmt.addBatch();

stmt.setInt(1, 3);
stmt.setString(2, "Ralph Johnson");
stmt.addBatch();

stmt.setInt(1, 4);
stmt.setString(2, "John Vlissides");
stmt.addBatch();

int[] result = stmt.executeBatch();]]></java>


							<h3>This will also be supported by jOOQ</h3>
							<p>jOOQ supports executing queries in batch
								mode as follows:</p>
<java><![CDATA[// 1. several queries
// ------------------
create.batch(
	create.insertInto(AUTHOR, ID, NAME).values(1, "Erich Gamma"),
	create.insertInto(AUTHOR, ID, NAME).values(2, "Richard Helm"),
	create.insertInto(AUTHOR, ID, NAME).values(3, "Ralph Johnson"),
	create.insertInto(AUTHOR, ID, NAME).values(4, "John Vlissides"))
.execute();

// 2. a single query
// -----------------
create.batch(create.insertInto(AUTHOR, ID, NAME).values("?", "?"))
	  .bind(1, "Erich Gamma")
	  .bind(2, "Richard Helm")
	  .bind(3, "Ralph Johnson")
	  .bind(4, "John Vlissides")
	  .execute();]]></java>
						</content>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>
