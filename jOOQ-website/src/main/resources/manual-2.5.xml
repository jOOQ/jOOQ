<?xml version="1.0" encoding="UTF-8"?>
<manual>
	<section id="manual">
		<title>The jOOQ User Manual. Multiple Pages</title>
		<content>
			<h2 id="Overview"><a href="#Overview" name="Overview">#</a> Overview</h2>
			<p>This manual is divided into six main sections:</p>

			<ul>
				<li>
					<reference id="getting-started"/>
					<p>
						This section will get you started with jOOQ quickly. It contains
						simple explanations about what jOOQ is, what jOOQ isn't and how
						to set it up for the first time
					</p>
				</li>
				<li>
					<reference id="sql-building"/>
					<p>
						This section explains all about the jOOQ syntax used for building
						queries. It explains the central factories, the supported SQL
						statements and various other syntax elements
					</p>
				</li>
				<li>
					<reference id="code-generation"/>
					<p>
						This section explains how to configure and use the built-in source code
						generator
					</p>
				</li>
				<li>
					<reference id="sql-execution"/>
					<p>
						This section will get you through the specifics of what can be done
						with jOOQ at runtime, in order to execute queries, perform CRUD
						operations, import and export data, and hook into the jOOQ execution
						lifecycle for debugging
					</p>
				</li>
				<li>
					<reference id="tools"/>
					<p>
						This section is dedicated to tools that ship with jOOQ, such as the
						jOOQ console
					</p>
				</li>
				<li>
					<reference id="reference"/>
					<p>
						This section is a reference for elements in this manual
					</p>
				</li>
			</ul>
		</content>

		<sections>
			<section id="getting-started">
				<title>Getting started with jOOQ</title>
				<content>
				</content>

				<sections>
					<section id="the-manual">
					    <title>How to read this manual</title>
						<content>
						</content>
					</section>

					<section id="the-sample-database">
					    <title>The sample database used in this manual</title>
						<content>
							<h3>Example CREATE TABLE statements</h3>
							<p>
							For the examples in this manual, the same database will always be referred to. It essentially consists of these entities created using the Oracle dialect
							</p>
<sql>CREATE TABLE t_language (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  cd CHAR(2) NOT NULL,
  description VARCHAR2(50)
)

CREATE TABLE t_author (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50) NOT NULL,
  date_of_birth DATE,
  year_of_birth NUMBER(7)
)

CREATE TABLE t_book (
  id NUMBER(7) NOT NULL PRIMARY KEY,
  author_id NUMBER(7) NOT NULL,
  title VARCHAR2(400) NOT NULL,
  published_in NUMBER(7) NOT NULL,
  language_id NUMBER(7) NOT NULL,
  FOREIGN KEY (AUTHOR_ID) REFERENCES T_AUTHOR(ID),
  FOREIGN KEY (LANGUAGE_ID) REFERENCES T_LANGUAGE(ID)
)

CREATE TABLE t_book_store (
  name VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE t_book_to_book_store (
  book_store_name VARCHAR2(400) NOT NULL,
  book_id INTEGER NOT NULL,
  stock INTEGER,
  PRIMARY KEY(book_store_name, book_id),
  CONSTRAINT b2bs_book_store_id
    FOREIGN KEY (book_store_name)
    REFERENCES t_book_store (name)
    ON DELETE CASCADE,
  CONSTRAINT b2bs_book_id
    FOREIGN KEY (book_id)
    REFERENCES t_book (id)
    ON DELETE CASCADE
)</sql>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc), stored procedures and packages are introduced for specific examples
							</p>
						</content>
					</section>

					<section id="use-cases">
						<title>Different use cases for jOOQ</title>
						<content>
						</content>

						<sections>
							<section id="jooq-as-a-standalone-sql-builder">
								<title>jOOQ as a SQL builder</title>
								<content></content>
							</section>

							<section id="jooq-as-a-sql-builder-with-code-generation">
								<title>jOOQ as a SQL builder with code generation</title>
								<content></content>
							</section>

							<section id="jooq-as-a-sql-executor">
								<title>jOOQ as a SQL executor</title>
								<content></content>
							</section>

							<section id="jooq-for-crud">
								<title>jOOQ for CRUD</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="tutorials">
						<title>Tutorials</title>
						<content></content>

						<sections>
							<section id="jooq-in-6-steps">
								<title>jOOQ in 6 easy steps</title>
								<content></content>
							</section>

							<section id="jooq-in-modern-ides">
								<title>Using jOOQ in modern IDEs</title>
								<content></content>
							</section>

							<section id="jooq-with-spring">
								<title>Using jOOQ with Spring</title>
								<content></content>
							</section>

							<section id="a-simple-web-application">
								<title>A simple web application with jOOQ</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="sql-building">
				<title>SQL building</title>
				<content>
					<h3>Overview</h3>
					<p>
					    SQL is a declarative language that is hard to integrate into procedural, object-oriented, functional or any other type of programming languages. jOOQ's philosophy is to give SQL the credit it deserves and integrate SQL itself as an <a href="http://en.wikipedia.org/wiki/Domain_Specific_Language">"internal domain specific language"</a> directly into Java.
					</p>
					<p>
						With this philosophy in mind, SQL building is the main feature of jOOQ. All other features (such as <reference id="sql-execution"/> and <reference id="code-generation"/>) are mere convenience built on top of jOOQ's SQL building capabilities.
					</p>
					<p>
						This section explains all about the various syntax elements involved with jOOQ's SQL building capabilities. For a complete overview of all syntax elements, please refer to the manual's section about <reference id="reference-bnf-notation"/>
					</p>
				</content>

				<sections>
					<section id="factory">
						<title>The Factory class</title>
						<content>
							<h3>The Factory and the jOOQ API</h3>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts from client code. The reasons for this are:
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> class is the main class from where you will create all jOOQ objects.	The Factory serves two types of purposes:
							</p>
							<ol>
								<li>It serves as a static factory for <reference id="table-expressions" title="table expressions"/>, <reference id="column-expressions" title="column expressions"/> (or "fields"), <reference id="conditional-expressions" title="conditional expressions"/> and many other <reference id="queryparts" title="QueryParts"/>.</li>
								<li>It implements <reference class="org.jooq.Configuration"/>, an object that configures jOOQ's behaviour when executing queries (see <reference id="sql-execution"/> for more details). Factories allow for creating <reference id="sql-statements" title="SQL statements"/> that are already "configured" and ready for execution.</li>
							</ol>

							<h3>The static Factory API</h3>
							<p>
								With jOOQ 2.0, static factory methods have been introduced in order to make client code look more like SQL. Ideally, when working with jOOQ, you will simply static import all methods from the Factory class:
							</p>
							<java>import static org.jooq.impl.Factory.*;</java>
							<p>
							    Note, that when working with Eclipse, you could also add the Factory to your favourites. This will allow to access functions even more fluently:
							</p>
<java>concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</java>

							<h3>The Factory as a Configuration object</h3>
							<p>
							    As any Configuration object, a Factory can be supplied with these objects:
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : The dialect of your database. This may be any of the currently supported database types (see <reference id="sql-dialect"/> for more details)</li>
								<li><reference class="java.sql.Connection"/> : An optional JDBC Connection that will be re-used for the whole lifecycle of your Factory (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="java.sql.DataSource"/> : An optional JDBC DataSource that will be re-used for the whole lifecycle of your Factory. If you prefer using DataSources over Connections, jOOQ will internally fetch new Connections from your DataSource, conveniently closing them again after query execution. This is particularly useful in J2EE or Spring contexts (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="org.jooq.conf.Settings"/> : An optional runtime configuration (see <reference id="custom-settings"/> for more details)</li>
							</ul>
							<p>
								As a Configuration object, a Factory can construct <reference id="sql-statements" title="statements"/>, for later <reference id="sql-execution" title="execution"/>. An example is given here:
							</p>
<java><![CDATA[// The Factory is "configured" with a Connection and a SQLDialect
Factory create = new Factory(connection, dialect);

// This select statement contains an internal reference to the Factory:
Select<?> select = create.selectOne();

// Using the internally referenced Factory, the select statement can now be executed:
Result<?> result = select.fetch();]]></java>
						</content>

						<sections>
							<section id="sql-dialect">
								<title>SQL Dialect</title>
								<content>
									<h3>The SQL dialect corresponding to your database</h3>
									<p>
										While jOOQ tries to represent the SQL standard as much as possible, many features are vendor-specific to a given database and to its "SQL dialect". jOOQ models this using the <reference class="org.jooq.SQLDialect"/> enum type.
									</p>
									<p>
										The SQL dialect is one of the main attributes of a <reference id="factory" title="Factory"/>. Queries created from such factories will assume dialect-specific behaviour when <reference id="sql-rendering" title="rendering SQL"/> and <reference id="variable-binding" title="binding bind values"/>.
									</p>
									<p>
										Some parts of the jOOQ API are officially supported only by a given subset of the supported SQL dialects. For instance, the <reference id="connect-by-clause" title="Oracle CONNECT BY clause"/>, which is supported by the Oracle and CUBRID databases, is annotated with a <reference class="org.jooq.Support"/> annotation, as such:
									</p>
<java><![CDATA[/**
 * Add an Oracle-specific <code>CONNECT BY</code> clause to the query
 */
@Support({ CUBRID, ORACLE })
SelectConnectByConditionStep connectBy(Condition condition);]]></java>
									<p>
									    jOOQ API methods which are not annotated with the <reference class="org.jooq.Support"/> annotation, or which are annotated with the Support annotation, but without any SQL dialects can be safely used in all SQL dialects. An example for this is the <reference id="select-statement" title="SELECT statement"/> factory method:
									</p>
<java><![CDATA[/**
 * Create a new DSL select statement.
 */
@Support
SelectSelectStep select(Field<?>... fields);]]></java>

									<h3>jOOQ and the Oracle SQL dialect</h3>
									<p>
										Oracle SQL is much more expressive than many other SQL dialects. It features many unique keywords, clauses and functions that are out of scope for the SQL standard. Some examples for this are
									</p>
									<ul>
										<li>The <reference id="connect-by-clause" title="CONNECT BY clause"/>, for hierarchical queries</li>
										<li>The <reference id="pivot-tables" title="PIVOT"/> keyword for creating PIVOT tables</li>
										<li><reference id="oracle-packages" title="Packages"/>, <reference id="oracle-member-procedures" title="object-oriented user-defined types, member procedures"/> as described in the section about <reference id="stored-procedures" title="stored procedures and functions"/></li>
										<li>Advanced analytical functions as described in the section about <reference id="window-functions" title="window functions"/></li>
									</ul>

									<p>
										jOOQ has a historic affinity to Oracle's SQL extensions. If something is supported in Oracle SQL, it has a high probability of making it into the jOOQ API
									</p>
								</content>
							</section>

							<section id="connection-vs-datasource">
								<title>Connection vs. DataSource</title>
								<content>
									<h3>Interact with JDBC Connections</h3>
									<p>
										While you can use jOOQ for <reference id="sql-building" title="SQL building"/> only, you can also run queries against a JDBC <reference class="java.sql.Connection"/>. Internally, jOOQ creates <reference class="java.sql.Statement"/> or <reference class="java.sql.PreparedStatement"/> objects from such a Connection, in order to execute statements. The normal operation mode is to provide a <reference id="factory" title="Factory"/> with a JDBC Connection, whose lifecycle you will control yourself. This means that jOOQ will not actively close connections, rollback or commit transactions.
									</p>
									<h3>Interact with JDBC DataSources</h3>
									<p>
										If you're in a J2EE or Spring context, however, you may wish to use a <reference class="javax.sql.DataSource"/> instead. Currently, Connections obtained from such a DataSource will be closed after query execution by jOOQ. The semantics of such a close operation should be the returning of the connection into a connection pool, not the actual closing of the underlying physical connection. Typically, this makes sense in an environment using distributed JTA transactions. An example of using DataSources with jOOQ can be seen in the tutorial section about <reference id="jooq-with-spring" title="using jOOQ with Spring"/>.
									</p>
								</content>
							</section>

							<section id="custom-settings">
								<title>Custom Settings</title>
								<content>
									<h3>Factory settings</h3>
									<p>
										The jOOQ Factory allows for some optional configuration elements to be used by advanced users. The <reference class="org.jooq.conf.Settings" /> class is a JAXB-annotated type, that can be provided to a Factory in several ways:
									</p>
									<ul>
										<li>In the constructor. This will override default settings below</li>
										<li>From a location specified by a JVM parameter: -Dorg.jooq.settings</li>
										<li>From the classpath at /jooq-settings.xml</li>
										<li>From the settings defaults, as specified in <a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a></li>
									</ul>
									<h3>Example</h3>
									<p>
										For example, if you want to indicate to jOOQ, that it should inline all bind variables, and execute static <reference class="java.sql.Statement"/> instead of binding its variables to <reference class="java.sql.PreparedStatement"/>, you can do so by using the following Factory:
									</p>
<java><![CDATA[Settings settings = new Settings();
settings.setStatementType(StatementType.STATIC_STATEMENT);
Factory create = new Factory(connection, dialect, settings);]]></java>
									<p>
										Subsequent sections of the manual contain some more in-depth explanations about these settings:
									</p>
									<ul>
										<li>
		     								<reference id="schema-mapping" title="Runtime schema and table mapping"/>
		   								</li>
		     							<li>
		     								<reference id="execute-listeners" title="Execute listeners and SQL tracing"/>
		     							</li>
		     							<li>
		     								<reference id="optimistic-locking" title="Execute CRUD with optimistic locking enabled"/>
		     							</li>
		     							<li>
		     								<reference id="logging" title="Enabling DEBUG logging of all executed SQL"/>
		     							</li>
		   							</ul>
		   							<p>
										Please refer to the jOOQ runtime configuration XSD for more details:<br/>
										<a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a>
									</p>
								</content>
							</section>

							<section id="factory-subclasses">
								<title>Factory subclasses</title>
								<content>
									<p>
										There are a couple of subclasses for the general Factory. Each SQL dialect has its own dialect-specific factory. For instance, if you're only using the MySQL dialect, you can choose to create a new Factory using any of the following types:
									</p>
<java>// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</java>
									<p>
										The advantage of using a dialect-specific Factory lies in the fact,	that you have access to more proprietary RDMBS functionality. This may include:
									</p>
									<ul>
		    							<li>MySQL's encryption functions</li>
		    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
									</ul>
									<p>
										Another type of Factory subclasses are each generated schema's factories. If you generate your schema TEST, then you will have access to a TestFactory. By default, such a schema-specific Factory will not render the schema name.
									</p>
								</content>
							</section>
						</sections>
					</section>

					<section id="sql-statements">
						<title>SQL Statements</title>
						<content>
							<h3>SQL statements as understood by jOOQ</h3>
							<p>
								jOOQ currently supports 6 types of SQL statements. All of these statements are constructed from a Factory instance with an optional <reference id="connection-vs-datasource" title="JDBC Connection or DataSource"/>. If supplied with a Connection or DataSource, they can be executed. Depending on the <reference id="query-vs-resultquery" title="query type"/>, executed queries can return results.
							</p>
						</content>

						<sections>
							<section id="dsl-and-non-dsl">
								<title>jOOQ's DSL and non-DSL API</title>
								<content>
									<h3>The power of jOOQ's DSL API</h3>
									<p>
										jOOQ ships with its own DSL (or	<a href="http://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">Domain Specific Language</a>) that	simulates SQL in Java. This means, that you can	write SQL statements almost as if Java natively supported it, just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a>
									</p>
									<p>
										Here is an example to illustrate what that means:
									</p>
<code-pair><sql><![CDATA[-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:
SELECT *
  FROM t_author a
  JOIN t_book b ON a.id = b.author_id
 WHERE a.year_of_birth > 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title]]></sql>
<java><![CDATA[Result<Record> result =
create.select()
      .from(T_AUTHOR.as("a"))
      .join(T_BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();]]></java></code-pair>

									<p>
										We'll see how the aliasing works later in the section about <reference id="aliasing" title="aliasing"/>
									</p>

									<h3>jOOQ as an internal domain specific language in Java</h3>
									<p>
										Many other frameworks have similar APIs with similar feature sets. Yet, what makes jOOQ special is its informal <reference id="reference-bnf-notation" title="BNF notation"/> modelling a unified SQL dialect suitable for many vendor-specific dialects, and implementing that BNF notation as a hierarchy of interfaces in Java. This concept is extremely powerful, when <reference id="jooq-in-modern-ides" title="using jOOQ in modern IDEs" /> with syntax completion. Not only can you code much faster, your SQL code will be compile-checked to a certain extent. An example of a DSL query equivalent to the previous one is given here:
									</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java>

                         			<p>
                         				Unlike other, simpler frameworks that use <a href="http://en.wikipedia.org/wiki/Fluent_interface">"fluent APIs"</a> or <a href="http://en.wikipedia.org/wiki/Method_chaining">"method chaining"</a>, jOOQ's BNF-based interface hierarchy will not allow bad query syntax. The following will not compile, for instance:
                         			</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                      //  ^^^^ "join" is not possible here
                         .from(AUTHOR)
                         .fetch();

Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .fetch();
                      //  ^^^^^ "on" is missing here

Result<?> result = create.select(rowNumber())
                      //         ^^^^^^^^^ "over()" is missing here
                         .from(AUTHOR)
                         .fetch();]]></java>

									<h3>History of SQL building and incremental query building</h3>
									<p>
										Historically, jOOQ started out as an object-oriented SQL builder library like any other. This meant that all queries and their syntactic components were modeled as so-called <reference id="queryparts" title="QueryParts"/>, which delegate <reference id="sql-rendering" title="SQL rendering"/> and <reference id="variable-binding" title="variable binding"/> to child components. This part of the API will be referred to as the non-DSL API, which is still maintained and used internally by jOOQ for incremental query building. An example of incremental query building is given here:
									</p>
<java><![CDATA[Factory create = new Factory(connection, dialect);
SelectQuery query = create.selectQuery();
query.addFrom(AUTHOR);

// Join books only under certain circumstances
if (join) {
    query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));
}

Result<?> result = query.fetch();]]></java>

									<p>
										This query is equivalent to the one shown before using the DSL syntax. In fact, internally, the DSL API constructs precisely this QueryObject. Note, that you can always access the SelectQuery object to switch between DSL and non-DSL APIs:
									</p>

<java><![CDATA[Factory create = new Factory(connection, dialect);
SelectFinalStep select = create.select().from(AUTHOR);

// Add the JOIN clause on the internal QueryObject representation
SelectQuery query = select.getQuery();
query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java>
								</content>
							</section>

							<section id="select-statement">
								<title>The SELECT statement</title>
								<content>
									<h3>SELECT from ad-hoc table expressions</h3>
									<p>
										When you don't just perform <reference id="crud-with-updatablerecords" title="CRUD"/> (i.e. SELECT * FROM your_table WHERE ID = ?), you're usually generating new record types using custom projections. With jOOQ, this is as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus some extensions, is provided by a query like this:
									</p>
<code-pair>
<sql>-- get all authors' first and last names, and the number
-- of books they've written in German, if they have written
-- more than five books in German in the last three years
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)
    FROM AUTHOR
    JOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_ID
   WHERE BOOK.LANGUAGE = 'DE'
     AND BOOK.PUBLISHED > '2008-01-01'
GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2
  OFFSET 1
     FOR UPDATE</sql>
<java>





Factory create = new Factory(connection, dialect);

create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
      .from(AUTHOR)
      .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
      .where(BOOK.LANGUAGE.equal("DE"))
      .and(BOOK.PUBLISHED.greaterThan(parseDate('2008-01-01')))
      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(1)
      .offset(2)
      .forUpdate();</java>
</code-pair>

									<p>
										Details about the various clauses of this query will be provided in subsequent sections
									</p>

									<h3>SELECT from single physical tables</h3>
									<p>
										A very similar, but limited API is available, if you want to select from single physical tables in order to retrieve <reference id="crud-with-updatablerecords" title="TableRecords or even UpdatableRecords"/>. The decision, which type of select to create is already made at the very first step, when you create the SELECT statement with the Factory:
									</p>

<java><![CDATA[public <R extends Record> SimpleSelectWhereStep<R> selectFrom(Table<R> table);]]></java>
									<p>
										As you can see, there is no way to further restrict/project the selected fields. This just selects all known TableFields in the supplied Table, and it also binds &lt;R extends Record&gt; to your Table's associated Record. An example of such a Query would then be:
									</p>
<java><![CDATA[Book book = create.selectFrom(BOOK)
                  .where(BOOK.LANGUAGE.equal("DE"))
                  .orderBy(BOOK.TITLE)
                  .fetchAny();]]></java>

                   					<p>
                   						The simple SELECT API is limited in the way that it does not support any of these clauses:
                   					</p>
                   					<ul>
                   						<li><reference id="select-clause"/></li>
                   						<li><reference id="join-clause"/></li>
                   						<li><reference id="group-by-clause"/></li>
                   						<li><reference id="having-clause"/></li>
                   					</ul>
                   					<p>
                   						In most parts of this manual, it is assumed that you do not use the simple SELECT API.
                   					</p>
								</content>

								<sections>
									<section id="select-clause">
										<title>The SELECT clause</title>
										<content>
											<h3>The SELECT clause, projecting your own record types</h3>
											<p>
												The SELECT clause lets you project your own record types, referencing table fields, functions, arithmetic expressions, etc. The Factory provides several methods for expressing a SELECT clause:
											</p>

<code-pair><java><![CDATA[// You can provide a varargs Fields list to the SELECT clause:
Select<?> select1 = create.select(BOOK.ID, BOOK.TITLE);
Select<?> select2 = create.select(BOOK.ID, trim(BOOK.TITLE));]]></java>
<sql><![CDATA[

SELECT BOOK.ID, BOOK.TITLE
SELECT BOOK.ID, TRIM(BOOK.TITLE)
]]></sql></code-pair>

											<p>
												Some commonly used projections can be easily created using convenience methods:
											</p>

<code-pair><java><![CDATA[// Select commonly used values
Select<?> select1 = create.selectCount();
Select<?> select2 = create.selectZero();
Select<?> select2 = create.selectOne();]]></java>
<sql><![CDATA[

SELECT COUNT(*)
SELECT 0 -- Not a bind variable
SELECT 1 -- Not a bind variable
]]></sql></code-pair>

											<p>
												See more details about functions and expressions in the manual's section about <reference id="column-expressions"/>
											</p>

											<h3>The SELECT DISTINCT clause</h3>
											<p>
												The DISTINCT keyword can be included in the method name, constructing a SELECT clause
											</p>

<code-pair><java><![CDATA[Select<?> select1 = create.selectDistinct(BOOK.TITLE);]]></java>
<sql><![CDATA[SELECT DISTINCT BOOK.TITLE]]></sql></code-pair>
										</content>
									</section>

									<section id="from-clause">
										<title>The FROM clause</title>
										<content>
											<h3>The FROM clause, allowing to specify a list of table expressions</h3>
											<p>
												The SQL FROM clause allows for specifying any number of <reference id="table-expressions" title="table expressions"/> to select data from. The following are examples of how to form normal FROM clauses:
											</p>

<code-pair>
	<sql><![CDATA[SELECT 1 FROM BOOK
SELECT 1 FROM BOOK, AUTHOR
SELECT 1 FROM BOOK "b", AUTHOR "a"]]></sql>
	<java><![CDATA[create.selectOne().from(BOOK);
create.selectOne().from(BOOK, AUTHOR);
create.selectOne().from(BOOK.as("b"), AUTHOR.as("a"));]]></java>
</code-pair>

											<p>
												Read more about aliasing in the manual's section about <reference id="aliasing" title="aliasing"/>.
											</p>

											<h3>Selecting FROM DUAL with jOOQ</h3>
											<p>
												In many SQL dialects, FROM is a mandatory clause, in some it isn't. jOOQ allows you to omit the FROM clause, returning just one record. An example:
											</p>

<code-pair>
	<sql><![CDATA[SELECT 1 FROM DUAL
SELECT 1]]></sql>
	<java><![CDATA[new Factory(SQLDialect.ORACLE).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES).selectOne().getSQL();]]></java>
</code-pair>

											<p>
												Read more about dual or dummy tables in the manual's section about <reference id="dual" title="the DUAL table"/>. The following are examples of how to form normal FROM clauses:
											</p>
										</content>
									</section>

									<section id="join-clause">
										<title>The JOIN clause</title>
										<content>
											<h3>Complex table expressions using the JOIN clause</h3>
											<p>
												jOOQ supports many different types of standard SQL JOIN operations:
											</p>
											<ul>
												<li>[ INNER ] JOIN</li>
												<li>LEFT [ OUTER ] JOIN</li>
												<li>RIGHT [ OUTER ] JOIN</li>
												<li>FULL OUTER JOIN</li>
												<li>CROSS JOIN</li>
												<li>NATURAL JOIN</li>
												<li>NATURAL LEFT [ OUTER ] JOIN</li>
												<li>NATURAL RIGHT [ OUTER ] JOIN</li>
											</ul>

											<p>
												All of these JOIN methods can be called on <reference class="org.jooq.Table"/> types, or directly after the FROM clause for convenience. The following example joins AUTHOR and BOOK
											</p>

<java><![CDATA[Factory create = new Factory(connection, dialect);

// Call "join" directly on the AUTHOR table
Result<?> result = create.select()
                         .from(AUTHOR.join(BOOK)
                                     .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)))
                         .fetch();

// Call "join" on the type returned by "from"
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java>

											<p>
												The two syntaxes will produce the same SQL statement. However, calling "join" on <reference class="org.jooq.Table"/> objects allows for more powerful, nested JOIN expressions (if you can handle the parentheses):
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN (
  BOOK JOIN BOOK_TO_BOOK_STORE
       ON BOOK_TO_BOOK_STORE.BOOK_ID = BOOK.ID
)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[// Nest joins and provide JOIN conditions only at the end
create.select()
      .from(AUTHOR
      .leftOuterJoin(BOOK
        .join(BOOK_TO_BOOK_STORE)
        .on(BOOK_TO_BOOK_STORE.BOOK_ID.equal(BOOK.ID)))
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)));]]></java></code-pair>

      										<ul>
      											<li>See the section about <reference id="conditional-expressions" title="conditional expressions"/> to learn more about the many ways to create <reference class="org.jooq.Condition"/> objects in jOOQ.</li>
      											<li>See the section about <reference id="table-expressions" title="table expressions"/> to learn about the various ways of referencing <reference class="org.jooq.Table"/> objects in jOOQ</li>
      										</ul>

											<h3>JOIN ON KEY, convenience provided by jOOQ</h3>
											<p>
												Surprisingly, SQL does not allow to formally JOIN on well-known foreign key relationship information. Naturally, when you join BOOK to AUTHOR, you will want to do that based on the BOOK.AUTHOR_ID foreign key to AUTHOR.ID primary key relation. Not being able to do this in SQL leads to a lot of repetitive code, re-writing the same JOIN predicate again and again - especially, when your foreign keys contain more than one column. With jOOQ, when you use <reference id="code-generation" title="code generation"/>, you can use foreign key constraint information in JOIN expressions as such:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
JOIN BOOK ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[create.select()
      .from(AUTHOR)
      .join(BOOK).onKey();]]></java></code-pair>

      										<p>
      											In case of ambiguity, you can also supply field references for your foreign keys, or the generated foreign key reference to the onKey() method.
      										</p>

											<h3>The JOIN USING syntax</h3>
											<p>
												Most often, you will provide jOOQ with JOIN conditions in the JOIN .. ON clause. SQL supports a different means of specifying how two tables are to be joined. This is the JOIN .. USING clause. Instead of a condition, you supply a set of fields whose names are common to both tables to the left and right of a JOIN operation. This can be useful when your database schema has a high degree of <a href="http://en.wikipedia.org/wiki/Database_normalization">relational normalisation</a>. An example:
											</p>

<code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
JOIN BOOK USING (AUTHOR_ID)]]></sql>
<java><![CDATA[

create.select()
      .from(AUTHOR)
      .join(BOOK).using(AUTHOR.AUTHOR_ID);]]></java></code-pair>

											<p>
												In schemas with high degrees of normalisation, you may also choose to use NATURAL JOIN, which takes no JOIN arguments as it joins using all fields that are common to the table expressions to the left and to the right of the JOIN operator. An example:
											</p>

<code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
NATURAL JOIN BOOK]]></sql>
<java><![CDATA[

create.select()
      .from(AUTHOR)
      .naturalJoin(BOOK);]]></java></code-pair>

											<h3>Oracle's partitioned OUTER JOIN</h3>
											<p>
												Oracle SQL ships with a special syntax available for OUTER JOIN clauses. According to the <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_10002.htm#i2196190">Oracle documentation about partitioned outer joins</a> this can be used to fill gaps for simplified analytical calculations. jOOQ only supports putting the PARTITION BY clause to the right of the OUTER JOIN clause. The following example will create at least one record per AUTHOR and per existing value in BOOK.PUBLISHED_IN, regardless if an AUTHOR has actually published a book in that year.
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN BOOK
PARTITION BY (PUBLISHED_IN)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql>
<java><![CDATA[create.select()
      .from(AUTHOR)
      .leftOuterJoin(BOOK)
      .partitionBy(BOOK.PUBLISHED_IN)
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java></code-pair>

										</content>
									</section>

									<section id="where-clause">
										<title>The WHERE clause</title>
										<content>
											<h3>Apply filtering predicates in the WHERE clause</h3>
											<p>
												The WHERE clause can be used for JOIN or filter predicates, in order to restrict the data returned by the <reference id="table-expressions" title="table expressions"/> supplied to the previously specified <reference id="from-clause" title="from clause"/> and <reference id="join-clause" title="join clause"/>. Here is an example:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1))
      .and(BOOK.TITLE.equal("1984"));]]></java></code-pair>

											<p>
												The above syntax is convenience provided by jOOQ, allowing you to connect the <reference class="org.jooq.Condition"/> supplied in the WHERE clause with another condition using an AND operator. You can of course also create a more complex condition and supply that to the WHERE clause directly (observe the different placing of parentheses). The results will be the same:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1).and(
             BOOK.TITLE.equal("1984")));]]></java></code-pair>

											<p>
												You will find more information about creating <reference id="conditional-expressions" title="conditional expressions"/> later in the manual.
											</p>
										</content>
									</section>

									<section id="connect-by-clause">
										<title>The CONNECT BY clause</title>
										<content>
											<h3>Oracle's syntax for creating hierarchical queries</h3>
											<p>
												The Oracle database knows a very succinct syntax for creating hierarchical queries: the CONNECT BY clause, which is fully supported by jOOQ, including all related functions and pseudo-columns. A more or less formal definition of this clause is given here:
											</p>
<sql>--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</sql>

											<p>
												An example for an iterative query, iterating through values between 1 and 5 is this:
											</p>

<code-pair>
<sql><![CDATA[SELECT LEVEL
FROM DUAL
CONNECT BY LEVEL <= 5]]></sql>
<java><![CDATA[// Get a table with elements 1, 2, 3, 4, 5
create.select(level())
      .connectBy(level().lessOrEqual(5));]]></java></code-pair>

											<p>
												Here's a more complex example where you can recursively fetch directories in your database, and concatenate them to a path:
											</p>
<code-pair>
<sql><![CDATA[SELECT SUBSTR(SYS_CONNECT_BY_PATH(DIRECTORY.NAME, '/'), 2)
FROM DIRECTORY
CONNECT BY PRIOR DIRECTORY.ID = DIRECTORY_PARENT_ID
START WITH DIRECTORY.PARENT_ID IS NULL
ORDER BY 1]]></sql>
<java><![CDATA[create.select(sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
      .from(DIRECTORY)
      .connectBy(prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
      .startWith(DIRECTORY.PARENT_ID.isNull())
      .orderBy(one());]]></java>
</code-pair>

    										<p>
    											The output might then look like this
   											</p>

<text>+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</text>

											<p>
												Some of the supported functions and pseudo-columns are these (available from the <reference id="factory" title="Factory"/>):
											</p>

											<ul>
												<li>LEVEL</li>
												<li>CONNECT_BY_IS_CYCLE</li>
												<li>CONNECT_BY_IS_LEAF</li>
												<li>CONNECT_BY_ROOT</li>
												<li>SYS_CONNECT_BY_PATH</li>
												<li>PRIOR</li>
											</ul>

											<p>
												Note that this syntax is also supported in the CUBRID database.
											</p>
										</content>
									</section>

									<section id="group-by-clause">
										<title>The GROUP BY clause</title>
										<content>
											<h3>The GROUP BY clause used for grouping and aggregations</h3>
											<p>
												GROUP BY can be used to create unique groups of data, to form aggregations, to remove duplicates and for other reasons. It will transform your previously defined <reference id="table-expressions" title="set of table expressions"/>, and return only one record per unique group as specified in this clause. For instance, you can group books by BOOK.AUTHOR_ID:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, count())
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair>

											<p>
												As defined in the SQL standard, when grouping, you may no longer project any columns that are not a formal part of the GROUP BY clause, or <reference id="aggregate-functions" title="aggregate functions"/>. The above example counts all books per author
											</p>

											<h3>MySQL's deviation from the SQL standard</h3>
											<p>
												MySQL has a peculiar way of not adhering to this standard behaviour. This is documented in the <a href="http://dev.mysql.com/doc/refman/5.6/en/group-by-hidden-columns.html">MySQL manual</a>. In short, with MySQL, you can also project any other field that are not part of the GROUP BY clause. The projected values will just be arbitrary values from within the group. You cannot rely on any ordering. For example:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
GROUP BY AUTHOR_ID]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair>

											<p>
												This will return an arbitrary title per author. jOOQ supports this syntax, as jOOQ is not doing any checks internally, about the consistence of tables/fields/functions that you provide it.
											</p>

											<h3>ROLLUP(), CUBE() and GROUPING SETS()</h3>
											<p>
												Some databases support the SQL standard grouping functions and some extensions thereof. See the manual's section about <reference id="grouping-functions" title="grouping functions"/> for more details.
											</p>
										</content>
									</section>

									<section id="having-clause">
										<title>The HAVING clause</title>
										<content>
											<h3>Restrict results from the GROUP BY clause using HAVING</h3>
											<p>
												The HAVING clause is commonly used to further restrict data resulting from a previously issued <reference id="group-by-clause" title="GROUP BY clause"/>. An example, selecting only those authors that have written at least two books:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID
HAVING COUNT(*) >= 2]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, count(*))
      .from(BOOK)
      .groupBy(AUTHOR_ID)
      .having(count().greaterOrEqual(2));]]></java></code-pair>

											<p>
												According to the SQL standard, you may omit the GROUP BY clause and still issue a HAVING clause. This will implicitly GROUP BY (). jOOQ also supports this syntax. The following example selects one record, only if there are at least 4 books in the books table:
											</p>

<code-pair>
<sql><![CDATA[SELECT COUNT(*)
FROM BOOK
HAVING COUNT(*) >= 4]]></sql>
<java><![CDATA[create.select(count(*))
      .from(BOOK)
      .having(count().greaterOrEqual(4));]]></java></code-pair>

										</content>
									</section>

									<section id="order-by-clause">
										<title>The ORDER BY clause</title>
										<content>
											<h3>The ORDER BY clause</h3>
											<p>
												Databases are allowed to return data in any arbitrary order, unless you explicitly declare that order in the ORDER BY clause. In jOOQ, this is straight-forward:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC, TITLE DESC]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(), BOOK.TITLE.desc());]]></java></code-pair>

											<p>
												Any jOOQ <reference id="column-expressions" title="column expression (or field)"/> can be transformed into an <reference class="org.jooq.SortField"/> by calling the asc() and desc() methods.
											</p>

											<h3>Ordering by field index</h3>
											<p>
												The SQL standard allows for specifying integer literals (<reference id="inlined-parameters" title="literals"/>, not <reference id="bind-values" title="bind values"/>!) to reference column indexes from the projection (<reference id="select-clause" title="SELECT clause"/>). This may be useful if you do not want to repeat a lengthy expression, by which you want to order - although most databases also allow for referencing <reference id="aliasing" title="aliased column references"/> in the ORDER BY clause. An example of this is given here:
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY 1 ASC, 2 DESC]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(one().asc(), inline(2).desc());]]></java></code-pair>

											<p>
												Note, how one() is used as a convenience short-cut for inline(1)
											</p>

											<h3>Ordering and NULLS</h3>
											<p>
												A few databases support the SQL standard "null ordering" clause in sort specification lists, to define whether NULL values should come first or last in an ordered result.
											</p>

<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, CO_AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC,
         CO_AUTHOR_ID ASC NULLS LAST]]></sql>
<java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.CO_AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(),
               BOOK.CO_AUTHOR_ID.asc().nullsLast());]]></java></code-pair>

											<p>
												If your database doesn't support this syntax, jOOQ simulates it using a <reference id="case-expressions" title="CASE expression"/> as follows
											</p>
<code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, CO_AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC,
    CASE WHEN CO_AUTHOR_ID IS NULL THEN 1 ELSE 0 END ASC,
         CO_AUTHOR_ID ASC]]></sql>
<java><![CDATA[

create.select(BOOK.AUTHOR_ID, BOOK.CO_AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(),
               BOOK.CO_AUTHOR_ID.asc().nullsLast());]]></java></code-pair>

											<h3>Ordering using CASE expressions</h3>
											<p>
												Using <reference id="case-expressions" title="CASE expressions"/> in SQL ORDER BY clauses is a common pattern, if you want to introduce some sort indirection / sort mapping into your queries. As with SQL, you can add any type of <reference id="column-expressions" title="column expression"/> into your ORDER BY clause. For instance, if you have two favourite books that you always want to appear on top, you could write:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
ORDER BY CASE TITLE
         WHEN '1984' THEN 0
         WHEN 'Animal Farm' THEN 1
         ELSE 2 END ASC]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(decode().value(BOOK.TITLE)
                       .when("1984", 0)
                       .when("Animal Farm", 1)
                       .otherwise(2).asc());]]></java></code-pair>

											<p>
												But writing these things can become quite verbose. jOOQ supports a convenient syntax for specifying sort mappings. The same query can be written in jOOQ as such:
											</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm"));]]></java>

											<p>
												More complex sort indirections can be provided using a Map:
											</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sort(new HashMap<String, Integer>() {{
          put("1984", 1);
          put("Animal Farm", 13);
          put("The jOOQ book", 10);
      }}));]]></java>

      										<p>
      											Of course, you can combine this feature with the previously discussed NULLS FIRST / NULLS LAST feature. So, if in fact these two books are the ones you like least, you can put all NULLS FIRST (all the other books):
      										</p>

<java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm").nullsFirst());]]></java>

											<h3>jOOQ's understanding of SELECT .. ORDER BY</h3>
											<p>
												The SQL standard defines that a "query expression" can be ordered, and that query expressions can contain <reference id="union-clause" title="UNION, INTERSECT and EXCEPT clauses"/>, whose subqueries cannot be ordered. While this is defined as such in the SQL standard, many databases allowing for the non-standard <reference id="limit-clause" title="LIMIT clause"/> in one way or another, do not adhere to this part of the SQL standard. Hence, jOOQ allows for ordering all SELECT statements, regardless whether they are constructed as a part of a UNION or not. Corner-cases are handled internally by jOOQ, by introducing synthetic subselects to adhere to the correct syntax, where this is needed.
											</p>
										</content>
									</section>

									<section id="limit-clause">
										<title>The LIMIT .. OFFSET clause</title>
										<content>
											<h3>The non-standard LIMIT .. OFFSET clause</h3>
											<p>
												While being extremely useful for every application that does paging, or just to limit result sets to reasonable sizes, this clause is not yet part of any SQL standard (up until SQL:2008). Hence, there exist a variety of possible implementations in various SQL dialects, concerning this limit clause. jOOQ chose to implement the LIMIT .. OFFSET clause as understood and supported by MySQL, H2, HSQLDB, Postgres, and SQLite. Here is an example of how to apply limits with jOOQ:
											</p>

<java><![CDATA[create.select().from(BOOK).limit(1).offset(2);]]></java>

											<p>
												This will limit the result to 1 books starting with the 2nd book (starting at offset 0!). limit() is supported in all dialects, offset() in all but Sybase ASE, which has no reasonable means to simulate it. This is how jOOQ simulates the above query in various SQL dialects:
											</p>

<sql><![CDATA[-- MySQL, H2, HSQLDB, Postgres, and SQLite
SELECT * FROM BOOK LIMIT 1 OFFSET 2

-- CUBRID supports a MySQL variant of the LIMIT .. OFFSET clause
SELECT * FROM BOOK LIMIT 2, 1

-- Derby
SELECT * FROM BOOK OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY

-- Ingres
SELECT * FROM BOOK OFFSET 2 FETCH FIRST 1 ROWS ONLY

-- Sybase SQL Anywhere
SELECT TOP 1 ROWS START AT 3 * FROM BOOK

-- DB2 (without OFFSET)
SELECT * FROM BOOK FETCH FIRST 1 ROWS ONLY

-- Sybase ASE, SQL Server (without OFFSET)
SELECT TOP 1 * FROM BOOK

-- DB2 (with OFFSET), SQL Server (with OFFSET), Oracle (actual query may vary)
SELECT * FROM (
  SELECT LIMIT_98843777.*, ROW_NUMBER() OVER (ORDER BY ID ASC) AS ROWNUM_98843777
  FROM (
    SELECT TOP 100 PERCENT *
    FROM BOOK
    ORDER BY ID ASC
  ) AS LIMIT_98843777
) AS OUTER_LIMIT_98843777
WHERE ROWNUM_98843777 > 1
AND ROWNUM_98843777 <= 3
]]></sql>

											<p>
												As you can see, jOOQ will take care of the incredibly painful ROW_NUMBER() OVER() (or ROWNUM for Oracle) filtering in subselects for you, you'll just have to write limit(1).offset(2) in any dialect.
											</p>

											<h3>SQL Server's ORDER BY, TOP and subqueries</h3>
											<p>
												As can be seen in the above example, writing correct SQL can be quite tricky, depending on the SQL dialect. For instance, with SQL Server, you cannot have an ORDER BY clause in a subquery, unless you also have a TOP clause. This is illustrated by the fact that jOOQ renders a TOP 100 PERCENT clause for you. The same applies to the fact that ROW_NUMBER() OVER() needs an ORDER BY windowing clause, even if you don't provide one to the jOOQ query. By default, jOOQ adds ordering by the first column of your projection.
											</p>
										</content>
									</section>

									<section id="for-update-clause">
										<title>The FOR UPDATE clause</title>
										<content>
											<h3>Pessimistic (exclusive) locking with the FOR UPDATE clause</h3>
											<p>
												For inter-process synchronisation and other reasons, you may choose to use the SELECT .. FOR UPDATE clause to indicate to the database, that a set of cells or records should be locked by a given transaction for subsequent updates. With jOOQ, this can be achieved as such:
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate();]]></java></code-pair>

											<p>
												The above example will produce a record-lock, locking the whole record for updates. Some databases also support cell-locks using FOR UPDATE OF ..
											</p>

<code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE OF TITLE]]></sql>
<java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate().of(BOOK.TITLE);]]></java></code-pair>

											<p>
												Oracle goes a bit further and also allows to specify the actual locking behaviour. It features these additional clauses, which are all supported by jOOQ:
											</p>
											<ul>
												<li>FOR UPDATE NOWAIT: This is the default behaviour. If the lock cannot be acquired, the query fails immediately</li>
												<li>FOR UPDATE WAIT n: Try to wait for [n] seconds for the lock acquisition. The query will fail only afterwards</li>
												<li>FOR UPDATE SKIP LOCKED: This peculiar syntax will skip all locked records. This is particularly useful when implementing queue tables with multiple consumers</li>
											</ul>
											<p>
												With jOOQ, you can use those Oracle extensions as such:
											</p>

<java><![CDATA[create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().nowait();
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().wait(5);
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().skipLocked();]]></java>

											<h3>FOR UPDATE in CUBRID and SQL Server</h3>
											<p>
												The SQL standard specifies a FOR UPDATE clause to be applicable for cursors. Most databases interpret this as being applicable for all SELECT statements. An exception to this rule are the CUBRID and SQL Server databases, that do not allow for any FOR UPDATE clause in a regular SQL SELECT statement. jOOQ simulates the FOR UPDATE behaviour, by locking record by record with JDBC. JDBC allows for specifying the flags TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE for any statement, and then using ResultSet.updateXXX() methods to produce a cell-lock / row-lock. Heres a simplified example in JDBC:
											</p>
<java><![CDATA[PreparedStatement stmt = connection.prepareStatement(
  "SELECT * FROM author WHERE id IN (3, 4, 5)",
  ResultSet.TYPE_SCROLL_SENSITIVE,
  ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery();

while (rs.next()) {
  // UPDATE the primary key for row-locks, or any other columns for cell-locks
  rs.updateObject(1, rs.getObject(1));
  rs.updateRow();

  // Do more stuff with this record
}]]></java>

											<p>
												The main drawback of this approach is the fact that the database has to maintain a scrollable cursor, whose records are locked one by one. This can cause a major risk of deadlocks or race conditions if the JDBC driver can recover from the unsuccessful locking, if two Java threads execute the following statements:
											</p>

<sql><![CDATA[-- thread 1
SELECT * FROM author ORDER BY id ASC;

-- thread 2
SELECT * FROM author ORDER BY id DESC;]]></sql>

											<p>
												So use this technique with care, possibly only ever locking single rows!
											</p>

											<h3>Pessimistic (shared) locking with the FOR SHARE clause</h3>
											<p>
												Some databases (MySQL, Postgres) also allow to issue a non-exclusive lock explicitly using a FOR SHARE clause. This is also supported by jOOQ
											</p>

											<h3>Optimistic locking in jOOQ</h3>
											<p>
												Note, that jOOQ also supports optimistic locking, if you're doing simple CRUD. This is documented in the section's manual about <reference id="optimistic-locking" title="optimistic locking"/>.
											</p>
										</content>
									</section>

									<section id="union-clause">
										<title>UNION, INTERSECTION and EXCEPT</title>
										<content></content>
									</section>

									<section id="oracle-hints">
										<title>Oracle-style hints</title>
										<content>
											<h3>How to embed Oracle hints in SELECT</h3>
											<p>
												If you are closely coupling your application to an Oracle (or CUBRID) database,	you might need to be able to pass hints of the form /*+HINT*/ with your SQL statements to the Oracle database. For example:
											</p>

<sql>SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM AUTHOR</sql>

				  							<p>
				  								This can be done in jOOQ using the .hint() clause in your SELECT statement:
			  								</p>

<java>create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(AUTHOR);</java>

											<p>
												Note that you can pass any string in the .hint() clause. If you use that clause, the passed string will always be put in between the SELECT [DISTINCT] keywords and the actual projection list
											</p>
										</content>
									</section>
								</sections>
							</section>

							<section id="insert-statement">
								<title>The INSERT statement</title>
								<content></content>
							</section>

							<section id="update-statement">
								<title>The UPDATE statement</title>
								<content></content>
							</section>

							<section id="delete-statement">
								<title>The DELETE statement</title>
								<content></content>
							</section>

							<section id="merge-statement">
								<title>The MERGE statement</title>
								<content></content>
							</section>

							<section id="truncate-statement">
								<title>The TRUNCATE statement</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="table-expressions">
						<title>Table expressions</title>
						<content></content>

						<sections>
							<section id="generated-tables">
								<title>Generated Tables</title>
								<content></content>
							</section>

							<section id="joined-tables">
								<title>Joined tables</title>
								<content></content>
							</section>

							<section id="nested-selects">
								<title>Nested SELECTs</title>
								<content></content>
							</section>

							<section id="pivot-tables">
								<title>PIVOT tables</title>
								<content></content>
							</section>

							<section id="relational-division">
								<title>jOOQ's relational division syntax</title>
								<content>
									<h3>Relational division</h3>
									<p>
									    There is one operation in relational algebra that is not given a lot of attention, because it is rarely used in real-world applications. It is the relational division, the opposite operation of the cross product (or, relational multiplication). The following is an approximate definition of a relational division:
									</p>

<config>Assume the following cross join / cartesian product
C = A  B

Then it can be said that
A = C  B
B = C  A</config>

									<p>
									   With jOOQ, you can simplify using relational divisions by using the following syntax:
									</p>

<java>C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT)</java>

									<p>
										The above roughly translates to
									</p>

<sql>SELECT DISTINCT C.TEXT FROM C "c1"
WHERE NOT EXISTS (
  SELECT 1 FROM B
  WHERE NOT EXISTS (
    SELECT 1 FROM C "c2"
    WHERE "c2".TEXT = "c1".TEXT
    AND "c2".ID = B.C_ID
  )
)</sql>

									<p>
										Or in plain text: Find those TEXT values in C whose ID's correspond to all ID's in B. Note that from the above SQL statement, it is immediately clear that proper indexing is of the essence. Be sure to have indexes on all columns referenced from the on(...) and returning(...) clauses.
									</p>

									<p>
										For more information about relational division and some nice, real-life examples, see
									</p>

									<ul>
										<li><a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" title="Wikipedia article on relational division">http://en.wikipedia.org/wiki/Relational_algebra#Division</a></li>
										<li><a href="http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" title="A nice summary of what relational division is and how it is best implemented in SQL">http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a></li>
									</ul>
								</content>

							</section>

							<section id="array-and-cursor-unnesting">
								<title>Array and cursor unnesting</title>
								<content></content>
							</section>

							<section id="dual">
								<title>The DUAL table</title>
								<content>
									<h3>Selecting from DUAL</h3>
									<p>
										The SQL standard specifies that the <reference id="from-clause" title="FROM clause"/> is optional in a <reference id="select-statement" title="SELECT statement"/>. However, according to the standard, you may then no longer use some other clauses, such as the <reference id="where-clause" title="WHERE clause"/>. In the real world, there exist three types of databases:
									</p>
									<ul>
										<li>The ones that always require a FROM clause</li>
										<li>The ones that never require a FROM clause (and still allow a WHERE clause)</li>
										<li>The ones that correctly implement the SQL standard</li>
									</ul>
									<p>
										With jOOQ, you don't have to worry about the above distinction of SQL dialects. jOOQ never requires a FROM clause, but renders the necessary "DUAL" table, if needed. The following program shows how jOOQ renders "DUAL" tables
									</p>

<code-pair>
	<sql><![CDATA[SELECT 1
SELECT 1 FROM "db_root"
SELECT 1 FROM "SYSIBM"."DUAL"
SELECT 1 FROM "SYSIBM"."SYSDUMMY1"
SELECT 1 FROM dual
SELECT 1 FROM "INFORMATION_SCHEMA"."SYSTEM_USERS"
SELECT 1 FROM (select 1 as dual) as dual
SELECT 1 FROM dual
SELECT 1 FROM dual
SELECT 1
SELECT 1
SELECT 1
SELECT 1 FROM [SYS].[DUMMY]
]]></sql>
	<java><![CDATA[new Factory(SQLDialect.ASE      ).selectOne().getSQL();
new Factory(SQLDialect.CUBRID   ).selectOne().getSQL();
new Factory(SQLDialect.DB2      ).selectOne().getSQL();
new Factory(SQLDialect.DERBY    ).selectOne().getSQL();
new Factory(SQLDialect.H2       ).selectOne().getSQL();
new Factory(SQLDialect.HSQLDB   ).selectOne().getSQL();
new Factory(SQLDialect.INGRES   ).selectOne().getSQL();
new Factory(SQLDialect.MYSQL    ).selectOne().getSQL();
new Factory(SQLDialect.ORACLE   ).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES ).selectOne().getSQL();
new Factory(SQLDialect.SQLITE   ).selectOne().getSQL();
new Factory(SQLDialect.SQLSERVER).selectOne().getSQL();
new Factory(SQLDialect.SYBASE   ).selectOne().getSQL();]]></java>
</code-pair>

									<p>
										Note, that some databases (H2, MySQL) can normally do without "dual". However, there exist some corner-cases with complex nested SELECT statements, where this will cause syntax errors (or parser bugs). To stay on the safe side, jOOQ will always render "dual" in those dialects.
									</p>
								</content>
							</section>
						</sections>
					</section>

					<section id="column-expressions">
						<title>Column expressions</title>
						<content></content>

						<sections>
							<section id="table-columns">
								<title>Table columns</title>
								<content></content>
							</section>

							<section id="aliasing">
								<title>Aliasing</title>
								<content></content>
							</section>

							<section id="casting">
								<title>Type casting</title>
								<content></content>
							</section>

							<section id="arithmetic-expressions">
								<title>Arithmetic expressions</title>
								<content></content>
							</section>

							<section id="numeric-functions">
								<title>Numeric functions</title>
								<content></content>
							</section>

							<section id="string-functions">
								<title>String functions</title>
								<content></content>
							</section>

							<section id="date-and-time-functions">
								<title>Date and time functions</title>
								<content></content>
							</section>

							<section id="system-functions">
								<title>System functions</title>
								<content></content>
							</section>

							<section id="aggregate-functions">
								<title>Aggregate functions</title>
								<content></content>
							</section>

							<section id="window-functions">
								<title>Window functions</title>
								<content></content>
							</section>

							<section id="grouping-functions">
								<title>Grouping functions</title>
								<content>
								</content>
							</section>

							<section id="user-defined-functions">
								<title>User-defined functions</title>
								<content></content>
							</section>

							<section id="user-defined-aggregate-functions">
								<title>User-defined aggregate functions</title>
								<content></content>
							</section>

							<section id="case-expressions">
								<title>The CASE expression</title>
								<content>
									<h3>The two flavours of CASE expressions</h3>
									<p>
										The CASE expression is part of the standard SQL syntax. While some RDBMS also offer an IF expression, or a DECODE function, you can always rely on the two types of CASE syntax:
									</p>

<code-pair>
<sql><![CDATA[CASE WHEN T_AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN T_AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                         ELSE 'unknown'
END

-- OR:

CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END]]></sql>
<java><![CDATA[create.decode()
      .when(T_AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(T_AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(T_AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");]]></java>
</code-pair>

								<p>
									In jOOQ, both syntaxes are supported (The second one is simulated in Derby, which only knows the first one). Unfortunately, both case and else are reserved words in Java. jOOQ chose to use decode() from the Oracle DECODE function, and otherwise(), which means the same as else.
								</p>

								<p>
									A CASE expression can be used anywhere where you can place a <reference id="column-expressions" title="column expression (or Field)"/>. For instance, you can SELECT the above expression, if you're selecting from AUTHOR:
							 	</p>

<sql>SELECT T_AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM T_AUTHOR</sql>

								<h3>The Oracle DECODE() function</h3>
								<p>
									Oracle knows a more succinct, but maybe less readable DECODE() function with a variable number of arguments. This function roughly does the same as the second case expression syntax. jOOQ supports the DECODE() function and simulates it using CASE expressions in all dialects other than Oracle:
								</p>

<code-pair>
<sql><![CDATA[-- Oracle:
DECODE(FIRST_NAME, 'Paulo', 'brazilian',
                   'George', 'english',
                   'unknown');

-- Other SQL dialects
CASE T_AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                         WHEN 'George' THEN 'english'
                                       ELSE 'unknown'
END]]></sql>
<java><![CDATA[




// Use the Oracle-style DECODE() function with jOOQ.
// Note, that you will not be able to rely on type-safety
create.decode(T_AUTHOR.FIRST_NAME,
    "Paulo", "brazilian",
    "George", "english",
    "unknown");]]></java>
</code-pair>

		  							<h3>CASE clauses in an ORDER BY clause</h3>
									<p>
										Sort indirection is often implemented with a CASE clause of a SELECT's ORDER BY clause. See the manual's section about the <reference id="order-by-clause" title="ORDER BY clause"/> for more details.
									</p>
								</content>
							</section>

							<section id="sequences-and-serials">
								<title>Sequences and serials</title>
								<content>
									<h3>Sequences as a source for identity values</h3>
									<p>
										Sequences implement the <reference class="org.jooq.Sequence"/> interface, providing essentially this functionality:
									</p>

<java><![CDATA[// Get a field for the CURRVAL sequence property
Field<T> currval();

// Get a field for the NEXTVAL sequence property
Field<T> nextval();]]></java>

									<p>
										So if you have a sequence like this in Oracle:
									</p>

<sql>CREATE SEQUENCE s_author_id</sql>

									<p>
										You can then use your <reference id="codegen-sequences" title="generated sequence"/> object directly in a SQL statement as such:
									</p>

<java><![CDATA[// Reference the sequence in a SELECT statement:
BigInteger nextID = create.select(s).fetchOne(S_AUTHOR_ID.nextval());

// Reference the sequence in an INSERT statement:
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(S_AUTHOR_ID.nextval(), "William", "Shakespeare");
]]></java>

									<ul>
										<li>For more information about generated sequences, refer to the manual's section about <reference id="codegen-sequences" title="generated sequences"/></li>
										<li>For more information about executing standalone calls to sequences, refer to the manual's section about <reference id="sequence-execution" title="sequence execution"/></li>
									</ul>
								</content>
							</section>
						</sections>
					</section>

					<section id="conditional-expressions">
					    <title>Conditional expressions</title>
						<content></content>

						<sections>
						    <section id="condition-building">
							    <title>Condition building</title>
								<content></content>
							</section>

						    <section id="comparison-predicate">
							    <title>Comparison predicate</title>
								<content></content>
							</section>

						    <section id="null-predicate">
							    <title>NULL predicate</title>
								<content></content>
							</section>

						    <section id="distinct-predicate">
							    <title>Distinct predicate</title>
								<content></content>
							</section>

						    <section id="between-predicate">
							    <title>BETWEEN predicate</title>
								<content></content>
							</section>

						    <section id="like-predicate">
							    <title>LIKE predicate</title>
								<content></content>
							</section>

						    <section id="in-predicate">
							    <title>IN predicate</title>
								<content></content>
							</section>

						    <section id="exists-predicate">
							    <title>EXISTS predicate</title>
								<content></content>
							</section>

						    <section id="and-or-boolean-operators">
							    <title>AND, OR boolean operators</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="plain-sql">
						<title>Plain SQL</title>
						<content></content>
					</section>

					<section id="bind-values">
					    <title>Bind values and parameters</title>
						<content></content>

						<sections>
						    <section id="indexed-parameters">
							    <title>Indexed parameters</title>
								<content></content>
							</section>

						    <section id="named-parameters">
							    <title>Named parameters</title>
								<content></content>
							</section>

						    <section id="inlined-parameters">
							    <title>Inlined parameters</title>
								<content></content>
							</section>

						    <section id="sql-injection-and-plain-sql-queryparts">
							    <title>SQL injection and plain SQL QueryParts</title>
								<content></content>
							</section>
						</sections>
					</section>

					<section id="queryparts">
					    <title>QueryParts</title>
						<content></content>

						<sections>
						    <section id="jooq-architecture">
							    <title>jOOQ architecture</title>
								<content></content>
							</section>

						    <section id="sql-rendering">
							    <title>SQL rendering</title>
								<content></content>
							</section>

						    <section id="variable-binding">
							    <title>Variable binding</title>
								<content></content>
							</section>

						    <section id="custom-queryparts">
							    <title>Custom QueryParts</title>
								<content></content>
							</section>

						    <section id="plain-sql-queryparts">
							    <title>Plain SQL QueryParts</title>
								<content></content>
							</section>

						    <section id="serializability">
							    <title>Serializability</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="sql-execution">
				<title>SQL execution</title>
				<content></content>

				<sections>
				    <section id="query-vs-resultquery">
						<title>Query vs. ResultQuery</title>
						<content></content>
					</section>

				    <section id="fetching">
						<title>Fetching</title>
						<content></content>

						<sections>
							<section id="record-vs-tablerecord">
								<title>Record vs. TableRecord</title>
								<content></content>
							</section>

							<section id="arrays-and-maps">
								<title>Arrays and Maps</title>
								<content></content>
							</section>

							<section id="recordhandler">
								<title>RecordHandler</title>
								<content></content>
							</section>

							<section id="pojos">
								<title>POJOs</title>
								<content></content>
							</section>

							<section id="lazy-fetching">
								<title>Lazy fetching</title>
								<content></content>
							</section>

							<section id="many-fetching">
								<title>Many fetching</title>
								<content></content>
							</section>

							<section id="resultset-fetching">
								<title>ResultSet fetching</title>
								<content></content>
							</section>

							<section id="data-type-conversion">
								<title>Data type conversion</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="batch-execution">
						<title>Batch execution</title>
						<content></content>
					</section>

				    <section id="sequence-execution">
						<title>Sequence execution</title>
						<content></content>
					</section>

				    <section id="stored-procedures">
						<title>Stored procedures and functions</title>
						<content></content>

						<sections>
							<section id="oracle-packages">
								<title>Oracle Packages</title>
								<content></content>
							</section>

							<section id="oracle-member-procedures">
								<title>Oracle user-defined types and member procedures</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="exporting">
						<title>Exporting to XML, CSV, JSON, HTML, Text</title>
						<content>
							<h3>Exporting with jOOQ</h3>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's exporting functionality (see also the <reference id="importing" title="importing functionality"/>). You can export any Result&lt;Record&gt; into the formats discussed in the subsequent chapters of the manual
							</p>
						</content>

						<sections>
							<section id="exporting-xml">
								<title>Exporting XML</title>
								<content>
									<h3>Export your results as XML</h3>

<java>// Fetch books and format them as XML
String xml = create.selectFrom(BOOK).fetch().formatXML();</java>

									<p>
										The above query will result in an XML document looking like the following one:
									</p>

<xml><![CDATA[<result xmlns="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">
  <fields>
    <field name="ID"/>
    <field name="AUTHOR_ID"/>
    <field name="TITLE"/>
  </fields>
  <records>
    <record>
      <value field="ID">1</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">1984</value>
    </record>
    <record>
      <value field="ID">2</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">Animal Farm</value>
    </record>
  </records>
</result>]]></xml>

									<p>
										The same result as an <reference class="org.w3c.dom.Document"/> can be obtained using the Result.intoXML() method:
									</p>


<java>// Fetch books and format them as XML
Document xml = create.selectFrom(BOOK).fetch().intoXML();</java>

									<p>
										See the XSD schema definition here, for a formal definition of the XML export format:<br/>
										<a href="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">http://www.jooq.org/xsd/jooq-export-1.6.2.xsd</a>
									</p>
								</content>
							</section>

							<section id="exporting-csv">
								<title>Exporting CSV</title>
								<content>
									<h3>Export your results as CSV</h3>

<java>// Fetch books and format them as CSV
String csv = create.selectFrom(BOOK).fetch().formatCSV();</java>

									<p>
										The above query will result in a CSV document looking like the following one:
									</p>

<text>ID,AUTHOR_ID,TITLE
1,1,1984
2,1,Animal Farm</text>

									<p>
										In addition to the standard behaviour, you can also specify a separator character, as well as a special string to represent NULL values (which cannot be represented in standard CSV):
									</p>

<java>// Use ";" as the separator character
String csv = create.selectFrom(BOOK).fetch().formatCSV(';');

// Specify "{null}" as a representation for NULL values
String csv = create.selectFrom(BOOK).fetch().formatCSV(';', "{null}");</java>

								</content>
							</section>

							<section id="exporting-json">
								<title>Exporting JSON</title>
								<content>
									<h3>Export your results as JSON</h3>

<java>// Fetch books and format them as JSON
String json = create.selectFrom(BOOK).fetch().formatJSON();</java>

									<p>
										The above query will result in a JSON document looking like the following one:
									</p>

<text>{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</text>
								</content>
							</section>

							<section id="exporting-html">
								<title>Exporting HTML</title>
								<content>
 									<h3>Export your results as HTML</h3>
<java>// Fetch books and format them as HTML
String html = create.selectFrom(BOOK).fetch().formatHTML();</java>

									<p>
										The above query will result in an HTML document looking like the following one
									</p>

<xml><![CDATA[<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>AUTHOR_ID</th>
      <th>TITLE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1984</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>Animal Farm</td>
    </tr>
  </tbody>
</table>]]></xml>

								</content>
							</section>

							<section id="exporting-text">
								<title>Exporting Text</title>
								<content>
									<h3>Export your results as text</h3>

<java>// Fetch books and format them as text
String text = create.selectFrom(BOOK).fetch().format();</java>

									<p>
										The above query will result in a text document looking like the following one
									</p>

<text>+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</text>

									<p>
										A simple text representation can also be obtained by calling toString() on a Result object. See also the manual's section about <reference id="logging" title="DEBUG logging"/>
									</p>
								</content>
							</section>
						</sections>
					</section>

				    <section id="importing">
						<title>Importing data</title>
						<content>
							<h3>Importing data into your database using jOOQ</h3>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's importing functionality (see also exporting functionality). You can import data directly into a table from the formats described in the subsequent sections of this manual.
							</p>
						</content>

						<sections>
							<section id="importing-csv">
								<title>Importing CSV</title>
								<content>
									<h3>Importing CSV with jOOQ</h3>

									<p>
										The below CSV data represents two author records that may have been exported previously, by jOOQ's <reference id="exporting" title="exporting functionality"/>, and then modified in Microsoft Excel or any other spreadsheet tool:
									</p>

<text>ID;AUTHOR_ID;TITLE
1;1;1984
2;1;Animal Farm</text>

									<p>
										With jOOQ, you can load this data using various parameters from the	loader API. A simple load may look like this:
									</p>

<java>Factory create = new Factory(connection, dialect);

// Load data into the AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</java>

      								<p>
      									Here are various other examples:
   									</p>

<java>// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</java>

									<p>
										Any of the above configuration methods can be combined to achieve the type of load you need. Please refer to the API's Javadoc to learn about more details. Errors that occur during the load are reported by the execute method's result:
									</p>

<java><![CDATA[Loader<Author> loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();

// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();

// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();

// The errors that may have occurred during loading
List<LoaderError> errors = loader.errors();
LoaderError error = errors.get(0);

// The exception that caused the error
DataAccessException exception = error.exception();

// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();

// The query that caused the error
Query query = error.query();]]></java>

								</content>
							</section>

							<section id="importing-xml">
								<title>XML</title>
								<content>
									<h3>Importing XML into jOOQ</h3>
									<p>This is not yet supported</p>
								</content>
							</section>
						</sections>
					</section>

				    <section id="crud-with-updatablerecords">
						<title>CRUD with UpdatableRecords</title>
						<content></content>

						<sections>
							<section id="simple-crud">
								<title>Simple CRUD</title>
								<content></content>
							</section>

							<section id="non-updatable-records">
								<title>Non-updatable records</title>
								<content></content>
							</section>

							<section id="optimistic-locking">
								<title>Optimistic locking</title>
								<content></content>
							</section>

							<section id="batch-execution-for-crud">
								<title>Batch execution</title>
								<content></content>
							</section>
						</sections>
					</section>

				    <section id="daos">
						<title>DAOs</title>
						<content></content>
					</section>

				    <section id="execute-listeners">
						<title>ExecuteListeners</title>
						<content></content>
					</section>

				    <section id="logging">
						<title>Logging</title>
						<content></content>
					</section>

				    <section id="performance-considerations">
						<title>Performance considerations</title>
						<content></content>
					</section>
				</sections>
			</section>

			<section id="code-generation">
				<title>Code generation</title>
				<content></content>

				<sections>
				    <section id="codegen-configuration">
						<title>Configuration</title>
						<content></content>
					</section>

				    <section id="codegen-advanced">
						<title>Advanced Configuration</title>
						<content></content>
					</section>

				    <section id="codegen-globals">
						<title>Generated global artefacts</title>
						<content></content>
					</section>

				    <section id="codegen-tables">
						<title>Generated tables</title>
						<content></content>
					</section>

				    <section id="codegen-sequences">
						<title>Generated sequences</title>
						<content></content>
					</section>

				    <section id="codegen-procedures">
						<title>Generated tables</title>
						<content></content>
					</section>

				    <section id="master-data-types">
						<title>Master data and enumeration tables</title>
						<content></content>
					</section>

				    <section id="custom-data-types">
						<title>Custom data types and type conversions</title>
						<content></content>
					</section>

				    <section id="schema-mapping">
						<title>Schema mapping</title>
						<content></content>
					</section>
				</sections>
			</section>

			<section id="tools">
				<title>Tools</title>
				<content></content>

				<sections>
					<section id="jooq-console">
						<title>jOOQ Console</title>
						<content></content>

						<sections>
							<section id="jooq-console-logger">
								<title>Logger</title>
								<content></content>
							</section>

							<section id="jooq-console-debugger">
								<title>Debugger</title>
								<content></content>
							</section>

							<section id="jooq-console-editor">
								<title>Editor</title>
								<content></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="reference">
				<title>Reference</title>
				<content></content>

				<sections>
					<section id="supported-rdbms">
						<title>Supported RDBMS</title>
						<content></content>
					</section>

					<section id="reference-data-types">
						<title>Data types</title>
						<content></content>
					</section>

					<section id="reference-functions">
						<title>Functions</title>
						<content></content>
					</section>

					<section id="reference-bnf-notation">
						<title>jOOQ's BNF pseudo-notation</title>
						<content></content>
					</section>

					<section id="reference-glossary">
						<title>Glossary</title>
						<content></content>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>