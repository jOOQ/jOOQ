/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Other licenses:
 * -----------------------------------------------------------------------------
 * Commercial licenses for this work are available. These replace the above
 * Apache-2.0 license and offer limited warranties, support, maintenance, and
 * commercial database integrations.
 *
 * For more information, please visit: https://www.jooq.org/legal/licensing
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
package org.jooq.impl;

import static java.util.Arrays.asList;
import static org.jooq.Operator.AND;
import static org.jooq.Operator.OR;
import static org.jooq.Operator.XOR;
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.CLICKHOUSE;
// ...
// ...
// ...
import static org.jooq.SQLDialect.CUBRID;
// ...
// ...
// ...
import static org.jooq.SQLDialect.DEFAULT;
import static org.jooq.SQLDialect.DERBY;
import static org.jooq.SQLDialect.DUCKDB;
// ...
import static org.jooq.SQLDialect.FIREBIRD;
// ...
// ...
import static org.jooq.SQLDialect.H2;
// ...
import static org.jooq.SQLDialect.HSQLDB;
import static org.jooq.SQLDialect.IGNITE;
// ...
// ...
import static org.jooq.SQLDialect.MARIADB;
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.MYSQL;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.POSTGRES;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.SQLITE;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.TRINO;
// ...
import static org.jooq.SQLDialect.YUGABYTEDB;
import static org.jooq.conf.ParamType.INLINED;
import static org.jooq.impl.Names.N_COUNT;
import static org.jooq.impl.Names.N_CUME_DIST;
import static org.jooq.impl.Names.N_DENSE_RANK;
import static org.jooq.impl.Names.N_E;
import static org.jooq.impl.Names.N_IF;
import static org.jooq.impl.Names.N_IIF;
import static org.jooq.impl.Names.N_PERCENTILE_CONT;
import static org.jooq.impl.Names.N_PERCENTILE_DISC;
import static org.jooq.impl.Names.N_PERCENT_RANK;
import static org.jooq.impl.Names.N_RANK;
import static org.jooq.impl.Names.N_SYSTEM_TIME;
import static org.jooq.impl.Names.N_VALUE;
import static org.jooq.impl.SQLDataType.BOOLEAN;
import static org.jooq.impl.SQLDataType.DATE;
import static org.jooq.impl.SQLDataType.INTEGER;
import static org.jooq.impl.SQLDataType.JSON;
import static org.jooq.impl.SQLDataType.JSONB;
import static org.jooq.impl.SQLDataType.TIME;
import static org.jooq.impl.SQLDataType.TIMESTAMP;
import static org.jooq.impl.Tools.CTX;
import static org.jooq.impl.Tools.EMPTY_FIELD;
import static org.jooq.impl.Tools.combine;
import static org.jooq.impl.Tools.configuration;
import static org.jooq.impl.Tools.getRecordQualifier;
import static org.jooq.impl.Tools.isEmpty;
import static org.jooq.impl.Tools.map;
import static org.jooq.impl.Tools.mostSpecificArray;
import static org.jooq.tools.StringUtils.defaultString;
import static org.jooq.tools.StringUtils.isEmpty;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.Date;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.temporal.Temporal;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.function.Function;

import javax.sql.DataSource;

import org.jooq.AggregateFunction;
import org.jooq.AlterTableStep;
import org.jooq.ArrayAggOrderByStep;
// ...
// ...
import org.jooq.Asterisk;
import org.jooq.Binding;
import org.jooq.Block;
import org.jooq.Case;
import org.jooq.CaseConditionStep;
import org.jooq.CaseValueStep;
import org.jooq.Catalog;
import org.jooq.CharacterSet;
import org.jooq.CheckReturnValue;
import org.jooq.CloseableDSLContext;
import org.jooq.Collation;
import org.jooq.Comment;
import org.jooq.CommonTableExpression;
import org.jooq.Condition;
import org.jooq.Configuration;
import org.jooq.ConnectionProvider;
import org.jooq.ConstraintEnforcementStep;
import org.jooq.ConstraintForeignKeyReferencesStep1;
import org.jooq.ConstraintForeignKeyReferencesStep10;
import org.jooq.ConstraintForeignKeyReferencesStep11;
import org.jooq.ConstraintForeignKeyReferencesStep12;
import org.jooq.ConstraintForeignKeyReferencesStep13;
import org.jooq.ConstraintForeignKeyReferencesStep14;
import org.jooq.ConstraintForeignKeyReferencesStep15;
import org.jooq.ConstraintForeignKeyReferencesStep16;
import org.jooq.ConstraintForeignKeyReferencesStep17;
import org.jooq.ConstraintForeignKeyReferencesStep18;
import org.jooq.ConstraintForeignKeyReferencesStep19;
import org.jooq.ConstraintForeignKeyReferencesStep2;
import org.jooq.ConstraintForeignKeyReferencesStep20;
import org.jooq.ConstraintForeignKeyReferencesStep21;
import org.jooq.ConstraintForeignKeyReferencesStep22;
import org.jooq.ConstraintForeignKeyReferencesStep3;
import org.jooq.ConstraintForeignKeyReferencesStep4;
import org.jooq.ConstraintForeignKeyReferencesStep5;
import org.jooq.ConstraintForeignKeyReferencesStep6;
import org.jooq.ConstraintForeignKeyReferencesStep7;
import org.jooq.ConstraintForeignKeyReferencesStep8;
import org.jooq.ConstraintForeignKeyReferencesStep9;
import org.jooq.ConstraintForeignKeyReferencesStepN;
import org.jooq.ConstraintTypeStep;
import org.jooq.Context;
// ...
import org.jooq.Converter;
import org.jooq.CreateTypeStep;
import org.jooq.CreateViewAsStep;
import org.jooq.DSLContext;
import org.jooq.DataType;
import org.jooq.DatePart;
// ...
import org.jooq.Delete;
import org.jooq.DeleteUsingStep;
import org.jooq.DerivedColumnList;
import org.jooq.Domain;
import org.jooq.DropTypeStep;
// ...
import org.jooq.False;
import org.jooq.Field;
import org.jooq.FieldOrRow;
// ...
import org.jooq.Function1;
import org.jooq.Geography;
import org.jooq.Geometry;
import org.jooq.GroupConcatOrderByStep;
import org.jooq.GroupConcatSeparatorStep;
import org.jooq.GroupField;
// ...
import org.jooq.Index;
import org.jooq.Insert;
import org.jooq.InsertSetStep;
import org.jooq.InsertValuesStep1;
import org.jooq.InsertValuesStep10;
import org.jooq.InsertValuesStep11;
import org.jooq.InsertValuesStep12;
import org.jooq.InsertValuesStep13;
import org.jooq.InsertValuesStep14;
import org.jooq.InsertValuesStep15;
import org.jooq.InsertValuesStep16;
import org.jooq.InsertValuesStep17;
import org.jooq.InsertValuesStep18;
import org.jooq.InsertValuesStep19;
import org.jooq.InsertValuesStep2;
import org.jooq.InsertValuesStep20;
import org.jooq.InsertValuesStep21;
import org.jooq.InsertValuesStep22;
import org.jooq.InsertValuesStep3;
import org.jooq.InsertValuesStep4;
import org.jooq.InsertValuesStep5;
import org.jooq.InsertValuesStep6;
import org.jooq.InsertValuesStep7;
import org.jooq.InsertValuesStep8;
import org.jooq.InsertValuesStep9;
import org.jooq.InsertValuesStepN;
import org.jooq.JSON;
import org.jooq.JSONArrayAggOrderByStep;
import org.jooq.JSONArrayNullStep;
import org.jooq.JSONB;
import org.jooq.JSONEntry;
import org.jooq.JSONEntryValueStep;
import org.jooq.JSONExistsOnStep;
import org.jooq.JSONFormat;
import org.jooq.JSONObjectAggNullStep;
import org.jooq.JSONObjectNullStep;
import org.jooq.JSONTableColumnsFirstStep;
import org.jooq.JSONValueOnStep;
import org.jooq.Keyword;
// ...
import org.jooq.Lambda1;
// ...
// ...
import org.jooq.Merge;
import org.jooq.MergeKeyStep1;
import org.jooq.MergeKeyStep10;
import org.jooq.MergeKeyStep11;
import org.jooq.MergeKeyStep12;
import org.jooq.MergeKeyStep13;
import org.jooq.MergeKeyStep14;
import org.jooq.MergeKeyStep15;
import org.jooq.MergeKeyStep16;
import org.jooq.MergeKeyStep17;
import org.jooq.MergeKeyStep18;
import org.jooq.MergeKeyStep19;
import org.jooq.MergeKeyStep2;
import org.jooq.MergeKeyStep20;
import org.jooq.MergeKeyStep21;
import org.jooq.MergeKeyStep22;
import org.jooq.MergeKeyStep3;
import org.jooq.MergeKeyStep4;
import org.jooq.MergeKeyStep5;
import org.jooq.MergeKeyStep6;
import org.jooq.MergeKeyStep7;
import org.jooq.MergeKeyStep8;
import org.jooq.MergeKeyStep9;
import org.jooq.MergeKeyStepN;
import org.jooq.MergeUsingStep;
import org.jooq.Name;
import org.jooq.Name.Quoted;
import org.jooq.Null;
import org.jooq.Operator;
import org.jooq.OptionallyOrderedAggregateFunction;
import org.jooq.OrderField;
import org.jooq.OrderedAggregateFunction;
import org.jooq.OrderedAggregateFunctionOfDeferredType;
import org.jooq.Param;
import org.jooq.ParamMode;
import org.jooq.Parameter;
// ...
import org.jooq.PlainSQL;
import org.jooq.Privilege;
// ...
import org.jooq.QualifiedRecord;
import org.jooq.QuantifiedSelect;
import org.jooq.Queries;
import org.jooq.Query;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.Record1;
import org.jooq.Record10;
import org.jooq.Record11;
import org.jooq.Record12;
import org.jooq.Record13;
import org.jooq.Record14;
import org.jooq.Record15;
import org.jooq.Record16;
import org.jooq.Record17;
import org.jooq.Record18;
import org.jooq.Record19;
import org.jooq.Record2;
import org.jooq.Record20;
import org.jooq.Record21;
import org.jooq.Record22;
import org.jooq.Record3;
import org.jooq.Record4;
import org.jooq.Record5;
import org.jooq.Record6;
import org.jooq.Record7;
import org.jooq.Record8;
import org.jooq.Record9;
import org.jooq.RecordType;
// ...
import org.jooq.Result;
import org.jooq.ResultQuery;
import org.jooq.Role;
import org.jooq.Row;
import org.jooq.Row1;
import org.jooq.Row10;
import org.jooq.Row11;
import org.jooq.Row12;
import org.jooq.Row13;
import org.jooq.Row14;
import org.jooq.Row15;
import org.jooq.Row16;
import org.jooq.Row17;
import org.jooq.Row18;
import org.jooq.Row19;
import org.jooq.Row2;
import org.jooq.Row20;
import org.jooq.Row21;
import org.jooq.Row22;
import org.jooq.Row3;
import org.jooq.Row4;
import org.jooq.Row5;
import org.jooq.Row6;
import org.jooq.Row7;
import org.jooq.Row8;
import org.jooq.Row9;
import org.jooq.RowCountQuery;
import org.jooq.RowN;
import org.jooq.Rows;
import org.jooq.SQL;
import org.jooq.SQLDialect;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.SelectField;
import org.jooq.SelectFieldOrAsterisk;
import org.jooq.SelectForStep;
import org.jooq.SelectGroupByStep;
import org.jooq.SelectLimitStep;
import org.jooq.SelectOffsetStep;
import org.jooq.SelectOrderByStep;
import org.jooq.SelectSelectStep;
import org.jooq.SelectWhereStep;
import org.jooq.Sequence;
import org.jooq.Spatial;
import org.jooq.Statement;
import org.jooq.Stringly;
import org.jooq.Support;
// ...
import org.jooq.Table;
import org.jooq.TableLike;
// ...
import org.jooq.True;
import org.jooq.Type;
import org.jooq.Update;
import org.jooq.UpdateSetFirstStep;
import org.jooq.User;
// ...
import org.jooq.WindowFromFirstLastStep;
import org.jooq.WindowIgnoreNullsStep;
import org.jooq.WindowOverStep;
import org.jooq.WindowSpecification;
import org.jooq.WindowSpecificationExcludeStep;
import org.jooq.WindowSpecificationOrderByStep;
import org.jooq.WindowSpecificationRowsAndStep;
import org.jooq.WindowSpecificationRowsStep;
import org.jooq.WithAsStep;
import org.jooq.WithAsStep1;
import org.jooq.WithAsStep10;
import org.jooq.WithAsStep11;
import org.jooq.WithAsStep12;
import org.jooq.WithAsStep13;
import org.jooq.WithAsStep14;
import org.jooq.WithAsStep15;
import org.jooq.WithAsStep16;
import org.jooq.WithAsStep17;
import org.jooq.WithAsStep18;
import org.jooq.WithAsStep19;
import org.jooq.WithAsStep2;
import org.jooq.WithAsStep20;
import org.jooq.WithAsStep21;
import org.jooq.WithAsStep22;
import org.jooq.WithAsStep3;
import org.jooq.WithAsStep4;
import org.jooq.WithAsStep5;
import org.jooq.WithAsStep6;
import org.jooq.WithAsStep7;
import org.jooq.WithAsStep8;
import org.jooq.WithAsStep9;
import org.jooq.WithStep;
import org.jooq.XML;
import org.jooq.XMLAggOrderByStep;
import org.jooq.XMLAttributes;
import org.jooq.XMLExistsPassingStep;
import org.jooq.XMLFormat;
import org.jooq.XMLQueryPassingStep;
import org.jooq.XMLTablePassingStep;
import org.jooq.conf.NestedCollectionEmulation;
import org.jooq.conf.RenderQuotedNames;
import org.jooq.conf.Settings;
import org.jooq.exception.SQLDialectNotSupportedException;
import org.jooq.impl.QOM.DocumentOrContent;
import org.jooq.impl.QOM.Quantifier;
import org.jooq.impl.QOM.ResultOption;
import org.jooq.tools.ClassUtils;
import org.jooq.tools.StringUtils;
import org.jooq.tools.jdbc.JDBCUtils;
import org.jooq.types.DayToSecond;
import org.jooq.types.UByte;
import org.jooq.types.UInteger;
import org.jooq.types.ULong;
import org.jooq.types.UShort;

import org.jetbrains.annotations.Blocking;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.ApiStatus.Obsolete;

import io.r2dbc.spi.ConnectionFactory;

/**
 * A DSL "entry point" providing implementations to the <code>org.jooq</code>
 * interfaces.
 * <p>
 * The {@link DSLContext} and this <code>DSL</code> are the main entry point for
 * client code, to access jOOQ classes and functionality. Here, you can
 * instantiate all of those objects that cannot be accessed through other
 * objects. For example, to create a {@link Field} representing a constant
 * value, you can write:
 * <p>
 * <pre><code>
 * Field&lt;String&gt; field = DSL.val("Hello World")
 * </code></pre>
 * <p>
 * Another example is the <code>EXISTS</code> clause, which you can apply to any
 * <code>SELECT</code> to form a {@link Condition}:
 * <p>
 * <pre><code>
 * Condition condition = DSL.exists(DSL.select(...));
 * </code></pre>
 * <p>
 * <h5>DSL and static imports</h5>
 * <p>
 * For increased fluency and readability of your jOOQ client code, it is
 * recommended that you static import all methods from the <code>DSL</code>. For
 * example: <pre><code>
 * import static org.jooq.impl.DSL.*;
 *
 * public class Main {
 *   public static void main(String[] args) {
 *     DSL.select(val("Hello"), inline("World"));
 *     // DSL.val ^^^           ^^^^^^ DSL.inline
 *   }
 * }
 * </code></pre>
 * <p>
 * In order to use the "contextual DSL", call one of the various overloaded
 * {@link #using(Configuration)} methods:
 * <p>
 * <pre><code>
 * // Create and immediately execute a SELECT statement:
 * DSL.using(connection, dialect)
 *    .selectOne()
 *    .fetch();
 * </code></pre>
 *
 * @see DSLContext
 * @author Lukas Eder
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class DSL {

    // -------------------------------------------------------------------------
    // XXX Contextual factory methods
    // -------------------------------------------------------------------------

    /**
     * Create an executor with a dialect configured.
     * <p>
     * Without a connection or data source, this executor cannot execute
     * queries. Use it to render SQL only.
     *
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(SQLDialect dialect) {
        return new DefaultDSLContext(dialect, null);
    }

    /**
     * Create an executor with a dialect and settings configured.
     * <p>
     * Without a connection or data source, this executor cannot execute
     * queries. Use it to render SQL only.
     *
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(dialect, settings);
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <pre><code>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test")) {
     *
     *     // ...
     * }
     * </code></pre>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @Blocking
    @NotNull
    public static CloseableDSLContext using(String url) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(null, connection, true, false), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                throw Tools.translate(CTX.get(), "Error when initialising Connection", e);
            }
        }
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <pre><code>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test", "sa", "")) {
     *
     *     // ...
     * }
     * </code></pre>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @param username The connection user name.
     * @param password The connection password.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @Blocking
    @NotNull
    public static CloseableDSLContext using(String url, String username, String password) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url, username, password);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(null, connection, true, false), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url, username, password);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                String driver = JDBCUtils.driver(url);
                Exception cause = e;

                if (!Driver.class.getName().equals(driver)) {
                    try {
                        Driver d = (Driver) ClassUtils.loadClass(driver).getConstructor().newInstance();
                        Properties properties = new Properties();
                        properties.put("user", defaultString(username));
                        properties.put("password", defaultString(password));
                        Connection connection = d.connect(url, properties);
                        return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
                    }
                    catch (Exception e2) {
                        e2.addSuppressed(e);
                        cause = e2;
                    }
                }

                throw Tools.translate(CTX.get(), "Error when initialising Connection", cause);
            }
        }
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <pre><code>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test", properties)) {
     *
     *     // ...
     * }
     * </code></pre>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @param properties The connection properties.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @Blocking
    @NotNull
    public static CloseableDSLContext using(String url, Properties properties) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url, properties);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(null, connection, true, false), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url, properties);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                throw Tools.translate(CTX.get(), "Error when initialising Connection", e);
            }
        }
    }

    /**
     * Create an executor with a connection configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(Connection, Settings)}, guessing the {@link SQLDialect}
     * using {@link JDBCUtils#dialect(Connection)}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(Connection)
     */
    @NotNull
    public static DSLContext using(Connection connection) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), null);
    }

    /**
     * Create an executor with a connection and a dialect configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @see DefaultConnectionProvider
     */
    @NotNull
    public static DSLContext using(Connection connection, SQLDialect dialect) {
        return new DefaultDSLContext(connection, dialect, null);
    }

    /**
     * Create an executor with a connection, a dialect and settings configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider} and guessing the {@link SQLDialect}
     * using {@link JDBCUtils#dialect(Connection)}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(Connection)
     */
    @NotNull
    public static DSLContext using(Connection connection, Settings settings) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), settings);
    }

    /**
     * Create an executor with a connection, a dialect and settings configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DefaultConnectionProvider
     */
    @NotNull
    public static DSLContext using(Connection connection, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connection, dialect, settings);
    }

    /**
     * Create an executor with a data source and a dialect configured.
     * <p>
     * If you provide a JDBC data source to a jOOQ Configuration, jOOQ will use
     * that data source for initialising connections, and creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect)} using a
     * {@link DataSourceConnectionProvider}
     *
     * @param datasource The data source to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @see DataSourceConnectionProvider
     */
    @NotNull
    public static DSLContext using(DataSource datasource, SQLDialect dialect) {
        return new DefaultDSLContext(datasource, dialect);
    }

    /**
     * Create an executor with a data source, a dialect and settings configured.
     * <p>
     * If you provide a JDBC data source to a jOOQ Configuration, jOOQ will use
     * that data source for initialising connections, and creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DataSourceConnectionProvider}
     *
     * @param datasource The data source to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DataSourceConnectionProvider
     */
    @NotNull
    public static DSLContext using(DataSource datasource, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(datasource, dialect, settings);
    }

    /**
     * Create an executor with a custom connection provider and a dialect
     * configured.
     *
     * @param connectionProvider The connection provider providing jOOQ with
     *            JDBC connections
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect) {
        return new DefaultDSLContext(connectionProvider, dialect);
    }

    /**
     * Create an executor with a custom connection provider, a dialect and settings
     * configured.
     *
     * @param connectionProvider The connection provider providing jOOQ with
     *            JDBC connections
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connectionProvider, dialect, settings);
    }

    /**
     * Create an executor with a custom R2DBC connection factory and guess the
     * dialect from it.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory) {
        return new DefaultDSLContext(connectionFactory, JDBCUtils.dialect(connectionFactory));
    }

    /**
     * Create an executor with a custom R2DBC connection factory and a dialect
     * configured.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory, SQLDialect dialect) {
        return new DefaultDSLContext(connectionFactory, dialect);
    }

    /**
     * Create an executor with a custom R2DBC connection factory, a dialect and
     * settings configured.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connectionFactory, dialect, settings);
    }

    /**
     * Create an executor with a custom R2DBC connection and guess the dialect.
     *
     * @param connection The R2DBC connection
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection) {
        return new DefaultDSLContext(new DefaultConnectionFactory(null, connection), JDBCUtils.dialect(connection));
    }

    /**
     * Create an executor with a custom R2DBC connection and a dialect
     * configured.
     *
     * @param connection The R2DBC connection
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection, SQLDialect dialect) {
        return new DefaultDSLContext(new DefaultConnectionFactory(null, connection), dialect);
    }

    /**
     * Create an executor with a custom R2DBC connection, a dialect and settings
     * configured.
     *
     * @param connection The R2DBC connection
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(new DefaultConnectionFactory(null, connection), dialect, settings);
    }

    /**
     * Create an executor from a custom configuration.
     *
     * @param configuration The configuration
     */
    @NotNull
    public static DSLContext using(Configuration configuration) {
        return new DefaultDSLContext(configuration);
    }

    // -------------------------------------------------------------------------
    // XXX Static subselect factory methods
    // -------------------------------------------------------------------------

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String)} for strictly non-recursive CTE
     * and {@link #withRecursive(String)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(String alias) {
        return new WithImpl(null, false).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(String alias, String... fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(String alias, Collection<String> fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(Name alias) {
        return new WithImpl(null, false).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(Name alias, Name... fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithAsStep with(Name alias, Collection<? extends Name> fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE and
     * {@link #withRecursive(String, String...)} for strictly recursive CTE.
     * <p>
     * This works in a similar way as {@link #with(String, String...)}, except
     * that all column names are produced by a function that receives the CTE's
     * {@link Select} columns as input.
     *
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support
    public static WithAsStep with(String alias, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return new WithImpl(null, false).with(alias, fieldNameFunction);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep1 with(String alias, String fieldAlias1) {
        return new WithImpl(null, false).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep2 with(String alias, String fieldAlias1, String fieldAlias2) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep3 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep4 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep5 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep6 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep7 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep8 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep9 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep10 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep11 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep12 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep13 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep14 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep15 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep16 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep17 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep18 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep19 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep20 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep21 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep22 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21, String fieldAlias22) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep1 with(Name alias, Name fieldAlias1) {
        return new WithImpl(null, false).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep2 with(Name alias, Name fieldAlias1, Name fieldAlias2) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep3 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep4 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep5 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep6 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep7 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep8 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep9 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep10 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep11 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep12 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep13 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep14 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep15 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep16 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep17 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep18 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep19 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep20 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep21 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support
    public static WithAsStep22 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21, Name fieldAlias22) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(ResultQuery)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithStep with(CommonTableExpression<?>... tables) {
        return new WithImpl(null, false).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(ResultQuery)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support
    public static WithStep with(Collection<? extends CommonTableExpression<?>> tables) {
        return new WithImpl(null, false).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String)} for strictly non-recursive CTE
     * and {@link #withRecursive(String)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(String alias) {
        return new WithImpl(null, true).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(String alias, String... fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(String alias, Collection<String> fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(Name alias) {
        return new WithImpl(null, true).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(Name alias, Name... fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(Name alias, Collection<? extends Name> fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     * <p>
     * This works in a similar way as {@link #with(String, String...)}, except
     * that all column names are produced by a function that receives the CTE's
     * {@link Select} columns as input.
     *
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep withRecursive(String alias, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return new WithImpl(null, true).with(alias, fieldNameFunction);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep1 withRecursive(String alias, String fieldAlias1) {
        return new WithImpl(null, true).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep2 withRecursive(String alias, String fieldAlias1, String fieldAlias2) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep3 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep4 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep5 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep6 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep7 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep8 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep9 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep10 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep11 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep12 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep13 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep14 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep15 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep16 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep17 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep18 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep19 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep20 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep21 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep22 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21, String fieldAlias22) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep1 withRecursive(Name alias, Name fieldAlias1) {
        return new WithImpl(null, true).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep2 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep3 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep4 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep5 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep6 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep7 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep8 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep9 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep10 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep11 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep12 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep13 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep14 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep15 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep16 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep17 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep18 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep19 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep20 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep21 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithAsStep22 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21, Name fieldAlias22) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(ResultQuery)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithStep withRecursive(CommonTableExpression<?>... tables) {
        return new WithImpl(null, true).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(ResultQuery)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WithStep withRecursive(Collection<? extends CommonTableExpression<?>> tables) {
        return new WithImpl(null, true).with(tables);
    }

    /**
     * Create a new DSL select statement, projecting the known columns from a
     * table.
     * <p>
     * This will project the known columns from the argument table querying
     * {@link Table#fields()}. If no known columns are available (e.g. because
     * the table has been created using {@link DSL#table(String)}), then
     * <code>SELECT *</code> is projected.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * SELECT table.col1, table.col2 FROM table
     * </code></pre>
     */
    @NotNull
    @Support
    public static <R extends Record> SelectWhereStep<R> selectFrom(TableLike<R> table) {
        return dsl().selectFrom(table);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(TableLike)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <pre><code>
     * SELECT * FROM table
     * </code></pre>
     *
     * @see DSL#table(Name)
     */
    @NotNull
    @Support
    public static SelectWhereStep<Record> selectFrom(Name table) {
        return dsl().selectFrom(table);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(TableLike)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <pre><code>
     * SELECT * FROM table
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(SQL)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(SQL sql) {
        return dsl().selectFrom(sql);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(TableLike)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <pre><code>
     * SELECT * FROM table
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String)
     * @see DSL#sql(String)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql) {
        return dsl().selectFrom(sql);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(TableLike)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <pre><code>
     * SELECT * FROM table
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String, Object...)
     * @see DSL#sql(String, Object...)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql, Object... bindings) {
        return dsl().selectFrom(sql, bindings);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(TableLike)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <pre><code>
     * SELECT * FROM table
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String, QueryPart...)
     * @see DSL#sql(String, QueryPart...)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql, QueryPart... parts) {
        return dsl().selectFrom(sql, parts);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(fields)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT tab1.col1, tab1.col2, …, tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#select(Collection)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> select(Collection<? extends SelectFieldOrAsterisk> fields) {
        return dsl().select(fields);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT tab1.col1, tab1.col2, …, tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> select(SelectFieldOrAsterisk... fields) {
        return dsl().select(fields);
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Field#in(Select)}, {@link Field#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1> SelectSelectStep<Record1<T1>> select(SelectField<T1> field1) {
        return (SelectSelectStep) select(new SelectField[] { field1 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row2#in(Select)}, {@link Row2#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2> SelectSelectStep<Record2<T1, T2>> select(SelectField<T1> field1, SelectField<T2> field2) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row3#in(Select)}, {@link Row3#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3> SelectSelectStep<Record3<T1, T2, T3>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row4#in(Select)}, {@link Row4#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, field4)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> SelectSelectStep<Record4<T1, T2, T3, T4>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row5#in(Select)}, {@link Row5#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, field4, field5)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> SelectSelectStep<Record5<T1, T2, T3, T4, T5>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row6#in(Select)}, {@link Row6#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field5, field6)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> SelectSelectStep<Record6<T1, T2, T3, T4, T5, T6>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row7#in(Select)}, {@link Row7#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field6, field7)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> SelectSelectStep<Record7<T1, T2, T3, T4, T5, T6, T7>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row8#in(Select)}, {@link Row8#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field7, field8)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> SelectSelectStep<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row9#in(Select)}, {@link Row9#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field8, field9)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> SelectSelectStep<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row10#in(Select)}, {@link Row10#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field9, field10)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> SelectSelectStep<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row11#in(Select)}, {@link Row11#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field10, field11)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> SelectSelectStep<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row12#in(Select)}, {@link Row12#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field11, field12)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> SelectSelectStep<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row13#in(Select)}, {@link Row13#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field12, field13)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> SelectSelectStep<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row14#in(Select)}, {@link Row14#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field13, field14)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> SelectSelectStep<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row15#in(Select)}, {@link Row15#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field14, field15)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> SelectSelectStep<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row16#in(Select)}, {@link Row16#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field15, field16)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> SelectSelectStep<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row17#in(Select)}, {@link Row17#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field16, field17)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> SelectSelectStep<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row18#in(Select)}, {@link Row18#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field17, field18)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> SelectSelectStep<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row19#in(Select)}, {@link Row19#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field18, field19)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> SelectSelectStep<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row20#in(Select)}, {@link Row20#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field19, field20)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> SelectSelectStep<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row21#in(Select)}, {@link Row21#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field20, field21)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> SelectSelectStep<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row22#in(Select)}, {@link Row22#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field21, field22)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> SelectSelectStep<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(fields)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT DISTINCT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT DISTINCT tab1.col1, tab1.col2, …, tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT DISTINCT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#selectDistinct(Collection)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> selectDistinct(Collection<? extends SelectFieldOrAsterisk> fields) {
        return dsl().selectDistinct(fields);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT DISTINCT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT DISTINCT tab1.col1, tab1.col2, …, tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT DISTINCT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> selectDistinct(SelectFieldOrAsterisk... fields) {
        return dsl().selectDistinct(fields);
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Field#in(Select)}, {@link Field#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1> SelectSelectStep<Record1<T1>> selectDistinct(SelectField<T1> field1) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row2#in(Select)}, {@link Row2#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2> SelectSelectStep<Record2<T1, T2>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row3#in(Select)}, {@link Row3#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3> SelectSelectStep<Record3<T1, T2, T3>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row4#in(Select)}, {@link Row4#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, field4)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> SelectSelectStep<Record4<T1, T2, T3, T4>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row5#in(Select)}, {@link Row5#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, field4, field5)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> SelectSelectStep<Record5<T1, T2, T3, T4, T5>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row6#in(Select)}, {@link Row6#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field5, field6)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> SelectSelectStep<Record6<T1, T2, T3, T4, T5, T6>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row7#in(Select)}, {@link Row7#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field6, field7)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> SelectSelectStep<Record7<T1, T2, T3, T4, T5, T6, T7>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row8#in(Select)}, {@link Row8#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field7, field8)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> SelectSelectStep<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row9#in(Select)}, {@link Row9#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field8, field9)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> SelectSelectStep<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row10#in(Select)}, {@link Row10#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field9, field10)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> SelectSelectStep<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row11#in(Select)}, {@link Row11#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field10, field11)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> SelectSelectStep<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row12#in(Select)}, {@link Row12#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field11, field12)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> SelectSelectStep<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row13#in(Select)}, {@link Row13#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field12, field13)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> SelectSelectStep<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row14#in(Select)}, {@link Row14#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field13, field14)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> SelectSelectStep<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row15#in(Select)}, {@link Row15#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field14, field15)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> SelectSelectStep<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row16#in(Select)}, {@link Row16#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field15, field16)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> SelectSelectStep<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row17#in(Select)}, {@link Row17#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field16, field17)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> SelectSelectStep<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row18#in(Select)}, {@link Row18#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field17, field18)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> SelectSelectStep<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row19#in(Select)}, {@link Row19#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field18, field19)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> SelectSelectStep<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row20#in(Select)}, {@link Row20#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field19, field20)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> SelectSelectStep<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row21#in(Select)}, {@link Row21#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field20, field21)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> SelectSelectStep<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row22#in(Select)}, {@link Row22#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field21, field22)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> SelectSelectStep<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL subselect statement for a constant <code>0</code>
     * literal.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectZero()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSL#zero()
     * @see DSLContext#selectZero()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectZero() {
        return dsl().selectZero();
    }

    /**
     * Create a new DSL subselect statement for a constant <code>1</code>
     * literal.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectOne()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSL#one()
     * @see DSLContext#selectOne()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectOne() {
        return dsl().selectOne();
    }

    /**
     * Create a new DSL subselect statement for <code>COUNT(*)</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectCount()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </code></pre>
     *
     * @see DSL#count()
     * @see DSLContext#selectCount()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectCount() {
        return dsl().selectCount();
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * This type of insert may feel more convenient to some users, as it uses
     * the <code>UPDATE</code> statement's <code>SET a = b</code> syntax.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table)
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .newRecord()
     *   .set(field1, value3)
     *   .set(field2, value4)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertSetStep<R> insertInto(Table<R> into) {
        return dsl().insertInto(into);
    }



    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1)
     *   .values(field1)
     *   .values(field1)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1> InsertValuesStep1<R, T1> insertInto(Table<R> into, Field<T1> field1) {
        return (InsertValuesStep1) insertInto(into, new Field[] { field1 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(field1, field2)
     *   .values(field1, field2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2> InsertValuesStep2<R, T1, T2> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2) {
        return (InsertValuesStep2) insertInto(into, new Field[] { field1, field2 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3)
     *   .values(field1, field2, field3)
     *   .values(field1, field2, field3)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3> InsertValuesStep3<R, T1, T2, T3> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return (InsertValuesStep3) insertInto(into, new Field[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, field4)
     *   .values(field1, field2, field3, field4)
     *   .values(field1, field2, field3, field4)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4> InsertValuesStep4<R, T1, T2, T3, T4> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return (InsertValuesStep4) insertInto(into, new Field[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, field4, field5)
     *   .values(field1, field2, field3, field4, field5)
     *   .values(field1, field2, field3, field4, field5)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5> InsertValuesStep5<R, T1, T2, T3, T4, T5> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return (InsertValuesStep5) insertInto(into, new Field[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field5, field6)
     *   .values(valueA1, valueA2, valueA3, .., valueA5, valueA6)
     *   .values(valueB1, valueB2, valueB3, .., valueB5, valueB6)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6> InsertValuesStep6<R, T1, T2, T3, T4, T5, T6> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return (InsertValuesStep6) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field6, field7)
     *   .values(valueA1, valueA2, valueA3, .., valueA6, valueA7)
     *   .values(valueB1, valueB2, valueB3, .., valueB6, valueB7)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7> InsertValuesStep7<R, T1, T2, T3, T4, T5, T6, T7> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return (InsertValuesStep7) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field7, field8)
     *   .values(valueA1, valueA2, valueA3, .., valueA7, valueA8)
     *   .values(valueB1, valueB2, valueB3, .., valueB7, valueB8)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8> InsertValuesStep8<R, T1, T2, T3, T4, T5, T6, T7, T8> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return (InsertValuesStep8) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field8, field9)
     *   .values(valueA1, valueA2, valueA3, .., valueA8, valueA9)
     *   .values(valueB1, valueB2, valueB3, .., valueB8, valueB9)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9> InsertValuesStep9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return (InsertValuesStep9) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field9, field10)
     *   .values(valueA1, valueA2, valueA3, .., valueA9, valueA10)
     *   .values(valueB1, valueB2, valueB3, .., valueB9, valueB10)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> InsertValuesStep10<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return (InsertValuesStep10) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field10, field11)
     *   .values(valueA1, valueA2, valueA3, .., valueA10, valueA11)
     *   .values(valueB1, valueB2, valueB3, .., valueB10, valueB11)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> InsertValuesStep11<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return (InsertValuesStep11) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field11, field12)
     *   .values(valueA1, valueA2, valueA3, .., valueA11, valueA12)
     *   .values(valueB1, valueB2, valueB3, .., valueB11, valueB12)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> InsertValuesStep12<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return (InsertValuesStep12) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field12, field13)
     *   .values(valueA1, valueA2, valueA3, .., valueA12, valueA13)
     *   .values(valueB1, valueB2, valueB3, .., valueB12, valueB13)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> InsertValuesStep13<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return (InsertValuesStep13) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field13, field14)
     *   .values(valueA1, valueA2, valueA3, .., valueA13, valueA14)
     *   .values(valueB1, valueB2, valueB3, .., valueB13, valueB14)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> InsertValuesStep14<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return (InsertValuesStep14) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field14, field15)
     *   .values(valueA1, valueA2, valueA3, .., valueA14, valueA15)
     *   .values(valueB1, valueB2, valueB3, .., valueB14, valueB15)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> InsertValuesStep15<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return (InsertValuesStep15) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field15, field16)
     *   .values(valueA1, valueA2, valueA3, .., valueA15, valueA16)
     *   .values(valueB1, valueB2, valueB3, .., valueB15, valueB16)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> InsertValuesStep16<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return (InsertValuesStep16) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field16, field17)
     *   .values(valueA1, valueA2, valueA3, .., valueA16, valueA17)
     *   .values(valueB1, valueB2, valueB3, .., valueB16, valueB17)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> InsertValuesStep17<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return (InsertValuesStep17) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field17, field18)
     *   .values(valueA1, valueA2, valueA3, .., valueA17, valueA18)
     *   .values(valueB1, valueB2, valueB3, .., valueB17, valueB18)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> InsertValuesStep18<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return (InsertValuesStep18) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field18, field19)
     *   .values(valueA1, valueA2, valueA3, .., valueA18, valueA19)
     *   .values(valueB1, valueB2, valueB3, .., valueB18, valueB19)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> InsertValuesStep19<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return (InsertValuesStep19) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field19, field20)
     *   .values(valueA1, valueA2, valueA3, .., valueA19, valueA20)
     *   .values(valueB1, valueB2, valueB3, .., valueB19, valueB20)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> InsertValuesStep20<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return (InsertValuesStep20) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field20, field21)
     *   .values(valueA1, valueA2, valueA3, .., valueA20, valueA21)
     *   .values(valueB1, valueB2, valueB3, .., valueB20, valueB21)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> InsertValuesStep21<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return (InsertValuesStep21) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field21, field22)
     *   .values(valueA1, valueA2, valueA3, .., valueA21, valueA22)
     *   .values(valueB1, valueB2, valueB3, .., valueB21, valueB22)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> InsertValuesStep22<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return (InsertValuesStep22) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(valueA1, valueA2)
     *   .values(valueB1, valueB2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Field...)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertValuesStepN<R> insertInto(Table<R> into, Field<?>... fields) {
        return dsl().insertInto(into, fields);
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(valueA1, valueA2)
     *   .values(valueB1, valueB2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </code></pre>
     *
     * @see DSLContext#insertInto(Table, Collection)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertValuesStepN<R> insertInto(Table<R> into, Collection<? extends Field<?>> fields) {
        return dsl().insertInto(into, fields);
    }

    /**
     * Create a new DSL update statement.
     * <p>
     * Unlike {@link Update} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>UPDATE</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * update(table)
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .where(field1.greaterThan(100))
     * </code></pre>
     * <p>
     * Note that some databases support table expressions more complex than
     * simple table references. In MySQL, for instance, you can write
     * <pre><code>
     * update(t1.join(t2).on(t1.id.eq(t2.id)))
     *   .set(t1.value, value1)
     *   .set(t2.value, value2)
     *   .where(t1.id.eq(10))
     * </code></pre>
     */
    @NotNull
    @Support
    public static <R extends Record> UpdateSetFirstStep<R> update(Table<R> table) {
        return dsl().update(table);
    }

    /**
     * Create a new DSL SQL standard MERGE statement.
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     * <p>
     * This statement is available from DSL syntax only. It is known to be
     * supported in some way by any of these dialects:
     * <table border="1">
     * <tr>
     * <th>dialect</th>
     * <th>support type</th>
     * <th>documentation</th>
     * </tr>
     * <tr>
     * <td>DB2</td>
     * <td>SQL:2008 standard and major enhancements</td>
     * <td><a href=
     * "http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=/com.ibm.db2.udb.admin.doc/doc/r0010873.htm"
     * >http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=/com.
     * ibm.db2.udb.admin.doc/doc/r0010873.htm</a></td>
     * </tr>
     * <tr>
     * <td>HSQLDB</td>
     * <td>SQL:2008 standard</td>
     * <td><a
     * href="http://hsqldb.org/doc/2.0/guide/dataaccess-chapt.html#N129BA"
     * >http://hsqldb.org/doc/2.0/guide/dataaccess-chapt.html#N129BA</a></td>
     * </tr>
     * <tr>
     * <td>Oracle</td>
     * <td>SQL:2008 standard and minor enhancements</td>
     * <td><a href=
     * "http://download.oracle.com/docs/cd/B28359_01/server.111/b28286/statements_9016.htm"
     * >http://download.oracle.com/docs/cd/B28359_01/server.111/b28286/
     * statements_9016.htm</a></td>
     * </tr>
     * <tr>
     * <td>SQL Server</td>
     * <td>Similar to SQL:2008 standard with some major enhancements</td>
     * <td><a href= "http://msdn.microsoft.com/de-de/library/bb510625.aspx"
     * >http://msdn.microsoft.com/de-de/library/bb510625.aspx</a></td>
     * </tr>
     * <tr>
     * <td>Sybase</td>
     * <td>Similar to SQL:2008 standard with some major enhancements</td>
     * <td><a href=
     * "http://dcx.sybase.com/1100/en/dbreference_en11/merge-statement.html"
     * >http://dcx.sybase.com/1100/en/dbreference_en11/merge-statement.html</a></td>
     * </tr>
     * </table>
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * mergeInto(table)
     *   .using(select)
     *   .on(condition)
     *   .whenMatchedThenUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .whenNotMatchedThenInsert(field1, field2)
     *   .values(value1, value2)
     * </code></pre>
     * <p>
     * Note: Using this method, you can also create an H2-specific MERGE
     * statement without field specification. See also
     * {@link #mergeInto(Table, Field...)}
     *
     * @see DSLContext#mergeInto(Table)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record> MergeUsingStep<R> mergeInto(Table<R> table) {
        return dsl().mergeInto(table);
    }



    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1> MergeKeyStep1<R, T1> mergeInto(Table<R> table, Field<T1> field1) {
        return using(new DefaultConfiguration()).mergeInto(table, field1);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2> MergeKeyStep2<R, T1, T2> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3> MergeKeyStep3<R, T1, T2, T3> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4> MergeKeyStep4<R, T1, T2, T3, T4> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5> MergeKeyStep5<R, T1, T2, T3, T4, T5> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6> MergeKeyStep6<R, T1, T2, T3, T4, T5, T6> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7> MergeKeyStep7<R, T1, T2, T3, T4, T5, T6, T7> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8> MergeKeyStep8<R, T1, T2, T3, T4, T5, T6, T7, T8> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9> MergeKeyStep9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MergeKeyStep10<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> MergeKeyStep11<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> MergeKeyStep12<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> MergeKeyStep13<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> MergeKeyStep14<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> MergeKeyStep15<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> MergeKeyStep16<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> MergeKeyStep17<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> MergeKeyStep18<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> MergeKeyStep19<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> MergeKeyStep20<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> MergeKeyStep21<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> MergeKeyStep22<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create a new DSL merge statement (H2-specific syntax).
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     * <p>
     * This statement is available from DSL syntax only. It is known to be
     * supported in some way by any of these dialects:
     * <table border="1">
     * <tr>
     * <td>H2</td>
     * <td>H2 natively supports this special syntax</td>
     * <td><a href="https://www.h2database.com/html/commands.html#merge_into"
     * >https://www.h2database.com/html/commands.html#merge_into</a></td>
     * </tr>
     * <tr>
     * <td>DB2, HSQLDB, Oracle, SQL Server, Sybase SQL Anywhere</td>
     * <td>These databases can emulate the H2-specific MERGE statement using a
     * standard SQL MERGE statement, without restrictions</td>
     * <td>See {@link #mergeInto(Table)} for the standard MERGE statement</td>
     * </tr>
     * </table>
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> MergeKeyStepN<R> mergeInto(Table<R> table, Field<?>... fields) {
        return dsl().mergeInto(table, fields);
    }

    /**
     * Create a new DSL merge statement (H2-specific syntax).
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     *
     * @see DSLContext#mergeInto(Table, Collection)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> MergeKeyStepN<R> mergeInto(Table<R> table, Collection<? extends Field<?>> fields) {
        return dsl().mergeInto(table, fields);
    }

    /**
     * Create a new DSL delete statement.
     * <p>
     * Unlike {@link Delete} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>DELETE</code> statement.
     * <p>
     * Example: <pre><code>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * deleteFrom(table)
     *   .where(field1.greaterThan(100))
     * </code></pre>
     * <p>
     * Some but not all databases support aliased tables in delete statements.
     *
     * @see DSLContext#deleteFrom(Table)
     */
    @NotNull
    @Support
    public static <R extends Record> DeleteUsingStep<R> deleteFrom(Table<R> table) {
        return dsl().deleteFrom(table);
    }

    /**
     * Create a new DSL delete statement.
     * <p>
     * This is an alias for {@link #deleteFrom(Table)}
     */
    @NotNull
    @Support
    public static <R extends Record> DeleteUsingStep<R> delete(Table<R> table) {
        return dsl().deleteFrom(table);
    }

    // -------------------------------------------------------------------------
    // XXX Comments
    // -------------------------------------------------------------------------

    /**
     * Create a comment.
     */
    @NotNull
    @Support
    public static Comment comment(String comment) {
        return isEmpty(comment) ? CommentImpl.NO_COMMENT : new CommentImpl(comment);
    }

    // -------------------------------------------------------------------------
    // XXX DDL Clauses
    // -------------------------------------------------------------------------

    /**
     * Create an unnamed (system named) <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint() {
        return new ConstraintImpl();
    }

    /**
     * Create a <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint(Name name) {
        return new ConstraintImpl(name);
    }

    /**
     * Create a <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint(String name) {
        return constraint(name(name));
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(String... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Name... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Field<?>... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Collection<? extends Field<?>> fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(String... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Name... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Field<?>... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Collection<? extends Field<?>> fields) {
        return constraint().foreignKey(fields);
    }



    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1> ConstraintForeignKeyReferencesStep1<T1> foreignKey(Field<T1> field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2> ConstraintForeignKeyReferencesStep2<T1, T2> foreignKey(Field<T1> field1, Field<T2> field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> ConstraintForeignKeyReferencesStep3<T1, T2, T3> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> ConstraintForeignKeyReferencesStep4<T1, T2, T3, T4> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> ConstraintForeignKeyReferencesStep5<T1, T2, T3, T4, T5> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> ConstraintForeignKeyReferencesStep6<T1, T2, T3, T4, T5, T6> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> ConstraintForeignKeyReferencesStep7<T1, T2, T3, T4, T5, T6, T7> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> ConstraintForeignKeyReferencesStep8<T1, T2, T3, T4, T5, T6, T7, T8> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> ConstraintForeignKeyReferencesStep9<T1, T2, T3, T4, T5, T6, T7, T8, T9> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ConstraintForeignKeyReferencesStep10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ConstraintForeignKeyReferencesStep11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ConstraintForeignKeyReferencesStep12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ConstraintForeignKeyReferencesStep13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ConstraintForeignKeyReferencesStep14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ConstraintForeignKeyReferencesStep15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ConstraintForeignKeyReferencesStep16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ConstraintForeignKeyReferencesStep17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ConstraintForeignKeyReferencesStep18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ConstraintForeignKeyReferencesStep19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ConstraintForeignKeyReferencesStep20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ConstraintForeignKeyReferencesStep21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ConstraintForeignKeyReferencesStep22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep1<?> foreignKey(Name field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep2<?, ?> foreignKey(Name field1, Name field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep3<?, ?, ?> foreignKey(Name field1, Name field2, Name field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep4<?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep5<?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep6<?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep7<?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep8<?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep9<?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20, Name field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20, Name field21, Name field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep1<?> foreignKey(String field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep2<?, ?> foreignKey(String field1, String field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep3<?, ?, ?> foreignKey(String field1, String field2, String field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep4<?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep5<?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep6<?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep7<?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep8<?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep9<?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20, String field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20, String field21, String field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(String... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Name... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Field<?>... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Collection<? extends Field<?>> fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>CHECK</code> constraint.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static ConstraintEnforcementStep check(Condition condition) {
        return constraint().check(condition);
    }

    // -------------------------------------------------------------------------
    // XXX DDL Statements
    // -------------------------------------------------------------------------



    // -------------------------------------------------------------------------
    // DDL statements
    // -------------------------------------------------------------------------

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabase(@Stringly.Name String database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabase(Name database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabase(Catalog database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(@Stringly.Name String database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(Name database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(Catalog database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(@Stringly.Name String domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(Name domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(Domain<T> domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(@Stringly.Name String domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(Name domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(Domain<T> domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(@Stringly.Name String index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(Name index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(Index index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(@Stringly.Name String index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(Name index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(Index index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(@Stringly.Name String schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(Name schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(Schema schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(@Stringly.Name String schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(Name schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(Schema schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterSequenceStep<Number> alterSequence(@Stringly.Name String sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterSequenceStep<Number> alterSequence(Name sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static <T extends Number> org.jooq.AlterSequenceStep<T> alterSequence(Sequence<T> sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterSequenceStep<Number> alterSequenceIfExists(@Stringly.Name String sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterSequenceStep<Number> alterSequenceIfExists(Name sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static <T extends Number> org.jooq.AlterSequenceStep<T> alterSequenceIfExists(Sequence<T> sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterType(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterType(@Stringly.Name String type) {
        return dsl().alterType(type);
    }

    /**
     * The <code>ALTER TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterType(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterType(Name type) {
        return dsl().alterType(type);
    }

    /**
     * The <code>ALTER TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterTypeIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterTypeIfExists(@Stringly.Name String type) {
        return dsl().alterTypeIfExists(type);
    }

    /**
     * The <code>ALTER TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterTypeIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterTypeIfExists(Name type) {
        return dsl().alterTypeIfExists(type);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterView(@Stringly.Name String view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterView(Name view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterView(Table<?> view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterViewIfExists(@Stringly.Name String view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterViewIfExists(Name view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterViewIfExists(Table<?> view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedView(@Stringly.Name String view) {
        return dsl().alterMaterializedView(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedView(Name view) {
        return dsl().alterMaterializedView(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedView(Table<?> view) {
        return dsl().alterMaterializedView(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedViewIfExists(@Stringly.Name String view) {
        return dsl().alterMaterializedViewIfExists(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedViewIfExists(Name view) {
        return dsl().alterMaterializedViewIfExists(view);
    }

    /**
     * The <code>ALTER MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterMaterializedViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterMaterializedViewIfExists(Table<?> view) {
        return dsl().alterMaterializedViewIfExists(view);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterView(Table<?> view, Field<?>... fields) {
        return dsl().alterView(view, fields);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.AlterViewStep alterView(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().alterView(view, fields);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnTable(@Stringly.Name String table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnTable(Name table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnTable(Table<?> table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnView(@Stringly.Name String view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnView(Name view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnView(Table<?> view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnMaterializedView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnMaterializedView(@Stringly.Name String view) {
        return dsl().commentOnMaterializedView(view);
    }

    /**
     * The <code>COMMENT ON MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnMaterializedView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnMaterializedView(Name view) {
        return dsl().commentOnMaterializedView(view);
    }

    /**
     * The <code>COMMENT ON MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnMaterializedView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnMaterializedView(Table<?> view) {
        return dsl().commentOnMaterializedView(view);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnColumn(@Stringly.Name String field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnColumn(Name field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(Field)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CommentOnIsStep commentOnColumn(Field<?> field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(@Stringly.Name String database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(Name database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(Catalog database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(@Stringly.Name String database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(Name database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, YUGABYTEDB })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(Catalog database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomain(@Stringly.Name String domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomain(Name domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomain(Domain<?> domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(@Stringly.Name String domain) {
        return dsl().createDomainIfNotExists(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(Name domain) {
        return dsl().createDomainIfNotExists(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(Domain<?> domain) {
        return dsl().createDomainIfNotExists(domain);
    }





































































    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndex(@Stringly.Name String index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndex(Name index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndex(Index index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex()
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndex() {
        return dsl().createIndex();
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(@Stringly.Name String index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(Name index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(Index index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists()
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createIndexIfNotExists() {
        return dsl().createIndexIfNotExists();
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndex(@Stringly.Name String index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndex(Name index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndex(Index index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex()
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndex() {
        return dsl().createUniqueIndex();
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(@Stringly.Name String index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(Name index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(Index index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists()
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists() {
        return dsl().createUniqueIndexIfNotExists();
    }





































































    /**
     * The <code>CREATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTable(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateTableElementListStep createTable(@Stringly.Name String table) {
        return dsl().createTable(table);
    }

    /**
     * The <code>CREATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateTableElementListStep createTable(Name table) {
        return dsl().createTable(table);
    }

    /**
     * The <code>CREATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateTableElementListStep createTable(Table<?> table) {
        return dsl().createTable(table);
    }

    /**
     * The <code>CREATE TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTableIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTableIfNotExists(@Stringly.Name String table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * The <code>CREATE TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTableIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTableIfNotExists(Name table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * The <code>CREATE TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTableIfNotExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTableIfNotExists(Table<?> table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTable(@Stringly.Name String table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTable(Name table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTable(Table<?> table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTableIfNotExists(@Stringly.Name String table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTableIfNotExists(Name table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createTemporaryTableIfNotExists(Table<?> table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTable(@Stringly.Name String table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTable(Name table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTable(Table<?> table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTableIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTableIfNotExists(@Stringly.Name String table) {
        return dsl().createGlobalTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTableIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTableIfNotExists(Name table) {
        return dsl().createGlobalTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE GLOBAL TEMPORARY TABLE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createGlobalTemporaryTableIfNotExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateTableElementListStep createGlobalTemporaryTableIfNotExists(Table<?> table) {
        return dsl().createGlobalTemporaryTableIfNotExists(table);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(Name view, Name... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(Table<?> view, Field<?>... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(Name view, Collection<? extends Name> fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createView(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createView(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createView(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(Name view, Name... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(Table<?> view, Field<?>... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(Name view, Collection<? extends Name> fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createViewIfNotExists(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createViewIfNotExists(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(Name view, Name... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(Table<?> view, Field<?>... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(Name view, Collection<? extends Name> fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceView(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceView(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(Name view, Name... fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(Table<?> view, Field<?>... fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(Name view, Collection<? extends Name> fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedView(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedView(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(Name view, Name... fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(Table<?> view, Field<?>... fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(Name view, Collection<? extends Name> fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE MATERIALIZED VIEW IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createMaterializedViewIfNotExists(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateViewAsStep<Record> createMaterializedViewIfNotExists(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createMaterializedViewIfNotExists(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(String, String...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(@Stringly.Name String view, @Stringly.Name String... fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(Name, Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(Name view, Name... fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(Table, Field...)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(Table<?> view, Field<?>... fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(String, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(@Stringly.Name String view, Collection<? extends String> fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(Name, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(Name view, Collection<? extends Name> fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }

    /**
     * The <code>CREATE OR REPLACE MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createOrReplaceMaterializedView(Table, Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.CreateViewAsStep<Record> createOrReplaceMaterializedView(Table<?> view, Collection<? extends Field<?>> fields) {
        return dsl().createOrReplaceMaterializedView(view, fields);
    }





































































































    /**
     * The <code>CREATE TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createType(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createType(@Stringly.Name String type) {
        return dsl().createType(type);
    }

    /**
     * The <code>CREATE TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createType(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createType(Name type) {
        return dsl().createType(type);
    }

    /**
     * The <code>CREATE TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createType(Type)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createType(Type<?> type) {
        return dsl().createType(type);
    }

    /**
     * The <code>CREATE TYPE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTypeIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createTypeIfNotExists(@Stringly.Name String type) {
        return dsl().createTypeIfNotExists(type);
    }

    /**
     * The <code>CREATE TYPE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTypeIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createTypeIfNotExists(Name type) {
        return dsl().createTypeIfNotExists(type);
    }

    /**
     * The <code>CREATE TYPE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createTypeIfNotExists(Type)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateTypeStep createTypeIfNotExists(Type<?> type) {
        return dsl().createTypeIfNotExists(type);
    }

    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchema(@Stringly.Name String schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchema(Name schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchema(Schema schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(@Stringly.Name String schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(Name schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(Schema schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequence(@Stringly.Name String sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequence(Name sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequence(Sequence<?> sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequenceIfNotExists(@Stringly.Name String sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequenceIfNotExists(Name sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.CreateSequenceAsStep<Number> createSequenceIfNotExists(Sequence<?> sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }





































































































































































































    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(@Stringly.Name String database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(Name database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(Catalog database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(@Stringly.Name String database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(Name database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(Catalog database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomain(@Stringly.Name String domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomain(Name domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomain(Domain<?> domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(@Stringly.Name String domain) {
        return dsl().dropDomainIfExists(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(Name domain) {
        return dsl().dropDomainIfExists(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(Domain<?> domain) {
        return dsl().dropDomainIfExists(domain);
    }





































































    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndex(@Stringly.Name String index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndex(Name index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndex(Index index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(@Stringly.Name String index) {
        return dsl().dropIndexIfExists(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(Name index) {
        return dsl().dropIndexIfExists(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(Index index) {
        return dsl().dropIndexIfExists(index);
    }





































































    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchema(@Stringly.Name String schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchema(Name schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchema(Schema schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(@Stringly.Name String schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(Name schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(Schema schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequence(@Stringly.Name String sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequence(Name sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequence(Sequence<?> sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(@Stringly.Name String sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(Name sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(Sequence<?> sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }





































































































































































































    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(@Stringly.Name String table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(Name table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(Table<?> table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTableIfExists(@Stringly.Name String table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTableIfExists(Name table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTableIfExists(Table<?> table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTable(@Stringly.Name String table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTable(Name table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTable(Table<?> table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(@Stringly.Name String table) {
        return dsl().dropTemporaryTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(Name table) {
        return dsl().dropTemporaryTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(Table<?> table) {
        return dsl().dropTemporaryTableIfExists(table);
    }





































































































    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(@Stringly.Name String types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(Name types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(Type)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(Type<?> types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(String...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(@Stringly.Name String... types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(Name... types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(Type...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(Type<?>... types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropType(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropType(Collection<? extends Type<?>> types) {
        return dsl().dropType(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(@Stringly.Name String types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(Name types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(Type)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(Type<?> types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(String...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(@Stringly.Name String... types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(Name...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(Name... types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(Type...)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(Type<?>... types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP TYPE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTypeIfExists(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static org.jooq.DropTypeStep dropTypeIfExists(Collection<? extends Type<?>> types) {
        return dsl().dropTypeIfExists(types);
    }

    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropView(@Stringly.Name String view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropView(Name view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropView(Table<?> view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropViewIfExists(@Stringly.Name String view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropViewIfExists(Name view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropViewIfExists(Table<?> view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedView(@Stringly.Name String view) {
        return dsl().dropMaterializedView(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedView(Name view) {
        return dsl().dropMaterializedView(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedView(Table<?> view) {
        return dsl().dropMaterializedView(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedViewIfExists(@Stringly.Name String view) {
        return dsl().dropMaterializedViewIfExists(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedViewIfExists(Name view) {
        return dsl().dropMaterializedViewIfExists(view);
    }

    /**
     * The <code>DROP MATERIALIZED VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropMaterializedViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.DropViewFinalStep dropMaterializedViewIfExists(Table<?> view) {
        return dsl().dropMaterializedViewIfExists(view);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.GrantOnStep grant(Privilege privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.GrantOnStep grant(Privilege... privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.GrantOnStep grant(Collection<? extends Privilege> privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revoke(Privilege privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revoke(Privilege... privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revoke(Collection<? extends Privilege> privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Privilege privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Privilege... privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Collection<? extends Privilege> privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>SET</code> statement.
     * <p>
     * Set a vendor specific session configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#set(String, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery set(@Stringly.Name String name, Param<?> value) {
        return dsl().set(name, value);
    }

    /**
     * The <code>SET</code> statement.
     * <p>
     * Set a vendor specific session configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#set(Name, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery set(Name name, Param<?> value) {
        return dsl().set(name, value);
    }

    /**
     * The <code>SET LOCAL</code> statement.
     * <p>
     * Set a vendor specific transaction-local configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setLocal(String, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery setLocal(@Stringly.Name String name, Param<?> value) {
        return dsl().setLocal(name, value);
    }

    /**
     * The <code>SET LOCAL</code> statement.
     * <p>
     * Set a vendor specific transaction-local configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setLocal(Name, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery setLocal(Name name, Param<?> value) {
        return dsl().setLocal(name, value);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(@Stringly.Name String catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(Name catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(Catalog catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery setSchema(@Stringly.Name String schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery setSchema(Name schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ CLICKHOUSE, DERBY, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static org.jooq.RowCountQuery setSchema(Schema schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(@Stringly.Name String table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(Name table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static <R extends Record> org.jooq.TruncateIdentityStep<R> truncate(Table<R> table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(String...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(@Stringly.Name String... table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Name...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(Name... table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Table...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(Table<?>... table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Collection)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(Collection<? extends Table<?>> table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(@Stringly.Name String table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(Name table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static <R extends Record> org.jooq.TruncateIdentityStep<R> truncateTable(Table<R> table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(String...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(@Stringly.Name String... table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Name...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(Name... table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Table...)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(Table<?>... table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Collection)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(Collection<? extends Table<?>> table) {
        return dsl().truncateTable(table);
    }













































    /**
     * The <code>START TRANSACTION</code> statement.
     * <p>
     * Start a transaction
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#startTransaction()
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery startTransaction() {
        return dsl().startTransaction();
    }

    /**
     * The <code>SAVEPOINT</code> statement.
     * <p>
     * Specify a savepoint
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#savepoint(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery savepoint(@Stringly.Name String name) {
        return dsl().savepoint(name);
    }

    /**
     * The <code>SAVEPOINT</code> statement.
     * <p>
     * Specify a savepoint
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#savepoint(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery savepoint(Name name) {
        return dsl().savepoint(name);
    }

    /**
     * The <code>RELEASE SAVEPOINT</code> statement.
     * <p>
     * Release a savepoint
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#releaseSavepoint(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery releaseSavepoint(@Stringly.Name String name) {
        return dsl().releaseSavepoint(name);
    }

    /**
     * The <code>RELEASE SAVEPOINT</code> statement.
     * <p>
     * Release a savepoint
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#releaseSavepoint(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery releaseSavepoint(Name name) {
        return dsl().releaseSavepoint(name);
    }

    /**
     * The <code>COMMIT</code> statement.
     * <p>
     * Commit a transaction
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commit()
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RowCountQuery commit() {
        return dsl().commit();
    }

    /**
     * The <code>ROLLBACK</code> statement.
     * <p>
     * Rollback a transaction
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#rollback()
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static org.jooq.RollbackToSavepointStep rollback() {
        return dsl().rollback();
    }



    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createView(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createView(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createView(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createOrReplaceView(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createOrReplaceView(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static CreateViewAsStep<Record> createOrReplaceView(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(String, String...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static CreateViewAsStep<Record> createViewIfNotExists(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(Name, Name...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static CreateViewAsStep<Record> createViewIfNotExists(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static CreateViewAsStep<Record> createViewIfNotExists(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(String)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(String table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(Name)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(Name table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(Table)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(Table<?> table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(String)
     */
    @NotNull
    @Support({ DUCKDB, H2, IGNITE, MARIADB, POSTGRES, TRINO, YUGABYTEDB })
    public static AlterTableStep alterTableIfExists(String table) {
        return dsl().alterTableIfExists(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(Name)
     */
    @NotNull
    @Support({ DUCKDB, H2, IGNITE, MARIADB, POSTGRES, TRINO, YUGABYTEDB })
    public static AlterTableStep alterTableIfExists(Name table) {
        return dsl().alterTableIfExists(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(Table)
     */
    @NotNull
    @Support({ DUCKDB, H2, IGNITE, MARIADB, POSTGRES, TRINO, YUGABYTEDB })
    public static AlterTableStep alterTableIfExists(Table<?> table) {
        return dsl().alterTableIfExists(table);
    }

    // -------------------------------------------------------------------------
    // XXX Quantified comparison predicate expressions
    // -------------------------------------------------------------------------

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static <R extends Record> QuantifiedSelect<R> all(Select<R> select) {
        return new QuantifiedSelectImpl<>(Quantifier.ALL, select);
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> QuantifiedSelect<Record1<T>> all(T... array) {
        return array instanceof Field[] ? all((Field<T>[]) array) : new QuantifiedArray<>(Quantifier.ALL, val(array));
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> QuantifiedSelect<Record1<T>> all(Field<T[]> array) {
        return new QuantifiedArray<>(Quantifier.ALL, array);
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> QuantifiedSelect<Record1<T>> all(Field<T>... fields) {
        return new QuantifiedArray<>(Quantifier.ALL, new Array<>(asList(fields)));
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static <R extends Record> QuantifiedSelect<R> any(Select<R> select) {
        return new QuantifiedSelectImpl<>(Quantifier.ANY, select);
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> QuantifiedSelect<Record1<T>> any(T... array) {
        return array instanceof Field[] ? any((Field<T>[]) array) : new QuantifiedArray<>(Quantifier.ANY, val(array));
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> QuantifiedSelect<Record1<T>> any(Field<T[]> array) {
        return new QuantifiedArray<>(Quantifier.ANY, array);
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> QuantifiedSelect<Record1<T>> any(Field<T>... fields) {
        return new QuantifiedArray<>(Quantifier.ANY, new Array<>(asList(fields)));
    }

    // -------------------------------------------------------------------------
    // XXX Other objects
    // -------------------------------------------------------------------------

    /**
     * Create a collation by its unqualified name.
     */
    @NotNull
    @Support({ HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Collation collation(String collation) {
        return collation(name(collation));
    }

    /**
     * Create a collation by its qualified name.
     */
    @NotNull
    @Support({ HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Collation collation(Name collation) {
        return new CollationImpl(collation);
    }

    /**
     * Create a character set by its unqualified name.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static CharacterSet characterSet(String characterSet) {
        return characterSet(name(characterSet));
    }

    /**
     * Create a character set by its qualified name.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static CharacterSet characterSet(Name characterSet) {
        return new CharacterSetImpl(characterSet);
    }

    /**
     * Create a new privilege reference.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     */
    @PlainSQL
    @NotNull
    @Support
    public static Privilege privilege(String privilege) {
        return privilege(keyword(privilege));
    }

    /**
     * Create a new privilege reference.
     */
    @NotNull
    @Support
    static Privilege privilege(Keyword privilege) {
        return new PrivilegeImpl(privilege);
    }

    /**
     * Create a new user reference.
     *
     * @see #user(Name)
     */
    @NotNull
    @Support
    public static User user(String name) {
        return user(name(name));
    }

    /**
     * Create a new user reference.
     */
    @NotNull
    @Support
    public static User user(Name name) {
        return new UserImpl(name);
    }

    /**
     * Create a new role reference.
     *
     * @see #role(Name)
     */
    @NotNull
    @Support
    public static Role role(String name) {
        return role(name(name));
    }

    /**
     * Create a new role reference.
     */
    @NotNull
    @Support
    public static Role role(Name name) {
        return new RoleImpl(name);
    }

    // -------------------------------------------------------------------------
    // XXX Data Change Delta Table
    // -------------------------------------------------------------------------

    /**
     * Get the data change delta table with result option <code>OLD</code> to
     * retrieve the modified data from before the {@link Update} or
     * {@link Delete} statement was applied.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, POSTGRES })
    public static <R extends Record> Table<R> oldTable(Update<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.OLD, query);
    }

    /**
     * Get the data change delta table with result option <code>OLD</code> to
     * retrieve the modified data from before the {@link Update} or
     * {@link Delete} statement was applied.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, POSTGRES })
    public static <R extends Record> Table<R> oldTable(Delete<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.OLD, query);
    }

    /**
     * Get the data change delta table with result option <code>OLD</code> to
     * retrieve the modified data from before the {@link Update} or
     * {@link Delete} statement was applied.
     */
    @NotNull
    @Support({ H2 })
    public static <R extends Record> Table<R> oldTable(Merge<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.OLD, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show transitive data prior to
     * referential integrity validation and the firing of any after triggers.
     */
    @NotNull
    @Support({ H2 })
    public static <R extends Record> Table<R> newTable(Insert<R> query) {
        return new DataChangeDeltaTable<R>(ResultOption.NEW, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show transitive data prior to
     * referential integrity validation and the firing of any after triggers.
     */
    @NotNull
    @Support({ H2 })
    public static <R extends Record> Table<R> newTable(Update<R> query) {
        return new DataChangeDeltaTable<R>(ResultOption.NEW, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show transitive data prior to
     * referential integrity validation and the firing of any after triggers.
     */
    @NotNull
    @Support({ H2 })
    public static <R extends Record> Table<R> newTable(Merge<R> query) {
        return new DataChangeDeltaTable<R>(ResultOption.NEW, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show data after all referential
     * integrity validation and all triggers have been executed or fired,
     * meaning there will be no more additional modification to the "final"
     * version of the modified data.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, POSTGRES })
    public static <R extends Record> Table<R> finalTable(Insert<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.FINAL, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show data after all referential
     * integrity validation and all triggers have been executed or fired,
     * meaning there will be no more additional modification to the "final"
     * version of the modified data.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, POSTGRES })
    public static <R extends Record> Table<R> finalTable(Update<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.FINAL, query);
    }

    /**
     * Get the data change delta table with result option <code>NEW</code> to
     * retrieve the modified data from after the {@link Update} or
     * {@link Insert} statement was applied.
     * <p>
     * Depending on the dialect, this may show data after all referential
     * integrity validation and all triggers have been executed or fired,
     * meaning there will be no more additional modification to the "final"
     * version of the modified data.
     */
    @NotNull
    @Support({ H2 })
    public static <R extends Record> Table<R> finalTable(Merge<R> query) {
        return new DataChangeDeltaTable<>(ResultOption.FINAL, query);
    }

    // -------------------------------------------------------------------------
    // XXX Conversion of objects into tables
    // -------------------------------------------------------------------------

    /**
     * A synonym for {@link Select#asTable()}, which might look a bit more fluent
     * like this, to some users.
     *
     * @see Select#asTable()
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(Select<R> select) {
        return select.asTable();
    }

    /**
     * Use a previously obtained result as a new {@link Table} that can be used
     * in SQL statements through {@link #values(RowN...)}.
     *
     * @see #values(RowN...)
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(Result<R> result) {

        // TODO [#2986] Coerce the record type upon the resulting table.
        return (Table<R>) values0(map(result, r -> r.valuesRow(), Row[]::new)).as(
            name("v"),
            map(result.fields(), f -> f.getUnqualifiedName(), Name[]::new)
        );
    }

    /**
     * Use a previously obtained record as a new Table
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(R record) {
        return table((R[]) new Record[] { record });
    }

    /**
     * Use a previously obtained set of records as a new Table
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(R... records) {
        if (records == null || records.length == 0)
            return (Table<R>) new Dual();

        Result<R> result = new ResultImpl(configuration(records[0]), (AbstractRow) records[0].fieldsRow());
        result.addAll(Arrays.asList(records));

        return table(result);
    }

    /**
     * A synonym for {@link #unnest(Collection)}.
     *
     * @see #unnest(Collection)
     */
    @NotNull
    @Support
    public static Table<?> table(Collection<?> list) {
        return unnest(list);
    }

    /**
     * A synonym for {@link #unnest(Object[])}.
     *
     * @see #unnest(Object[])
     */
    @NotNull
    @Support
    public static Table<?> table(Object[] array) {
        return unnest(array);
    }















    /**
     * A synonym for {@link #unnest(Field)}.
     *
     * @see #unnest(Field)
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES })
    public static Table<?> table(Field<?> cursor) {
        return unnest(cursor);
    }

    /**
     * Create a table from a list of values.
     * <p>
     * This is equivalent to the <code>TABLE</code> function for H2, or the
     * <code>UNNEST</code> function in HSQLDB and Postgres
     * <p>
     * For Oracle, use {@link #table(ArrayRecord)} instead, as Oracle knows only
     * typed arrays
     * <p>
     * In all other dialects, unnesting of arrays is emulated using several
     * <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support
    public static Table<?> unnest(Collection<?> list) {
        return unnest(list.toArray());
    }

    /**
     * Create a table from an array of values.
     * <p>
     * This is equivalent to the <code>TABLE</code> function for H2, or the
     * <code>UNNEST</code> function in HSQLDB and Postgres
     * <p>
     * For Oracle, use {@link #table(ArrayRecord)} instead, as Oracle knows only
     * typed arrays
     * <p>
     * In all other dialects, unnesting of arrays is emulated using several
     * <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support
    public static Table<?> unnest(Object[] array) {
        boolean notEmpty = !isEmpty(array);

        if (notEmpty && array[0] instanceof Field)
            return new ArrayOfValues(Tools.fieldsArray(array));
        else if (notEmpty && array.getClass() == Object[].class)
            return unnest0(val(mostSpecificArray(array)));
        else
            return unnest0(val(array));
    }
















    /**
     * Create a table from a field.
     * <p>
     * The supplied field can have any of these types:
     * <ul>
     * <li> {@link Result}: For <code>CURSOR</code> or <code>REF CURSOR</code>
     * fields, typically fetched from stored functions or from nested tables</li>
     * <li> {@link ArrayRecord}: For Oracle-style <code>VARRAY</code> types.</li>
     * <li> {@link Object}[]: Array types, for other RDBMS's ARRAY types (e.g.
     * H2, HSQLDB, and Postgres)</li>
     * <li> {@link Object}: Any other type that jOOQ will try to convert in an
     * array first, before converting that array into a table</li>
     * </ul>
     * <p>
     * This functionality has only limited scope when used in H2, as ARRAY types
     * involved with stored functions can only be of type <code>Object[]</code>.
     * Such arrays are converted into <code>VARCHAR</code> arrays by jOOQ.
     * <p>
     * In all dialects where arrays are not supported, unnesting of arrays is
     * emulated using several <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES })
    public static Table<?> unnest(Field<?> cursor) {
        return unnest0(cursor);
    }

    private static Table<?> unnest0(Field<?> cursor) {
        if (cursor == null)
            throw new IllegalArgumentException();

        // The field is an actual CURSOR or REF CURSOR returned from a stored
        // procedure or from a NESTED TABLE
        else if (cursor.getDataType().getFromType() == Result.class)
            return new FunctionTable<Record>(cursor);











        // The field is a regular array
        else if (cursor.getDataType().getFromType().isArray()
              && cursor.getDataType().getFromType() != byte[].class)
            return new ArrayTable(cursor);

        // The field has any other type. Try to make it an array
        throw new SQLDialectNotSupportedException("Converting arbitrary types into array tables is currently not supported");
    }

    // -------------------------------------------------------------------------
    // XXX Table functions
    // -------------------------------------------------------------------------

    /**
     * The <code>DUAL</code> table to be used for syntactic completeness.
     * <p>
     * In general, jOOQ will generate a <code>DUAL</code> table (or any
     * equivalent construct, see below), if this is needed syntactically in
     * generated SQL. You may still wish to explicitly use a <code>DUAL</code>
     * construct in jOOQ code for various reasons. This <code>DUAL</code> table
     * will always contain a single record with a single varchar(1) value:
     * <pre><code>
     * +-------+
     * | DUMMY |
     * +-------+
     * | X     |
     * +-------+
     * </code></pre>
     */
    @NotNull
    @Support
    public static Table<Record> dual() {
        return new Dual(true);
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, int to) {
        return generateSeries(val(from), val(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to) {
        return generateSeries(val(from), Tools.nullSafe(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to) {
        return new GenerateSeries(Tools.nullSafe(from), val(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects
     * may be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c- 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, int to, int step) {
        return generateSeries(val(from), val(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to, int step) {
        return generateSeries(val(from), Tools.nullSafe(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to, int step) {
        return new GenerateSeries(Tools.nullSafe(from), val(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to, int step) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects
     * may be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c- 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, int to, Field<Integer> step) {
        return generateSeries(val(from), val(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to, Field<Integer> step) {
        return generateSeries(val(from), Tools.nullSafe(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to, Field<Integer> step) {
        return new GenerateSeries(Tools.nullSafe(from), val(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <pre><code>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </code></pre>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to, Field<Integer> step) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to), Tools.nullSafe(step));
    }

    /**
     * Create a <code>LATERAL</code> joined table.
     * <p>
     * Example:
     * <pre><code>
     * SELECT *
     * FROM employees e,
     *      LATERAL(SELECT * FROM departments d
     *              WHERE e.department_id = d.department_id);
     * </code></pre>
     */
    @NotNull
    @Support({ FIREBIRD, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static <R extends Record> Table<R> lateral(TableLike<R> table) {

        // [#14988] LATERAL (table reference) isn't supported in any dialect
        //          and it's also superfluous, so we'll just omit it to make
        //          sure things like APPLY table reference are emulated correctly
        if (table instanceof TableImpl || table instanceof JoinTable)
            return (Table<R>) table;
        else
            return new Lateral<>(table.asTable());
    }

    /**
     * Create a <code>ROWS FROM (tables…)</code> expression.
     * <p>
     * Example: <pre><code>
     * SELECT *
     * FROM ROWS FROM (function1('a', 'b'), function2('c', 'd'));
     * </code></pre>
     * <p>
     * This allows for full outer joining several table-valued functions on the
     * row number of each function's produced rows.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Table<Record> rowsFrom(Table<?>... tables) {
        return new RowsFrom(tables);
    }

    // -------------------------------------------------------------------------
    // XXX SQL keywords
    // -------------------------------------------------------------------------

    /**
     * Create a SQL keyword.
     * <p>
     * A <code>Keyword</code> is a {@link QueryPart} that renders a SQL keyword
     * according to the settings specified in
     * {@link Settings#getRenderKeywordCase()}. It can be embedded in other
     * plain SQL <code>QueryParts</code> as shown in this example:
     * <p>
     * <pre><code>
     * Condition c = condition("{0} {1} {2} {3} {4}",
     *     value1, keyword("between")
     *     value2, keyword("and")
     *     value3
     * );
     * </code></pre>
     */
    @NotNull
    @Support
    public static Keyword keyword(String keyword) {
        return new KeywordImpl(keyword);
    }

    // -------------------------------------------------------------------------
    // XXX Names
    // -------------------------------------------------------------------------

    /**
     * Create a new SQL identifier using an unqualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <pre><code>
     * // This unqualified name here
     * name("book");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </code></pre>
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName);
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <pre><code>
     * // This qualified name here
     * name("book", "title");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </code></pre>
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(String... qualifiedName) {
        if (Tools.isEmpty(qualifiedName))
            return new UnqualifiedName(null);

        Name result = new UnqualifiedName(qualifiedName[0]);

        for (int i = 1; i < qualifiedName.length; i++)
            result = result.append(new UnqualifiedName(qualifiedName[i]));

        return result;
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Unlike other {@link #name(String...)} constructors, this one constructs a
     * name from its argument {@link Name#unqualifiedName()} parts, retaining
     * the quoted flag, to construct a new name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li>{@link #field(Name)}</li>
     * <li>{@link #field(Name, Class)}</li>
     * <li>{@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <pre><code>
     * // This qualified name here
     * name(quotedName("book"), unquotedName("title"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].title
     * </code></pre>
     *
     * @param nameParts The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(Name... nameParts) {
        if (Tools.isEmpty(nameParts))
            return new UnqualifiedName(null);

        Name result = nameParts[0] != null ? nameParts[0] : new UnqualifiedName(null);

        for (int i = 1; i < nameParts.length; i++)
            result = result.append(nameParts[i]);

        return result;
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <pre><code>
     * // This qualified name here
     * name("book", "title");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </code></pre>
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(Collection<String> qualifiedName) {
        return name(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    /**
     * Create a new SQL identifier using an unqualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be quoted by default in databases that support quoted
     * identifiers, exept if forced to be unquoted using
     * {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#NEVER}.
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName, Quoted.QUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be quoted by default in databases that support quoted
     * identifiers, exept if forced to be unquoted using
     * {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#NEVER}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(String... qualifiedName) {
        if (Tools.isEmpty(qualifiedName))
            return new UnqualifiedName(null);

        Name result = new UnqualifiedName(qualifiedName[0], Quoted.QUOTED);

        for (int i = 1; i < qualifiedName.length; i++)
            result = result.append(new UnqualifiedName(qualifiedName[i], Quoted.QUOTED));

        return result;
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(Collection)}, except that generated
     * identifiers will be quoted by default in databases that support quoted
     * identifiers, exept if forced to be unquoted using
     * {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#NEVER}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(Collection<String> qualifiedName) {
        return quotedName(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    /**
     * Create a new SQL identifier using an unqualified, quoted name.
     * <p>
     * This works like {@link #name(String)}, except that generated
     * identifiers will be unquoted by default, except if forced to be quoted
     * using {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName, Quoted.UNQUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be unquoted by default, except if forced to be quoted
     * using {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(String... qualifiedName) {
        if (Tools.isEmpty(qualifiedName))
            return new UnqualifiedName(null);

        Name result = new UnqualifiedName(qualifiedName[0], Quoted.UNQUOTED);

        for (int i = 1; i < qualifiedName.length; i++)
            result = result.append(new UnqualifiedName(qualifiedName[i], Quoted.UNQUOTED));

        return result;
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(Collection)}, except that generated
     * identifiers will be unquoted by default, except if forced to be quoted
     * using {@link Settings#getRenderQuotedNames()} with value
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(Collection<String> qualifiedName) {
        return unquotedName(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    /**
     * Create a new SQL identifier using an unqualified, quoted name.
     * <p>
     * This works like {@link #unquotedName(String)}, except that generated
     * identifiers will be guaranteed to be unquoted, even when the relevant
     * {@link Settings#getRenderQuotedNames()} flag is set to
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name systemName(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName, Quoted.SYSTEM);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #unquotedName(String...)}, except that generated
     * identifiers will be guaranteed to be unquoted, even when the relevant
     * {@link Settings#getRenderQuotedNames()} flag is set to
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name systemName(String... qualifiedName) {
        if (Tools.isEmpty(qualifiedName))
            return new UnqualifiedName(null);

        Name result = new UnqualifiedName(qualifiedName[0], Quoted.SYSTEM);

        for (int i = 1; i < qualifiedName.length; i++)
            result = result.append(new UnqualifiedName(qualifiedName[i], Quoted.SYSTEM));

        return result;
    }

    /**
     * Create a new SQL identifier using a qualified, system name.
     * <p>
     * This works like {@link #unquotedName(Collection)}, except that generated
     * identifiers will be guaranteed to be unquoted, even when the relevant
     * {@link Settings#getRenderQuotedNames()} flag is set to
     * {@link RenderQuotedNames#ALWAYS}.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name systemName(Collection<String> qualifiedName) {
        return systemName(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    // -------------------------------------------------------------------------
    // XXX QueryPart composition
    // -------------------------------------------------------------------------

    /**
     * Compose a list of <code>QueryParts</code> into a new
     * <code>QueryPart</code>, with individual parts being comma-separated.
     */
    @NotNull
    @Support
    public static QueryPart list(QueryPart... parts) {
        return list(Arrays.asList(parts));
    }

    /**
     * Compose a list of <code>QueryParts</code> into a new
     * <code>QueryPart</code>, with individual parts being comma-separated.
     */
    @NotNull
    @Support
    public static QueryPart list(Collection<? extends QueryPart> parts) {
        return new QueryPartList<>(parts);
    }

    // -------------------------------------------------------------------------
    // XXX SQL identifiers
    // -------------------------------------------------------------------------

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * While the <code>DEFAULT</code> keyword works with all data types, you may
     * still prefer to associate a {@link Field} type with your
     * <code>DEFAULT</code> value. In that case, use
     * {@link #defaultValue(Class)} or {@link #defaultValue(DataType)} instead.
     * <p>
     * This is an alias for {@link #default_()}.
     *
     * @see #default_()
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Object> defaultValue() {
        return default_();
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(Class)}.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #defaultValue(DataType)}.
     *
     * @see #default_(Class)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> defaultValue(Class<T> type) {
        return default_(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(DataType)}.
     *
     * @see #default_(DataType)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> defaultValue(DataType<T> type) {
        return default_(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(Field)}.
     *
     * @see #default_(Field)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> defaultValue(Field<T> field) {
        return default_(field);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * While the <code>DEFAULT</code> keyword works with all data types, you may
     * still prefer to associate a {@link Field} type with your
     * <code>DEFAULT</code> value. In that case, use
     * {@link #defaultValue(Class)} or {@link #defaultValue(DataType)} instead.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Object> default_() {
        return default_(Object.class);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #default_(DataType)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> default_(Class<T> type) {
        return default_(getDataType(type));
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> default_(DataType<T> type) {
        return new Default<T>(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static <T> Field<T> default_(Field<T> field) {
        return default_(field.getDataType());
    }

    /**
     * Return a {@link Table} that behaves like no table being present.
     * <p>
     * When creating dynamic SQL queries using expressions, it is often useful
     * to be able to decide dynamically whether a clause is being added to a
     * query or not. In case that clause accepts tables, the {@link #noTable()}
     * can be used to avoid creating a <code>FROM</code> clause or a join
     * operation.
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Table} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     */
    @NotNull
    @Support
    public static Table<?> noTable() {
        return NoTable.INSTANCE;
    }

    /**
     * Return a {@link Field} that behaves like no field being present.
     * <p>
     * When creating dynamic SQL queries using expressions, it is often useful
     * to be able to decide dynamically whether a clause is being added to a
     * query or not. In case that clause accepts fields, the {@link #noField()}
     * can be used to avoid creating a clause, which is useful for the following
     * {@link Select} clauses, for example:
     * <ul>
     * <li>{@link SelectGroupByStep#groupBy(GroupField...)}</li>
     * <li>{@link SelectOrderByStep#orderBy(OrderField...)}</li>
     * <li>{@link SelectLimitStep#limit(Field)}</li>
     * <li>{@link SelectOffsetStep#offset(Field)}</li>
     * </ul>
     * It can also be useful for other, similar clauses, e.g. when passing
     * optional expressions to window function clauses, such as:
     * <ul>
     * <li>{@link DSL#partitionBy(GroupField...)}</li>
     * <li>{@link DSL#orderBy(OrderField...)}</li>
     * </ul>
     * In clauses that project fields to a given {@link Record} type, the
     * {@link #noField()} simply projects <code>NULL</code> and cannot be used
     * to avoid the clause.
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Field} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     */
    @NotNull
    @Support
    public static Field<?> noField() {
        return NoField.INSTANCE;
    }

    /**
     * Return a {@link Field} that behaves like no field being present.
     * <p>
     * When creating dynamic SQL queries using expressions, it is often useful
     * to be able to decide dynamically whether a clause is being added to a
     * query or not. In case that clause accepts fields, the {@link #noField()}
     * can be used to avoid creating a clause, which is useful for the following
     * {@link Select} clauses, for example:
     * <ul>
     * <li>{@link SelectGroupByStep#groupBy(GroupField...)}</li>
     * <li>{@link SelectOrderByStep#orderBy(OrderField...)}</li>
     * <li>{@link SelectLimitStep#limit(Field)}</li>
     * <li>{@link SelectOffsetStep#offset(Field)}</li>
     * </ul>
     * It can also be useful for other, similar clauses, e.g. when passing
     * optional expressions to window function clauses, such as:
     * <ul>
     * <li>{@link DSL#partitionBy(GroupField...)}</li>
     * <li>{@link DSL#orderBy(OrderField...)}</li>
     * </ul>
     * In clauses that project fields to a given {@link Record} type, the
     * {@link #noField()} simply projects <code>NULL</code> and cannot be used
     * to avoid the clause.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class} references
     * of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to {@link #noField(DataType)}.
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Field} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     *
     * @param type A class to derive the {@link Field#getDataType()} from.
     */
    @NotNull
    @Support
    public static <T> Field<T> noField(Class<T> type) {
        return noField(getDataType(type));
    }

    /**
     * Return a {@link Field} that behaves like no field being present.
     * <p>
     * When creating dynamic SQL queries using expressions, it is often useful
     * to be able to decide dynamically whether a clause is being added to a
     * query or not. In case that clause accepts fields, the {@link #noField()}
     * can be used to avoid creating a clause, which is useful for the following
     * {@link Select} clauses, for example:
     * <ul>
     * <li>{@link SelectGroupByStep#groupBy(GroupField...)}</li>
     * <li>{@link SelectOrderByStep#orderBy(OrderField...)}</li>
     * <li>{@link SelectLimitStep#limit(Field)}</li>
     * <li>{@link SelectOffsetStep#offset(Field)}</li>
     * </ul>
     * It can also be useful for other, similar clauses, e.g. when passing
     * optional expressions to window function clauses, such as:
     * <ul>
     * <li>{@link DSL#partitionBy(GroupField...)}</li>
     * <li>{@link DSL#orderBy(OrderField...)}</li>
     * </ul>
     * In clauses that project fields to a given {@link Record} type, the
     * {@link #noField()} simply projects <code>NULL</code> and cannot be used
     * to avoid the clause.
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Field} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     *
     * @param type A type to derive the {@link Field#getDataType()} from.
     */
    @NotNull
    @Support
    public static <T> Field<T> noField(DataType<T> type) {
        return new NoField<>(type);
    }

    /**
     * Return a {@link Field} that behaves like no field being present.
     * <p>
     * When creating dynamic SQL queries using expressions, it is often useful
     * to be able to decide dynamically whether a clause is being added to a
     * query or not. In case that clause accepts fields, the {@link #noField()}
     * can be used to avoid creating a clause, which is useful for the following
     * {@link Select} clauses, for example:
     * <ul>
     * <li>{@link SelectGroupByStep#groupBy(GroupField...)}</li>
     * <li>{@link SelectOrderByStep#orderBy(OrderField...)}</li>
     * <li>{@link SelectLimitStep#limit(Field)}</li>
     * <li>{@link SelectOffsetStep#offset(Field)}</li>
     * </ul>
     * It can also be useful for other, similar clauses, e.g. when passing
     * optional expressions to window function clauses, such as:
     * <ul>
     * <li>{@link DSL#partitionBy(GroupField...)}</li>
     * <li>{@link DSL#orderBy(OrderField...)}</li>
     * </ul>
     * In clauses that project fields to a given {@link Record} type, the
     * {@link #noField()} simply projects <code>NULL</code> and cannot be used
     * to avoid the clause.
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Field} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     *
     * @param type A field to derive the {@link Field#getDataType()} from.
     */
    @NotNull
    @Support
    public static <T> Field<T> noField(Field<T> field) {
        return noField(field.getDataType());
    }

    /**
     * Create a qualified catalog, given its catalog name.
     * <p>
     * This constructs a catalog reference given the catalog's qualified name.
     * <p>
     * Example: <pre><code>
     * // This catalog...
     * catalog(name("MY_CATALOG"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG]
     * </code></pre>
     */
    @NotNull
    @Support
    public static Catalog catalog(String name) {
        return catalog(name(name));
    }

    /**
     * Create a qualified catalog, given its catalog name.
     * <p>
     * This constructs a catalog reference given the catalog's qualified name.
     * <p>
     * Example: <pre><code>
     * // This catalog...
     * catalog(name("MY_CATALOG"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG]
     * </code></pre>
     */
    @NotNull
    @Support
    public static Catalog catalog(Name name) {
        return new CatalogImpl(name);
    }

    /**
     * Create a qualified schema, given its schema name.
     * <p>
     * This constructs a schema reference given the schema's qualified name.
     * <p>
     * Example: <pre><code>
     * // This schema...
     * schema(name("MY_CATALOG", "MY_SCHEMA"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG].[MY_SCHEMA]
     * </code></pre>
     */
    @NotNull
    @Support
    public static Schema schema(String name) {
        return schema(name(name));
    }

    /**
     * Create a qualified schema, given its schema name.
     * <p>
     * This constructs a schema reference given the schema's qualified name.
     * <p>
     * Example: <pre><code>
     * // This schema...
     * schema(name("MY_CATALOG", "MY_SCHEMA"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG].[MY_SCHEMA]
     * </code></pre>
     */
    @NotNull
    @Support
    public static Schema schema(Name name) {
        return new SchemaImpl(name);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <pre><code>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </code></pre>
     */
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static Sequence<BigInteger> sequence(Name name) {
        return sequence(name, BigInteger.class);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example:
     *
     * <pre>
     * <code>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </code>
     * </pre>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #sequence(Name, DataType)}.
     *
     * @param name The sequence name
     * @param type The sequence type (a type that is supported by
     *            {@link SQLDataType})
     */
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static <T extends Number> Sequence<T> sequence(Name name, Class<T> type) {
        return sequence(name, getDataType(type));
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <pre><code>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </code></pre>
     */
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static <T extends Number> Sequence<T> sequence(Name name, DataType<T> type) {
        return new SequenceImpl<>(
            name.unqualifiedName(),
            name.qualified() ? schema(name.qualifier()) : null,
            CommentImpl.NO_COMMENT,
            type,
            false
        );
    }






























    /**
     * Create a qualified type, given its type name.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static Type<?> type(@Stringly.Name String name) {
        return type(name(name));
    }

    /**
     * Create a qualified type, given its type name.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static Type<?> type(Name name) {
        return type(name, SQLDataType.OTHER);
    }

    /**
     * Create a qualified type, given its type name.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static <T> Type<T> type(@Stringly.Name String name, DataType<T> type) {
        return type(name(name), type);
    }

    /**
     * Create a qualified type, given its type name.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static <T> Type<T> type(Name name, DataType<T> type) {
        return new TypeImpl<>(name, CommentImpl.NO_COMMENT, type);
    }

    /**
     * Create a qualified table, given its table name.
     * <p>
     * This constructs a table reference given the table's qualified name. jOOQ
     * <p>
     * Example: <pre><code>
     * // This table...
     * tableByName("MY_SCHEMA", "MY_TABLE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE]
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     */
    @NotNull
    @Support
    public static Table<Record> table(Name name) {
        return new TableImpl<>(name);
    }

    /**
     * Create a qualified table, given its table name.
     * <p>
     * This constructs a table reference given the table's qualified name. jOOQ
     * <p>
     * Example: <pre><code>
     * // This table...
     * tableByName("MY_SCHEMA", "MY_TABLE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE]
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     */
    @NotNull
    @Support
    public static Table<Record> table(Name name, Comment comment) {
        return new TableImpl<>(name, null, null, null, comment);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example:
     *
     * <pre>
     * <code>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </code>
     * </pre>
     * <p>
     * Another example:
     *
     * <pre>
     * <code>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: A lot of things work less well in jOOQ if no
     * {@link DataType} information is attached to a {@link Field} expression,
     * including:
     * <ul>
     * <li>Some drivers may find it hard to bind <code>NULL</code> values.</li>
     * <li>Some RDBMS may find it hard to infer a type from an expression
     * alone.</li>
     * <li>User defined types may not be supported.</li>
     * <li>You don't get compile time type safety.</li>
     * </ul>
     * It is usually better to use {@link DSL#field(Name, DataType)}, instead,
     * or even better, use code generation where possible: <a href=
     * "https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/">https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/</a>,
     * in case of which {@link DataType} information is attached to all
     * {@link Field} expressions automatically.
     */
    @NotNull
    @Support
    public static Field<Object> field(Name name) {
        return field(name, Object.class);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example:
     *
     * <pre>
     * <code>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </code>
     * </pre>
     * <p>
     * Another example:
     *
     * <pre>
     * <code>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </code>
     * </pre>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #field(Name, DataType)}.
     *
     * @param name The field name
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, Class<T> type) {
        return field(name, getDataType(type));
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <pre><code>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </code></pre>
     * <p>
     * Another example: <pre><code>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, DataType<T> type) {
        return field(name, type, null);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <pre><code>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </code></pre>
     * <p>
     * Another example: <pre><code>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, DataType<T> type, Comment comment) {
        return new TableFieldImpl<>(name, type, comment);
    }

    /**
     * Create a qualified index reference by name.
     */
    @NotNull
    @Support
    public static Index index(Name name) {
        return new IndexImpl(name);
    }






































































































    // -------------------------------------------------------------------------
    // XXX: Lambda constructors
    // -------------------------------------------------------------------------

    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    @NotNull
    static <T1, QR extends QueryPart> Lambda1<Field<T1>, QR> lambda(T1[] field, org.jooq.Function1<? super Field<T1>, ? extends QR> function) {
        return lambda(Tools.field(field), function);
    }

    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    @NotNull
    static <T1, QR extends QueryPart> Lambda1<Field<T1>, QR> lambda(Field<T1[]> field, org.jooq.Function1<? super Field<T1>, ? extends QR> function) {
        Field<T1> e = (Field<T1>) DSL.field(N_E, field.getDataType().getArrayBaseDataType());
        return lambda(e, function.apply(e));
    }

    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    @NotNull
    public static <Q1 extends QueryPart, QR extends QueryPart> Lambda1<Q1, QR> lambda(Q1 arg1, QR result) {
        return new org.jooq.impl.LambdaImpl1<>(arg1, result);
    }

    // -------------------------------------------------------------------------
    // XXX: Routine parameter constructors
    // -------------------------------------------------------------------------

    /**
     * Create an <code>IN</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> in(String name, DataType<T> type) {
        return in(name(name), type);
    }

    /**
     * Create an <code>IN</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> in(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.IN, name, type);
    }

    /**
     * Create an <code>IN OUT</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> inOut(String name, DataType<T> type) {
        return inOut(name(name), type);
    }

    /**
     * Create an <code>IN OUT</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> inOut(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.INOUT, name, type);
    }

    /**
     * Create an <code>OUT</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> out(String name, DataType<T> type) {
        return out(name(name), type);
    }

    /**
     * Create an <code>OUT</code> parameter.
     * <p>
     * A parameter renders itself differently, depending on
     * {@link Context#declareParameters()}. There are two rendering modes:
     * <ul>
     * <li>Declaration: The paramet renders its {@link Parameter#getParamMode()}
     * along with the parameter name and data type. This typically happens in
     * <code>CREATE PROCEDURE</code> or <code>CREATE FUNCTION</code>
     * clauses.</li>
     * <li>Reference: The parameter renders its identifier. This happens
     * everywhere else.</li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Parameter<T> out(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.OUT, name, type);
    }

    // -------------------------------------------------------------------------
    // XXX: Queries
    // -------------------------------------------------------------------------

    /**
     * Wrap a collection of queries.
     *
     * @see DSLContext#queries(Query...)
     */
    @NotNull
    @Support
    public static Queries queries(Query... queries) {
        return queries(Arrays.asList(queries));
    }

    /**
     * Wrap a collection of queries.
     *
     * @see DSLContext#queries(Collection)
     */
    @NotNull
    @Support
    public static Queries queries(Collection<? extends Query> queries) {
        return DSL.using(new DefaultConfiguration()).queries(queries);
    }

    /**
     * Wrap a collection of statements in an anonymous procedural block.
     *
     * @see DSLContext#begin(Statement...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Block begin(Statement... statements) {
        return begin(Arrays.asList(statements));
    }

    /**
     * Wrap a collection of statements in an anonymous procedural block.
     *
     * @see DSLContext#begin(Collection)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Block begin(Collection<? extends Statement> statements) {
        return DSL.using(new DefaultConfiguration()).begin(statements);
    }










































































































































































































































































































































































































































































































    // -------------------------------------------------------------------------
    // XXX Plain SQL object factory
    // -------------------------------------------------------------------------

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * Unlike other ways to create plain SQL templates, this only contains raw
     * String content, without any templating capabilities or bind values.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL raw(String sql) {
        return new SQLImpl(sql, true);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql) {
        return sql(sql, new Object[0]);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * This overload takes a set of {@link QueryPart} arguments which are
     * replaced into the SQL string template at the appropriate index. Example:
     * <p>
     * <pre><code>
     * // Argument QueryParts are replaced into the SQL string at the appropriate index
     * sql("select {0}, {1} from {2}", TABLE.COL1, TABLE.COL2, TABLE);
     *
     * // Bind variables are supported as well, for backwards compatibility
     * sql("select col1, col2 from table where col1 = ?", val(1));
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query part wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql, QueryPart... parts) {
        return sql(sql, (Object[]) parts);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL. There must be as many bind variables contained
     * in the SQL, as passed in the bindings parameter
     * <p>
     * This overload takes a set of bind value arguments which are replaced our
     * bound into the SQL string template at the appropriate index. Example:
     * <p>
     * <pre><code>
     * sql("select col1, col2 from table where col1 = ?", 1);
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql, Object... bindings) {
        return new SQLImpl(sql, false, bindings);
    }

    // -------------------------------------------------------------------------
    // XXX Plain SQL API
    // -------------------------------------------------------------------------

    /**
     * Create a new query holding plain SQL. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "SET SCHEMA 'abc'";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(SQL sql) {
        return dsl().query(sql);
    }

    /**
     * Create a new query holding plain SQL. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "SET SCHEMA 'abc'";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql) {
        return dsl().query(sql);
    }

    /**
     * Create a new query holding plain SQL. There must be as many bind
     * variables contained in the SQL, as passed in the bindings parameter.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "SET SCHEMA 'abc'";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql, Object... bindings) {
        return dsl().query(sql, bindings);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * Unlike {@link #query(String, Object...)}, the SQL passed to this method
     * should not contain any bind variables. Instead, you can pass
     * {@link QueryPart} objects to the method which will be rendered at indexed
     * locations of your SQL string as such: <pre><code>
     * // The following query
     * query("select {0}, {1} from {2}", val(1), inline("test"), name("DUAL"));
     *
     * // Will render this SQL by default, using Oracle SQL dialect
     * select ?, 'test' from "DUAL"
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link DSL#name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql, QueryPart... parts) {
        return dsl().query(sql, parts);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <pre><code>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</code></pre> Example
     * (SQLite):
     * <p>
     * <pre><code>
     * String sql = "pragma table_info('my_table')";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return An executable query
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(SQL sql) {
        return dsl().resultQuery(sql);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <pre><code>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</code></pre> Example
     * (SQLite):
     * <p>
     * <pre><code>
     * String sql = "pragma table_info('my_table')";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return An executable query
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql) {
        return dsl().resultQuery(sql);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must be as many bind variables contained in the SQL, as passed in
     * the bindings parameter
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <pre><code>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</code></pre> Example
     * (SQLite):
     * <p>
     * <pre><code>
     * String sql = "pragma table_info('my_table')";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql, Object... bindings) {
        return dsl().resultQuery(sql, bindings);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * Unlike {@link #resultQuery(String, Object...)}, the SQL passed to this
     * method should not contain any bind variables. Instead, you can pass
     * {@link QueryPart} objects to the method which will be rendered at indexed
     * locations of your SQL string as such: <pre><code>
     * // The following query
     * resultQuery("select {0}, {1} from {2}", val(1), inline("test"), name("DUAL"));
     *
     * // Will render this SQL by default, using Oracle SQL dialect
     * select ?, 'test' from "DUAL"
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link DSL#name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql, QueryPart... parts) {
        return dsl().resultQuery(sql, parts);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <pre><code>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = 'MY_SCHEMA')";
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(SQL sql) {
        return new SQLTable(sql);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <pre><code>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = 'MY_SCHEMA')";
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql) {
        return table(sql, new Object[0]);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * There must be as many bind variables contained in the SQL, as passed
     * in the bindings parameter
     * <p>
     * Example
     * <p>
     * <pre><code>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = ?)";
     * Object[] bindings = new Object[] { "MY_SCHEMA" };
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql, Object... bindings) {
        return table(sql(sql, bindings));
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <pre><code>
     * String sql = "(SELECT * FROM USER_TABLES WHERE {0})";
     * QueryPart[] parts = new QueryPart[] { USER_TABLES.OWNER.equal("MY_SCHEMA") };
     * </code></pre>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A table wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql, QueryPart... parts) {
        return table(sql, (Object[]) parts);
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name)} instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    @PlainSQL
    public static Sequence<BigInteger> sequence(String sql) {
        return sequence(sql, BigInteger.class);
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #sequence(String, DataType)}.
     *
     * @param sql The sequence name
     * @param type The sequence type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name, Class)}
     *             instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    @PlainSQL
    public static <T extends Number> Sequence<T> sequence(String sql, Class<T> type) {
        return sequence(sql, getDataType(type));
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name, DataType)}
     *             instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    @PlainSQL
    public static <T extends Number> Sequence<T> sequence(String sql, DataType<T> type) {
        return new SequenceImpl<>(sql, null, CommentImpl.NO_COMMENT, type, true);
    }

    /**
     * Create the <code>VALUE</code> pseudo field for usage with
     * <code>DOMAIN</code> specifications.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #value(DataType)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Field<T> value(Class<T> type) {
        return value(DefaultDataType.getDataType(null, type));
    }

    /**
     * Create the <code>VALUE</code> pseudo field for usage with
     * <code>DOMAIN</code> specifications.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Field<T> value(DataType<T> type) {
        return field(N_VALUE, type);
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static Domain<?> domain(String name) {
        return domain(name(name));
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static Domain<?> domain(Name name) {
        return domain(name, SQLDataType.OTHER);
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #domain(String, DataType)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Domain<T> domain(String name, Class<T> type) {
        return domain(name(name), getDataType(type));
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #domain(Name, DataType)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Domain<T> domain(Name name, Class<T> type) {
        return domain(name, getDataType(type));
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Domain<T> domain(String name, DataType<T> type) {
        return domain(name(name), type);
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Domain<T> domain(Name name, DataType<T> type) {
        return new DomainImpl<>(
            name.qualified() ? schema(name.qualifier()) : null,
            name.unqualifiedName(),
            CommentImpl.NO_COMMENT,
            new DefaultDataType<>(null, type.getSQLDataType(), name)
        );
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     *
     * <pre>
     * <code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: A lot of things work less well in jOOQ if no
     * {@link DataType} information is attached to a {@link Field} expression,
     * including:
     * <ul>
     * <li>Some drivers may find it hard to bind <code>NULL</code> values.</li>
     * <li>Some RDBMS may find it hard to infer a type from an expression
     * alone.</li>
     * <li>User defined types may not be supported.</li>
     * <li>You don't get compile time type safety.</li>
     * </ul>
     * It is usually better to use {@link DSL#field(SQL, DataType)}, instead, or
     * even better, use code generation where possible: <a href=
     * "https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/">https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/</a>,
     * in case of which {@link DataType} information is attached to all
     * {@link Field} expressions automatically.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(SQL sql) {
        return field(sql, Object.class);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     *
     * <pre>
     * <code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: A lot of things work less well in jOOQ if no
     * {@link DataType} information is attached to a {@link Field} expression,
     * including:
     * <ul>
     * <li>Some drivers may find it hard to bind <code>NULL</code> values.</li>
     * <li>Some RDBMS may find it hard to infer a type from an expression
     * alone.</li>
     * <li>User defined types may not be supported.</li>
     * <li>You don't get compile time type safety.</li>
     * </ul>
     * It is usually better to use {@link DSL#field(String, DataType)}, instead,
     * or even better, use code generation where possible: <a href=
     * "https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/">https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/</a>,
     * in case of which {@link DataType} information is attached to all
     * {@link Field} expressions automatically.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql) {
        return field(sql, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     *
     * <pre>
     * <code>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</code>
     * </pre>
     * <p>
     * <b>NOTE</b>: A lot of things work less well in jOOQ if no
     * {@link DataType} information is attached to a {@link Field} expression,
     * including:
     * <ul>
     * <li>Some drivers may find it hard to bind <code>NULL</code> values.</li>
     * <li>Some RDBMS may find it hard to infer a type from an expression
     * alone.</li>
     * <li>User defined types may not be supported.</li>
     * <li>You don't get compile time type safety.</li>
     * </ul>
     * It is usually better to use {@link DSL#field(String, DataType, Object...)}, instead,
     * or even better, use code generation where possible: <a href=
     * "https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/">https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/</a>,
     * in case of which {@link DataType} information is attached to all
     * {@link Field} expressions automatically.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql, Object... bindings) {
        return field(sql, Object.class, bindings);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     *
     * <pre>
     * <code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only {@link Class}
     * references of types supported by jOOQ internally, i.e. types from
     * {@link SQLDataType}. If you're using any custom data types by means of a
     * {@link Converter} or {@link Binding}, it's better to pass that converted
     * {@link DataType} reference explicitly to
     * {@link #field(SQL, DataType)}.
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(SQL sql, Class<T> type) {
        return field(sql, getDataType(type));
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     *
     * <pre>
     * <code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #field(String, DataType)}.
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type) {
        return field(sql, type, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #field(String, DataType, Object...)}.
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type, Object... bindings) {
        return field(sql, getDataType(type), bindings);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(SQL sql, DataType<T> type) {
        return new SQLField(type, sql);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type) {
        return field(sql, type, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A plain SQL field is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type, Object... bindings) {
        return field(sql(sql, bindings), type);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL: <pre><code>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </code></pre>
     * <p>
     * The above MySQL function can be expressed as such: <pre><code>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL
     * @param type The field type
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type, QueryPart... parts) {
        return field(sql(sql, parts), type);
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL:
     *
     * <pre>
     * <code>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </code>
     * </pre>
     * <p>
     * The above MySQL function can be expressed as such:
     *
     * <pre>
     * <code>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </code>
     * </pre>
     * <p>
     * <b>NOTE</b>: A lot of things work less well in jOOQ if no
     * {@link DataType} information is attached to a {@link Field} expression,
     * including:
     * <ul>
     * <li>Some drivers may find it hard to bind <code>NULL</code> values.</li>
     * <li>Some RDBMS may find it hard to infer a type from an expression
     * alone.</li>
     * <li>User defined types may not be supported.</li>
     * <li>You don't get compile time type safety.</li>
     * </ul>
     * It is usually better to use {@link DSL#field(String, DataType, QueryPart...)}, instead,
     * or even better, use code generation where possible: <a href=
     * "https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/">https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/</a>,
     * in case of which {@link DataType} information is attached to all
     * {@link Field} expressions automatically.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql, QueryPart... parts) {
        return field(sql, (Object[]) parts);
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL: <pre><code>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </code></pre>
     * <p>
     * The above MySQL function can be expressed as such: <pre><code>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #field(String, DataType, QueryPart...)}.
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type, QueryPart... parts) {
        return field(sql, getDataType(type), (Object[]) parts);
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #function(String, DataType, Field...)}.
     *
     * @param name The function name (without parentheses)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, Class<T> type, Field<?>... arguments) {
        return function(name, type, asList(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The function name (without parentheses)
     * @param type The function return type
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, DataType<T> type, Field<?>... arguments) {
        return function(name, type, asList(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #function(Name, DataType, Field...)}.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, Class<T> type, Field<?>... arguments) {
        return function(name, type, asList(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, DataType<T> type, Field<?>... arguments) {
        return function(name, type, asList(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #function(String, DataType, Field...)}.
     *
     * @param name The function name (without parentheses)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, Class<T> type, Collection<? extends Field<?>> arguments) {
        return function(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The function name (without parentheses)
     * @param type The function return type
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, DataType<T> type, Collection<? extends Field<?>> arguments) {
        return new org.jooq.impl.Function<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #function(Name, DataType, Field...)}.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, Class<T> type, Collection<? extends Field<?>> arguments) {
        return function(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, DataType<T> type, Collection<? extends Field<?>> arguments) {
        return new org.jooq.impl.Function<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    static <T> Field<T> function(Name name, DataType<T> type, Field<?> argument) {
        return new org.jooq.impl.Function1<>(name, type, Tools.nullSafe(argument));
    }

    /**
     * <code>aggregate()</code> can be used to access native or user-defined
     * aggregate functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #aggregate(String, DataType, Field...)}.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregate(String name, Class<T> type, Field<?>... arguments) {
        return aggregate(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregate(String name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or user-defined
     * aggregate functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #aggregate(Name, DataType, Field...)}.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregate(Name name, Class<T> type, Field<?>... arguments) {
        return aggregate(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregate(Name name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #aggregateDistinct(String, DataType, Field...)}.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregateDistinct(String name, Class<T> type, Field<?>... arguments) {
        return aggregateDistinct(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregateDistinct(String name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(true, name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #aggregateDistinct(Name, DataType, Field...)}.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregateDistinct(Name name, Class<T> type, Field<?>... arguments) {
        return aggregateDistinct(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregateDistinct(Name name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(true, name, type, Tools.nullSafe(arguments));
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "(X = 1 and Y = 2)";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A condition wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(SQL sql) {
        return new SQLCondition(sql);
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "(X = 1 and Y = 2)";</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A condition wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql) {
        return condition(sql, new Object[0]);
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must be as many bind variables contained in the SQL, as passed
     * in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <pre><code>
     * String sql = "(X = ? and Y = ?)";
     * Object[] bindings = new Object[] { 1, 2 };</code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A condition wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql, Object... bindings) {
        return condition(sql(sql, bindings));
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Condition</code> types are expected. An example for this are
     * Postgres's various operators, some of which are missing in the jOOQ API.
     * For instance, the "overlap" operator for arrays:
     * <pre><code>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</code></pre>
     * <p>
     * The above Postgres operator can be expressed as such: <pre><code>
     * condition("{0} &amp;&amp; {1}", array1, array2);
     * </code></pre>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A condition wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql, QueryPart... parts) {
        return condition(sql, (Object[]) parts);
    }

    /**
     * Create a condition from a boolean field.
     * <p>
     * Databases that support boolean data types can use boolean expressions
     * as predicates or as columns interchangeably. This extends to any type
     * of field, including functions. A Postgres example:
     * <p>
     * <pre><code>
     * select 1 where texteq('a', 'a');
     * </code></pre>
     *
     * @param value The boolean expression.
     * @return A condition wrapping the boolean expression
     */
    @NotNull
    @Support
    public static Condition condition(Boolean value) {
        return condition(Tools.field(value));
    }

    /**
     * Create a condition from a map.
     * <p>
     * The result is a condition generated from keys and values of the argument <code>map</code>, such that:
     *
     * <pre><code>
     * key1 = value1 AND key2 = value2 AND ... AND keyN = valueN
     * </code></pre>
     *
     * @param map A map containing keys and values to form predicates.
     * @return A condition comparing keys with values.
     */
    @NotNull
    @Support
    public static Condition condition(Map<Field<?>, ?> map) {
        return new MapCondition(map);
    }

    /**
     * Create a "Query By Example" (QBE) {@link Condition} from a {@link Record}
     * .
     * <p>
     * This will take all the non-null values in the argument
     * <code>record</code> to form a predicate from them. If all values in the
     * <code>record</code> are <code>null</code>, the predicate will be the
     * {@link #trueCondition()}.
     *
     * @param record The record from which to create a condition.
     * @return The condition.
     * @see <a href="https://en.wikipedia.org/wiki/Query_by_Example">https://en.
     *      wikipedia.org/wiki/Query_by_Example</a>
     */
    @NotNull
    @Support
    public static Condition condition(Record record) {
        return new RecordCondition(record);
    }

    // -------------------------------------------------------------------------
    // XXX Global Condition factory
    // -------------------------------------------------------------------------

    /**
     * Return a <code>Condition</code> that behaves like no condition being
     * present.
     * <p>
     * This is useful as an "identity" condition for reduction operations, for
     * both <code>AND</code> and <code>OR</code> reductions, e.g.
     * <p>
     * <pre><code>
     * Condition combined =
     * Stream.of(cond1, cond2, cond3)
     *       .reduce(noCondition(), Condition::and);
     * </code></pre>
     * <p>
     * When this condition is passed to SQL clauses, such as the
     * <code>WHERE</code> clause, the entire clause is omitted:
     * <p>
     * <pre><code>
     * selectFrom(T).where(noCondition())
     * </code></pre>
     * <p>
     * ... will produce
     * <p>
     * <pre><code>
     * SELECT * FROM t
     * </code></pre>
     * <p>
     * <b>NOTE [#16918]</b> that this {@link Condition} is meant to be used with the
     * {@link DSL} API only, not with the {@link QOM} API, which cannot offer
     * any no-op operations. The behaviour when used with the {@link QOM} API is
     * undefined.
     */
    @NotNull
    @Support
    public static Condition noCondition() {
        return NoCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that will always evaluate to
     * <code>TRUE</code>.
     */
    @NotNull
    @Support
    public static True trueCondition() {
        return TrueCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that will always evaluate to
     * <code>FALSE</code>.
     */
    @NotNull
    @Support
    public static False falseCondition() {
        return FalseCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that will always evaluate to
     * <code>NULL</code>.
     */
    @NotNull
    @Support
    public static Null nullCondition() {
        return NullCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Condition left, Condition right) {
        return condition(AND, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Condition... conditions) {
        return condition(AND, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Collection<? extends Condition> conditions) {
        return condition(AND, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Condition left, Condition right) {
        return condition(OR, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Condition... conditions) {
        return condition(OR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Collection<? extends Condition> conditions) {
        return condition(OR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#XOR}.
     */
    @NotNull
    @Support
    public static Condition xor(Condition left, Condition right) {
        return condition(XOR, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#XOR}.
     */
    @NotNull
    @Support
    public static Condition xor(Condition... conditions) {
        return condition(XOR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#XOR}.
     */
    @NotNull
    @Support
    public static Condition xor(Collection<? extends Condition> conditions) {
        return condition(XOR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Condition left, Condition right) {
        if (left == null || left instanceof NoCondition)
            return right == null ? noCondition() : right;
        else if (right == null || right instanceof NoCondition)
            return left;
        else if (operator == AND)
            return new And(left, right);
        else if (operator == XOR)
            return new Xor(left, right);
        else
            return new Or(left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Condition... conditions) {
        return condition(operator, asList(conditions));
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Collection<? extends Condition> conditions) {
        Condition result = null;

        for (Condition condition : conditions)
            if (result == null)
                result = condition;
            else
                result = condition(operator, result, condition);

        if (result != null)
            return result;

        // [#9998] All conditions were NoCondition
        else if (!conditions.isEmpty())
            return noCondition();

        // [#9998] Otherwise, return the identity for the operator
        else
            return operator.identity();
    }

    // -------------------------------------------------------------------------
    // XXX Global Field and Function factory
    // -------------------------------------------------------------------------

    /**
     * Get the MySQL <code>FIELD(expr, expr1, expr2, …)</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<Integer> field(Field<T> field, T... list) {
        return field(field, Tools.fieldsArray(list, field.getDataType()));
    }

    /**
     * Get the MySQL <code>FIELD(expr, expr1, expr2, …)</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<Integer> field(Field<T> field, Field<T>... list) {
        return new FieldFunction<>(field, list);
    }

    /**
     * Wrap a {@link SelectField} in a general-purpose {@link Field}
     */
    @NotNull
    @Support
    public static <T> Field<T> field(SelectField<T> field) {
        return field instanceof Field<T> f
             ? f
             : field instanceof AbstractRow<?> r
             ? (Field<T>) r.rf()
             : field instanceof AbstractTable<?> t
             ? (Field<T>) t.tf()
             : field("{0}", field.getDataType(), field);
    }



    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link RowN} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static  Field<Record> rowField(RowN row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row1} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1> Field<Record1<T1>> rowField(Row1<T1> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row2} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2> Field<Record2<T1, T2>> rowField(Row2<T1, T2> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row3} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3> Field<Record3<T1, T2, T3>> rowField(Row3<T1, T2, T3> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row4} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4> Field<Record4<T1, T2, T3, T4>> rowField(Row4<T1, T2, T3, T4> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row5} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5> Field<Record5<T1, T2, T3, T4, T5>> rowField(Row5<T1, T2, T3, T4, T5> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row6} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6> Field<Record6<T1, T2, T3, T4, T5, T6>> rowField(Row6<T1, T2, T3, T4, T5, T6> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row7} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7> Field<Record7<T1, T2, T3, T4, T5, T6, T7>> rowField(Row7<T1, T2, T3, T4, T5, T6, T7> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row8} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Field<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> rowField(Row8<T1, T2, T3, T4, T5, T6, T7, T8> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row9} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Field<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> rowField(Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row10} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Field<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> rowField(Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row11} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Field<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> rowField(Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row12} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Field<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> rowField(Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row13} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Field<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> rowField(Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row14} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Field<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> rowField(Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row15} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Field<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> rowField(Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row16} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Field<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> rowField(Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row17} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Field<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> rowField(Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row18} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Field<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> rowField(Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row19} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Field<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> rowField(Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row20} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Field<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> rowField(Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row21} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Field<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> rowField(Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row) {
        return new RowAsField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row22} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Field<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> rowField(Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row) {
        return new RowAsField<>(row);
    }



    /**
     * Transform a subquery into a correlated subquery.
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Select<? extends Record1<T>> select) {
        if (select == null)
            return (Field) inline((Object) null);
        else
            return select.asField();
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, T ifTrue, T ifFalse) {
        return iif0(N_IF, condition, Tools.field(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, T ifTrue, Field<T> ifFalse) {
        return iif0(N_IF, condition, Tools.field(ifTrue), Tools.nullSafe(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, Field<T> ifTrue, T ifFalse) {
        return iif0(N_IF, condition, Tools.nullSafe(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return iif0(N_IF, condition, Tools.nullSafe(ifTrue), Tools.nullSafe(ifFalse));
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case"
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case choose() {
        return decode();
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </code></pre>
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case".
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> choose(V value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </code></pre>
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case".
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> choose(Field<V> value) {
        return decode().value(value);
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> choose(int index, T... values) {
        return choose(val(index), Tools.fieldsArray(values));
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> choose(int index, Field<T>... values) {
        return choose(val(index), values);
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> choose(Field<Integer> index, T... values) {
        return choose(index, Tools.fieldsArray(values));
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> choose(Field<Integer> index, Field<T>... values) {
        return new Choose<>(index, values);
    }

    /**
     * Initialise a {@link Case} statement.
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case case_() {
        return decode();
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </code></pre>
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> case_(V value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </code></pre>
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> case_(Field<V> value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, T result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, Field<T> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, Select<? extends Record1<T>> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, T result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, Field<T> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <pre><code>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </code></pre>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, Select<? extends Record1<T>> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * Decode is used as a method name to avoid name clashes with Java's
     * reserved literal "case"
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case decode() {
        return new CaseImpl();
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]… [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(T value, T search, Z result) {
        return decode(value, search, result, new Object[0]);
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]… [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(T value, T search, Z result, Object... more) {
        return decode(Tools.field(value), Tools.field(search), Tools.field(result), Tools.fieldsArray(more));
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]… [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(Field<T> value, Field<T> search, Field<Z> result) {
        return decode(Tools.nullSafe(value), Tools.nullSafe(search), Tools.nullSafe(result), EMPTY_FIELD);
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]… [, default])</code>
     * function.
     * <p>
     * Returns the dialect's equivalent to DECODE:
     * <ul>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/decode.php">DECODE</a>
     * </li>
     * </ul>
     * <p>
     * Other dialects: <pre><code>
     * CASE WHEN [this IS NOT DISTINCT FROM search] THEN [result],
     *     [WHEN more...                            THEN more...]
     *     [ELSE more...]
     * END
     * </code></pre>
     * <p>
     * Note the use of the <code>DISTINCT</code> predicate to produce the same,
     * conveniently <code>NULL</code>-agnostic behaviour as Oracle.
     *
     * @param value The value to decode
     * @param search the mandatory first search parameter
     * @param result the mandatory first result candidate parameter
     * @param more the optional parameters. If <code>more.length</code> is even,
     *            then it is assumed that it contains more search/result pairs.
     *            If <code>more.length</code> is odd, then it is assumed that it
     *            contains more search/result pairs plus a default at the end.
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(Field<T> value, Field<T> search, Field<Z> result, Field<?>... more) {
        return new Decode<>(Tools.nullSafe(value), Tools.nullSafe(search), Tools.nullSafe(result), Tools.nullSafe(more));
    }

    /**
     * Coerce this field to the type of another field.
     * <p>
     * Unlike with {@link DSL#cast(Object, Field)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     *
     * @see #coerce(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, Field<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce this field to another type.
     * <p>
     * Unlike with {@link DSL#cast(Object, Class)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #coerce(Object, DataType)}.
     *
     * @param value The value to be coerced
     * @param as The field type (a type that is supported by
     *            {@link SQLDataType})
     * @see #coerce(Field, Class)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, Class<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce a field to another type.
     * <p>
     * Unlike with {@link DSL#cast(Object, DataType)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     *
     * @see #coerce(Field, DataType)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, DataType<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce this field to the type of another field.
     * <p>
     * Unlike with {@link DSL#cast(Field, Field)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     *
     * @param <T> The generic type of the coerced field
     * @param field The field to be coerced
     * @param as The field whose type is used for the coercion
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, Field<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }

    /**
     * Coerce this field to another type.
     * <p>
     * Unlike with {@link DSL#cast(Field, Class)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #coerce(Field, DataType)}.
     *
     * @param <T> The generic type of the coerced field
     * @param value The value to be coerced
     * @param as The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(Class)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, Class<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }

    /**
     * Coerce a field to another type.
     * <p>
     * Unlike with {@link DSL#cast(Field, DataType)}, coercing doesn't affect the
     * way the database sees a <code>Field</code>'s type. This is how coercing
     * affects your SQL:
     * <p>
     * <h3>Bind values</h3>
     *
     * <pre>
     * <code>
     * // This binds an int value to a JDBC PreparedStatement,
     * // where a String is expected
     * DSL.val(1).coerce(VARCHAR);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(VARCHAR);
     * </code>
     * </pre>
     *
     * <h3>Other Field types</h3>
     *
     * <pre>
     * <code>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(VARCHAR);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(VARCHAR);
     * </code>
     * </pre>
     *
     * @param <T> The generic type of the coerced field
     * @param field The field to be coerced
     * @param as The type that is used for the coercion
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(DataType)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, DataType<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }







































    /**
     * Cast a value to the type of another field.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Object, Field)} instead.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, Field<T> as) {
        return Tools.field(value, as).cast(as);
    }

    /**
     * Cast a field to the type of another field.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Field, Field)} instead.
     *
     * @param <T> The generic type of the cast field
     * @param field The field to cast
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, Field<T> as) {
        return Tools.nullSafe(field).cast(as);
    }

    /**
     * Cast null to the type of another field.
     *
     * @param <T> The generic type of the cast field
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(Field<T> as) {
        return inline((Object) null).cast(as);
    }

    /**
     * Cast a value to another type.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Object, Class)} instead.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #cast(Object, DataType)}.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param type The type that is used for the cast (a type that is supported
     *            by {@link SQLDataType})
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, Class<T> type) {
        return Tools.field(value, type).cast(type);
    }

    /**
     * Cast a field to another type.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Field, Class)} instead.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #cast(Field, DataType)}.
     *
     * @param <T> The generic type of the cast field
     * @param field The field to cast
     * @param type The type that is used for the cast (a type that is supported
     *            by {@link SQLDataType})
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, Class<T> type) {
        return Tools.nullSafe(field).cast(type);
    }

    /**
     * Cast null to a type.
     *
     * @param <T> The generic type of the cast field
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(DataType<T> type) {
        return inline((Object) null).cast(type);
    }

    /**
     * Cast a value to another type.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Object, DataType)} instead.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, DataType<T> type) {
        return Tools.field(value).cast(type);
    }

    /**
     * Cast a field to another type.
     * <p>
     * Casting converts expressions between data types directly in SQL using SQL
     * <code>CAST</code> expressions or similar. If you want to convert data
     * types only in jOOQ without any effect on generated SQL, you can use
     * {@link DSL#coerce(Field, DataType)} instead.
     *
     * @param <T> The generic type of the cast field
     * @param field The value to cast
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, DataType<T> type) {
        return Tools.nullSafe(field).cast(type);
    }

    /**
     * Cast null to a type.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #castNull(DataType)}.
     *
     * @param <T> The generic type of the cast field
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(Class<T> type) {
        return inline((Object) null).cast(type);
    }

    /**
     * The <code>COALESCE(value1, value2, … , value n)</code> function.
     *
     * @see #coalesce(Field, Field...)
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(T value, T... values) {
        return coalesce0(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * The <code>COALESCE(field, value)</code> function.
     *
     * @see #coalesce(Field, Field...)
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(Field<T> field, T value) {
        return coalesce0(field, Tools.field(value, field));
    }

    /**
     * The <code>COALESCE(field1, field2, … , field n)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(Field<T> field, Field<?>... fields) {
        return coalesce0(field, fields);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> coalesce0(Field<T> field, Field<?>... fields) {
        return new Coalesce<>(Tools.nullSafe(combine(field, fields)));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Z valueIfNotNull, Z valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.field(valueIfNotNull), Tools.field(valueIfNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Z valueIfNotNull, Field<Z> valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.field(valueIfNotNull, valueIfNull), Tools.nullSafe(valueIfNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Field<Z> valueIfNotNull, Z valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.nullSafe(valueIfNotNull), Tools.field(valueIfNull, valueIfNotNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     * <p>
     * Returns the dialect's equivalent to NVL2:
     * <ul>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/nvl2.php">NVL2</a></li>
     * </ul>
     * <p>
     * Other dialects:
     * <code>CASE WHEN [value] IS NULL THEN [valueIfNull] ELSE [valueIfNotNull] END</code>
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Field<Z> valueIfNotNull, Field<Z> valueIfNull) {
        return nvl20(value, valueIfNotNull, valueIfNull);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <Z> Field<Z> nvl20(Field<?> value, Field<Z> valueIfNotNull, Field<Z> valueIfNull) {
        return new Nvl2<>(Tools.nullSafe(value), Tools.nullSafe(valueIfNotNull), Tools.nullSafe(valueIfNull));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, T ifTrue, T ifFalse) {
        return iif0(N_IIF, condition, Tools.field(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, T ifTrue, Field<T> ifFalse) {
        return iif0(N_IIF, condition, Tools.field(ifTrue, ifFalse), Tools.nullSafe(ifFalse));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, Field<T> ifTrue, T ifFalse) {
        return iif0(N_IIF, condition, Tools.nullSafe(ifTrue), Tools.field(ifFalse, ifTrue));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return iif0(N_IIF, condition, ifTrue, ifFalse);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> iif0(Name name, Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return new Iif<>(
            name,
            condition,
            Tools.nullSafe(ifTrue, ifFalse.getDataType()),
            Tools.nullSafe(ifFalse, ifTrue.getDataType())
        );
    }



    // -------------------------------------------------------------------------
    // Generic predicates
    // -------------------------------------------------------------------------

    /**
     * The <code>EXISTS</code> function.
     */
    @NotNull
    @Support
    public static Condition exists(Select<?> query) {
        return new Exists(query);
    }

    /**
     * The <code>NOT EXISTS</code> function.
     */
    @NotNull
    @Support
    public static Condition notExists(Select<?> query) {
        return not(exists(query));
    }

    /**
     * The <code>NOT</code> function.
     */
    @NotNull
    @Support
    public static Condition not(Condition condition) {
        return new Not(condition);
    }

    /**
     * The <code>NOT</code> function.
     */
    @NotNull
    @Support
    public static Field<Boolean> not(Field<Boolean> field) {
        return new NotField(field);
    }

    /**
     * The <code>UNIQUE</code> function.
     */
    @NotNull
    @Support
    public static Condition unique(Select<?> query) {
        return new Unique(query);
    }

    /**
     * The <code>NOT UNIQUE</code> function.
     */
    @NotNull
    @Support
    public static Condition notUnique(Select<?> query) {
        return not(unique(query));
    }

    // -------------------------------------------------------------------------
    // Table functions
    // -------------------------------------------------------------------------

    /**
     * The <code>EXCLUDED</code> function.
     * <p>
     * Provide "EXCLUDED" qualification for a column for use in ON CONFLICT or ON DUPLICATE
     * KEY UPDATE.
     *
     * @param field The excluded field.
     */
    @NotNull
    @Support
    public static <T> Field<T> excluded(Field<T> field) {
        return new Excluded<>(field);
    }

    // -------------------------------------------------------------------------
    // Numeric functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ABS</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> abs(T value) {
        return new Abs<>(Tools.field(value));
    }

    /**
     * The <code>ABS</code> function.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> abs(Field<T> value) {
        return new Abs<>(value);
    }

    /**
     * The <code>ACOS</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> acos(Number value) {
        return new Acos(Tools.field(value));
    }

    /**
     * The <code>ACOS</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> acos(Field<? extends Number> value) {
        return new Acos(value);
    }

    /**
     * The <code>ACOSH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> acosh(Number value) {
        return new Acosh(Tools.field(value));
    }

    /**
     * The <code>ACOSH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> acosh(Field<? extends Number> value) {
        return new Acosh(value);
    }

    /**
     * The <code>ACOTH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> acoth(Number value) {
        return new Acoth(Tools.field(value));
    }

    /**
     * The <code>ACOTH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> acoth(Field<? extends Number> value) {
        return new Acoth(value);
    }

    /**
     * The <code>ASIN</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> asin(Number value) {
        return new Asin(Tools.field(value));
    }

    /**
     * The <code>ASIN</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> asin(Field<? extends Number> value) {
        return new Asin(value);
    }

    /**
     * The <code>ASINH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> asinh(Number value) {
        return new Asinh(Tools.field(value));
    }

    /**
     * The <code>ASINH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> asinh(Field<? extends Number> value) {
        return new Asinh(value);
    }

    /**
     * The <code>ATAN</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan(Number value) {
        return new Atan(Tools.field(value));
    }

    /**
     * The <code>ATAN</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan(Field<? extends Number> value) {
        return new Atan(value);
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param x is wrapped as {@link DSL#val(Object)}.
     * @param y is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan2(Number x, Number y) {
        return new Atan2(Tools.field(x), Tools.field(y));
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param x is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan2(Number x, Field<? extends Number> y) {
        return new Atan2(Tools.field(x), y);
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param y is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan2(Field<? extends Number> x, Number y) {
        return new Atan2(x, Tools.field(y));
    }

    /**
     * The <code>ATAN2</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<BigDecimal> atan2(Field<? extends Number> x, Field<? extends Number> y) {
        return new Atan2(x, y);
    }

    /**
     * The <code>ATANH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> atanh(Number value) {
        return new Atanh(Tools.field(value));
    }

    /**
     * The <code>ATANH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> atanh(Field<? extends Number> value) {
        return new Atanh(value);
    }

    /**
     * The <code>BIT_AND</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitAnd(T arg1, T arg2) {
        return new BitAnd<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_AND</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitAnd(T arg1, Field<T> arg2) {
        return new BitAnd<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_AND</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitAnd(Field<T> arg1, T arg2) {
        return new BitAnd<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_AND</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitAnd(Field<T> arg1, Field<T> arg2) {
        return new BitAnd<>(arg1, arg2);
    }

    /**
     * The <code>BIT_COUNT</code> function.
     * <p>
     * Count the number of bits set in a number
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<Integer> bitCount(Number value) {
        return new BitCount(Tools.field(value));
    }

    /**
     * The <code>BIT_COUNT</code> function.
     * <p>
     * Count the number of bits set in a number
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<Integer> bitCount(Field<? extends Number> value) {
        return new BitCount(value);
    }

    /**
     * The <code>BIT_GET</code> function.
     *
     * @param bit is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitGet(Field<T> value, int bit) {
        return new BitGet<>(value, Tools.field(bit));
    }

    /**
     * The <code>BIT_GET</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitGet(Field<T> value, Field<? extends Number> bit) {
        return new BitGet<>(value, bit);
    }

    /**
     * The <code>BIT_NAND</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNand(T arg1, T arg2) {
        return new BitNand<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_NAND</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNand(T arg1, Field<T> arg2) {
        return new BitNand<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_NAND</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNand(Field<T> arg1, T arg2) {
        return new BitNand<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_NAND</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNand(Field<T> arg1, Field<T> arg2) {
        return new BitNand<>(arg1, arg2);
    }

    /**
     * The <code>BIT_NOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNor(T arg1, T arg2) {
        return new BitNor<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_NOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNor(T arg1, Field<T> arg2) {
        return new BitNor<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_NOR</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNor(Field<T> arg1, T arg2) {
        return new BitNor<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_NOR</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNor(Field<T> arg1, Field<T> arg2) {
        return new BitNor<>(arg1, arg2);
    }

    /**
     * The <code>BIT_NOT</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNot(T arg1) {
        return new BitNot<>(Tools.field(arg1));
    }

    /**
     * The <code>BIT_NOT</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitNot(Field<T> arg1) {
        return new BitNot<>(arg1);
    }

    /**
     * The <code>BIT_OR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitOr(T arg1, T arg2) {
        return new BitOr<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_OR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitOr(T arg1, Field<T> arg2) {
        return new BitOr<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_OR</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitOr(Field<T> arg1, T arg2) {
        return new BitOr<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_OR</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitOr(Field<T> arg1, Field<T> arg2) {
        return new BitOr<>(arg1, arg2);
    }

    /**
     * The <code>BIT_SET</code> function.
     *
     * @param bit is wrapped as {@link DSL#val(Object)}.
     * @param newValue is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, int bit, T newValue) {
        return new BitSet<>(value, Tools.field(bit), Tools.field(newValue, value));
    }

    /**
     * The <code>BIT_SET</code> function.
     *
     * @param bit is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, int bit, Field<T> newValue) {
        return new BitSet<>(value, Tools.field(bit), newValue);
    }

    /**
     * The <code>BIT_SET</code> function.
     *
     * @param newValue is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, Field<? extends Number> bit, T newValue) {
        return new BitSet<>(value, bit, Tools.field(newValue, value));
    }

    /**
     * The <code>BIT_SET</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, Field<? extends Number> bit, Field<T> newValue) {
        return new BitSet<>(value, bit, newValue);
    }

    /**
     * The <code>BIT_SET</code> function.
     *
     * @param bit is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, int bit) {
        return new BitSet<>(value, Tools.field(bit));
    }

    /**
     * The <code>BIT_SET</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitSet(Field<T> value, Field<? extends Number> bit) {
        return new BitSet<>(value, bit);
    }

    /**
     * The <code>BIT_XNOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXNor(T arg1, T arg2) {
        return new BitXNor<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_XNOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXNor(T arg1, Field<T> arg2) {
        return new BitXNor<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_XNOR</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXNor(Field<T> arg1, T arg2) {
        return new BitXNor<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_XNOR</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXNor(Field<T> arg1, Field<T> arg2) {
        return new BitXNor<>(arg1, arg2);
    }

    /**
     * The <code>BIT_XOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXor(T arg1, T arg2) {
        return new BitXor<>(Tools.field(arg1), Tools.field(arg2));
    }

    /**
     * The <code>BIT_XOR</code> function.
     *
     * @param arg1 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXor(T arg1, Field<T> arg2) {
        return new BitXor<>(Tools.field(arg1), arg2);
    }

    /**
     * The <code>BIT_XOR</code> function.
     *
     * @param arg2 is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXor(Field<T> arg1, T arg2) {
        return new BitXor<>(arg1, Tools.field(arg2, arg1));
    }

    /**
     * The <code>BIT_XOR</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> bitXor(Field<T> arg1, Field<T> arg2) {
        return new BitXor<>(arg1, arg2);
    }

    /**
     * The <code>CBRT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cbrt(Number value) {
        return new Cbrt(Tools.field(value));
    }

    /**
     * The <code>CBRT</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cbrt(Field<? extends Number> value) {
        return new Cbrt(value);
    }

    /**
     * The <code>CEIL</code> function.
     * <p>
     * Get the smallest integer value equal or greater to a value.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> ceil(T value) {
        return new Ceil<>(Tools.field(value));
    }

    /**
     * The <code>CEIL</code> function.
     * <p>
     * Get the smallest integer value equal or greater to a value.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> ceil(Field<T> value) {
        return new Ceil<>(value);
    }

    /**
     * The <code>COS</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cos(Number value) {
        return new Cos(Tools.field(value));
    }

    /**
     * The <code>COS</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cos(Field<? extends Number> value) {
        return new Cos(value);
    }

    /**
     * The <code>COSH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cosh(Number value) {
        return new Cosh(Tools.field(value));
    }

    /**
     * The <code>COSH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cosh(Field<? extends Number> value) {
        return new Cosh(value);
    }

    /**
     * The <code>COT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cot(Number value) {
        return new Cot(Tools.field(value));
    }

    /**
     * The <code>COT</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> cot(Field<? extends Number> value) {
        return new Cot(value);
    }

    /**
     * The <code>COTH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> coth(Number value) {
        return new Coth(Tools.field(value));
    }

    /**
     * The <code>COTH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> coth(Field<? extends Number> value) {
        return new Coth(value);
    }

    /**
     * The <code>DEGREES</code> function.
     * <p>
     * Turn a value in radians to degrees.
     *
     * @param radians The value in radians.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> deg(Number radians) {
        return new Degrees(Tools.field(radians));
    }

    /**
     * The <code>DEGREES</code> function.
     * <p>
     * Turn a value in radians to degrees.
     *
     * @param radians The value in radians.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> deg(Field<? extends Number> radians) {
        return new Degrees(radians);
    }

    /**
     * The <code>E</code> function.
     * <p>
     * The E literal (Euler number).
     */
    @NotNull
    @Support
    public static Field<BigDecimal> e() {
        return new Euler();
    }

    /**
     * The <code>EXP</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> exp(Number value) {
        return new Exp(Tools.field(value));
    }

    /**
     * The <code>EXP</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> exp(Field<? extends Number> value) {
        return new Exp(value);
    }

    /**
     * The <code>FLOOR</code> function.
     * <p>
     * Get the biggest integer value equal or less than a value.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> floor(T value) {
        return new Floor<>(Tools.field(value));
    }

    /**
     * The <code>FLOOR</code> function.
     * <p>
     * Get the biggest integer value equal or less than a value.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> floor(Field<T> value) {
        return new Floor<>(value);
    }

    /**
     * The <code>LN</code> function.
     * <p>
     * Get the natural logarithm of a value.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> ln(Number value) {
        return new Ln(Tools.field(value));
    }

    /**
     * The <code>LN</code> function.
     * <p>
     * Get the natural logarithm of a value.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> ln(Field<? extends Number> value) {
        return new Ln(value);
    }

    /**
     * The <code>LOG</code> function.
     * <p>
     * Get the logarithm of a value for a base.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     * @param base is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log(Number value, int base) {
        return new Log(Tools.field(value), Tools.field(base));
    }

    /**
     * The <code>LOG</code> function.
     * <p>
     * Get the logarithm of a value for a base.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log(Number value, Field<? extends Number> base) {
        return new Log(Tools.field(value), base);
    }

    /**
     * The <code>LOG</code> function.
     * <p>
     * Get the logarithm of a value for a base.
     *
     * @param base is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log(Field<? extends Number> value, int base) {
        return new Log(value, Tools.field(base));
    }

    /**
     * The <code>LOG</code> function.
     * <p>
     * Get the logarithm of a value for a base.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log(Field<? extends Number> value, Field<? extends Number> base) {
        return new Log(value, base);
    }

    /**
     * The <code>LOG10</code> function.
     * <p>
     * Get the logarithm of a value for base 10.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log10(Number value) {
        return new Log10(Tools.field(value));
    }

    /**
     * The <code>LOG10</code> function.
     * <p>
     * Get the logarithm of a value for base 10.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> log10(Field<? extends Number> value) {
        return new Log10(value);
    }

    /**
     * The <code>PI</code> function.
     * <p>
     * The π literal.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> pi() {
        return new Pi();
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param base is wrapped as {@link DSL#val(Object)}.
     * @param exponent is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> power(Number base, Number exponent) {
        return new Power(Tools.field(base), Tools.field(exponent));
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param base is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> power(Number base, Field<? extends Number> exponent) {
        return new Power(Tools.field(base), exponent);
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param exponent is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> power(Field<? extends Number> base, Number exponent) {
        return new Power(base, Tools.field(exponent));
    }

    /**
     * The <code>POWER</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> power(Field<? extends Number> base, Field<? extends Number> exponent) {
        return new Power(base, exponent);
    }

    /**
     * The <code>RADIANS</code> function.
     * <p>
     * Turn a value in degrees to radians.
     *
     * @param degrees The value in degrees.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rad(Number degrees) {
        return new Radians(Tools.field(degrees));
    }

    /**
     * The <code>RADIANS</code> function.
     * <p>
     * Turn a value in degrees to radians.
     *
     * @param degrees The value in degrees.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rad(Field<? extends Number> degrees) {
        return new Radians(degrees);
    }

    /**
     * The <code>RAND</code> function.
     * <p>
     * Get a random numeric value.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rand() {
        return new Rand();
    }

    /**
     * The <code>ROOT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     * @param degree is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> root(Number value, Number degree) {
        return new Root(Tools.field(value), Tools.field(degree));
    }

    /**
     * The <code>ROOT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> root(Number value, Field<? extends Number> degree) {
        return new Root(Tools.field(value), degree);
    }

    /**
     * The <code>ROOT</code> function.
     *
     * @param degree is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> root(Field<? extends Number> value, Number degree) {
        return new Root(value, Tools.field(degree));
    }

    /**
     * The <code>ROOT</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> root(Field<? extends Number> value, Field<? extends Number> degree) {
        return new Root(value, degree);
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value, int decimals) {
        return new Round<>(Tools.field(value), Tools.field(decimals));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value, Field<Integer> decimals) {
        return new Round<>(Tools.field(value), decimals);
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value, int decimals) {
        return new Round<>(value, Tools.field(decimals));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value, Field<Integer> decimals) {
        return new Round<>(value, decimals);
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value) {
        return new Round<>(Tools.field(value));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value) {
        return new Round<>(value);
    }

    /**
     * The <code>SHL</code> function.
     * <p>
     * Left shift all bits in a number
     *
     * @param value The number whose bits to shift left.
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shl(T value, Number count) {
        return new Shl<>(Tools.field(value), Tools.field(count));
    }

    /**
     * The <code>SHL</code> function.
     * <p>
     * Left shift all bits in a number
     *
     * @param value The number whose bits to shift left.
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shl(T value, Field<? extends Number> count) {
        return new Shl<>(Tools.field(value), count);
    }

    /**
     * The <code>SHL</code> function.
     * <p>
     * Left shift all bits in a number
     *
     * @param value The number whose bits to shift left.
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shl(Field<T> value, Number count) {
        return new Shl<>(value, Tools.field(count));
    }

    /**
     * The <code>SHL</code> function.
     * <p>
     * Left shift all bits in a number
     *
     * @param value The number whose bits to shift left.
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shl(Field<T> value, Field<? extends Number> count) {
        return new Shl<>(value, count);
    }

    /**
     * The <code>SHR</code> function.
     * <p>
     * Right shift all bits in a number
     *
     * @param value The number whose bits to shift right
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shr(T value, Number count) {
        return new Shr<>(Tools.field(value), Tools.field(count));
    }

    /**
     * The <code>SHR</code> function.
     * <p>
     * Right shift all bits in a number
     *
     * @param value The number whose bits to shift right
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shr(T value, Field<? extends Number> count) {
        return new Shr<>(Tools.field(value), count);
    }

    /**
     * The <code>SHR</code> function.
     * <p>
     * Right shift all bits in a number
     *
     * @param value The number whose bits to shift right
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shr(Field<T> value, Number count) {
        return new Shr<>(value, Tools.field(count));
    }

    /**
     * The <code>SHR</code> function.
     * <p>
     * Right shift all bits in a number
     *
     * @param value The number whose bits to shift right
     * @param count The number of bits to shift.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> shr(Field<T> value, Field<? extends Number> count) {
        return new Shr<>(value, count);
    }

    /**
     * The <code>SIGN</code> function.
     * <p>
     * Get the sign of a number and return it as any of +1, 0, -1.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> sign(Number value) {
        return new Sign(Tools.field(value));
    }

    /**
     * The <code>SIGN</code> function.
     * <p>
     * Get the sign of a number and return it as any of +1, 0, -1.
     */
    @NotNull
    @Support
    public static Field<Integer> sign(Field<? extends Number> value) {
        return new Sign(value);
    }

    /**
     * The <code>SIN</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sin(Number value) {
        return new Sin(Tools.field(value));
    }

    /**
     * The <code>SIN</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sin(Field<? extends Number> value) {
        return new Sin(value);
    }

    /**
     * The <code>SINH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sinh(Number value) {
        return new Sinh(Tools.field(value));
    }

    /**
     * The <code>SINH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sinh(Field<? extends Number> value) {
        return new Sinh(value);
    }

    /**
     * The <code>SQRT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sqrt(Number value) {
        return new Sqrt(Tools.field(value));
    }

    /**
     * The <code>SQRT</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> sqrt(Field<? extends Number> value) {
        return new Sqrt(value);
    }

    /**
     * The <code>SQUARE</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> square(T value) {
        return new Square<>(Tools.field(value));
    }

    /**
     * The <code>SQUARE</code> function.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> square(Field<T> value) {
        return new Square<>(value);
    }

    /**
     * The <code>TAN</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tan(Number value) {
        return new Tan(Tools.field(value));
    }

    /**
     * The <code>TAN</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tan(Field<? extends Number> value) {
        return new Tan(value);
    }

    /**
     * The <code>TANH</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tanh(Number value) {
        return new Tanh(Tools.field(value));
    }

    /**
     * The <code>TANH</code> function.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tanh(Field<? extends Number> value) {
        return new Tanh(value);
    }

    /**
     * The <code>TAU</code> function.
     * <p>
     * The τ literal, or π, in a better world.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tau() {
        return new Tau();
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> trunc(T value, int decimals) {
        return new Trunc<>(Tools.field(value), Tools.field(decimals));
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> trunc(T value, Field<Integer> decimals) {
        return new Trunc<>(Tools.field(value), decimals);
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> trunc(Field<T> value, int decimals) {
        return new Trunc<>(value, Tools.field(decimals));
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> Field<T> trunc(Field<T> value, Field<Integer> decimals) {
        return new Trunc<>(value, decimals);
    }

    /**
     * The <code>WIDTH_BUCKET</code> function.
     * <p>
     * Divide a range into buckets of equal size.
     *
     * @param field The value to divide into the range.
     * @param low The lower bound of the range.
     * @param high The upper bound of the range.
     * @param buckets The number of buckets to produce.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> widthBucket(Field<T> field, T low, T high, int buckets) {
        return new WidthBucket<>(field, Tools.field(low, field), Tools.field(high, field), Tools.field(buckets));
    }

    /**
     * The <code>WIDTH_BUCKET</code> function.
     * <p>
     * Divide a range into buckets of equal size.
     *
     * @param field The value to divide into the range.
     * @param low The lower bound of the range.
     * @param high The upper bound of the range.
     * @param buckets The number of buckets to produce.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> widthBucket(Field<T> field, Field<T> low, Field<T> high, Field<Integer> buckets) {
        return new WidthBucket<>(field, low, high, buckets);
    }

    // -------------------------------------------------------------------------
    // String functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ASCII</code> function.
     * <p>
     * The ASCII value of a character.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> ascii(@Stringly.Param String string) {
        return new Ascii(Tools.field(string));
    }

    /**
     * The <code>ASCII</code> function.
     * <p>
     * The ASCII value of a character.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> ascii(Field<String> string) {
        return new Ascii(string);
    }

    /**
     * The <code>BIT_LENGTH</code> function.
     * <p>
     * The length of a string in bits.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> bitLength(@Stringly.Param String string) {
        return new BitLength(Tools.field(string));
    }

    /**
     * The <code>BIT_LENGTH</code> function.
     * <p>
     * The length of a string in bits.
     */
    @NotNull
    @Support
    public static Field<Integer> bitLength(Field<String> string) {
        return new BitLength(string);
    }

    /**
     * The <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> charLength(@Stringly.Param String string) {
        return new CharLength(Tools.field(string));
    }

    /**
     * The <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     */
    @NotNull
    @Support
    public static Field<Integer> charLength(Field<String> string) {
        return new CharLength(string);
    }

    /**
     * The <code>CHR</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> chr(Number value) {
        return new Chr(Tools.field(value));
    }

    /**
     * The <code>CHR</code> function.
     */
    @NotNull
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> chr(Field<? extends Number> value) {
        return new Chr(value);
    }

    /**
     * The <code>DIGITS</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> digits(Number value) {
        return new Digits(Tools.field(value));
    }

    /**
     * The <code>DIGITS</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> digits(Field<? extends Number> value) {
        return new Digits(value);
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(@Stringly.Param String string, int length) {
        return new Left(Tools.field(string), Tools.field(length));
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(@Stringly.Param String string, Field<? extends Number> length) {
        return new Left(Tools.field(string), length);
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(Field<String> string, int length) {
        return new Left(string, Tools.field(length));
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(Field<String> string, Field<? extends Number> length) {
        return new Left(string, length);
    }

    /**
     * The <code>LENGTH</code> function, an alias for the <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> length(@Stringly.Param String string) {
        return charLength(string);
    }

    /**
     * The <code>LENGTH</code> function, an alias for the <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     */
    @NotNull
    @Support
    public static Field<Integer> length(Field<String> string) {
        return charLength(string);
    }

    /**
     * The <code>LOWER</code> function.
     * <p>
     * Turn a string into lower case.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<String> lower(@Stringly.Param String string) {
        return new Lower(Tools.field(string));
    }

    /**
     * The <code>LOWER</code> function.
     * <p>
     * Turn a string into lower case.
     */
    @NotNull
    @Support
    public static Field<String> lower(Field<String> string) {
        return new Lower(string);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, int length, @Stringly.Param String character) {
        return new Lpad(string, Tools.field(length), Tools.field(character));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, int length, Field<String> character) {
        return new Lpad(string, Tools.field(length), character);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length, @Stringly.Param String character) {
        return new Lpad(string, length, Tools.field(character));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length, Field<String> character) {
        return new Lpad(string, length, character);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, int length) {
        return new Lpad(string, Tools.field(length));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length) {
        return new Lpad(string, length);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> ltrim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Ltrim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> ltrim(@Stringly.Param String string, Field<String> characters) {
        return new Ltrim(Tools.field(string), characters);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> ltrim(Field<String> string, @Stringly.Param String characters) {
        return new Ltrim(string, Tools.field(characters));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> ltrim(Field<String> string, Field<String> characters) {
        return new Ltrim(string, characters);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> ltrim(@Stringly.Param String string) {
        return new Ltrim(Tools.field(string));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the left side of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> ltrim(Field<String> string) {
        return new Ltrim(string);
    }

    /**
     * The <code>MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a string.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> md5(@Stringly.Param String string) {
        return new Md5(Tools.field(string));
    }

    /**
     * The <code>MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a string.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> md5(Field<String> string) {
        return new Md5(string);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition, int length) {
        return substring(string, startingPosition, length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition, Field<? extends Number> length) {
        return substring(string, startingPosition, length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition, int length) {
        return substring(string, startingPosition, length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition, Field<? extends Number> length) {
        return substring(string, startingPosition, length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition) {
        return substring(string, startingPosition);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition) {
        return substring(string, startingPosition);
    }

    /**
     * The <code>OCTET_LENGTH</code> function.
     * <p>
     * The length of a string in octets.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> octetLength(@Stringly.Param String string) {
        return new OctetLength(Tools.field(string));
    }

    /**
     * The <code>OCTET_LENGTH</code> function.
     * <p>
     * The length of a string in octets.
     */
    @NotNull
    @Support
    public static Field<Integer> octetLength(Field<String> string) {
        return new OctetLength(string);
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, @Stringly.Param String placing, Number startIndex, Number length) {
        return new Overlay(in, Tools.field(placing), Tools.field(startIndex), Tools.field(length));
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, Field<String> placing, Field<? extends Number> startIndex, Field<? extends Number> length) {
        return new Overlay(in, placing, startIndex, length);
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, @Stringly.Param String placing, Number startIndex) {
        return new Overlay(in, Tools.field(placing), Tools.field(startIndex));
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, Field<String> placing, Field<? extends Number> startIndex) {
        return new Overlay(in, placing, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search, int startIndex) {
        return new Position(Tools.field(in), Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search, Field<? extends Number> startIndex) {
        return new Position(Tools.field(in), Tools.field(search), startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search, int startIndex) {
        return new Position(Tools.field(in), search, Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search, Field<? extends Number> startIndex) {
        return new Position(Tools.field(in), search, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search, int startIndex) {
        return new Position(in, Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search, Field<? extends Number> startIndex) {
        return new Position(in, Tools.field(search), startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search, int startIndex) {
        return new Position(in, search, Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search, Field<? extends Number> startIndex) {
        return new Position(in, search, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search) {
        return new Position(Tools.field(in), Tools.field(search));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search) {
        return new Position(Tools.field(in), search);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search) {
        return new Position(in, Tools.field(search));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search) {
        return new Position(in, search);
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> repeat(@Stringly.Param String string, int count) {
        return new Repeat(Tools.field(string), Tools.field(count));
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> repeat(@Stringly.Param String string, Field<? extends Number> count) {
        return new Repeat(Tools.field(string), count);
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> repeat(Field<String> string, int count) {
        return new Repeat(string, Tools.field(count));
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> repeat(Field<String> string, Field<? extends Number> count) {
        return new Repeat(string, count);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search, @Stringly.Param String replace) {
        return new Replace(string, Tools.field(search), Tools.field(replace));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search, Field<String> replace) {
        return new Replace(string, Tools.field(search), replace);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, Field<String> search, @Stringly.Param String replace) {
        return new Replace(string, search, Tools.field(replace));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, Field<String> search, Field<String> replace) {
        return new Replace(string, search, replace);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search) {
        return new Replace(string, Tools.field(search));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> replace(Field<String> string, Field<String> search) {
        return new Replace(string, search);
    }

    /**
     * The <code>REVERSE</code> function.
     * <p>
     * Reverse a string.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> reverse(@Stringly.Param String string) {
        return new Reverse(Tools.field(string));
    }

    /**
     * The <code>REVERSE</code> function.
     * <p>
     * Reverse a string.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> reverse(Field<String> string) {
        return new Reverse(string);
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(@Stringly.Param String string, int length) {
        return new Right(Tools.field(string), Tools.field(length));
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(@Stringly.Param String string, Field<? extends Number> length) {
        return new Right(Tools.field(string), length);
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(Field<String> string, int length) {
        return new Right(string, Tools.field(length));
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(Field<String> string, Field<? extends Number> length) {
        return new Right(string, length);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, int length, @Stringly.Param String character) {
        return new Rpad(string, Tools.field(length), Tools.field(character));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, int length, Field<String> character) {
        return new Rpad(string, Tools.field(length), character);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length, @Stringly.Param String character) {
        return new Rpad(string, length, Tools.field(character));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length, Field<String> character) {
        return new Rpad(string, length, character);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, int length) {
        return new Rpad(string, Tools.field(length));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length) {
        return new Rpad(string, length);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static Field<String> rtrim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Rtrim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static Field<String> rtrim(@Stringly.Param String string, Field<String> characters) {
        return new Rtrim(Tools.field(string), characters);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static Field<String> rtrim(Field<String> string, @Stringly.Param String characters) {
        return new Rtrim(string, Tools.field(characters));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static Field<String> rtrim(Field<String> string, Field<String> characters) {
        return new Rtrim(string, characters);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> rtrim(@Stringly.Param String string) {
        return new Rtrim(Tools.field(string));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from the right side of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> rtrim(Field<String> string) {
        return new Rtrim(string);
    }

    /**
     * The <code>SPACE</code> function.
     * <p>
     * Get a string of spaces of a given length.
     *
     * @param count The number of spaces to produce.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> space(Number count) {
        return new Space(Tools.field(count));
    }

    /**
     * The <code>SPACE</code> function.
     * <p>
     * Get a string of spaces of a given length.
     *
     * @param count The number of spaces to produce.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> space(Field<? extends Number> count) {
        return new Space(count);
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> splitPart(Field<String> string, @Stringly.Param String delimiter, Number n) {
        return new SplitPart(string, Tools.field(delimiter), Tools.field(n));
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> splitPart(Field<String> string, @Stringly.Param String delimiter, Field<? extends Number> n) {
        return new SplitPart(string, Tools.field(delimiter), n);
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> splitPart(Field<String> string, Field<String> delimiter, Number n) {
        return new SplitPart(string, delimiter, Tools.field(n));
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> splitPart(Field<String> string, Field<String> delimiter, Field<? extends Number> n) {
        return new SplitPart(string, delimiter, n);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition, int length) {
        return new Substring(string, Tools.field(startingPosition), Tools.field(length));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition, Field<? extends Number> length) {
        return new Substring(string, Tools.field(startingPosition), length);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition, int length) {
        return new Substring(string, startingPosition, Tools.field(length));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition, Field<? extends Number> length) {
        return new Substring(string, startingPosition, length);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition) {
        return new Substring(string, Tools.field(startingPosition));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition) {
        return new Substring(string, startingPosition);
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ CLICKHOUSE, MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, @Stringly.Param String delimiter, int n) {
        return new SubstringIndex(string, Tools.field(delimiter), Tools.field(n));
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ CLICKHOUSE, MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, @Stringly.Param String delimiter, Field<? extends Number> n) {
        return new SubstringIndex(string, Tools.field(delimiter), n);
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ CLICKHOUSE, MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, Field<String> delimiter, int n) {
        return new SubstringIndex(string, delimiter, Tools.field(n));
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ CLICKHOUSE, MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, Field<String> delimiter, Field<? extends Number> n) {
        return new SubstringIndex(string, delimiter, n);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Object value, @Stringly.Param String formatMask) {
        return new ToChar(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Object value, Field<String> formatMask) {
        return new ToChar(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Field<?> value, @Stringly.Param String formatMask) {
        return new ToChar(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Field<?> value, Field<String> formatMask) {
        return new ToChar(value, formatMask);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     */
    @NotNull
    @Support
    public static Field<String> toChar(Object value) {
        return new ToChar(Tools.field(value));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     */
    @NotNull
    @Support
    public static Field<String> toChar(Field<?> value) {
        return new ToChar(value);
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Date> toDate(@Stringly.Param String value, @Stringly.Param String formatMask) {
        return new ToDate(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Date> toDate(@Stringly.Param String value, Field<String> formatMask) {
        return new ToDate(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Date> toDate(Field<String> value, @Stringly.Param String formatMask) {
        return new ToDate(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Date> toDate(Field<String> value, Field<String> formatMask) {
        return new ToDate(value, formatMask);
    }

    /**
     * The <code>TO_HEX</code> function.
     * <p>
     * Format a number to its hex value.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> toHex(Number value) {
        return new ToHex(Tools.field(value));
    }

    /**
     * The <code>TO_HEX</code> function.
     * <p>
     * Format a number to its hex value.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<String> toHex(Field<? extends Number> value) {
        return new ToHex(value);
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Timestamp> toTimestamp(@Stringly.Param String value, @Stringly.Param String formatMask) {
        return new ToTimestamp(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Timestamp> toTimestamp(@Stringly.Param String value, Field<String> formatMask) {
        return new ToTimestamp(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Timestamp> toTimestamp(Field<String> value, @Stringly.Param String formatMask) {
        return new ToTimestamp(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ HSQLDB, POSTGRES, YUGABYTEDB })
    public static Field<Timestamp> toTimestamp(Field<String> value, Field<String> formatMask) {
        return new ToTimestamp(value, formatMask);
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> translate(Field<String> string, @Stringly.Param String from, @Stringly.Param String to) {
        return new Translate(string, Tools.field(from), Tools.field(to));
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> translate(Field<String> string, @Stringly.Param String from, Field<String> to) {
        return new Translate(string, Tools.field(from), to);
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> translate(Field<String> string, Field<String> from, @Stringly.Param String to) {
        return new Translate(string, from, Tools.field(to));
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<String> translate(Field<String> string, Field<String> from, Field<String> to) {
        return new Translate(string, from, to);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Trim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(@Stringly.Param String string, Field<String> characters) {
        return new Trim(Tools.field(string), characters);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(Field<String> string, @Stringly.Param String characters) {
        return new Trim(string, Tools.field(characters));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(Field<String> string, Field<String> characters) {
        return new Trim(string, characters);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> trim(@Stringly.Param String string) {
        return new Trim(Tools.field(string));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> trim(Field<String> string) {
        return new Trim(string);
    }

    /**
     * The <code>UPPER</code> function.
     * <p>
     * Turn a string into upper case.
     *
     * @param string is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support
    public static Field<String> upper(@Stringly.Param String string) {
        return new Upper(Tools.field(string));
    }

    /**
     * The <code>UPPER</code> function.
     * <p>
     * Turn a string into upper case.
     */
    @NotNull
    @Support
    public static Field<String> upper(Field<String> string) {
        return new Upper(string);
    }

    // -------------------------------------------------------------------------
    // UUID functions
    // -------------------------------------------------------------------------

    /**
     * The <code>UUID</code> function.
     * <p>
     * Generate a random UUID.
     */
    @NotNull
    @Support({ DUCKDB, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static Field<UUID> uuid() {
        return new Uuid();
    }

    /**
     * The <code>BIN_TO_UUID</code> function.
     * <p>
     * Convert a {@link SQLDataType#BINARY} representation of a UUID to a {@link SQLDataType#UUID}
     * representation.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<UUID> binToUuid(byte[] bytes) {
        return new BinToUuid(Tools.field(bytes));
    }

    /**
     * The <code>BIN_TO_UUID</code> function.
     * <p>
     * Convert a {@link SQLDataType#BINARY} representation of a UUID to a {@link SQLDataType#UUID}
     * representation.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<UUID> binToUuid(Field<byte[]> bytes) {
        return new BinToUuid(bytes);
    }

    /**
     * The <code>UUID_TO_BIN</code> function.
     * <p>
     * Convert a {@link SQLDataType#BINARY} representation of a UUID to a {@link SQLDataType#UUID}
     * representation.
     *
     * @param uuid is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<byte[]> uuidToBin(UUID uuid) {
        return new UuidToBin(Tools.field(uuid));
    }

    /**
     * The <code>UUID_TO_BIN</code> function.
     * <p>
     * Convert a {@link SQLDataType#BINARY} representation of a UUID to a {@link SQLDataType#UUID}
     * representation.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<byte[]> uuidToBin(Field<UUID> uuid) {
        return new UuidToBin(uuid);
    }

    // -------------------------------------------------------------------------
    // Binary functions
    // -------------------------------------------------------------------------

    /**
     * The <code>BINARY_BIT_LENGTH</code> function.
     * <p>
     * The length of a binary string in bits.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryBitLength(byte[] bytes) {
        return new BinaryBitLength(Tools.field(bytes));
    }

    /**
     * The <code>BINARY_BIT_LENGTH</code> function.
     * <p>
     * The length of a binary string in bits.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryBitLength(Field<byte[]> bytes) {
        return new BinaryBitLength(bytes);
    }

    /**
     * The <code>BINARY_CONCAT</code> function.
     * <p>
     * The concatenation of binary strings.
     *
     * @param bytes1 The first binary string.
     * @param bytes2 The second binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryConcat(byte[] bytes1, byte[] bytes2) {
        return new BinaryConcat(Tools.field(bytes1), Tools.field(bytes2));
    }

    /**
     * The <code>BINARY_CONCAT</code> function.
     * <p>
     * The concatenation of binary strings.
     *
     * @param bytes1 The first binary string.
     * @param bytes2 The second binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryConcat(byte[] bytes1, Field<byte[]> bytes2) {
        return new BinaryConcat(Tools.field(bytes1), bytes2);
    }

    /**
     * The <code>BINARY_CONCAT</code> function.
     * <p>
     * The concatenation of binary strings.
     *
     * @param bytes1 The first binary string.
     * @param bytes2 The second binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryConcat(Field<byte[]> bytes1, byte[] bytes2) {
        return new BinaryConcat(bytes1, Tools.field(bytes2));
    }

    /**
     * The <code>BINARY_CONCAT</code> function.
     * <p>
     * The concatenation of binary strings.
     *
     * @param bytes1 The first binary string.
     * @param bytes2 The second binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryConcat(Field<byte[]> bytes1, Field<byte[]> bytes2) {
        return new BinaryConcat(bytes1, bytes2);
    }

    /**
     * The <code>BINARY_LENGTH</code> function.
     * <p>
     * The length of a binary string in bytes.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryLength(byte[] bytes) {
        return new BinaryLength(Tools.field(bytes));
    }

    /**
     * The <code>BINARY_LENGTH</code> function.
     * <p>
     * The length of a binary string in bytes.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryLength(Field<byte[]> bytes) {
        return new BinaryLength(bytes);
    }

    /**
     * The <code>BINARY_LTRIM</code> function.
     * <p>
     * Trim bytes from the left side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The binary characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryLtrim(byte[] bytes, byte[] characters) {
        return new BinaryLtrim(Tools.field(bytes), Tools.field(characters));
    }

    /**
     * The <code>BINARY_LTRIM</code> function.
     * <p>
     * Trim bytes from the left side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The binary characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryLtrim(byte[] bytes, Field<byte[]> characters) {
        return new BinaryLtrim(Tools.field(bytes), characters);
    }

    /**
     * The <code>BINARY_LTRIM</code> function.
     * <p>
     * Trim bytes from the left side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The binary characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryLtrim(Field<byte[]> bytes, byte[] characters) {
        return new BinaryLtrim(bytes, Tools.field(characters));
    }

    /**
     * The <code>BINARY_LTRIM</code> function.
     * <p>
     * Trim bytes from the left side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The binary characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryLtrim(Field<byte[]> bytes, Field<byte[]> characters) {
        return new BinaryLtrim(bytes, characters);
    }

    /**
     * The <code>BINARY_MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryMd5(byte[] bytes) {
        return new BinaryMd5(Tools.field(bytes));
    }

    /**
     * The <code>BINARY_MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a binary string.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryMd5(Field<byte[]> bytes) {
        return new BinaryMd5(bytes);
    }

    /**
     * The <code>BINARY_OCTET_LENGTH</code> function.
     * <p>
     * The length of a binary string in octets.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryOctetLength(byte[] bytes) {
        return new BinaryOctetLength(Tools.field(bytes));
    }

    /**
     * The <code>BINARY_OCTET_LENGTH</code> function.
     * <p>
     * The length of a binary string in octets.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryOctetLength(Field<byte[]> bytes) {
        return new BinaryOctetLength(bytes);
    }

    /**
     * The <code>BINARY_OVERLAY</code> function.
     * <p>
     * Place a binary string on top of another binary string, replacing the original contents.
     *
     * @param in The original binary string on top of which the overlay is placed.
     * @param placing The binary string that is being placed on top of the other binary string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryOverlay(Field<byte[]> in, byte[] placing, Number startIndex, Number length) {
        return new BinaryOverlay(in, Tools.field(placing), Tools.field(startIndex), Tools.field(length));
    }

    /**
     * The <code>BINARY_OVERLAY</code> function.
     * <p>
     * Place a binary string on top of another binary string, replacing the original contents.
     *
     * @param in The original binary string on top of which the overlay is placed.
     * @param placing The binary string that is being placed on top of the other binary string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryOverlay(Field<byte[]> in, Field<byte[]> placing, Field<? extends Number> startIndex, Field<? extends Number> length) {
        return new BinaryOverlay(in, placing, startIndex, length);
    }

    /**
     * The <code>BINARY_OVERLAY</code> function.
     * <p>
     * Place a binary string on top of another binary string, replacing the original contents.
     *
     * @param in The original binary string on top of which the overlay is placed.
     * @param placing The binary string that is being placed on top of the other binary string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryOverlay(Field<byte[]> in, byte[] placing, Number startIndex) {
        return new BinaryOverlay(in, Tools.field(placing), Tools.field(startIndex));
    }

    /**
     * The <code>BINARY_OVERLAY</code> function.
     * <p>
     * Place a binary string on top of another binary string, replacing the original contents.
     *
     * @param in The original binary string on top of which the overlay is placed.
     * @param placing The binary string that is being placed on top of the other binary string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryOverlay(Field<byte[]> in, Field<byte[]> placing, Field<? extends Number> startIndex) {
        return new BinaryOverlay(in, placing, startIndex);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, byte[] search, int startIndex) {
        return new BinaryPosition(Tools.field(in), Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, byte[] search, Field<? extends Number> startIndex) {
        return new BinaryPosition(Tools.field(in), Tools.field(search), startIndex);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, Field<byte[]> search, int startIndex) {
        return new BinaryPosition(Tools.field(in), search, Tools.field(startIndex));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, Field<byte[]> search, Field<? extends Number> startIndex) {
        return new BinaryPosition(Tools.field(in), search, startIndex);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, byte[] search, int startIndex) {
        return new BinaryPosition(in, Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, byte[] search, Field<? extends Number> startIndex) {
        return new BinaryPosition(in, Tools.field(search), startIndex);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, Field<byte[]> search, int startIndex) {
        return new BinaryPosition(in, search, Tools.field(startIndex));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, Field<byte[]> search, Field<? extends Number> startIndex) {
        return new BinaryPosition(in, search, startIndex);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, byte[] search) {
        return new BinaryPosition(Tools.field(in), Tools.field(search));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(byte[] in, Field<byte[]> search) {
        return new BinaryPosition(Tools.field(in), search);
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, byte[] search) {
        return new BinaryPosition(in, Tools.field(search));
    }

    /**
     * The <code>BINARY_POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<Integer> binaryPosition(Field<byte[]> in, Field<byte[]> search) {
        return new BinaryPosition(in, search);
    }

    /**
     * The <code>BINARY_RTRIM</code> function.
     * <p>
     * Trim bytes from the right side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryRtrim(byte[] bytes, byte[] characters) {
        return new BinaryRtrim(Tools.field(bytes), Tools.field(characters));
    }

    /**
     * The <code>BINARY_RTRIM</code> function.
     * <p>
     * Trim bytes from the right side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryRtrim(byte[] bytes, Field<byte[]> characters) {
        return new BinaryRtrim(Tools.field(bytes), characters);
    }

    /**
     * The <code>BINARY_RTRIM</code> function.
     * <p>
     * Trim bytes from the right side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryRtrim(Field<byte[]> bytes, byte[] characters) {
        return new BinaryRtrim(bytes, Tools.field(characters));
    }

    /**
     * The <code>BINARY_RTRIM</code> function.
     * <p>
     * Trim bytes from the right side of a binary string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<byte[]> binaryRtrim(Field<byte[]> bytes, Field<byte[]> characters) {
        return new BinaryRtrim(bytes, characters);
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, int startingPosition, int length) {
        return new BinarySubstring(string, Tools.field(startingPosition), Tools.field(length));
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, int startingPosition, Field<? extends Number> length) {
        return new BinarySubstring(string, Tools.field(startingPosition), length);
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, Field<? extends Number> startingPosition, int length) {
        return new BinarySubstring(string, startingPosition, Tools.field(length));
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, Field<? extends Number> startingPosition, Field<? extends Number> length) {
        return new BinarySubstring(string, startingPosition, length);
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, int startingPosition) {
        return new BinarySubstring(string, Tools.field(startingPosition));
    }

    /**
     * The <code>BINARY_SUBSTRING</code> function.
     * <p>
     * Get a substring of a binary string, from a given position.
     *
     * @param string The binary string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binarySubstring(Field<byte[]> string, Field<? extends Number> startingPosition) {
        return new BinarySubstring(string, startingPosition);
    }

    /**
     * The <code>BINARY_TRIM</code> function.
     * <p>
     * Trim characters from both sides of a string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryTrim(byte[] bytes, byte[] characters) {
        return new BinaryTrim(Tools.field(bytes), Tools.field(characters));
    }

    /**
     * The <code>BINARY_TRIM</code> function.
     * <p>
     * Trim characters from both sides of a string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryTrim(byte[] bytes, Field<byte[]> characters) {
        return new BinaryTrim(Tools.field(bytes), characters);
    }

    /**
     * The <code>BINARY_TRIM</code> function.
     * <p>
     * Trim characters from both sides of a string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryTrim(Field<byte[]> bytes, byte[] characters) {
        return new BinaryTrim(bytes, Tools.field(characters));
    }

    /**
     * The <code>BINARY_TRIM</code> function.
     * <p>
     * Trim characters from both sides of a string.
     *
     * @param bytes The binary string to be trimmed.
     * @param characters The characters to be removed.
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<byte[]> binaryTrim(Field<byte[]> bytes, Field<byte[]> characters) {
        return new BinaryTrim(bytes, characters);
    }

    // -------------------------------------------------------------------------
    // Date functions
    // -------------------------------------------------------------------------

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Date date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Date date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Field<Date> date, Number interval, DatePart datePart) {
        return new DateAdd<>(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Field<Date> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(date, interval, datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Date date, Number interval) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Date date, Field<? extends Number> interval) {
        return new DateAdd<>(Tools.field(date), interval);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Field<Date> date, Number interval) {
        return new DateAdd<>(date, Tools.field(interval));
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<Date> dateAdd(Field<Date> date, Field<? extends Number> interval) {
        return new DateAdd<>(date, interval);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(LocalDate date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(LocalDate date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(Field<LocalDate> date, Number interval, DatePart datePart) {
        return new DateAdd<>(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(Field<LocalDate> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(date, interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(LocalDate date, Number interval) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(LocalDate date, Field<? extends Number> interval) {
        return new DateAdd<>(Tools.field(date), interval);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(Field<LocalDate> date, Number interval) {
        return new DateAdd<>(date, Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateAdd(Field<LocalDate> date, Field<? extends Number> interval) {
        return new DateAdd<>(date, interval);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Timestamp date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Timestamp date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Field<Timestamp> date, Number interval, DatePart datePart) {
        return new DateAdd<>(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Field<Timestamp> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(date, interval, datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Timestamp date, Number interval) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Timestamp date, Field<? extends Number> interval) {
        return new DateAdd<>(Tools.field(date), interval);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Field<Timestamp> date, Number interval) {
        return new DateAdd<>(date, Tools.field(interval));
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampAdd(Field<Timestamp> date, Field<? extends Number> interval) {
        return new DateAdd<>(date, interval);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Number interval, DatePart datePart) {
        return new DateAdd<>(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(date, interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Number interval) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Field<? extends Number> interval) {
        return new DateAdd<>(Tools.field(date), interval);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Number interval) {
        return new DateAdd<>(date, Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Field<? extends Number> interval) {
        return new DateAdd<>(date, interval);
    }

    // -------------------------------------------------------------------------
    // Array functions
    // -------------------------------------------------------------------------

    /**
     * The <code>CARDINALITY</code> function.
     * <p>
     * Calculate the cardinality of an array field.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static Field<Integer> cardinality(Field<? extends Object[]> array) {
        return new Cardinality(array);
    }

    /**
     * The <code>ARRAY_GET</code> function.
     * <p>
     * Get an array element at a given index (1 based).
     *
     * @param index is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T> arrayGet(Field<T[]> array, int index) {
        return new ArrayGet<>(array, Tools.field(index));
    }

    /**
     * The <code>ARRAY_GET</code> function.
     * <p>
     * Get an array element at a given index (1 based).
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T> arrayGet(Field<T[]> array, Field<Integer> index) {
        return new ArrayGet<>(array, index);
    }

    /**
     * The <code>ARRAY_CONCAT</code> function.
     * <p>
     * Concatenate two arrays.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayConcat(T[] array1, T[] array2) {
        return new ArrayConcat<>(Tools.field(array1), Tools.field(array2));
    }

    /**
     * The <code>ARRAY_CONCAT</code> function.
     * <p>
     * Concatenate two arrays.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayConcat(T[] array1, Field<T[]> array2) {
        return new ArrayConcat<>(Tools.field(array1), array2);
    }

    /**
     * The <code>ARRAY_CONCAT</code> function.
     * <p>
     * Concatenate two arrays.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayConcat(Field<T[]> array1, T[] array2) {
        return new ArrayConcat<>(array1, Tools.field(array2, array1));
    }

    /**
     * The <code>ARRAY_CONCAT</code> function.
     * <p>
     * Concatenate two arrays.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayConcat(Field<T[]> array1, Field<T[]> array2) {
        return new ArrayConcat<>(array1, array2);
    }

    /**
     * The <code>ARRAY_APPEND</code> function.
     * <p>
     * Append an element to an array.
     *
     * @param array The array to which to append an element.
     * @param append The element to append to the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayAppend(T[] array, T append) {
        return new ArrayAppend<>(Tools.field(array), Tools.field(append));
    }

    /**
     * The <code>ARRAY_APPEND</code> function.
     * <p>
     * Append an element to an array.
     *
     * @param array The array to which to append an element.
     * @param append The element to append to the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayAppend(T[] array, Field<T> append) {
        return new ArrayAppend<>(Tools.field(array), append);
    }

    /**
     * The <code>ARRAY_APPEND</code> function.
     * <p>
     * Append an element to an array.
     *
     * @param array The array to which to append an element.
     * @param append The element to append to the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayAppend(Field<T[]> array, T append) {
        return new ArrayAppend<>(array, Tools.field(append));
    }

    /**
     * The <code>ARRAY_APPEND</code> function.
     * <p>
     * Append an element to an array.
     *
     * @param array The array to which to append an element.
     * @param append The element to append to the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayAppend(Field<T[]> array, Field<T> append) {
        return new ArrayAppend<>(array, append);
    }

    /**
     * The <code>ARRAY_PREPEND</code> function.
     * <p>
     * Prepend an element to an array.
     *
     * @param prepend The element to prepend to the array.
     * @param array The array to which to prepend an element.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayPrepend(T prepend, T[] array) {
        return new ArrayPrepend<>(Tools.field(prepend), Tools.field(array));
    }

    /**
     * The <code>ARRAY_PREPEND</code> function.
     * <p>
     * Prepend an element to an array.
     *
     * @param prepend The element to prepend to the array.
     * @param array The array to which to prepend an element.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayPrepend(T prepend, Field<T[]> array) {
        return new ArrayPrepend<>(Tools.field(prepend), array);
    }

    /**
     * The <code>ARRAY_PREPEND</code> function.
     * <p>
     * Prepend an element to an array.
     *
     * @param prepend The element to prepend to the array.
     * @param array The array to which to prepend an element.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayPrepend(Field<T> prepend, T[] array) {
        return new ArrayPrepend<>(prepend, Tools.field(array));
    }

    /**
     * The <code>ARRAY_PREPEND</code> function.
     * <p>
     * Prepend an element to an array.
     *
     * @param prepend The element to prepend to the array.
     * @param array The array to which to prepend an element.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayPrepend(Field<T> prepend, Field<T[]> array) {
        return new ArrayPrepend<>(prepend, array);
    }

    /**
     * The <code>ARRAY_OVERLAP</code> function.
     * <p>
     * Check if 2 arrays overlap.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayOverlap(T[] array1, T[] array2) {
        return new ArrayOverlap<>(Tools.field(array1), Tools.field(array2));
    }

    /**
     * The <code>ARRAY_OVERLAP</code> function.
     * <p>
     * Check if 2 arrays overlap.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayOverlap(T[] array1, Field<T[]> array2) {
        return new ArrayOverlap<>(Tools.field(array1), array2);
    }

    /**
     * The <code>ARRAY_OVERLAP</code> function.
     * <p>
     * Check if 2 arrays overlap.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayOverlap(Field<T[]> array1, T[] array2) {
        return new ArrayOverlap<>(array1, Tools.field(array2, array1));
    }

    /**
     * The <code>ARRAY_OVERLAP</code> function.
     * <p>
     * Check if 2 arrays overlap.
     *
     * @param array1 The first array.
     * @param array2 The second array.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayOverlap(Field<T[]> array1, Field<T[]> array2) {
        return new ArrayOverlap<>(array1, array2);
    }

    /**
     * The <code>ARRAY_REMOVE</code> function.
     * <p>
     * Remove an element from an array.
     *
     * @param array The array whose elements are to be removed.
     * @param remove The array element that should be removed.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayRemove(T[] array, T remove) {
        return new ArrayRemove<>(Tools.field(array), Tools.field(remove));
    }

    /**
     * The <code>ARRAY_REMOVE</code> function.
     * <p>
     * Remove an element from an array.
     *
     * @param array The array whose elements are to be removed.
     * @param remove The array element that should be removed.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayRemove(T[] array, Field<T> remove) {
        return new ArrayRemove<>(Tools.field(array), remove);
    }

    /**
     * The <code>ARRAY_REMOVE</code> function.
     * <p>
     * Remove an element from an array.
     *
     * @param array The array whose elements are to be removed.
     * @param remove The array element that should be removed.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayRemove(Field<T[]> array, T remove) {
        return new ArrayRemove<>(array, Tools.field(remove));
    }

    /**
     * The <code>ARRAY_REMOVE</code> function.
     * <p>
     * Remove an element from an array.
     *
     * @param array The array whose elements are to be removed.
     * @param remove The array element that should be removed.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayRemove(Field<T[]> array, Field<T> remove) {
        return new ArrayRemove<>(array, remove);
    }

    /**
     * The <code>ARRAY_REPLACE</code> function.
     * <p>
     * Replace an element in an array.
     *
     * @param array The array whose elements are to be replaced.
     * @param search The expression to search for in the array.
     * @param replace The value to replace a value by.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayReplace(T[] array, T search, T replace) {
        return new ArrayReplace<>(Tools.field(array), Tools.field(search), Tools.field(replace));
    }

    /**
     * The <code>ARRAY_REPLACE</code> function.
     * <p>
     * Replace an element in an array.
     *
     * @param array The array whose elements are to be replaced.
     * @param search The expression to search for in the array.
     * @param replace The value to replace a value by.
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayReplace(Field<T[]> array, Field<T> search, Field<T> replace) {
        return new ArrayReplace<>(array, search, replace);
    }

    /**
     * The <code>ARRAY_TO_STRING</code> function.
     * <p>
     * Join array elements into a string.
     *
     * @param array The array whose elements are joined
     * @param delimiter The delimiter to place between elements
     * @param nullString The NULL encoding
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String> arrayToString(Object[] array, @Stringly.Param String delimiter, @Stringly.Param String nullString) {
        return new ArrayToString<>(Tools.field(array), Tools.field(delimiter), Tools.field(nullString));
    }

    /**
     * The <code>ARRAY_TO_STRING</code> function.
     * <p>
     * Join array elements into a string.
     *
     * @param array The array whose elements are joined
     * @param delimiter The delimiter to place between elements
     * @param nullString The NULL encoding
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String> arrayToString(Field<? extends Object[]> array, Field<String> delimiter, Field<String> nullString) {
        return new ArrayToString<>(array, delimiter, nullString);
    }

    /**
     * The <code>ARRAY_TO_STRING</code> function.
     * <p>
     * Join array elements into a string.
     *
     * @param array The array whose elements are joined
     * @param delimiter The delimiter to place between elements
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String> arrayToString(Object[] array, @Stringly.Param String delimiter) {
        return new ArrayToString<>(Tools.field(array), Tools.field(delimiter));
    }

    /**
     * The <code>ARRAY_TO_STRING</code> function.
     * <p>
     * Join array elements into a string.
     *
     * @param array The array whose elements are joined
     * @param delimiter The delimiter to place between elements
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String> arrayToString(Field<? extends Object[]> array, Field<String> delimiter) {
        return new ArrayToString<>(array, delimiter);
    }

    /**
     * The <code>ARRAY_FILTER</code> function.
     * <p>
     * Filter elements out of an array.
     *
     * @param array The array whose elements are filtered.
     * @param predicate A predicate defining which elements to keep in the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayFilter(T[] array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayFilter<>(Tools.field(array), DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_FILTER</code> function.
     * <p>
     * Filter elements out of an array.
     *
     * @param array The array whose elements are filtered.
     * @param predicate A predicate defining which elements to keep in the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayFilter(T[] array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayFilter<>(Tools.field(array), predicate);
    }

    /**
     * The <code>ARRAY_FILTER</code> function.
     * <p>
     * Filter elements out of an array.
     *
     * @param array The array whose elements are filtered.
     * @param predicate A predicate defining which elements to keep in the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayFilter(Field<T[]> array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayFilter<>(array, DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_FILTER</code> function.
     * <p>
     * Filter elements out of an array.
     *
     * @param array The array whose elements are filtered.
     * @param predicate A predicate defining which elements to keep in the array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> arrayFilter(Field<T[]> array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayFilter<>(array, predicate);
    }

    /**
     * The <code>ARRAY_MAP</code> function.
     * <p>
     * Map elements of an array.
     *
     * @param array The array whose elements are mapped.
     * @param mapper The function that defines the mapping between source elements and result elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T, U> Field<U[]> arrayMap(T[] array, Function1<? super Field<T>, ? extends Field<U>> mapper) {
        return new ArrayMap<>(Tools.field(array), DSL.lambda(array, mapper));
    }

    /**
     * The <code>ARRAY_MAP</code> function.
     * <p>
     * Map elements of an array.
     *
     * @param array The array whose elements are mapped.
     * @param mapper The function that defines the mapping between source elements and result elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T, U> Field<U[]> arrayMap(T[] array, Lambda1<Field<T>, Field<U>> mapper) {
        return new ArrayMap<>(Tools.field(array), mapper);
    }

    /**
     * The <code>ARRAY_MAP</code> function.
     * <p>
     * Map elements of an array.
     *
     * @param array The array whose elements are mapped.
     * @param mapper The function that defines the mapping between source elements and result elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T, U> Field<U[]> arrayMap(Field<T[]> array, Function1<? super Field<T>, ? extends Field<U>> mapper) {
        return new ArrayMap<>(array, DSL.lambda(array, mapper));
    }

    /**
     * The <code>ARRAY_MAP</code> function.
     * <p>
     * Map elements of an array.
     *
     * @param array The array whose elements are mapped.
     * @param mapper The function that defines the mapping between source elements and result elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T, U> Field<U[]> arrayMap(Field<T[]> array, Lambda1<Field<T>, Field<U>> mapper) {
        return new ArrayMap<>(array, mapper);
    }

    /**
     * The <code>ARRAY_ALL_MATCH</code> function.
     * <p>
     * Check if all elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for all array elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAllMatch(T[] array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayAllMatch<>(Tools.field(array), DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_ALL_MATCH</code> function.
     * <p>
     * Check if all elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for all array elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAllMatch(T[] array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayAllMatch<>(Tools.field(array), predicate);
    }

    /**
     * The <code>ARRAY_ALL_MATCH</code> function.
     * <p>
     * Check if all elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for all array elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAllMatch(Field<T[]> array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayAllMatch<>(array, DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_ALL_MATCH</code> function.
     * <p>
     * Check if all elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for all array elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAllMatch(Field<T[]> array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayAllMatch<>(array, predicate);
    }

    /**
     * The <code>ARRAY_ANY_MATCH</code> function.
     * <p>
     * Check if any elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for at least 1 array element
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAnyMatch(T[] array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayAnyMatch<>(Tools.field(array), DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_ANY_MATCH</code> function.
     * <p>
     * Check if any elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for at least 1 array element
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAnyMatch(T[] array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayAnyMatch<>(Tools.field(array), predicate);
    }

    /**
     * The <code>ARRAY_ANY_MATCH</code> function.
     * <p>
     * Check if any elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for at least 1 array element
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAnyMatch(Field<T[]> array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayAnyMatch<>(array, DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_ANY_MATCH</code> function.
     * <p>
     * Check if any elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be true for at least 1 array element
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayAnyMatch(Field<T[]> array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayAnyMatch<>(array, predicate);
    }

    /**
     * The <code>ARRAY_NONE_MATCH</code> function.
     * <p>
     * Check if none of the elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be false for all elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayNoneMatch(T[] array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayNoneMatch<>(Tools.field(array), DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_NONE_MATCH</code> function.
     * <p>
     * Check if none of the elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be false for all elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayNoneMatch(T[] array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayNoneMatch<>(Tools.field(array), predicate);
    }

    /**
     * The <code>ARRAY_NONE_MATCH</code> function.
     * <p>
     * Check if none of the elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be false for all elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayNoneMatch(Field<T[]> array, Function1<? super Field<T>, ? extends Condition> predicate) {
        return new ArrayNoneMatch<>(array, DSL.lambda(array, predicate));
    }

    /**
     * The <code>ARRAY_NONE_MATCH</code> function.
     * <p>
     * Check if none of the elements of an array match a given predicate.
     *
     * @param array The array to be checked.
     * @param predicate The predicate that must be false for all elements.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Condition arrayNoneMatch(Field<T[]> array, Lambda1<Field<T>, Condition> predicate) {
        return new ArrayNoneMatch<>(array, predicate);
    }

    /**
     * The <code>STRING_TO_ARRAY</code> function.
     * <p>
     * Split a string into array elements.
     *
     * @param string The string to split
     * @param delimiter The delimiter to parse between elements
     * @param nullString The NULL encoding
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String[]> stringToArray(@Stringly.Param String string, @Stringly.Param String delimiter, @Stringly.Param String nullString) {
        return new StringToArray(Tools.field(string), Tools.field(delimiter), Tools.field(nullString));
    }

    /**
     * The <code>STRING_TO_ARRAY</code> function.
     * <p>
     * Split a string into array elements.
     *
     * @param string The string to split
     * @param delimiter The delimiter to parse between elements
     * @param nullString The NULL encoding
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String[]> stringToArray(Field<String> string, Field<String> delimiter, Field<String> nullString) {
        return new StringToArray(string, delimiter, nullString);
    }

    /**
     * The <code>STRING_TO_ARRAY</code> function.
     * <p>
     * Split a string into array elements.
     *
     * @param string The string to split
     * @param delimiter The delimiter to parse between elements
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String[]> stringToArray(@Stringly.Param String string, @Stringly.Param String delimiter) {
        return new StringToArray(Tools.field(string), Tools.field(delimiter));
    }

    /**
     * The <code>STRING_TO_ARRAY</code> function.
     * <p>
     * Split a string into array elements.
     *
     * @param string The string to split
     * @param delimiter The delimiter to parse between elements
     */
    @NotNull
    @Support({ POSTGRES, YUGABYTEDB })
    public static Field<String[]> stringToArray(Field<String> string, Field<String> delimiter) {
        return new StringToArray(string, delimiter);
    }

    // -------------------------------------------------------------------------
    // Utility functions
    // -------------------------------------------------------------------------

    /**
     * The <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(T value, T defaultValue) {
        return new Nvl<>(Tools.field(value), Tools.field(defaultValue));
    }

    /**
     * The <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(T value, Field<T> defaultValue) {
        return new Nvl<>(Tools.field(value), defaultValue);
    }

    /**
     * The <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(Field<T> value, T defaultValue) {
        return new Nvl<>(value, Tools.field(defaultValue, value));
    }

    /**
     * The <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(Field<T> value, Field<T> defaultValue) {
        return new Nvl<>(value, defaultValue);
    }

    /**
     * The <code>ISNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(T value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>ISNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(T value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>ISNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(Field<T> value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>ISNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(Field<T> value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(T value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(T value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(Field<T> value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL</code> function, an alias for the <code>NVL</code> function.
     * <p>
     * Return the first non-null argument.
     *
     * @param value The nullable value.
     * @param defaultValue The default value if the other value is null.
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(Field<T> value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>NULLIF</code> function.
     *
     * @param value The result value if the other value is not equal.
     * @param other The value to compare the result value with.
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(T value, T other) {
        return new Nullif<>(Tools.field(value), Tools.field(other));
    }

    /**
     * The <code>NULLIF</code> function.
     *
     * @param value The result value if the other value is not equal.
     * @param other The value to compare the result value with.
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(T value, Field<T> other) {
        return new Nullif<>(Tools.field(value), other);
    }

    /**
     * The <code>NULLIF</code> function.
     *
     * @param value The result value if the other value is not equal.
     * @param other The value to compare the result value with.
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(Field<T> value, T other) {
        return new Nullif<>(value, Tools.field(other, value));
    }

    /**
     * The <code>NULLIF</code> function.
     *
     * @param value The result value if the other value is not equal.
     * @param other The value to compare the result value with.
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(Field<T> value, Field<T> other) {
        return new Nullif<>(value, other);
    }

    /**
     * The <code>TRY_CAST</code> function.
     *
     * @param value The value to be cast to a data type
     * @param dataType The data type to try to cast the value to
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, TRINO })
    public static <T> Field<T> tryCast(Object value, DataType<T> dataType) {
        return new TryCast<>(Tools.field(value), dataType);
    }

    /**
     * The <code>TRY_CAST</code> function.
     *
     * @param value The value to be cast to a data type
     * @param dataType The data type to try to cast the value to
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, TRINO })
    public static <T> Field<T> tryCast(Field<?> value, DataType<T> dataType) {
        return new TryCast<>(value, dataType);
    }

    // -------------------------------------------------------------------------
    // System functions
    // -------------------------------------------------------------------------

    /**
     * The <code>CURRENT_CATALOG</code> function.
     * <p>
     * The CURRENT_CATALOG of the current session
     */
    @NotNull
    @Support({ CLICKHOUSE, FIREBIRD, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> currentCatalog() {
        return new CurrentCatalog();
    }

    /**
     * The <code>CURRENT_SCHEMA</code> function.
     * <p>
     * The CURRENT_SCHEMA of the current session
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> currentSchema() {
        return new CurrentSchema();
    }

    /**
     * The <code>CURRENT_USER</code> function.
     * <p>
     * The CURRENT_USER of the current session with the database
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> currentUser() {
        return new CurrentUser();
    }


































































































    // -------------------------------------------------------------------------
    // XML functions
    // -------------------------------------------------------------------------

    /**
     * The <code>XMLCOMMENT</code> function.
     *
     * @param comment is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlcomment(@Stringly.Param String comment) {
        return new XMLComment(Tools.field(comment));
    }

    /**
     * The <code>XMLCOMMENT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlcomment(Field<String> comment) {
        return new XMLComment(comment);
    }

    /**
     * The <code>XMLCONCAT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlconcat(Field<?>... args) {
        return new XMLConcat(Arrays.asList(args));
    }

    /**
     * The <code>XMLCONCAT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlconcat(Collection<? extends Field<?>> args) {
        return new XMLConcat(new QueryPartList<>(args));
    }















    /**
     * The <code>XMLFOREST</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlforest(Field<?>... fields) {
        return new XMLForest(Arrays.asList(fields));
    }

    /**
     * The <code>XMLFOREST</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlforest(Collection<? extends Field<?>> fields) {
        return new XMLForest(new QueryPartList<>(fields));
    }

    /**
     * The <code>XMLPI</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(@Stringly.Name String target, Field<?> content) {
        return new XMLPi(DSL.name(target), content);
    }

    /**
     * The <code>XMLPI</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(Name target, Field<?> content) {
        return new XMLPi(target, content);
    }

    /**
     * The <code>XMLPI</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(@Stringly.Name String target) {
        return new XMLPi(DSL.name(target));
    }

    /**
     * The <code>XMLPI</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(Name target) {
        return new XMLPi(target);
    }

    /**
     * The <code>XMLSERIALIZE</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeDocument(XML value, DataType<T> type) {
        return new XMLSerialize<>(false, Tools.field(value), type);
    }

    /**
     * The <code>XMLSERIALIZE</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeDocument(Field<XML> value, DataType<T> type) {
        return new XMLSerialize<>(false, value, type);
    }

    /**
     * The <code>XMLSERIALIZE_CONTENT</code> function.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeContent(XML value, DataType<T> type) {
        return new XMLSerialize<>(true, Tools.field(value), type);
    }

    /**
     * The <code>XMLSERIALIZE_CONTENT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeContent(Field<XML> value, DataType<T> type) {
        return new XMLSerialize<>(true, value, type);
    }

    // -------------------------------------------------------------------------
    // JSON functions
    // -------------------------------------------------------------------------

    /**
     * The <code>JSON_ARRAY</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayNullStep<JSON> jsonArray(Field<?>... fields) {
        return new JSONArray(SQLDataType.JSON, Arrays.asList(fields));
    }

    /**
     * The <code>JSON_ARRAY</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayNullStep<JSON> jsonArray(Collection<? extends Field<?>> fields) {
        return new JSONArray(SQLDataType.JSON, new QueryPartList<>(fields));
    }

    /**
     * The <code>JSONB_ARRAY</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayNullStep<JSONB> jsonbArray(Field<?>... fields) {
        return new JSONArray(SQLDataType.JSONB, Arrays.asList(fields));
    }

    /**
     * The <code>JSONB_ARRAY</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayNullStep<JSONB> jsonbArray(Collection<? extends Field<?>> fields) {
        return new JSONArray(SQLDataType.JSONB, new QueryPartList<>(fields));
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject(JSONEntry<?>... entries) {
        return new JSONObject(SQLDataType.JSON, Arrays.asList(entries));
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject(Collection<? extends JSONEntry<?>> entries) {
        return new JSONObject(SQLDataType.JSON, new QueryPartList<>(entries));
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject(JSONEntry<?>... entries) {
        return new JSONObject(SQLDataType.JSONB, Arrays.asList(entries));
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject(Collection<? extends JSONEntry<?>> entries) {
        return new JSONObject(SQLDataType.JSONB, new QueryPartList<>(entries));
    }

    /**
     * The <code>JSON_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSON array expression.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetElement(JSON field, int index) {
        return new JSONGetElement(Tools.field(field), Tools.field(index));
    }

    /**
     * The <code>JSON_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSON array expression.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetElement(JSON field, Field<Integer> index) {
        return new JSONGetElement(Tools.field(field), index);
    }

    /**
     * The <code>JSON_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSON array expression.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetElement(Field<JSON> field, int index) {
        return new JSONGetElement(field, Tools.field(index));
    }

    /**
     * The <code>JSON_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSON array expression.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetElement(Field<JSON> field, Field<Integer> index) {
        return new JSONGetElement(field, index);
    }

    /**
     * The <code>JSONB_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSONB array expression.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetElement(JSONB field, int index) {
        return new JSONBGetElement(Tools.field(field), Tools.field(index));
    }

    /**
     * The <code>JSONB_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSONB array expression.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetElement(JSONB field, Field<Integer> index) {
        return new JSONBGetElement(Tools.field(field), index);
    }

    /**
     * The <code>JSONB_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSONB array expression.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetElement(Field<JSONB> field, int index) {
        return new JSONBGetElement(field, Tools.field(index));
    }

    /**
     * The <code>JSONB_GET_ELEMENT</code> function.
     * <p>
     * Access an array element from a JSONB array expression.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetElement(Field<JSONB> field, Field<Integer> index) {
        return new JSONBGetElement(field, index);
    }

    /**
     * The <code>JSON_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSON array expression and return it as a string.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetElementAsText(JSON field, int index) {
        return new JSONGetElementAsText(Tools.field(field), Tools.field(index));
    }

    /**
     * The <code>JSON_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSON array expression and return it as a string.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetElementAsText(JSON field, Field<Integer> index) {
        return new JSONGetElementAsText(Tools.field(field), index);
    }

    /**
     * The <code>JSON_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSON array expression and return it as a string.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetElementAsText(Field<JSON> field, int index) {
        return new JSONGetElementAsText(field, Tools.field(index));
    }

    /**
     * The <code>JSON_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSON array expression and return it as a string.
     *
     * @param field The JSON document
     * @param index The 0-based JSON array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetElementAsText(Field<JSON> field, Field<Integer> index) {
        return new JSONGetElementAsText(field, index);
    }

    /**
     * The <code>JSONB_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSONB array expression and return it as a string.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetElementAsText(JSONB field, int index) {
        return new JSONBGetElementAsText(Tools.field(field), Tools.field(index));
    }

    /**
     * The <code>JSONB_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSONB array expression and return it as a string.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetElementAsText(JSONB field, Field<Integer> index) {
        return new JSONBGetElementAsText(Tools.field(field), index);
    }

    /**
     * The <code>JSONB_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSONB array expression and return it as a string.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetElementAsText(Field<JSONB> field, int index) {
        return new JSONBGetElementAsText(field, Tools.field(index));
    }

    /**
     * The <code>JSONB_GET_ELEMENT_AS_TEXT</code> function.
     * <p>
     * Access an array element from a JSONB array expression and return it as a string.
     *
     * @param field The JSONB document
     * @param index The 0-based JSONB array index
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetElementAsText(Field<JSONB> field, Field<Integer> index) {
        return new JSONBGetElementAsText(field, index);
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetAttribute(JSON field, @Stringly.Param String attribute) {
        return new JSONGetAttribute(Tools.field(field), Tools.field(attribute));
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetAttribute(JSON field, Field<String> attribute) {
        return new JSONGetAttribute(Tools.field(field), attribute);
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetAttribute(Field<JSON> field, @Stringly.Param String attribute) {
        return new JSONGetAttribute(field, Tools.field(attribute));
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonGetAttribute(Field<JSON> field, Field<String> attribute) {
        return new JSONGetAttribute(field, attribute);
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetAttribute(JSONB field, @Stringly.Param String attribute) {
        return new JSONBGetAttribute(Tools.field(field), Tools.field(attribute));
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetAttribute(JSONB field, Field<String> attribute) {
        return new JSONBGetAttribute(Tools.field(field), attribute);
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetAttribute(Field<JSONB> field, @Stringly.Param String attribute) {
        return new JSONBGetAttribute(field, Tools.field(attribute));
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbGetAttribute(Field<JSONB> field, Field<String> attribute) {
        return new JSONBGetAttribute(field, attribute);
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression and return it as string.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetAttributeAsText(JSON field, @Stringly.Param String attribute) {
        return new JSONGetAttributeAsText(Tools.field(field), Tools.field(attribute));
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression and return it as string.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetAttributeAsText(JSON field, Field<String> attribute) {
        return new JSONGetAttributeAsText(Tools.field(field), attribute);
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression and return it as string.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetAttributeAsText(Field<JSON> field, @Stringly.Param String attribute) {
        return new JSONGetAttributeAsText(field, Tools.field(attribute));
    }

    /**
     * The <code>JSON_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSON object expression and return it as string.
     *
     * @param field The JSON document
     * @param attribute The JSON object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonGetAttributeAsText(Field<JSON> field, Field<String> attribute) {
        return new JSONGetAttributeAsText(field, attribute);
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression and return it as
     * string.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetAttributeAsText(JSONB field, @Stringly.Param String attribute) {
        return new JSONBGetAttributeAsText(Tools.field(field), Tools.field(attribute));
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression and return it as
     * string.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetAttributeAsText(JSONB field, Field<String> attribute) {
        return new JSONBGetAttributeAsText(Tools.field(field), attribute);
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression and return it as
     * string.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetAttributeAsText(Field<JSONB> field, @Stringly.Param String attribute) {
        return new JSONBGetAttributeAsText(field, Tools.field(attribute));
    }

    /**
     * The <code>JSONB_GET_ATTRIBUTE_AS_TEXT</code> function.
     * <p>
     * Access an object attribute value from a JSONB object expression and return it as
     * string.
     *
     * @param field The JSONB document
     * @param attribute The JSONB object attribute name
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<String> jsonbGetAttributeAsText(Field<JSONB> field, Field<String> attribute) {
        return new JSONBGetAttributeAsText(field, attribute);
    }

    /**
     * The <code>JSON_ARRAY_LENGTH</code> function.
     * <p>
     * Calculate the length of a JSON array.
     *
     * @param field is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Integer> jsonArrayLength(JSON field) {
        return new JSONArrayLength(Tools.field(field));
    }

    /**
     * The <code>JSON_ARRAY_LENGTH</code> function.
     * <p>
     * Calculate the length of a JSON array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Integer> jsonArrayLength(Field<JSON> field) {
        return new JSONArrayLength(field);
    }

    /**
     * The <code>JSONB_ARRAY_LENGTH</code> function.
     * <p>
     * Calculate the length of a JSONB array.
     *
     * @param field is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Integer> jsonbArrayLength(JSONB field) {
        return new JSONBArrayLength(Tools.field(field));
    }

    /**
     * The <code>JSONB_ARRAY_LENGTH</code> function.
     * <p>
     * Calculate the length of a JSONB array.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static Field<Integer> jsonbArrayLength(Field<JSONB> field) {
        return new JSONBArrayLength(field);
    }

    /**
     * The <code>JSON_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSON object
     *
     * @param json The JSON object
     * @param key The key in the JSON object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonKeyExists(JSON json, @Stringly.Param String key) {
        return new JSONKeyExists(Tools.field(json), Tools.field(key));
    }

    /**
     * The <code>JSON_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSON object
     *
     * @param json The JSON object
     * @param key The key in the JSON object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonKeyExists(JSON json, Field<String> key) {
        return new JSONKeyExists(Tools.field(json), key);
    }

    /**
     * The <code>JSON_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSON object
     *
     * @param json The JSON object
     * @param key The key in the JSON object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonKeyExists(Field<JSON> json, @Stringly.Param String key) {
        return new JSONKeyExists(json, Tools.field(key));
    }

    /**
     * The <code>JSON_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSON object
     *
     * @param json The JSON object
     * @param key The key in the JSON object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonKeyExists(Field<JSON> json, Field<String> key) {
        return new JSONKeyExists(json, key);
    }

    /**
     * The <code>JSONB_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSONB object
     *
     * @param json The JSONB object
     * @param key The key in the JSONB object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonbKeyExists(JSONB json, @Stringly.Param String key) {
        return new JSONBKeyExists(Tools.field(json), Tools.field(key));
    }

    /**
     * The <code>JSONB_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSONB object
     *
     * @param json The JSONB object
     * @param key The key in the JSONB object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonbKeyExists(JSONB json, Field<String> key) {
        return new JSONBKeyExists(Tools.field(json), key);
    }

    /**
     * The <code>JSONB_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSONB object
     *
     * @param json The JSONB object
     * @param key The key in the JSONB object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonbKeyExists(Field<JSONB> json, @Stringly.Param String key) {
        return new JSONBKeyExists(json, Tools.field(key));
    }

    /**
     * The <code>JSONB_KEY_EXISTS</code> function.
     * <p>
     * Check if a key exists in a JSONB object
     *
     * @param json The JSONB object
     * @param key The key in the JSONB object
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Condition jsonbKeyExists(Field<JSONB> json, Field<String> key) {
        return new JSONBKeyExists(json, key);
    }

    /**
     * The <code>JSON_KEYS</code> function.
     * <p>
     * Retrieve all keys from a JSON object as an array of strings.
     *
     * @param field is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonKeys(JSON field) {
        return new JSONKeys(Tools.field(field));
    }

    /**
     * The <code>JSON_KEYS</code> function.
     * <p>
     * Retrieve all keys from a JSON object as an array of strings.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSON> jsonKeys(Field<JSON> field) {
        return new JSONKeys(field);
    }

    /**
     * The <code>JSONB_KEYS</code> function.
     * <p>
     * Retrieve all keys from a JSONB object as an array of strings.
     *
     * @param field is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbKeys(JSONB field) {
        return new JSONBKeys(Tools.field(field));
    }

    /**
     * The <code>JSONB_KEYS</code> function.
     * <p>
     * Retrieve all keys from a JSONB object as an array of strings.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static Field<JSONB> jsonbKeys(Field<JSONB> field) {
        return new JSONBKeys(field);
    }

    /**
     * The <code>JSON_SET</code> function.
     * <p>
     * Add or replace a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonSet(Field<JSON> field, @Stringly.Param String path, Object value) {
        return new JSONSet(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSON_SET</code> function.
     * <p>
     * Add or replace a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonSet(Field<JSON> field, @Stringly.Param String path, Field<?> value) {
        return new JSONSet(field, Tools.field(path), value);
    }

    /**
     * The <code>JSON_SET</code> function.
     * <p>
     * Add or replace a JSON value to a JSON field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonSet(Field<JSON> field, Field<String> path, Object value) {
        return new JSONSet(field, path, Tools.field(value));
    }

    /**
     * The <code>JSON_SET</code> function.
     * <p>
     * Add or replace a JSON value to a JSON field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonSet(Field<JSON> field, Field<String> path, Field<?> value) {
        return new JSONSet(field, path, value);
    }

    /**
     * The <code>JSONB_SET</code> function.
     * <p>
     * Add or replace a JSONB value to a JSONB field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbSet(Field<JSONB> field, @Stringly.Param String path, Object value) {
        return new JSONBSet(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSONB_SET</code> function.
     * <p>
     * Add or replace a JSONB value to a JSONB field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbSet(Field<JSONB> field, @Stringly.Param String path, Field<?> value) {
        return new JSONBSet(field, Tools.field(path), value);
    }

    /**
     * The <code>JSONB_SET</code> function.
     * <p>
     * Add or replace a JSONB value to a JSONB field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbSet(Field<JSONB> field, Field<String> path, Object value) {
        return new JSONBSet(field, path, Tools.field(value));
    }

    /**
     * The <code>JSONB_SET</code> function.
     * <p>
     * Add or replace a JSONB value to a JSONB field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbSet(Field<JSONB> field, Field<String> path, Field<?> value) {
        return new JSONBSet(field, path, value);
    }

    /**
     * The <code>JSON_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonInsert(Field<JSON> field, @Stringly.Param String path, Object value) {
        return new JSONInsert(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSON_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonInsert(Field<JSON> field, @Stringly.Param String path, Field<?> value) {
        return new JSONInsert(field, Tools.field(path), value);
    }

    /**
     * The <code>JSON_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonInsert(Field<JSON> field, Field<String> path, Object value) {
        return new JSONInsert(field, path, Tools.field(value));
    }

    /**
     * The <code>JSON_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonInsert(Field<JSON> field, Field<String> path, Field<?> value) {
        return new JSONInsert(field, path, value);
    }

    /**
     * The <code>JSONB_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbInsert(Field<JSONB> field, @Stringly.Param String path, Object value) {
        return new JSONBInsert(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSONB_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbInsert(Field<JSONB> field, @Stringly.Param String path, Field<?> value) {
        return new JSONBInsert(field, Tools.field(path), value);
    }

    /**
     * The <code>JSONB_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbInsert(Field<JSONB> field, Field<String> path, Object value) {
        return new JSONBInsert(field, path, Tools.field(value));
    }

    /**
     * The <code>JSONB_INSERT</code> function.
     * <p>
     * Add (but not replace) a JSON value to a JSON field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbInsert(Field<JSONB> field, Field<String> path, Field<?> value) {
        return new JSONBInsert(field, path, value);
    }

    /**
     * The <code>JSON_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonReplace(Field<JSON> field, @Stringly.Param String path, Object value) {
        return new JSONReplace(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSON_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSON value to a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonReplace(Field<JSON> field, @Stringly.Param String path, Field<?> value) {
        return new JSONReplace(field, Tools.field(path), value);
    }

    /**
     * The <code>JSON_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSON value to a JSON field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonReplace(Field<JSON> field, Field<String> path, Object value) {
        return new JSONReplace(field, path, Tools.field(value));
    }

    /**
     * The <code>JSON_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSON value to a JSON field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonReplace(Field<JSON> field, Field<String> path, Field<?> value) {
        return new JSONReplace(field, path, value);
    }

    /**
     * The <code>JSONB_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSONB value to a JSONB field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbReplace(Field<JSONB> field, @Stringly.Param String path, Object value) {
        return new JSONBReplace(field, Tools.field(path), Tools.field(value));
    }

    /**
     * The <code>JSONB_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSONB value to a JSONB field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbReplace(Field<JSONB> field, @Stringly.Param String path, Field<?> value) {
        return new JSONBReplace(field, Tools.field(path), value);
    }

    /**
     * The <code>JSONB_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSONB value to a JSONB field at a given path.
     *
     * @param value is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbReplace(Field<JSONB> field, Field<String> path, Object value) {
        return new JSONBReplace(field, path, Tools.field(value));
    }

    /**
     * The <code>JSONB_REPLACE</code> function.
     * <p>
     * Replace (but not add) a JSONB value to a JSONB field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbReplace(Field<JSONB> field, Field<String> path, Field<?> value) {
        return new JSONBReplace(field, path, value);
    }

    /**
     * The <code>JSON_REMOVE</code> function.
     * <p>
     * Remove a JSON value from a JSON field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonRemove(Field<JSON> field, @Stringly.Param String path) {
        return new JSONRemove(field, Tools.field(path));
    }

    /**
     * The <code>JSON_REMOVE</code> function.
     * <p>
     * Remove a JSON value from a JSON field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSON> jsonRemove(Field<JSON> field, Field<String> path) {
        return new JSONRemove(field, path);
    }

    /**
     * The <code>JSONB_REMOVE</code> function.
     * <p>
     * Remove a JSONB value from a JSONB field at a given path.
     *
     * @param path is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbRemove(Field<JSONB> field, @Stringly.Param String path) {
        return new JSONBRemove(field, Tools.field(path));
    }

    /**
     * The <code>JSONB_REMOVE</code> function.
     * <p>
     * Remove a JSONB value from a JSONB field at a given path.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, SQLITE })
    public static Field<JSONB> jsonbRemove(Field<JSONB> field, Field<String> path) {
        return new JSONBRemove(field, path);
    }







































    // -------------------------------------------------------------------------
    // Utilities
    // -------------------------------------------------------------------------

    /**
     * The <code>FIELD</code> function.
     * <p>
     * Wrap a condition in a boolean field.
     */
    @NotNull
    @Support
    public static Field<Boolean> field(Condition condition) {
        return condition instanceof NoCondition ? noField(BOOLEAN) : condition instanceof FieldCondition f ? f.field : new ConditionAsField(condition);
    }

    /**
     * The <code>CONDITION</code> function.
     * <p>
     * Create a condition from a boolean field.
     * <p>
     * Databases that support boolean data types can use boolean expressions
     * as predicates or as columns interchangeably. This extends to any type
     * of field, including functions. A Postgres example:
     * <p>
     * <pre><code>
     * select 1 where texteq('a', 'a');
     * </code></pre>
     */
    @NotNull
    @Support
    public static Condition condition(Field<Boolean> field) {
        return field instanceof Condition ? (Condition) field : field instanceof NoField ? noCondition() : field instanceof ConditionAsField c ? c.condition : new FieldCondition(field);
    }

    // -------------------------------------------------------------------------
    // Aggregate functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ANY_VALUE</code> function.
     * <p>
     * Get any arbitrary value from the group.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> anyValue(Field<T> field) {
        return new AnyValue<>(field);
    }

    /**
     * The <code>AVG</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> avg(Field<? extends Number> field) {
        return new Avg(field, false);
    }

    /**
     * The <code>AVG_DISTINCT</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field) {
        return new Avg(field, true);
    }

    /**
     * The <code>BIT_AND_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>AND</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitAndAgg(Field<T> value) {
        return new BitAndAgg<>(value);
    }

    /**
     * The <code>BIT_OR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>OR</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitOrAgg(Field<T> value) {
        return new BitOrAgg<>(value);
    }

    /**
     * The <code>BIT_XOR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>XOR</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitXorAgg(Field<T> value) {
        return new BitXorAgg<>(value);
    }

    /**
     * The <code>BIT_NAND_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>NAND</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitNandAgg(Field<T> value) {
        return new BitNandAgg<>(value);
    }

    /**
     * The <code>BIT_NOR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>NOR</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitNorAgg(Field<T> value) {
        return new BitNorAgg<>(value);
    }

    /**
     * The <code>BIT_XNOR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>XNOR</code> aggregate value.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T extends Number> AggregateFunction<T> bitXNorAgg(Field<T> value) {
        return new BitXNorAgg<>(value);
    }

    /**
     * The <code>BOOL_AND</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolAnd(Field<Boolean> condition) {
        return new BoolAnd(DSL.condition(condition));
    }

    /**
     * The <code>BOOL_AND</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolAnd(Condition condition) {
        return new BoolAnd(condition);
    }

    /**
     * The <code>BOOL_OR</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolOr(Field<Boolean> condition) {
        return new BoolOr(DSL.condition(condition));
    }

    /**
     * The <code>BOOL_OR</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolOr(Condition condition) {
        return new BoolOr(condition);
    }

    /**
     * The <code>CORR</code> function.
     * <p>
     * Calculate the correlation coefficient. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#covarPop(Field, Field)} and {@link DSL#stddevPop(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> corr(Field<? extends Number> y, Field<? extends Number> x) {
        return new Corr(y, x);
    }

    /**
     * The <code>COUNT</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(Field<?> field) {
        return new Count(field, false);
    }

    /**
     * The <code>COUNT_DISTINCT</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> countDistinct(Field<?> field) {
        return new Count(field, true);
    }

    /**
     * The <code>COVAR_SAMP</code> function.
     * <p>
     * Calculate the sample covariance. This standard SQL function may be supported natively,
     * or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> covarSamp(Field<? extends Number> y, Field<? extends Number> x) {
        return new CovarSamp(y, x);
    }

    /**
     * The <code>COVAR_POP</code> function.
     * <p>
     * Calculate the population covariance. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> covarPop(Field<? extends Number> y, Field<? extends Number> x) {
        return new CovarPop(y, x);
    }

    /**
     * The <code>EVERY</code> function, an alias for the <code>BOOL_AND</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> every(Field<Boolean> condition) {
        return boolAnd(condition);
    }

    /**
     * The <code>EVERY</code> function, an alias for the <code>BOOL_AND</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> every(Condition condition) {
        return boolAnd(condition);
    }

    /**
     * The <code>MAX</code> function.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> max(Field<T> field) {
        return new Max<>(field, false);
    }

    /**
     * The <code>MAX_DISTINCT</code> function.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> maxDistinct(Field<T> field) {
        return new Max<>(field, true);
    }

    /**
     * The <code>MAX_BY</code> function.
     * <p>
     * Evaluate <code>value</code> at the row having the maximum value for <code>by</code>.
     *
     * @param value The returned value.
     * @param by The expression to use to evaluate the maximum.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> OptionallyOrderedAggregateFunction<T> maxBy(Field<T> value, Field<?> by) {
        return new MaxBy<>(value, by);
    }

    /**
     * The <code>MEDIAN</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, H2, HSQLDB, MARIADB, POSTGRES, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> median(Field<? extends Number> field) {
        return new Median(field);
    }

    /**
     * The <code>MIN</code> function.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> min(Field<T> field) {
        return new Min<>(field, false);
    }

    /**
     * The <code>MIN_DISTINCT</code> function.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> minDistinct(Field<T> field) {
        return new Min<>(field, true);
    }

    /**
     * The <code>MIN_BY</code> function.
     * <p>
     * Evaluate <code>value</code> at the row having the minimum value for <code>by</code>.
     *
     * @param value The returned value.
     * @param by The expression to use to evaluate the minimum
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> OptionallyOrderedAggregateFunction<T> minBy(Field<T> value, Field<?> by) {
        return new MinBy<>(value, by);
    }

    /**
     * The <code>PRODUCT</code> function.
     * <p>
     * Get the sum over a numeric field: product(distinct field).
     * <p>
     * Few dialects currently support multiplicative aggregation natively. jOOQ
     * emulates this using <code>exp(sum(log(arg)))</code> for strictly positive
     * numbers, and does some additional handling for zero and negative numbers.
     * <p>
     * Note that this implementation may introduce rounding errors, even for
     * integer multiplication.
     * <p>
     * More information here: <a href=
     * "https://blog.jooq.org/how-to-write-a-multiplication-aggregate-function-in-sql">https://blog.jooq.org/how-to-write-a-multiplication-aggregate-function-in-sql</a>.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> product(Field<? extends Number> field) {
        return new Product(field, false);
    }

    /**
     * The <code>PRODUCT_DISTINCT</code> function.
     * <p>
     * Get the sum over a numeric field: product(distinct field).
     * <p>
     * Few dialects currently support multiplicative aggregation natively. jOOQ
     * emulates this using <code>exp(sum(log(arg)))</code> for strictly positive
     * numbers, and does some additional handling for zero and negative numbers.
     * <p>
     * Note that this implementation may introduce rounding errors, even for
     * integer multiplication.
     * <p>
     * More information here: <a href=
     * "https://blog.jooq.org/how-to-write-a-multiplication-aggregate-function-in-sql">https://blog.jooq.org/how-to-write-a-multiplication-aggregate-function-in-sql</a>.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> productDistinct(Field<? extends Number> field) {
        return new Product(field, true);
    }

    /**
     * The <code>RANK</code> function.
     * <p>
     * The <code>RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<Integer> rank(Field<?>... fields) {
        return new RankAgg(Arrays.asList(fields));
    }

    /**
     * The <code>RANK</code> function.
     * <p>
     * The <code>RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<Integer> rank(Collection<? extends Field<?>> fields) {
        return new RankAgg(new QueryPartList<>(fields));
    }

    /**
     * The <code>DENSE_RANK</code> function.
     * <p>
     * The <code>DENSE_RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<Integer> denseRank(Field<?>... fields) {
        return new DenseRankAgg(Arrays.asList(fields));
    }

    /**
     * The <code>DENSE_RANK</code> function.
     * <p>
     * The <code>DENSE_RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<Integer> denseRank(Collection<? extends Field<?>> fields) {
        return new DenseRankAgg(new QueryPartList<>(fields));
    }

    /**
     * The <code>PERCENT_RANK</code> function.
     * <p>
     * The <code>PERCENT_RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentRank(Field<?>... fields) {
        return new PercentRankAgg(Arrays.asList(fields));
    }

    /**
     * The <code>PERCENT_RANK</code> function.
     * <p>
     * The <code>PERCENT_RANK</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentRank(Collection<? extends Field<?>> fields) {
        return new PercentRankAgg(new QueryPartList<>(fields));
    }

    /**
     * The <code>CUME_DIST</code> function.
     * <p>
     * The <code>CUME_DIST</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> cumeDist(Field<?>... fields) {
        return new CumeDistAgg(Arrays.asList(fields));
    }

    /**
     * The <code>CUME_DIST</code> function.
     * <p>
     * The <code>CUME_DIST</code> hypothetical set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> cumeDist(Collection<? extends Field<?>> fields) {
        return new CumeDistAgg(new QueryPartList<>(fields));
    }

    /**
     * The <code>PERCENTILE_CONT</code> function.
     * <p>
     * Calculate the <code>PERCENTILE_CONT</code> inverse distribution aggregate function.
     *
     * @param percentile is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentileCont(Number percentile) {
        return new PercentileCont(Tools.field(percentile));
    }

    /**
     * The <code>PERCENTILE_CONT</code> function.
     * <p>
     * Calculate the <code>PERCENTILE_CONT</code> inverse distribution aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentileCont(Field<? extends Number> percentile) {
        return new PercentileCont(percentile);
    }

    /**
     * The <code>PERCENTILE_DISC</code> function.
     * <p>
     * Calculate the <code>PERCENTILE_DISC</code> inverse distribution aggregate function.
     *
     * @param percentile is wrapped as {@link DSL#val(Object)}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentileDisc(Number percentile) {
        return new PercentileDisc(Tools.field(percentile));
    }

    /**
     * The <code>PERCENTILE_DISC</code> function.
     * <p>
     * Calculate the <code>PERCENTILE_DISC</code> inverse distribution aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunction<BigDecimal> percentileDisc(Field<? extends Number> percentile) {
        return new PercentileDisc(percentile);
    }

    /**
     * The <code>REGR_AVGX</code> function.
     * <p>
     * Calculate the average of the independent values (x). This standard SQL function may
     * be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrAvgX(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrAvgX(y, x);
    }

    /**
     * The <code>REGR_AVGY</code> function.
     * <p>
     * Calculate the average of the dependent values (y). This standard SQL function may
     * be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrAvgY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrAvgY(y, x);
    }

    /**
     * The <code>REGR_COUNT</code> function.
     * <p>
     * Calculate the number of non-<code>NULL</code> pairs. This standard SQL function may
     * be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrCount(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrCount(y, x);
    }

    /**
     * The <code>REGR_INTERCEPT</code> function.
     * <p>
     * Calculate the y intercept of the regression line. This standard SQL function may
     * be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrIntercept(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrIntercept(y, x);
    }

    /**
     * The <code>REGR_R2</code> function.
     * <p>
     * Calculate the coefficient of determination. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> regrR2(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrR2(y, x);
    }

    /**
     * The <code>REGR_SLOPE</code> function.
     * <p>
     * Calculate the slope of the regression line. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSlope(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSlope(y, x);
    }

    /**
     * The <code>REGR_SXX</code> function.
     * <p>
     * Calculate the <code>REGR_SXX</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSXX(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSxx(y, x);
    }

    /**
     * The <code>REGR_SXY</code> function.
     * <p>
     * Calculate the <code>REGR_SXY</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSXY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSxy(y, x);
    }

    /**
     * The <code>REGR_SYY</code> function.
     * <p>
     * Calculate the <code>REGR_SYY</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSYY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSyy(y, x);
    }

    /**
     * The <code>STDDEV_POP</code> function.
     * <p>
     * Calculate the population standard deviation. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field) {
        return new StddevPop(field);
    }

    /**
     * The <code>STDDEV_SAMP</code> function.
     * <p>
     * Calculate the sample standard deviation. This standard SQL function may be supported
     * natively, or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field) {
        return new StddevSamp(field);
    }

    /**
     * The <code>SUM</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> sum(Field<? extends Number> field) {
        return new Sum(field, false);
    }

    /**
     * The <code>SUM_DISTINCT</code> function.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field) {
        return new Sum(field, true);
    }

    /**
     * The <code>VAR_POP</code> function.
     * <p>
     * Calculate the population variance. This standard SQL function may be supported natively,
     * or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> varPop(Field<? extends Number> field) {
        return new VarPop(field);
    }

    /**
     * The <code>VAR_SAMP</code> function.
     * <p>
     * Calculate the sample variance. This standard SQL function may be supported natively,
     * or emulated using {@link DSL#sum(Field)} and {@link DSL#count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO, YUGABYTEDB })
    public static AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field) {
        return new VarSamp(field);
    }



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































    /**
     * Get the rpad(field, length, character) function.
     *
     * @see #rpad(Field, Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> field, int length, char character) {
        return rpad(field, length, Character.toString(character));
    }

    /**
     * Get the lpad(field, length, character) function.
     *
     * @see #lpad(Field, Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> field, int length, char character) {
        return lpad(field, length, Character.toString(character));
    }

    /**
     * Convenience method for {@link #replace(Field, String, String)} to escape
     * data for use with {@link Field#like(Field, char)}.
     * <p>
     * Essentially, this escapes <code>%</code> and <code>_</code> characters
     *
     * @see #replace(Field, String, String)
     * @see Field#like(Field, char)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static String escape(String value, char escape) {
        String esc = "" + escape;
        return StringUtils.replace(
                   StringUtils.replace(
                       StringUtils.replace(value, esc, esc + esc), "%", esc + "%"
                   ), "_", esc + "_"
               );
    }

    /**
     * Convenience method for {@link #replace(Field, String, String)} to escape
     * data for use with {@link Field#like(Field, char)}.
     * <p>
     * Essentially, this escapes <code>%</code> and <code>_</code> characters
     *
     * @see #replace(Field, String, String)
     * @see Field#like(Field, char)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> escape(Field<String> field, char escape) {
        Field<String> replace = field;

        String esc = "" + escape;
        replace = replace(replace, inline(esc), inline(esc + esc));
        replace = replace(replace, inline("%"), inline(esc + "%"));
        replace = replace(replace, inline("_"), inline(esc + "_"));

        return replace;
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> regexpReplaceAll(Field<String> field, String pattern, String replacement) {
        return regexpReplaceAll(field, Tools.field(pattern), Tools.field(replacement));
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> regexpReplaceAll(Field<String> field, Field<String> pattern, Field<String> replacement) {
        return new RegexpReplace(field, Tools.nullSafe(pattern), Tools.nullSafe(replacement), true);
    }

    /**
     * Get the <code>REGEXP_REPLACE_FIRST</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> regexpReplaceFirst(Field<String> field, String pattern, String replacement) {
        return regexpReplaceFirst(field, Tools.field(pattern), Tools.field(replacement));
    }

    /**
     * Get the <code>REGEXP_REPLACE_FIRST</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<String> regexpReplaceFirst(Field<String> field, Field<String> pattern, Field<String> replacement) {
        return new RegexpReplace(field, Tools.nullSafe(pattern), Tools.nullSafe(replacement), false);
    }

    /**
     * Get the insert(in, startIndex, length, placing) function.
     */
    @NotNull
    @Support
    public static Field<String> insert(Field<String> in, Number startIndex, Number length, String placing) {
        return insert(Tools.nullSafe(in), Tools.field(startIndex), Tools.field(length), Tools.field(placing));
    }

    /**
     * Get the insert(in, startIndex, length, placing) function.
     */
    @NotNull
    @Support
    public static Field<String> insert(Field<String> in, Field<? extends Number> startIndex, Field<? extends Number> length, Field<String> placing) {
        return overlay(in, placing, startIndex, length);
    }

    /**
     * Get the <code>concat(field, value)</code> function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(Field<String> field, String value) {
        return concat(Tools.nullSafe(field), Tools.field(value));
    }

    /**
     * Get the <code>concat(value, field)</code> function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(String value, Field<String> field) {
        return concat(Tools.field(value), Tools.nullSafe(field));
    }

    /**
     * Get the concat(value[, value, ...]) function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(String... values) {
        return concat(Tools.fieldsArray(values));
    }

    /**
     * Get the concat(field[, field, ...]) function.
     * <p>
     * This creates <code>fields[0] || fields[1] || …</code> as an
     * expression, or <code>concat(fields[0], fields[1], …)</code>,
     * depending on the dialect.
     * <p>
     * If any of the given fields is not a {@link String} field, they are cast
     * to <code>Field&lt;String&gt;</code> first using {@link #cast(Object, Class)}
     */
    @NotNull
    @Support
    public static Field<String> concat(Field<?>... fields) {
        return new Concat(Tools.nullSafe(fields));
    }

    // ------------------------------------------------------------------------
    // XXX Date and time functions
    // ------------------------------------------------------------------------

    /**
     * Get the current_date() function returning a SQL standard
     * {@link SQLDataType#DATE} type.
     * <p>
     * Note, while there is a <code>CURRENT_DATE</code> function in
     * {@link SQLDialect#ORACLE}, that function returns a seconds-precision
     * {@link SQLDataType#TIMESTAMP}, which is undesired from a vendor
     * agnosticity perspective. This function thus produces an expression that
     * conforms to the SQL standard idea of a {@link SQLDataType#DATE} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> currentDate() {
        return new CurrentDate<>(DATE.notNull());
    }

    /**
     * Get the current_time() function returning a SQL standard
     * {@link SQLDataType#TIME} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Time> currentTime() {
        return new CurrentTime<>(TIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> currentTimestamp() {
        return new CurrentTimestamp<>(TIMESTAMP.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> currentTimestamp(int precision) {
        return currentTimestamp(Tools.field(precision));
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> currentTimestamp(Field<Integer> precision) {
        return new CurrentTimestamp<>(TIMESTAMP.notNull(), precision);
    }

    /**
     * Synonym for {@link #currentTimestamp()}.
     */
    @NotNull
    @Support
    public static Field<Timestamp> now() {
        return currentTimestamp();
    }

    /**
     * Synonym for {@link #currentTimestamp(Field)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> now(Field<Integer> precision) {
        return currentTimestamp(precision);
    }

    /**
     * Get the current_date() function returning a SQL standard
     * {@link SQLDataType#DATE} type.
     * <p>
     * Note, while there is a <code>CURRENT_DATE</code> function in
     * {@link SQLDialect#ORACLE}, that function returns a seconds-precision
     * {@link SQLDataType#TIMESTAMP}, which is undesired from a vendor
     * agnosticity perspective. This function thus produces an expression that
     * conforms to the SQL standard idea of a {@link SQLDataType#DATE} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> currentLocalDate() {
        return new CurrentDate<>(SQLDataType.LOCALDATE.notNull());
    }

    /**
     * Get the current_time() function returning a SQL standard
     * {@link SQLDataType#TIME} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalTime> currentLocalTime() {
        return new CurrentTime<>(SQLDataType.LOCALTIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> currentLocalDateTime() {
        return new CurrentTimestamp<>(SQLDataType.LOCALDATETIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<LocalDateTime> currentLocalDateTime(int precision) {
        return currentLocalDateTime(Tools.field(precision));
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<LocalDateTime> currentLocalDateTime(Field<Integer> precision) {
        return new CurrentTimestamp<>(SQLDataType.LOCALDATETIME.notNull(), precision);
    }

    /**
     * Get the current_time() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<OffsetTime> currentOffsetTime() {
        return currentTime().cast(SQLDataType.OFFSETTIME.notNull());
    }

    /**
     * Get the current_timestamp() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<OffsetDateTime> currentOffsetDateTime() {
        return currentTimestamp().cast(SQLDataType.OFFSETDATETIME.notNull());
    }

    /**
     * Get the current_timestamp() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Instant> currentInstant() {
        return currentTimestamp().cast(SQLDataType.INSTANT.notNull());
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Date endDate, Date startDate) {
        return dateDiff(Tools.field(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Field<Date> endDate, Date startDate) {
        return dateDiff(Tools.nullSafe(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Date endDate, Field<Date> startDate) {
        return dateDiff(Tools.field(endDate), Tools.nullSafe(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Field<Date> endDate, Field<Date> startDate) {
        return new DateDiff<>(null, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> dateDiff(DatePart part, Date startDate, Date endDate) {
        return dateDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> dateDiff(DatePart part, Field<Date> startDate, Date endDate) {
        return dateDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> dateDiff(DatePart part, Date startDate, Field<Date> endDate) {
        return dateDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static Field<Integer> dateDiff(DatePart part, Field<Date> startDate, Field<Date> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Number interval) {
        return dateSub(Tools.field(date), Tools.field(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateSub(Date date, Field<? extends Number> interval) {
        return dateSub(Tools.field(date), Tools.nullSafe(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateSub(Field<Date> date, Number interval) {
        return dateSub(Tools.nullSafe(date), Tools.field(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Field)
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Field<? extends Number> interval) {
        return Tools.nullSafe(date).sub(interval);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Number interval, DatePart datePart) {
        return dateSub(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Field<? extends Number> interval, DatePart datePart) {
        return dateSub(Tools.field(date), Tools.nullSafe(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Number interval, DatePart datePart) {
        return dateSub(Tools.nullSafe(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Number)
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp timestamp, Number interval) {
        return timestampSub(Tools.field(timestamp), Tools.field(interval));
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> timestamp, Field<? extends Number> interval) {
        return Tools.nullSafe(timestamp).sub(interval);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Timestamp timestamp1, Timestamp timestamp2) {
        return timestampDiff(Tools.field(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Field<Timestamp> timestamp1, Timestamp timestamp2) {
        return timestampDiff(Tools.nullSafe(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Timestamp timestamp1, Field<Timestamp> timestamp2) {
        return timestampDiff(Tools.field(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Field<Timestamp> timestamp1, Field<Timestamp> timestamp2) {
        return new TimestampDiff<>(Tools.nullSafe(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Timestamp startDate, Timestamp endDate) {
        return timestampDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Field<Timestamp> startDate, Timestamp endDate) {
        return timestampDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Timestamp startDate, Field<Timestamp> endDate) {
        return timestampDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Field<Timestamp> startDate, Field<Timestamp> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(LocalDate endDate, LocalDate startDate) {
        return localDateDiff(Tools.field(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(Field<LocalDate> endDate, LocalDate startDate) {
        return localDateDiff(Tools.nullSafe(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(LocalDate endDate, Field<LocalDate> startDate) {
        return localDateDiff(Tools.field(endDate), Tools.nullSafe(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(Field<LocalDate> endDate, Field<LocalDate> startDate) {
        return new DateDiff<>(null, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, LocalDate startDate, LocalDate endDate) {
        return localDateDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, Field<LocalDate> startDate, LocalDate endDate) {
        return localDateDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, LocalDate startDate, Field<LocalDate> endDate) {
        return localDateDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, Field<LocalDate> startDate, Field<LocalDate> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Number interval) {
        return localDateSub(Tools.field(date), Tools.field(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Field)
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Field<? extends Number> interval) {
        return Tools.nullSafe(date).sub(interval);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Number interval, DatePart datePart) {
        return localDateSub(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Field<? extends Number> interval, DatePart datePart) {
        return localDateSub(Tools.field(date), Tools.nullSafe(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Number interval, DatePart datePart) {
        return localDateSub(Tools.nullSafe(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Number)
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime timestamp, Number interval) {
        return localDateTimeSub(Tools.field(timestamp), Tools.field(interval));
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> timestamp, Field<? extends Number> interval) {
        return Tools.nullSafe(timestamp).sub(interval);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(LocalDateTime timestamp1, LocalDateTime timestamp2) {
        return localDateTimeDiff(Tools.field(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(Field<LocalDateTime> timestamp1, LocalDateTime timestamp2) {
        return localDateTimeDiff(Tools.nullSafe(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(LocalDateTime timestamp1, Field<LocalDateTime> timestamp2) {
        return localDateTimeDiff(Tools.field(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(Field<LocalDateTime> timestamp1, Field<LocalDateTime> timestamp2) {
        return new TimestampDiff<>(Tools.nullSafe(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, LocalDateTime startDate, LocalDateTime endDate) {
        return localDateTimeDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, Field<LocalDateTime> startDate, LocalDateTime endDate) {
        return localDateTimeDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, LocalDateTime startDate, Field<LocalDateTime> endDate) {
        return localDateTimeDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, Field<LocalDateTime> startDate, Field<LocalDateTime> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Truncate a date to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Date> trunc(Date date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Date> trunc(Date date, DatePart part) {
        return trunc(Tools.field(date), part);
    }

    /**
     * Truncate a date to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> trunc(LocalDate date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> trunc(LocalDate date, DatePart part) {
        return trunc(Tools.field(date), part);
    }

    /**
     * Truncate a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> trunc(Timestamp timestamp) {
        return trunc(timestamp, DatePart.DAY);
    }

    /**
     * Truncate a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> trunc(Timestamp timestamp, DatePart part) {
        return trunc(Tools.field(timestamp), part);
    }

    /**
     * Truncate a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> trunc(LocalDateTime timestamp) {
        return trunc(timestamp, DatePart.DAY);
    }

    /**
     * Truncate a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> trunc(LocalDateTime timestamp, DatePart part) {
        return trunc(Tools.field(timestamp), part);
    }

    /**
     * Truncate a date or a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> trunc(Field<T> date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date or a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> trunc(Field<T> date, DatePart part) {
        return new TruncDate<>(date, part);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(java.util.Date value, DatePart datePart) {
        return extract(Tools.field(Convert.convert(value, Timestamp.class)), datePart);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(Temporal value, DatePart datePart) {
        return extract(Tools.field(value), datePart);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(Field<?> field, DatePart datePart) {
        return new Extract(Tools.nullSafe(field), datePart);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(java.util.Date value) {
        return extract(value, DatePart.EPOCH);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(Temporal value) {
        return extract(value, DatePart.EPOCH);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(Field<?> field) {
        return extract(field, DatePart.EPOCH);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(java.util.Date value) {
        return extract(value, DatePart.MILLENNIUM);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(Temporal value) {
        return extract(value, DatePart.MILLENNIUM);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(Field<?> field) {
        return extract(field, DatePart.MILLENNIUM);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(java.util.Date value) {
        return extract(value, DatePart.CENTURY);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(Temporal value) {
        return extract(value, DatePart.CENTURY);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(Field<?> field) {
        return extract(field, DatePart.CENTURY);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(java.util.Date value) {
        return extract(value, DatePart.DECADE);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(Temporal value) {
        return extract(value, DatePart.DECADE);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(Field<?> field) {
        return extract(field, DatePart.DECADE);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(java.util.Date value) {
        return extract(value, DatePart.QUARTER);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(Temporal value) {
        return extract(value, DatePart.QUARTER);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(Field<?> field) {
        return extract(field, DatePart.QUARTER);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(java.util.Date value) {
        return extract(value, DatePart.YEAR);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(Temporal value) {
        return extract(value, DatePart.YEAR);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(Field<?> field) {
        return extract(field, DatePart.YEAR);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(java.util.Date value) {
        return extract(value, DatePart.MONTH);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(Temporal value) {
        return extract(value, DatePart.MONTH);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(Field<?> field) {
        return extract(field, DatePart.MONTH);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(java.util.Date value) {
        return extract(value, DatePart.WEEK);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(Temporal value) {
        return extract(value, DatePart.WEEK);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(Field<?> field) {
        return extract(field, DatePart.WEEK);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(java.util.Date value) {
        return extract(value, DatePart.DAY);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(Temporal value) {
        return extract(value, DatePart.DAY);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(Field<?> field) {
        return extract(field, DatePart.DAY);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(java.util.Date value) {
        return extract(value, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(Temporal value) {
        return extract(value, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(Field<?> field) {
        return extract(field, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(java.util.Date value) {
        return extract(value, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(Temporal value) {
        return extract(value, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(Field<?> field) {
        return extract(field, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(java.util.Date value) {
        return extract(value, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(Temporal value) {
        return extract(value, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(Field<?> field) {
        return extract(field, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(java.util.Date value) {
        return extract(value, DatePart.HOUR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(Temporal value) {
        return extract(value, DatePart.HOUR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(Field<?> field) {
        return extract(field, DatePart.HOUR);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(java.util.Date value) {
        return extract(value, DatePart.MINUTE);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(Temporal value) {
        return extract(value, DatePart.MINUTE);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(Field<?> field) {
        return extract(field, DatePart.MINUTE);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(java.util.Date value) {
        return extract(value, DatePart.SECOND);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(Temporal value) {
        return extract(value, DatePart.SECOND);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(Field<?> field) {
        return extract(field, DatePart.SECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(java.util.Date value) {
        return extract(value, DatePart.MILLISECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(Temporal value) {
        return extract(value, DatePart.MILLISECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(Field<?> field) {
        return extract(field, DatePart.MILLISECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(java.util.Date value) {
        return extract(value, DatePart.MICROSECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(Temporal value) {
        return extract(value, DatePart.MICROSECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(Field<?> field) {
        return extract(field, DatePart.MICROSECOND);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(Temporal value) {
        return extract(value, DatePart.TIMEZONE);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(Field<?> field) {
        return extract(field, DatePart.TIMEZONE);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(Temporal value) {
        return extract(value, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(Field<?> field) {
        return extract(field, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(Temporal value) {
        return extract(value, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(Field<?> field) {
        return extract(field, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Convert a string value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(String value) {
        return Tools.field(Convert.convert(value, Date.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(java.util.Date value) {
        return Tools.field(Convert.convert(value, Date.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.DATE);
    }

    /**
     * Convert a string value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(String value) {
        return Tools.field(Convert.convert(value, Time.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(java.util.Date value) {
        return Tools.field(Convert.convert(value, Time.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.TIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(String value) {
        return Tools.field(Convert.convert(value, Timestamp.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(java.util.Date value) {
        return Tools.field(Convert.convert(value, Timestamp.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.TIMESTAMP);
    }

    /**
     * Convert a string value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(String value) {
        return Tools.field(Convert.convert(value, LocalDate.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(LocalDate value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(Field<LocalDate> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALDATE);
    }

    /**
     * Convert a string value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(String value) {
        return Tools.field(Convert.convert(value, LocalTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(LocalTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(Field<LocalTime> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALTIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(String value) {
        return Tools.field(Convert.convert(value, LocalDateTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(LocalDateTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(Field<LocalDateTime> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALDATETIME);
    }

    /**
     * Convert a string value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(String value) {
        return Tools.field(Convert.convert(value, OffsetTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(OffsetTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(Field<OffsetTime> field) {
        return new DateOrTime<>(field, SQLDataType.OFFSETTIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(String value) {
        return Tools.field(Convert.convert(value, OffsetDateTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(OffsetDateTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(Field<OffsetDateTime> field) {
        return new DateOrTime<>(field, SQLDataType.OFFSETDATETIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(String value) {
        return Tools.field(Convert.convert(value, Instant.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(Instant value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(Field<Instant> field) {
        return new DateOrTime<>(field, SQLDataType.INSTANT);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(String value, String format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(String value, Field<String> format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(Field<String> value, String format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(Field<String> value, Field<String> format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(String value, String format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(String value, Field<String> format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(Field<String> value, String format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(Field<String> value, Field<String> format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    // ------------------------------------------------------------------------
    // XXX Construction of GROUPING SET functions
    // ------------------------------------------------------------------------

    /**
     * Create a GROUPING SETS(field1, field2, .., fieldn) grouping field where
     * each grouping set only consists of a single field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support
    public static GroupField emptyGroupingSet() {
        return EmptyGroupingSet.INSTANCE;
    }

    /**
     * Create a ROLLUP(field1, field2, .., fieldn) grouping field.
     *
     * @see #rollup(FieldOrRow...)
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO })
    public static GroupField rollup(Field<?>... fields) {
        return rollup((FieldOrRow[]) Tools.nullSafe(fields));
    }

    /**
     * Create a ROLLUP(field1, field2, .., fieldn) grouping field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>ROLLUP</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, MARIADB, MYSQL, POSTGRES, TRINO })
    public static GroupField rollup(FieldOrRow... fields) {
        return new Rollup(fields);
    }

    /**
     * Create a CUBE(field1, field2, .., fieldn) grouping field.
     *
     * @see #cube(Field...)
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, POSTGRES, TRINO })
    public static GroupField cube(Field<?>... fields) {
        return cube((FieldOrRow[]) Tools.nullSafe(fields));
    }

    /**
     * Create a CUBE(field1, field2, .., fieldn) grouping field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>CUBE</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, POSTGRES, TRINO })
    public static GroupField cube(FieldOrRow... fields) {
        return new Cube(fields);
    }

    /**
     * Create a GROUPING SETS(field1, field2, .., fieldn) grouping field where
     * each grouping set only consists of a single field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, POSTGRES, TRINO })
    public static GroupField groupingSets(Field<?>... fields) {
        List<Field<?>>[] array = map(fields, f -> asList(f), List[]::new);
        return groupingSets(array);
    }

    /**
     * Create a GROUPING SETS((field1a, field1b), (field2a), .., (fieldna,
     * fieldnb)) grouping field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fieldSets The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, POSTGRES, TRINO })
    public static GroupField groupingSets(Field<?>[]... fieldSets) {
        List<Field<?>>[] array = map(fieldSets, f -> asList(f), List[]::new);
        return groupingSets(array);
    }

    /**
     * Create a GROUPING SETS((field1a, field1b), (field2a), .., (fieldna,
     * fieldnb)) grouping field.
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fieldSets The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, POSTGRES, TRINO })
    @SafeVarargs
    public static GroupField groupingSets(Collection<? extends Field<?>>... fieldSets) {
        return new GroupingSets(fieldSets);
    }





































    /**
     * Create a GROUPING(field) aggregation field to be used along with
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * groupings.
     *
     * @param field The function argument
     * @return The <code>GROUPING</code> aggregation field
     * @see #cube(Field...)
     * @see #rollup(Field...)
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MYSQL, POSTGRES, TRINO })
    public static Field<Integer> grouping(Field<?> field) {
        return function("grouping", INTEGER, field);
    }

    // ------------------------------------------------------------------------
    // XXX Mathematical functions
    // ------------------------------------------------------------------------

    /**
     * Find the greatest among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     *
     * @see #greatest(Field, Field...)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> greatest(T value, T... values) {
        return greatest(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * Find the greatest among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> greatest(Field<T> field, Field<?>... others) {
        return new Greatest<>(Tools.nullSafe(combine(field, others)));
    }

    /**
     * Find the least among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     *
     * @see #least(Field, Field...)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> least(T value, T... values) {
        return least(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * Find the least among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> least(Field<T> field, Field<?>... others) {
        return new Least<>(Tools.nullSafe(combine(field, others)));
    }

    /**
     * Negate a field to get its negative value.
     *
     * @see Field#neg()
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> neg(Field<T> field) {
        return field.neg();
    }

    /**
     * Negate a field to get its negative value.
     *
     * @see Field#neg()
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> minus(Field<T> field) {
        return field.neg();
    }

    /**
     * Truncate a number to a given number of decimals.
     *
     * @see #trunc(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(T number) {
        return trunc(Tools.field(number), inline(0));
    }

    // -------------------------------------------------------------------------
    // XXX XML functions
    // -------------------------------------------------------------------------

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseDocument(String content) {
        return xmlparseDocument(Tools.field(content));
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseDocument(Field<String> content) {
        return new XMLParse(content, DocumentOrContent.DOCUMENT);
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseContent(String content) {
        return xmlparseContent(Tools.field(content));
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseContent(Field<String> content) {
        return new XMLParse(content, DocumentOrContent.CONTENT);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, Field<?>... content) {
        return xmlelement(name(name), (XMLAttributes) null, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, Collection<? extends Field<?>> content) {
        return xmlelement(name(name), (XMLAttributes) null, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, Field<?>... content) {
        return xmlelement(name, (XMLAttributes) null, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, Collection<? extends Field<?>> content) {
        return xmlelement(name, (XMLAttributes) null, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, XMLAttributes attributes, Field<?>... content) {
        return xmlelement(name(name), attributes, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, XMLAttributes attributes, Collection<? extends Field<?>> content) {
        return xmlelement(name(name), attributes, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, XMLAttributes attributes, Field<?>... content) {
        return xmlelement(name, attributes, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, XMLAttributes attributes, Collection<? extends Field<?>> content) {
        return new XMLElement(name, attributes, content);
    }

    /**
     * The XML attributes constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAttributes xmlattributes(Field<?>... attributes) {
        return xmlattributes(asList(attributes));
    }

    /**
     * The XML attributes constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAttributes xmlattributes(Collection<? extends Field<?>> attributes) {
        return new XMLAttributesImpl(attributes);
    }

    /**
     * The XML aggregate function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAggOrderByStep<XML> xmlagg(Field<XML> field) {
        return new XMLAgg(field);
    }

    /**
     * The XML query function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLQueryPassingStep xmlquery(String xpath) {
        return xmlquery(Tools.field(xpath));
    }

    /**
     * The XML query function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLQueryPassingStep xmlquery(Field<String> xpath) {
        return new XMLQuery(xpath);
    }

    /**
     * The XML exists function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLExistsPassingStep xmlexists(String xpath) {
        return xmlexists(Tools.field(xpath));
    }

    /**
     * The XML exists function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLExistsPassingStep xmlexists(Field<String> xpath) {
        return new XMLExists(xpath);
    }

    /**
     * The XML table function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLTablePassingStep xmltable(String xpath) {
        return xmltable(Tools.field(xpath));
    }

    /**
     * The XML table function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLTablePassingStep xmltable(Field<String> xpath) {
        return new XMLTable(xpath);
    }

    // -------------------------------------------------------------------------
    // XXX JSON functions
    // -------------------------------------------------------------------------

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONValueOnStep<JSON> jsonValue(Field<JSON> json, String path) {
        return jsonValue(json, Tools.field(path));
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONValueOnStep<JSON> jsonValue(Field<JSON> json, Field<String> path) {
        return new JSONValue<>(SQLDataType.JSON, json, path, null);
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONValueOnStep<JSONB> jsonbValue(Field<JSONB> json, String path) {
        return jsonbValue(json, Tools.field(path));
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONValueOnStep<JSONB> jsonbValue(Field<JSONB> json, Field<String> path) {
        return new JSONValue<>(SQLDataType.JSONB, json, path, null);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONEntryValueStep key(String key) {
        return key(Tools.field(key));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(Field, Field)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONEntryValueStep key(Field<String> key) {
        return new JSONEntryImpl<>(key);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(Field<T> value) {
        return jsonEntry(value.getName(), value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(String key, T value) {
        return jsonEntry(Tools.field(key), Tools.field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(String key, Field<T> value) {
        return jsonEntry(Tools.field(key), value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(String key, Select<? extends Record1<T>> value) {
        return jsonEntry(Tools.field(key), field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, T value) {
        return jsonEntry(key, Tools.field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, Field<T> value) {
        return new JSONEntryImpl<>(key, value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, Select<? extends Record1<T>> value) {
        return jsonEntry(key, field(value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject(String key, Field<?> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject(Field<String> key, Field<?> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject(Field<String> key, Select<? extends Record1<?>> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     *
     * @deprecated - [#15196] - 3.19.0 - The semantics of the {@link Field}
     *             arguments in this method is inconsistent with that of other
     *             overloads, such as {@link #jsonbObject(Field, Field)}, which
     *             can lead to subtle bugs. Please refrain from using this
     *             overload as it will be removed in the future. Use
     *             {@link #jsonObject(JSONEntry...)} instead.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    @Deprecated(forRemoval = true, since = "3.19")
    public static JSONObjectNullStep<JSON> jsonObject(Field<?>... entries) {
        return new JSONObject(SQLDataType.JSON, Tools.jsonEntries(entries));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject(String key, Field<?> value) {
        return jsonbObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject(Field<String> key, Field<?> value) {
        return jsonbObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject(Field<String> key, Select<? extends Record1<?>> value) {
        return jsonbObject(jsonEntry(key, value));
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     *
     * @deprecated - [#15196] - 3.19.0 - The semantics of the {@link Field}
     *             arguments in this method is inconsistent with that of other
     *             overloads, such as {@link #jsonbObject(Field, Field)}, which
     *             can lead to subtle bugs. Please refrain from using this
     *             overload as it will be removed in the future. Use
     *             {@link #jsonObject(JSONEntry...)} instead.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    @Deprecated(forRemoval = true, since = "3.19")
    public static JSONObjectNullStep<JSONB> jsonbObject(Field<?>... entries) {
        return new JSONObject(SQLDataType.JSONB, Tools.jsonEntries(entries));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSON> jsonObject() {
        return jsonObject(Tools.EMPTY_JSONENTRY);
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectNullStep<JSONB> jsonbObject() {
        return jsonbObject(Tools.EMPTY_JSONENTRY);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayAggOrderByStep<JSON> jsonArrayAgg(Field<?> value) {
        return new JSONArrayAgg<>(JSON, value, false);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayAggOrderByStep<JSONB> jsonbArrayAgg(Field<?> value) {
        return new JSONArrayAgg<>(JSONB, value, false);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, SQLITE, TRINO })
    public static JSONArrayAggOrderByStep<JSON> jsonArrayAggDistinct(Field<?> value) {
        return new JSONArrayAgg<>(JSON, value, true);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONArrayAggOrderByStep<JSONB> jsonbArrayAggDistinct(Field<?> value) {
        return new JSONArrayAgg<>(JSONB, value, true);
    }

    /**
     * The JSON object aggregate function.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(Field<?> value) {
        return jsonObjectAgg(jsonEntry(value));
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(String key, Field<?> value) {
        return jsonObjectAgg(Tools.field(key), value);
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(Field<String> key, Field<?> value) {
        return jsonObjectAgg(jsonEntry(key, value));
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(JSONEntry<?> entry) {
        return new JSONObjectAgg<>(JSON, entry);
    }

    /**
     * The JSONB object aggregate function.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(Field<?> field) {
        return jsonbObjectAgg(jsonEntry(field));
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(String key, Field<?> value) {
        return jsonbObjectAgg(Tools.field(key), value);
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(Field<String> key, Field<?> value) {
        return jsonbObjectAgg(jsonEntry(key, value));
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(JSONEntry<?> entry) {
        return new JSONObjectAgg<>(JSONB, entry);
    }

    /**
     * The JSON exists predicate.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static JSONExistsOnStep jsonExists(Field<JSON> field, String path) {
        return jsonExists(field, Tools.field(path));
    }

    /**
     * The JSON exists predicate.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONExistsOnStep jsonExists(Field<JSON> field, Field<String> path) {
        return new JSONExists(field, Tools.nullSafe(path));
    }

    /**
     * The JSONB exists predicate.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONExistsOnStep jsonbExists(Field<JSONB> field, String path) {
        return jsonbExists(field, Tools.field(path));
    }

    /**
     * The JSONB exists predicate.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static JSONExistsOnStep jsonbExists(Field<JSONB> field, Field<String> path) {
        return new JSONExists(field, Tools.nullSafe(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static JSONTableColumnsFirstStep jsonTable(JSON json, String path) {
        return jsonTable(Tools.field(json), Tools.field(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static JSONTableColumnsFirstStep jsonTable(Field<JSON> json, Field<String> path) {
        return new JSONTable(Tools.nullSafe(json), Tools.nullSafe(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static JSONTableColumnsFirstStep jsonbTable(JSONB json, String path) {
        return jsonbTable(Tools.field(json), Tools.field(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES, YUGABYTEDB })
    public static JSONTableColumnsFirstStep jsonbTable(Field<JSONB> json, Field<String> path) {
        return new JSONTable(Tools.nullSafe(json), Tools.nullSafe(path));
    }

    // -------------------------------------------------------------------------
    // XXX Array functions
    // -------------------------------------------------------------------------

    /**
     * Create an array literal.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> array(T... values) {
        return array(Tools.fields(values));
    }

    /**
     * Create an array literal.
     */
    @SafeVarargs
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> array(Field<T>... fields) {
        return array(Arrays.asList(fields));
    }

    /**
     * Create an array literal.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> Field<T[]> array(Collection<? extends Field<T>> fields) {
        return new Array<>(fields);
    }

    /**
     * The PostgreSQL <code>array(select)</code> function.
     * <p>
     * Example: <pre><code>
     * {1, 2, 3} = array(select 1 union select 2 union select 3)
     * </code></pre>
     */
    @NotNull
    @Support({ DUCKDB, H2, HSQLDB, POSTGRES, YUGABYTEDB })
    public static <T> Field<T[]> array(Select<? extends Record1<T>> select) {
        return new ArrayQuery<>(select);
    }

    /**
     * Get the <code>MULTISET</code> operator to nest subqueries.
     * <p>
     * The standard SQL <code>MULTISET</code> operator is emulated using
     * elaborate mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * An important limitation is that correlating <code>MULTISET</code>
     * subqueries currently only fully works on dialects that support
     * correlating derived tables. This excludes:
     * <ul>
     * <li>{@link SQLDialect#DB2}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#MARIADB}</li>
     * <li>{@link SQLDialect#MYSQL_5_7}</li>
     * </ul>
     * <p>
     * On the above dialects, a simplified emulation is implemented, which does
     * not support the following inside of <code>MULTISET</code>:
     * <ul>
     * <li><code>SELECT DISTINCT</code></li>
     * <li>Aggregate functions</li>
     * <li>Window functions</li>
     * <li><code>GROUP BY</code></li>
     * <li><code>HAVING</code></li>
     * <li><code>WINDOW</code></li>
     * <li><code>QUALIFY</code></li>
     * <li><code>OFFSET</code></li>
     * <li><code>LIMIT</code></li>
     * <li><code>UNION</code> and other set operations</li>
     * </ul>
     * <p>
     * See also <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12045">https://github.com/jOOQ/jOOQ/issues/12045</a>.
     * The various {@link #multisetAgg(Field...)} overloads are not affected
     * from this limitation.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <R extends Record> Field<Result<R>> multiset(TableLike<R> table) {
        return new Multiset<>(table);
    }

    // -------------------------------------------------------------------------
    // XXX Aggregate functions
    // -------------------------------------------------------------------------

    /**
     * Get the count(*) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count() {
        return new Count(false);
    }

    /**
     * Get the count(field) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(SelectFieldOrAsterisk field) {
        return count(field instanceof Field<?> f ? f : field("{0}", field));
    }

    /**
     * Get the count(table) function.
     * <p>
     * If this is not supported by a given database (i.e. non
     * {@link SQLDialect#POSTGRES}, then the primary key is used with
     * {@link #count(Field)}, instead.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(Table<?> table) {
        return new CountTable(table, false);
    }

    /**
     * Get the count(distinct field) function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static AggregateFunction<Integer> countDistinct(SelectFieldOrAsterisk field) {
        return countDistinct(field instanceof Field<?> f ? f : field("{0}", field));
    }

    /**
     * Get the count(distinct table) function.
     * <p>
     * If this is not supported by a given database (i.e. non
     * {@link SQLDialect#POSTGRES}, then the primary key is used with
     * {@link #count(Field)}, instead.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static AggregateFunction<Integer> countDistinct(Table<?> table) {
        return new CountTable(table, true);
    }

    /**
     * Get the count(distinct field1, field2) function.
     * <p>
     * Some dialects support several expressions in the
     * <code>COUNT(DISTINCT expr1, expr2)</code> aggregate function.
     * <p>
     * {@link SQLDialect#POSTGRES} supports this as
     * <code>COUNT(DISTINCT(expr1, expr2))</code>.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<Integer> countDistinct(Field<?>... fields) {
        fields = Tools.nullSafe(fields);
        return fields.length == 0 ? countDistinct(asterisk()) : new DefaultAggregateFunction<>(true, N_COUNT, SQLDataType.INTEGER, fields);
    }

    /**
     * Get the <code>array_agg()</code> aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> ArrayAggOrderByStep<T[]> arrayAgg(Field<T> field) {
        return new ArrayAgg(false, Tools.nullSafe(field));
    }

    /**
     * Get the <code>array_agg()</code> aggregate function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, H2, HSQLDB, POSTGRES, TRINO, YUGABYTEDB })
    public static <T> ArrayAggOrderByStep<T[]> arrayAggDistinct(Field<T> field) {
        return new ArrayAgg(true, Tools.nullSafe(field));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static ArrayAggOrderByStep<Result<Record>> multisetAgg(Collection<? extends SelectField<?>> fields) {
        return new MultisetAgg<>(false, row(fields));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static ArrayAggOrderByStep<Result<Record>> multisetAgg(SelectField<?>... fields) {
        return new MultisetAgg<>(false, row(fields));
    }

    /**
     * @see #multisetAgg(SelectField...)
     */
    @Obsolete
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static ArrayAggOrderByStep<Result<Record>> multisetAgg(Field<?>... fields) {
        return new MultisetAgg<>(false, row(fields));
    }



    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1> ArrayAggOrderByStep<Result<Record1<T1>>> multisetAgg(SelectField<T1> field1) {
        return new MultisetAgg<>(false, row(field1));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2> ArrayAggOrderByStep<Result<Record2<T1, T2>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2) {
        return new MultisetAgg<>(false, row(field1, field2));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3> ArrayAggOrderByStep<Result<Record3<T1, T2, T3>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return new MultisetAgg<>(false, row(field1, field2, field3));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4> ArrayAggOrderByStep<Result<Record4<T1, T2, T3, T4>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5> ArrayAggOrderByStep<Result<Record5<T1, T2, T3, T4, T5>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6> ArrayAggOrderByStep<Result<Record6<T1, T2, T3, T4, T5, T6>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7> ArrayAggOrderByStep<Result<Record7<T1, T2, T3, T4, T5, T6, T7>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8> ArrayAggOrderByStep<Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> ArrayAggOrderByStep<Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ArrayAggOrderByStep<Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ArrayAggOrderByStep<Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ArrayAggOrderByStep<Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ArrayAggOrderByStep<Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ArrayAggOrderByStep<Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ArrayAggOrderByStep<Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ArrayAggOrderByStep<Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ArrayAggOrderByStep<Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ArrayAggOrderByStep<Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ArrayAggOrderByStep<Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ArrayAggOrderByStep<Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ArrayAggOrderByStep<Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ArrayAggOrderByStep<Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22));
    }



    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static ArrayAggOrderByStep<Result<Record>> multisetAggDistinct(Collection<? extends Field<?>> fields) {
        return new MultisetAgg<>(true, row(fields));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE, YUGABYTEDB })
    public static ArrayAggOrderByStep<Result<Record>> multisetAggDistinct(Field<?>... fields) {
        return new MultisetAgg<>(true, row(fields));
    }



    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1> ArrayAggOrderByStep<Result<Record1<T1>>> multisetAggDistinct(SelectField<T1> field1) {
        return new MultisetAgg<>(true, row(field1));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2> ArrayAggOrderByStep<Result<Record2<T1, T2>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2) {
        return new MultisetAgg<>(true, row(field1, field2));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3> ArrayAggOrderByStep<Result<Record3<T1, T2, T3>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return new MultisetAgg<>(true, row(field1, field2, field3));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4> ArrayAggOrderByStep<Result<Record4<T1, T2, T3, T4>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5> ArrayAggOrderByStep<Result<Record5<T1, T2, T3, T4, T5>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6> ArrayAggOrderByStep<Result<Record6<T1, T2, T3, T4, T5, T6>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7> ArrayAggOrderByStep<Result<Record7<T1, T2, T3, T4, T5, T6, T7>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8> ArrayAggOrderByStep<Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> ArrayAggOrderByStep<Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ArrayAggOrderByStep<Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ArrayAggOrderByStep<Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ArrayAggOrderByStep<Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ArrayAggOrderByStep<Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ArrayAggOrderByStep<Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ArrayAggOrderByStep<Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ArrayAggOrderByStep<Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ArrayAggOrderByStep<Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ArrayAggOrderByStep<Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ArrayAggOrderByStep<Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ArrayAggOrderByStep<Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ArrayAggOrderByStep<Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21));
    }

    /**
     * Get the <code>MULTISET_AGG(DISTINCT)</code> aggregate function to nest group
     * contents.
     * <p>
     * This synthetic, non-standard aggregate function works in a similar way as
     * the standard SQL <code>ARRAY_AGG</code> aggregate function. It is
     * emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAggDistinct(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAggDistinct(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * Note that unlike <code>MULTISET_AGG</code>, this depends on whether the
     * underlying emulation supports the <code>DISTINCT</code> clause.
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     */
    @NotNull
    @Support({ DUCKDB, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ArrayAggOrderByStep<Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>>> multisetAggDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return new MultisetAgg<>(true, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22));
    }

















































































    /**
     * The <code>mode(field)</code> aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES })
    public static <T> AggregateFunction<T> mode(Field<T> field) {
        return new Mode(Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static OrderedAggregateFunction<String> listAgg(Field<?> field) {
        return new ListAgg(false, Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static OrderedAggregateFunction<String> listAgg(Field<?> field, String separator) {
        return listAgg(field, inline(separator));
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO })
    public static OrderedAggregateFunction<String> listAgg(Field<?> field, Field<String> separator) {
        return new ListAgg(false, Tools.nullSafe(field), separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static OrderedAggregateFunction<String> listAggDistinct(Field<?> field) {
        return new ListAgg(true, Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> listAggDistinct(Field<?> field, String separator) {
        return listAggDistinct(field, inline(separator));
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> listAggDistinct(Field<?> field, Field<String> separator) {
        return new ListAgg(true, Tools.nullSafe(field), separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAgg(Field<?> field) {
        return new BinaryListAgg(false, Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAgg(Field<?> field, byte[] separator) {
        return binaryListAgg(field, inline(separator));
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAgg(Field<?> field, Field<byte[]> separator) {
        return new BinaryListAgg(false, Tools.nullSafe(field), separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAggDistinct(Field<?> field) {
        return new BinaryListAgg(true, Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAggDistinct(Field<?> field, byte[] separator) {
        return binaryListAggDistinct(field, inline(separator));
    }

    /**
     * Get the aggregated concatenation for a field.
     */
    @NotNull
    @Support({ POSTGRES })
    public static OrderedAggregateFunction<byte[]> binaryListAggDistinct(Field<?> field, Field<byte[]> separator) {
        return new BinaryListAgg(true, Tools.nullSafe(field), separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static OrderedAggregateFunction<String> stringAgg(Field<?> field) {
        return listAgg(field);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static OrderedAggregateFunction<String> stringAgg(Field<?> field, String separator) {
        return listAgg(field, separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, TRINO })
    public static OrderedAggregateFunction<String> stringAgg(Field<?> field, Field<String> separator) {
        return listAgg(field, separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static OrderedAggregateFunction<String> stringAggDistinct(Field<?> field) {
        return listAggDistinct(field);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> stringAggDistinct(Field<?> field, String separator) {
        return listAggDistinct(field, separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     *
     * @see #groupConcatDistinct(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> stringAggDistinct(Field<?> field, Field<String> separator) {
        return listAggDistinct(field, separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#MEMSQL} (but without <code>ORDER BY</code>)</li>
     * <li> {@link SQLDialect#MYSQL}</li>
     * <li> {@link SQLDialect#SQLITE} (but without <code>ORDER BY</code>)</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li> {@link SQLDialect#ORACLE}: Using <code>LISTAGG()</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static GroupConcatOrderByStep groupConcat(Field<?> field) {
        return new GroupConcat(Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li>{@link SQLDialect#AURORA_MYSQL}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#HSQLDB}</li>
     * <li>{@link SQLDialect#MEMSQL}</li>
     * <li>{@link SQLDialect#MYSQL}</li>
     * <li>{@link SQLDialect#SQLITE}</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li>{@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li>{@link SQLDialect#ORACLE}: Using <code>LISTAGG()</code></li>
     * <li>{@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li>{@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     * @deprecated - [#7956] - 3.12.0 - Use {@link #groupConcat(Field)} and
     *             {@link GroupConcatSeparatorStep#separator(String)} instead.
     */
    @Deprecated(forRemoval = true, since = "3.12")
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO })
    public static AggregateFunction<String> groupConcat(Field<?> field, String separator) {
        return new GroupConcat(Tools.nullSafe(field)).separator(separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#MYSQL}</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static GroupConcatOrderByStep groupConcatDistinct(Field<?> field) {
        return new GroupConcat(Tools.nullSafe(field), true);
    }

    // -------------------------------------------------------------------------
    // XXX Ordered-set aggregate functions and hypothetical set functions
    // -------------------------------------------------------------------------

    /**
     * The <code>mode() within group (oder by [order clause])</code> ordered
     * aggregate function.
     */
    @NotNull
    @Support({ DUCKDB, H2, POSTGRES, YUGABYTEDB })
    public static OrderedAggregateFunctionOfDeferredType mode() {
        return new ModeDeferred();
    }

    // -------------------------------------------------------------------------
    // XXX Window clauses
    // -------------------------------------------------------------------------

    /**
     * Create a {@link WindowSpecification} with a <code>PARTITION BY</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationOrderByStep partitionBy(GroupField... fields) {
        return new WindowSpecificationImpl().partitionBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>PARTITION BY</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationOrderByStep partitionBy(Collection<? extends GroupField> fields) {
        return new WindowSpecificationImpl().partitionBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsStep orderBy(Field<?>... fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsStep orderBy(OrderField<?>... fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsStep orderBy(Collection<? extends OrderField<?>> fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rowsUnboundedPreceding() {
        return new WindowSpecificationImpl().rowsUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rowsPreceding(int number) {
        return new WindowSpecificationImpl().rowsPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rowsCurrentRow() {
        return new WindowSpecificationImpl().rowsCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rowsUnboundedFollowing() {
        return new WindowSpecificationImpl().rowsUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rowsFollowing(int number) {
        return new WindowSpecificationImpl().rowsFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rowsBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().rowsBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rowsBetweenPreceding(int number) {
        return new WindowSpecificationImpl().rowsBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rowsBetweenCurrentRow() {
        return new WindowSpecificationImpl().rowsBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rowsBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().rowsBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rowsBetweenFollowing(int number) {
        return new WindowSpecificationImpl().rowsBetweenFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rangeUnboundedPreceding() {
        return new WindowSpecificationImpl().rangeUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rangePreceding(int number) {
        return new WindowSpecificationImpl().rangePreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rangeCurrentRow() {
        return new WindowSpecificationImpl().rangeCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rangeUnboundedFollowing() {
        return new WindowSpecificationImpl().rangeUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep rangeFollowing(int number) {
        return new WindowSpecificationImpl().rangeFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rangeBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().rangeBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rangeBetweenPreceding(int number) {
        return new WindowSpecificationImpl().rangeBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rangeBetweenCurrentRow() {
        return new WindowSpecificationImpl().rangeBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rangeBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().rangeBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep rangeBetweenFollowing(int number) {
        return new WindowSpecificationImpl().rangeBetweenFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep groupsUnboundedPreceding() {
        return new WindowSpecificationImpl().groupsUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep groupsPreceding(int number) {
        return new WindowSpecificationImpl().groupsPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep groupsCurrentRow() {
        return new WindowSpecificationImpl().groupsCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep groupsUnboundedFollowing() {
        return new WindowSpecificationImpl().groupsUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationExcludeStep groupsFollowing(int number) {
        return new WindowSpecificationImpl().groupsFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep groupsBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().groupsBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep groupsBetweenPreceding(int number) {
        return new WindowSpecificationImpl().groupsBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep groupsBetweenCurrentRow() {
        return new WindowSpecificationImpl().groupsBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep groupsBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().groupsBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowSpecificationRowsAndStep groupsBetweenFollowing(int number) {
        return new WindowSpecificationImpl().groupsBetweenFollowing(number);
    }

    // -------------------------------------------------------------------------
    // XXX Window functions
    // -------------------------------------------------------------------------

    /**
     * The <code>row_number() over ([analytic clause])</code> function.
     * <p>
     * Newer versions of {@link SQLDialect#DERBY} and {@link SQLDialect#H2} also
     * support the <code>ROW_NUMBER() OVER()</code> window function without any
     * window clause. See the respective docs for details.
     * {@link SQLDialect#HSQLDB} can emulate this function using
     * <code>ROWNUM()</code>
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DERBY, DUCKDB, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<Integer> rowNumber() {
        return new RowNumber();
    }

    /**
     * The <code>rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<Integer> rank() {
        return new Rank();
    }

    /**
     * The <code>dense_rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<Integer> denseRank() {
        return new DenseRank();
    }

    /**
     * The <code>percent_rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<BigDecimal> percentRank() {
        return new PercentRank();
    }

    /**
     * The <code>cume_dist() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<BigDecimal> cumeDist() {
        return new CumeDist();
    }

    /**
     * The <code>ntile([number]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<Integer> ntile(int number) {
        return new Ntile(inline(number));
    }

    /**
     * The <code>ntile([number]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<Integer> ntile(Field<Integer> number) {
        return new Ntile(number);
    }

    /**
     * The <code>ratio_to_report([expression]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<BigDecimal> ratioToReport(Number number) {
        return ratioToReport(Tools.field(number));
    }

    /**
     * The <code>ratio_to_report([expression]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static WindowOverStep<BigDecimal> ratioToReport(Field<? extends Number> field) {
        return new RatioToReport(Tools.nullSafe(field));
    }

    /**
     * The <code>first_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> firstValue(Field<T> field) {
        return new FirstValue<>(Tools.nullSafe(field));
    }

    /**
     * The <code>last_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lastValue(Field<T> field) {
        return new LastValue<>(Tools.nullSafe(field));
    }

    /**
     * The <code>nth_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowFromFirstLastStep<T> nthValue(Field<T> field, int nth) {
        return nthValue(field, val(nth));
    }

    /**
     * The <code>nth_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowFromFirstLastStep<T> nthValue(Field<T> field, Field<Integer> nth) {
        return new NthValue<>(Tools.nullSafe(field), Tools.nullSafe(nth));
    }

    /**
     * The <code>lead(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field) {
        return new Lead<>(Tools.nullSafe(field), null, null);
    }

    /**
     * The <code>lead(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset) {
        return lead(field, inline(offset));
    }

    /**
     * The <code>lead(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset) {
        return new Lead<>(Tools.nullSafe(field), Tools.nullSafe(offset), null);
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset, T defaultValue) {
        return lead(Tools.nullSafe(field), inline(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset, Field<T> defaultValue) {
        return lead(field, inline(offset), defaultValue);
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset, T defaultValue) {
        return lead(field, Tools.nullSafe(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset, Field<T> defaultValue) {
        return new Lead<>(Tools.nullSafe(field), Tools.nullSafe(offset), Tools.nullSafe(defaultValue));
    }

    /**
     * The <code>lag(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field) {
        return new Lag<>(Tools.nullSafe(field), null, null);
    }

    /**
     * The <code>lag(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset) {
        return lag(field, inline(offset));
    }

    /**
     * The <code>lag(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset) {
        return new Lag<>(Tools.nullSafe(field), Tools.nullSafe(offset), null);
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset, T defaultValue) {
        return lag(Tools.nullSafe(field), inline(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset, Field<T> defaultValue) {
        return lag(field, inline(offset), defaultValue);
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset, T defaultValue) {
        return lag(field, offset, Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CLICKHOUSE, CUBRID, DUCKDB, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE, TRINO, YUGABYTEDB })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset, Field<T> defaultValue) {
        return new Lag<>(Tools.nullSafe(field), Tools.nullSafe(offset), Tools.nullSafe(defaultValue));
    }

    // -------------------------------------------------------------------------
    // XXX Bind values
    // -------------------------------------------------------------------------

    /**
     * Create an unnamed parameter with a generic type ({@link Object} /
     * {@link SQLDataType#OTHER}) and no initial value.
     * <p>
     * Try to avoid this method when using any of these databases, as these
     * databases may have trouble inferring the type of the bind value. Use
     * typed named parameters instead, using {@link #param(Class)} or
     * {@link #param(DataType)}
     * <ul>
     * <li> {@link SQLDialect#DB2}</li>
     * <li> {@link SQLDialect#DERBY}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#INGRES}</li>
     * <li> {@link SQLDialect#SYBASE}</li>
     * </ul>
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<Object> param() {
        return param(Object.class);
    }

    /**
     * Create an unnamed parameter with a defined type and no initial value.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #param(DataType)}.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(Class<T> type) {
        return val0(null, DefaultDataType.getDataType(null, type), true, 0, null);
    }

    /**
     * Create an unnamed parameter with a defined type and no initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(DataType<T> type) {
        return val0(null, type, false, 0, null);
    }

    /**
     * Create an unnamed parameter with the defined type of another field and no
     * initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(Field<T> field) {
        return param(field.getDataType());
    }

    /**
     * Create a named parameter with a generic type ({@link Object} /
     * {@link SQLDataType#OTHER}) and no initial value.
     * <p>
     * Try to avoid this method when using any of these databases, as these
     * databases may have trouble inferring the type of the bind value. Use
     * typed named parameters instead, using {@link #param(String, Class)} or
     * {@link #param(String, DataType)}
     * <ul>
     * <li> {@link SQLDialect#DB2}</li>
     * <li> {@link SQLDialect#DERBY}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#INGRES}</li>
     * <li> {@link SQLDialect#SYBASE}</li>
     * </ul>
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static Param<Object> param(String name) {
        return param(name, Object.class);
    }

    /**
     * Create a named parameter with a defined type and no initial value.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #param(String, DataType)}.
     *
     * @param name The parameter name
     * @param type The type that is used for the parameter (a type that is
     *            supported by {@link SQLDataType})
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, Class<T> type) {
        return val0(null, DefaultDataType.getDataType(null, type), true, 0, name);
    }

    /**
     * Create a named parameter with a defined type and no initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, DataType<T> type) {
        return val0(null, type, false, 0, name);
    }

    /**
     * Create a named parameter with a defined type of another field and no
     * initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, Field<T> type) {
        return param(name, type.getDataType());
    }

    /**
     * Create a named parameter with an initial value.
     * <p>
     * Named parameters are useful for several use-cases:
     * <ul>
     * <li>They can be used with Spring's <code>JdbcTemplate</code>, which
     * supports named parameters. Use
     * {@link DSLContext#renderNamedParams(QueryPart)} to render
     * parameter names in SQL</li>
     * <li>Named parameters can be retrieved using a well-known name from
     * {@link Query#getParam(String)} and {@link Query#getParams()}.</li>
     * </ul>
     *
     * @see Query#getParam(String)
     * @see Query#getParams()
     * @see DSLContext#renderNamedParams(QueryPart)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, T value) {
        return val0(value, val(value).getDataType(), true, 0, name);
    }

    /**
     * A synonym for {@link #val(Object)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * instances of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #value(Object, DataType)}.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(T value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(byte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(byte)
     */
    @NotNull
    @Support
    public static Param<Byte> value(byte value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Byte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Byte)
     */
    @NotNull
    @Support
    public static Param<Byte> value(Byte value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(UByte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UByte)
     */
    @NotNull
    @Support
    public static Param<UByte> value(UByte value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(short)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(short)
     */
    @NotNull
    @Support
    public static Param<Short> value(short value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Short)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Short)
     */
    @NotNull
    @Support
    public static Param<Short> value(Short value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(UShort)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UShort)
     */
    @NotNull
    @Support
    public static Param<UShort> value(UShort value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(int)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(int)
     */
    @NotNull
    @Support
    public static Param<Integer> value(int value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Integer)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Integer)
     */
    @NotNull
    @Support
    public static Param<Integer> value(Integer value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(UInteger)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UInteger)
     */
    @NotNull
    @Support
    public static Param<UInteger> value(UInteger value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(long)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(long)
     */
    @NotNull
    @Support
    public static Param<Long> value(long value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Long)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Long)
     */
    @NotNull
    @Support
    public static Param<Long> value(Long value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(ULong)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(ULong)
     */
    @NotNull
    @Support
    public static Param<ULong> value(ULong value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(float)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(float)
     */
    @NotNull
    @Support
    public static Param<Float> value(float value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Float)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Float)
     */
    @NotNull
    @Support
    public static Param<Float> value(Float value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(double)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(double)
     */
    @NotNull
    @Support
    public static Param<Double> value(double value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Double)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Double)
     */
    @NotNull
    @Support
    public static Param<Double> value(Double value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(boolean)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(boolean)
     */
    @NotNull
    @Support
    public static Param<Boolean> value(boolean value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Boolean)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Boolean)
     */
    @NotNull
    @Support
    public static Param<Boolean> value(Boolean value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(BigDecimal)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(BigDecimal)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> value(BigDecimal value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(BigInteger)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(BigInteger)
     */
    @NotNull
    @Support
    public static Param<BigInteger> value(BigInteger value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(byte[])} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(byte[])
     */
    @NotNull
    @Support
    public static Param<byte[]> value(byte[] value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(String)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(String)
     */
    @NotNull
    @Support
    public static Param<String> value(String value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Date)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Date)
     */
    @NotNull
    @Support
    public static Param<Date> value(Date value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Time)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Time)
     */
    @NotNull
    @Support
    public static Param<Time> value(Time value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Timestamp)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Timestamp)
     */
    @NotNull
    @Support
    public static Param<Timestamp> value(Timestamp value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(LocalDate)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalDate)
     */
    @NotNull
    @Support
    public static Param<LocalDate> value(LocalDate value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(LocalTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalTime)
     */
    @NotNull
    @Support
    public static Param<LocalTime> value(LocalTime value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(LocalDateTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalDateTime)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> value(LocalDateTime value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(OffsetTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(OffsetTime)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> value(OffsetTime value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(OffsetDateTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(OffsetDateTime)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> value(OffsetDateTime value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(Instant)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Instant)
     */
    @NotNull
    @Support
    public static Param<Instant> value(Instant value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(UUID)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UUID)
     */
    @NotNull
    @Support
    public static Param<UUID> value(UUID value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(JSON)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(JSON)
     */
    @NotNull
    @Support
    public static Param<JSON> value(JSON value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(JSONB)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(JSONB)
     */
    @NotNull
    @Support
    public static Param<JSONB> value(JSONB value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(XML)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(XML)
     */
    @NotNull
    @Support
    public static Param<XML> value(XML value) {
        return val(value);
    }





























    /**
     * A synonym for {@link #val(Object, Class)} to be used in Scala and Groovy,
     * where <code>val</code> is a reserved keyword.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #value(Object, DataType)}.
     *
     * @param value The bind value
     * @param type The type that is used for the bind value (a type that is
     *            supported by {@link SQLDataType})
     * @see #val(Object, Class)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, Class<T> type) {
        return val(value, type);
    }

    /**
     * A synonym for {@link #val(Object, Field)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Object, Field)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, Field<T> field) {
        return val(value, field);
    }

    /**
     * A synonym for {@link #val(Object, DataType)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, DataType<T> type) {
        return val(value, type);
    }

    /**
     * Inline all bind variables produced by the argument {@link Field}.
     */
    @NotNull
    @Support
    public static <T> Field<T> inlined(Field<T> field) {
        return CustomField.of(field.getQualifiedName(), field.getDataType(), c -> c.visit(field, INLINED));
    }

    /**
     * Inline all bind variables produced by the argument {@link Condition}.
     */
    @NotNull
    @Support
    public static Condition inlined(Condition condition) {
        return CustomCondition.of(c -> c.visit(condition, INLINED));
    }

    /**
     * Inline all bind variables produced by the argument {@link QueryPart}.
     */
    @NotNull
    @Support
    public static QueryPart inlined(QueryPart part) {
        return CustomQueryPart.of(c -> c.visit(part, INLINED));
    }














    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * instances of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #inline(Object, DataType)}.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(T value) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> inline(byte value) {
        return inline0((Object) value, SQLDataType.TINYINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> inline(Byte value) {
        return inline0((Object) value, SQLDataType.TINYINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UByte> inline(UByte value) {
        return inline0((Object) value, SQLDataType.TINYINTUNSIGNED, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> inline(short value) {
        return inline0((Object) value, SQLDataType.SMALLINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> inline(Short value) {
        return inline0((Object) value, SQLDataType.SMALLINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UShort> inline(UShort value) {
        return inline0((Object) value, SQLDataType.SMALLINTUNSIGNED, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> inline(int value) {
        return inline0((Object) value, SQLDataType.INTEGER, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> inline(Integer value) {
        return inline0((Object) value, SQLDataType.INTEGER, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UInteger> inline(UInteger value) {
        return inline0((Object) value, SQLDataType.INTEGERUNSIGNED, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> inline(long value) {
        return inline0((Object) value, SQLDataType.BIGINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> inline(Long value) {
        return inline0((Object) value, SQLDataType.BIGINT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<ULong> inline(ULong value) {
        return inline0((Object) value, SQLDataType.BIGINTUNSIGNED, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> inline(float value) {
        return inline0((Object) value, SQLDataType.REAL, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> inline(Float value) {
        return inline0((Object) value, SQLDataType.REAL, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> inline(double value) {
        return inline0((Object) value, SQLDataType.DOUBLE, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> inline(Double value) {
        return inline0((Object) value, SQLDataType.DOUBLE, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> inline(boolean value) {
        return inline0((Object) value, SQLDataType.BOOLEAN, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> inline(Boolean value) {
        return inline0((Object) value, SQLDataType.BOOLEAN, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> inline(BigDecimal value) {
        return inline0((Object) value, SQLDataType.DECIMAL, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigInteger> inline(BigInteger value) {
        return inline0((Object) value, SQLDataType.DECIMAL_INTEGER, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<byte[]> inline(byte[] value) {
        return inline0((Object) value, SQLDataType.VARBINARY, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(String value) {
        return inline0((Object) value, SQLDataType.VARCHAR, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Date> inline(Date value) {
        return inline0((Object) value, SQLDataType.DATE, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Time> inline(Time value) {
        return inline0((Object) value, SQLDataType.TIME, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Timestamp> inline(Timestamp value) {
        return inline0((Object) value, SQLDataType.TIMESTAMP, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDate> inline(LocalDate value) {
        return inline0((Object) value, SQLDataType.LOCALDATE, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalTime> inline(LocalTime value) {
        return inline0((Object) value, SQLDataType.LOCALTIME, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> inline(LocalDateTime value) {
        return inline0((Object) value, SQLDataType.LOCALDATETIME, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> inline(OffsetTime value) {
        return inline0((Object) value, SQLDataType.OFFSETTIME, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> inline(OffsetDateTime value) {
        return inline0((Object) value, SQLDataType.OFFSETDATETIME, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Instant> inline(Instant value) {
        return inline0((Object) value, SQLDataType.INSTANT, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UUID> inline(UUID value) {
        return inline0((Object) value, SQLDataType.UUID, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSON> inline(JSON value) {
        return inline0((Object) value, SQLDataType.JSON, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSONB> inline(JSONB value) {
        return inline0((Object) value, SQLDataType.JSONB, true);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<XML> inline(XML value) {
        return inline0((Object) value, SQLDataType.XML, true);
    }

















































    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;Character&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(char character) {
        return inline("" + character);
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;Character&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(Character character) {
        return inline((character == null) ? null : ("" + character));
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;CharSequence&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(CharSequence character) {

        // Delegate to inline(T)
        return (Param) inline((Object) ((character == null) ? null : ("" + character)));
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, Class)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #inline(Object, DataType)}.
     *
     * @param value The inline value
     * @param type The data type to enforce upon the value (a type that is
     *            supported by {@link SQLDataType})
     * @see #val(Object, Class)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, Class<T> type) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value, type);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, DataType)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #val(Object, Field)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, Field<T> field) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value, field);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, DataType)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, DataType<T> type) {
        return inline0(value, type, false);
    }

    static <T> Param<T> inline0(Object value, DataType<T> type, boolean inferredDataType) {
        AbstractParamX<T> val = (AbstractParamX<T>) val0(value, type, inferredDataType);
        val.setInline0(true);
        return val;
    }

    /**
     * Get a bind value.
     * <p>
     * jOOQ tries to derive the RDBMS {@link DataType} from the provided Java
     * type <code>&lt;T&gt;</code>. This may not always be accurate, which can
     * lead to problems in some strongly typed RDMBS, especially when value is
     * <code>null</code>. These databases are namely:
     * <ul>
     * <li>{@link SQLDialect#DERBY}</li>
     * <li>{@link SQLDialect#DB2}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#HSQLDB}</li>
     * <li>{@link SQLDialect#INGRES}</li>
     * <li>{@link SQLDialect#SYBASE}</li>
     * </ul>
     * <p>
     * If you need more type-safety, please use {@link #val(Object, DataType)}
     * instead, and provide the precise RDMBS-specific data type, that is
     * needed.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * instances of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #val(Object, DataType)}.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @return A field representing the constant value
     */
    @NotNull
    @Support
    public static <T> Param<T> val(T value) {
        return val0(value, true);
    }

    static <T> Param<T> val0(T value, boolean inferredDataType) {
        Class type = value == null ? Object.class : value.getClass();
        DataType dataType = getDataType0(type);
        return val0(value, dataType, inferredDataType);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> val(byte value) {
        return val0((Object) value, SQLDataType.TINYINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> val(Byte value) {
        return val0((Object) value, SQLDataType.TINYINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UByte> val(UByte value) {
        return val0((Object) value, SQLDataType.TINYINTUNSIGNED, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> val(short value) {
        return val0((Object) value, SQLDataType.SMALLINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> val(Short value) {
        return val0((Object) value, SQLDataType.SMALLINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UShort> val(UShort value) {
        return val0((Object) value, SQLDataType.SMALLINTUNSIGNED, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> val(int value) {
        return val0((Object) value, SQLDataType.INTEGER, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> val(Integer value) {
        return val0((Object) value, SQLDataType.INTEGER, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UInteger> val(UInteger value) {
        return val0((Object) value, SQLDataType.INTEGERUNSIGNED, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> val(long value) {
        return val0((Object) value, SQLDataType.BIGINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> val(Long value) {
        return val0((Object) value, SQLDataType.BIGINT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<ULong> val(ULong value) {
        return val0((Object) value, SQLDataType.BIGINTUNSIGNED, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> val(float value) {
        return val0((Object) value, SQLDataType.REAL, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> val(Float value) {
        return val0((Object) value, SQLDataType.REAL, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> val(double value) {
        return val0((Object) value, SQLDataType.DOUBLE, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> val(Double value) {
        return val0((Object) value, SQLDataType.DOUBLE, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> val(boolean value) {
        return val0((Object) value, SQLDataType.BOOLEAN, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> val(Boolean value) {
        return val0((Object) value, SQLDataType.BOOLEAN, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> val(BigDecimal value) {
        return val0((Object) value, SQLDataType.DECIMAL, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigInteger> val(BigInteger value) {
        return val0((Object) value, SQLDataType.DECIMAL_INTEGER, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<byte[]> val(byte[] value) {
        return val0((Object) value, SQLDataType.VARBINARY, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<String> val(String value) {
        return val0((Object) value, SQLDataType.VARCHAR, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Date> val(Date value) {
        return val0((Object) value, SQLDataType.DATE, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Time> val(Time value) {
        return val0((Object) value, SQLDataType.TIME, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Timestamp> val(Timestamp value) {
        return val0((Object) value, SQLDataType.TIMESTAMP, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDate> val(LocalDate value) {
        return val0((Object) value, SQLDataType.LOCALDATE, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalTime> val(LocalTime value) {
        return val0((Object) value, SQLDataType.LOCALTIME, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> val(LocalDateTime value) {
        return val0((Object) value, SQLDataType.LOCALDATETIME, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> val(OffsetTime value) {
        return val0((Object) value, SQLDataType.OFFSETTIME, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> val(OffsetDateTime value) {
        return val0((Object) value, SQLDataType.OFFSETDATETIME, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Instant> val(Instant value) {
        return val0((Object) value, SQLDataType.INSTANT, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UUID> val(UUID value) {
        return val0((Object) value, SQLDataType.UUID, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSON> val(JSON value) {
        return val0((Object) value, SQLDataType.JSON, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSONB> val(JSONB value) {
        return val0((Object) value, SQLDataType.JSONB, true);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<XML> val(XML value) {
        return val0((Object) value, SQLDataType.XML, true);
    }



























    /**
     * Get a bind value with an associated type, taken from a field.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #val(Object, DataType)}.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param type The data type to enforce upon the value (a type that is
     *            supported by {@link SQLDataType})
     * @return A field representing the constant value
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, Class<T> type) {
        return val0(value, getDataType(type), true);
    }

    /**
     * Get a bind value with an associated type, taken from a field.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param field The field whose data type to enforce upon the value
     * @return A field representing the constant value
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, Field<T> field) {
        return val(value, Tools.nullSafeDataType(field));
    }

    /**
     * Get a bind value with an associated type.
     * <p>
     * This will try to bind <code>value</code> as <code>type</code> in a
     * <code>PreparedStatement</code>. If <code>value</code> and
     * <code>type</code> are not compatible, jOOQ will first try to convert and
     * then to cast <code>value</code> to <code>type</code>.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param type The data type to enforce upon the value
     * @return A field representing the constant value
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, DataType<T> type) {
        return val0(value, type, false);
    }

    private static <T> Param<T> val0(Object value, DataType<T> type, boolean inferredDataType) {
        return val0(value, type, inferredDataType, 0, null);
    }

    static <T> Param<T> val0(Object value, DataType<T> type, boolean inferredDataType, int index, String paramName) {

        // Advanced data types have dedicated constant types
        if (value instanceof QualifiedRecord<?> r)
            return new QualifiedRecordConstant(r, r.getQualifier());
        else if (value == null && QualifiedRecord.class.isAssignableFrom(type.getType()))
            return new QualifiedRecordConstant(null, getRecordQualifier(type));










        // [#14694] value can be a Param contained in a Row
        else if (value instanceof Val<?> p)
            return p.convertTo(type);

        // The default behaviour
        T converted = type.convert(value);
        return new Val<>(converted, mostSpecific(converted, type), inferredDataType, index, paramName);
    }

    /**
     * Get the "most specific" data type between a concrete value and an actual
     * coercion data type.
     * <p>
     * [#2007] When coercing a (previously converted) value to a type, it may be that
     * the type is still more general than the actual type. This is typically
     * the case when <code>dataType == SQLDataType.OTHER</code>, i.e. when
     * <code>dataType.getType() == Object.class</code>. In that case, it is wise
     * to keep the additional type information of the <code>value</code>
     *
     * @param value The value
     * @param dataType The coercion data type
     * @return The most specific data type
     */
    private static <T> DataType<T> mostSpecific(T value, DataType<T> dataType) {

        // [#3888] With custom data type conversion, users may wish to
        // allow for a less specific data type than the actual value. Example:
        //   data type: Serializable
        //   value    : byte[]
        // [#3889] TODO: Improve this once DataType.getBinding() is available

        if (value != null && !(dataType instanceof ConvertedDataType)) {
            Class<T> valueType = (Class<T>) value.getClass();
            Class<T> coercionType = dataType.getType();

            if (valueType != coercionType && coercionType.isAssignableFrom(valueType)) {
                return DefaultDataType.getDataType(null, valueType, dataType);
            }
        }

        return dataType;
    }

    /**
     * Create a {@link RecordType} of an arbitrary degree.
     */
    @NotNull
    public static <T1> RecordType<Record> recordType(Field<?>[] fields) {
        return new FieldsImpl(fields);
    }

    /**
     * Create a {@link RecordType} of an arbitrary degree.
     */
    @NotNull
    public static <T1> RecordType<Record> recordType(Collection<? extends Field<?>> fields) {
        return new FieldsImpl(fields);
    }



    /**
     * Create a {@link RecordType} of degree <code>1</code>.
     */
    @NotNull
    public static <T1> RecordType<Record1<T1>> recordType(Field<T1> field1) {
        return new FieldsImpl(field1);
    }

    /**
     * Create a {@link RecordType} of degree <code>2</code>.
     */
    @NotNull
    public static <T1, T2> RecordType<Record2<T1, T2>> recordType(Field<T1> field1, Field<T2> field2) {
        return new FieldsImpl(field1, field2);
    }

    /**
     * Create a {@link RecordType} of degree <code>3</code>.
     */
    @NotNull
    public static <T1, T2, T3> RecordType<Record3<T1, T2, T3>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return new FieldsImpl(field1, field2, field3);
    }

    /**
     * Create a {@link RecordType} of degree <code>4</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4> RecordType<Record4<T1, T2, T3, T4>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return new FieldsImpl(field1, field2, field3, field4);
    }

    /**
     * Create a {@link RecordType} of degree <code>5</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5> RecordType<Record5<T1, T2, T3, T4, T5>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return new FieldsImpl(field1, field2, field3, field4, field5);
    }

    /**
     * Create a {@link RecordType} of degree <code>6</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6> RecordType<Record6<T1, T2, T3, T4, T5, T6>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a {@link RecordType} of degree <code>7</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7> RecordType<Record7<T1, T2, T3, T4, T5, T6, T7>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a {@link RecordType} of degree <code>8</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8> RecordType<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a {@link RecordType} of degree <code>9</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> RecordType<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a {@link RecordType} of degree <code>10</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> RecordType<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a {@link RecordType} of degree <code>11</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> RecordType<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a {@link RecordType} of degree <code>12</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> RecordType<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a {@link RecordType} of degree <code>13</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> RecordType<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a {@link RecordType} of degree <code>14</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> RecordType<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a {@link RecordType} of degree <code>15</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> RecordType<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a {@link RecordType} of degree <code>16</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> RecordType<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a {@link RecordType} of degree <code>17</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> RecordType<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a {@link RecordType} of degree <code>18</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> RecordType<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a {@link RecordType} of degree <code>19</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> RecordType<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a {@link RecordType} of degree <code>20</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> RecordType<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a {@link RecordType} of degree <code>21</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> RecordType<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a {@link RecordType} of degree <code>22</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> RecordType<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }





    /**
     * Create a row value expression of degree <code>1</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1> Row1<T1> row(T1 t1) {
        return row(Tools.field(t1));
    }

    /**
     * Create a row value expression of degree <code>2</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2> Row2<T1, T2> row(T1 t1, T2 t2) {
        return row(Tools.field(t1), Tools.field(t2));
    }

    /**
     * Create a row value expression of degree <code>3</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> Row3<T1, T2, T3> row(T1 t1, T2 t2, T3 t3) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3));
    }

    /**
     * Create a row value expression of degree <code>4</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Row4<T1, T2, T3, T4> row(T1 t1, T2 t2, T3 t3, T4 t4) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4));
    }

    /**
     * Create a row value expression of degree <code>5</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Row5<T1, T2, T3, T4, T5> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5));
    }

    /**
     * Create a row value expression of degree <code>6</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Row6<T1, T2, T3, T4, T5, T6> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6));
    }

    /**
     * Create a row value expression of degree <code>7</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Row7<T1, T2, T3, T4, T5, T6, T7> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7));
    }

    /**
     * Create a row value expression of degree <code>8</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Row8<T1, T2, T3, T4, T5, T6, T7, T8> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8));
    }

    /**
     * Create a row value expression of degree <code>9</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9));
    }

    /**
     * Create a row value expression of degree <code>10</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10));
    }

    /**
     * Create a row value expression of degree <code>11</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11));
    }

    /**
     * Create a row value expression of degree <code>12</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12));
    }

    /**
     * Create a row value expression of degree <code>13</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13));
    }

    /**
     * Create a row value expression of degree <code>14</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14));
    }

    /**
     * Create a row value expression of degree <code>15</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15));
    }

    /**
     * Create a row value expression of degree <code>16</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16));
    }

    /**
     * Create a row value expression of degree <code>17</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17));
    }

    /**
     * Create a row value expression of degree <code>18</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18));
    }

    /**
     * Create a row value expression of degree <code>19</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19));
    }

    /**
     * Create a row value expression of degree <code>20</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20));
    }

    /**
     * Create a row value expression of degree <code>21</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20), Tools.field(t21));
    }

    /**
     * Create a row value expression of degree <code>22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20), Tools.field(t21), Tools.field(t22));
    }



    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(Object... values) {
        return row(Tools.fieldsArray(values));
    }



    /**
     * Create a row value expression of degree <code>1</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1> Row1<T1> row(SelectField<T1> field1) {
        return new RowImpl1<>(field1);
    }

    /**
     * Create a row value expression of degree <code>2</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2> Row2<T1, T2> row(SelectField<T1> field1, SelectField<T2> field2) {
        return new RowImpl2<>(field1, field2);
    }

    /**
     * Create a row value expression of degree <code>3</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> Row3<T1, T2, T3> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return new RowImpl3<>(field1, field2, field3);
    }

    /**
     * Create a row value expression of degree <code>4</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Row4<T1, T2, T3, T4> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return new RowImpl4<>(field1, field2, field3, field4);
    }

    /**
     * Create a row value expression of degree <code>5</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Row5<T1, T2, T3, T4, T5> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return new RowImpl5<>(field1, field2, field3, field4, field5);
    }

    /**
     * Create a row value expression of degree <code>6</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Row6<T1, T2, T3, T4, T5, T6> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return new RowImpl6<>(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a row value expression of degree <code>7</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Row7<T1, T2, T3, T4, T5, T6, T7> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return new RowImpl7<>(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a row value expression of degree <code>8</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Row8<T1, T2, T3, T4, T5, T6, T7, T8> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return new RowImpl8<>(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a row value expression of degree <code>9</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return new RowImpl9<>(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a row value expression of degree <code>10</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return new RowImpl10<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a row value expression of degree <code>11</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return new RowImpl11<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a row value expression of degree <code>12</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return new RowImpl12<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a row value expression of degree <code>13</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return new RowImpl13<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a row value expression of degree <code>14</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return new RowImpl14<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a row value expression of degree <code>15</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return new RowImpl15<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a row value expression of degree <code>16</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return new RowImpl16<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a row value expression of degree <code>17</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return new RowImpl17<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a row value expression of degree <code>18</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return new RowImpl18<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a row value expression of degree <code>19</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return new RowImpl19<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a row value expression of degree <code>20</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return new RowImpl20<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a row value expression of degree <code>21</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return new RowImpl21<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a row value expression of degree <code>22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return new RowImpl22<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(SelectField<?>... values) {
        return new RowImplN(values);
    }

    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(Collection<?> values) {
        return row(values.toArray());
    }

    // -------------------------------------------------------------------------
    // XXX [#915] VALUES() table constructors
    // -------------------------------------------------------------------------

    /**
     * Create a <code>VALUES()</code> expression of arbitrary degree.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2),
     *       (val2_1, val2_2),
     *       (val3_1, val3_2)
     * AS "v"("c1"  , "c2"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function...)
     */
    @NotNull
    @Support
    public static Table<Record> values(RowN... rows) {
        return values0(rows);
    }

    /**
     * Internal values constructor.
     * <p>
     * [#6003] TODO: Make this public
     */
    @NotNull
    @Support
    static Table<Record> values0(Row... rows) {
        return new Values<Record>(Values.assertNotEmpty(rows));
    }



    /**
     * Create a <code>VALUES()</code> expression of degree <code>1</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1),
     *       (val2_1),
     *       (val3_1)
     * AS "v"("c1"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1") UNION ALL
     * SELECT val1_1 AS "c1") UNION ALL
     * SELECT val1_1 AS "c1")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1> Table<Record1<T1>> values(Row1<T1>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>2</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2),
     *       (val2_1, val2_2),
     *       (val3_1, val3_2)
     * AS "v"("c1"  , "c2"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2> Table<Record2<T1, T2>> values(Row2<T1, T2>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>3</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3),
     *       (val2_1, val2_2, val2_3),
     *       (val3_1, val3_2, val3_3)
     * AS "v"("c1"  , "c2"  , "c3"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3> Table<Record3<T1, T2, T3>> values(Row3<T1, T2, T3>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>4</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4),
     *       (val2_1, val2_2, val2_3, val2_4),
     *       (val3_1, val3_2, val3_3, val3_4)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Table<Record4<T1, T2, T3, T4>> values(Row4<T1, T2, T3, T4>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>5</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Table<Record5<T1, T2, T3, T4, T5>> values(Row5<T1, T2, T3, T4, T5>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>6</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Table<Record6<T1, T2, T3, T4, T5, T6>> values(Row6<T1, T2, T3, T4, T5, T6>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>7</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Table<Record7<T1, T2, T3, T4, T5, T6, T7>> values(Row7<T1, T2, T3, T4, T5, T6, T7>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>8</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Table<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> values(Row8<T1, T2, T3, T4, T5, T6, T7, T8>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>9</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Table<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> values(Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>10</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Table<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> values(Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>11</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Table<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> values(Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>12</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Table<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> values(Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>13</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Table<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> values(Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>14</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Table<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> values(Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>15</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Table<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> values(Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>16</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Table<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> values(Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>17</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Table<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> values(Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>18</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Table<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> values(Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>19</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Table<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> values(Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>20</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Table<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> values(Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>21</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20, val1_21),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20, val2_21),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20, val3_21)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  , "c21"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Table<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> values(Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>... rows) {
        return new Values(rows);
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>22</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT … UNION ALL …</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20, val1_21, val1_22),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20, val2_21, val2_22),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20, val3_21, val3_22)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  , "c21"  , "c22"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Table<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> values(Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>... rows) {
        return new Values(rows);
    }



    // -------------------------------------------------------------------------
    // XXX Literals
    // -------------------------------------------------------------------------

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> Field<T> nullSafe(Field<T> field) {
        return Tools.nullSafe(field);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> Field<T> nullSafe(Field<T> field, DataType<?> type) {
        return Tools.nullSafe(field, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static Field<?>[] nullSafe(Field<?>... fields) {
        return Tools.nullSafe(fields);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static Field<?>[] nullSafe(Field<?>[] fields, DataType<?> type) {
        return Tools.nullSafe(fields, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static List<Field<?>> nullSafeList(Field<?>... fields) {
        return Tools.nullSafeList(fields);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static List<Field<?>> nullSafeList(Field<?>[] fields, DataType<?> type) {
        return Tools.nullSafeList(fields, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> DataType<T> nullSafeDataType(Field<T> field) {
        return Tools.nullSafeDataType(field);
    }

    /**
     * The asterisk (<code>*</code>) to be used in <code>SELECT</code> clauses.
     * <p>
     * When using an asterisk, jOOQ will let the database server define the
     * order of columns, as well as which columns are included in the result
     * set. If using jOOQ with generated code, this may conflict with the column
     * set and its ordering as defined at code generation time, meaning columns
     * may be in a different order, there may be fewer or more columns than
     * expected. It is usually better to list columns explicitly.
     */
    @NotNull
    @Support
    public static Asterisk asterisk() {
        return AsteriskImpl.INSTANCE.get();
    }

    /**
     * A <code>0</code> literal.
     * <p>
     * This is useful for mathematical functions or for
     * <code>EXISTS (SELECT 0 …)</code> or <code>PARTITION BY 0</code> clauses
     * and similar constructs. The <code>0</code> literal will not generate a
     * bind variable.
     *
     * @return A <code>0</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> zero() {
        return inline(0);
    }

    /**
     * A <code>1</code> literal.
     * <p>
     * This is useful for mathematical functions or for
     * <code>EXISTS (SELECT 1 …)</code> or <code>PARTITION BY 1</code> clauses
     * and similar constructs. The <code>1</code> literal will not generate a
     * bind variable.
     *
     * @return A <code>1</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> one() {
        return inline(1);
    }

    /**
     * A <code>2</code> literal.
     * <p>
     * This is useful for mathematical functions. The <code>1</code> literal
     * will not generate a bind variable.
     *
     * @return A <code>2</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> two() {
        return inline(2);
    }

    // -------------------------------------------------------------------------
    // XXX utility API
    // -------------------------------------------------------------------------

    /**
     * Get the default data type for the {@link DSLContext}'s underlying
     * {@link SQLDialect} and a given Java type.
     * <p>
     * <b>NOTE [#15286]</b>: It is strongly recommended to pass only
     * {@link Class} references of types supported by jOOQ internally, i.e.
     * types from {@link SQLDataType}. If you're using any custom data types by
     * means of a {@link Converter} or {@link Binding}, it's better to pass that
     * converted {@link DataType} reference explicitly to
     * {@link #param(DataType)}.
     *
     * @param <T> The generic type
     * @param type The Java type. This must be a type supported by
     *            {@link SQLDataType}.
     * @return The <code>DSL</code>'s underlying default data type.
     * @deprecated - 3.11.0 - [#7483] - The (indirect) use of the internal
     *             static data type registry is not recommended.
     */
    @Deprecated(forRemoval = true, since = "3.11")
    @NotNull
    @Support
    public static <T> DataType<T> getDataType(Class<T> type) {
        return DefaultDataType.getDataType(SQLDialect.DEFAULT, type);
    }

    /**
     * [#9492] [#10438] Get a static data type for a class.
     * <p>
     * This will:
     * <ul>
     * <li>Get a built-in data type, if available</li>
     * <li>Get a DataTypeProxy wrapped LegacyConvertedDataType, if available
     * (#9492)</li>
     * <li>Get a DataTypeProxy, otherwise, for lazy data type lookups
     * (#10438)</li>
     * </ul>
     */
    static <T> DataType<T> getDataType0(Class<T> type) {
        DataType t = DefaultDataType.getDataType(DEFAULT, type, (DataType) SQLDataType.OTHER);

        if (t instanceof LegacyConvertedDataType l)
            return new DataTypeProxy(l);
        else if (t.isArray() && t.getArrayComponentDataType() != SQLDataType.OTHER)
            return t;
        else if (t != SQLDataType.OTHER)
            return t;
        else
            return DefaultDataType.getDataType(DEFAULT, type, new DataTypeProxy((AbstractDataType) SQLDataType.OTHER));
    }

    private static final DSLContext dsl() {
        return using(new DefaultConfiguration());
    }

    /**
     * No instances.
     */
    protected DSL() {
        throw new UnsupportedOperationException();
    }
}
