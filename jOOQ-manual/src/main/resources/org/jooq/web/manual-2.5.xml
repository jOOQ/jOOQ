<?xml version="1.0" encoding="UTF-8"?>
<manual version="2.5" end-of-life="true">
	<section id="manual">
		<title>The jOOQ User Manual. Multiple Pages</title>
		<content><html>
			<h2 id="Overview"><a href="#Overview" name="Overview">#</a> Overview</h2>
			<p>This manual is divided into six main sections:</p>

			<ul>
				<li>
					<reference id="getting-started"/>
					<p>
						This section will get you started with jOOQ quickly. It contains
						simple explanations about what jOOQ is, what jOOQ isn't and how
						to set it up for the first time
					</p>
				</li>
				<li>
					<reference id="sql-building"/>
					<p>
						This section explains all about the jOOQ syntax used for building
						queries. It explains the central factories, the supported SQL
						statements and various other syntax elements
					</p>
				</li>
				<li>
					<reference id="code-generation"/>
					<p>
						This section explains how to configure and use the built-in source code
						generator
					</p>
				</li>
				<li>
					<reference id="sql-execution"/>
					<p>
						This section will get you through the specifics of what can be done
						with jOOQ at runtime, in order to execute queries, perform CRUD
						operations, import and export data, and hook into the jOOQ execution
						lifecycle for debugging
					</p>
				</li>
				<li>
					<reference id="tools"/>
					<p>
						This section is dedicated to tools that ship with jOOQ, such as the
						jOOQ console
					</p>
				</li>
				<li>
					<reference id="reference"/>
					<p>
						This section is a reference for elements in this manual
					</p>
				</li>
			</ul>
		</html></content>

		<sections>
			<section id="preface">
				<title>Preface</title>
				<content><html>
					<h3>jOOQ's reason of being - compared to JPA</h3>
					<p>
						Java and SQL have come a long way. SQL is an "ancient", yet established and well-understood technology. Java is a legacy too, although its platform JVM allows for many new and contemporary languages built on top of it. Yet, after all these years, libraries dealing with the interface between SQL and Java have come and gone, leaving JPA to be a standard that is accepted only with doubts, short of any surviving options.
					</p>
					<p>
						So far, there had been only few database abstraction frameworks or libraries, that truly respected SQL as a first class citizen among languages. Most frameworks, including the industry standards JPA, EJB, Hibernate, JDO, Criteria Query, and many others try to hide SQL itself, minimising its scope to things called JPQL, HQL, JDOQL and various other inferior query languages
					</p>
					<p>
						jOOQ has come to fill this gap.
					</p>

					<h3>jOOQ's reason of being - compared to LINQ</h3>
					<p>
						Other platforms incorporate ideas such as LINQ (with LINQ-to-SQL), or Scala's SLICK, or also Java's QueryDSL to better integrate querying as a concept into their respective language. By querying, they understand querying of arbitrary targets, such as SQL, XML, Collections and other heterogeneous data stores. jOOQ claims that this is going the wrong way too.
					</p>
					<p>
 						In more advanced querying use-cases (more than simple CRUD and the occasional JOIN), people will want to profit from the expressivity of SQL. Due to the relational nature of SQL, this is quite different from what object-oriented and partially functional languages such as C#, Scala, or Java can offer.
 					</p>
 					<p>
 						It is very hard to formally express and validate joins and the ad-hoc table expression types they create. It gets even harder when you want support for more advanced table expressions, such as pivot tables, unnested cursors, or just arbitrary projections from derived tables. With a very strong object-oriented typing model, these features will probably stay out of scope.
 					</p>
 					<p>
 						In essence, the decision of creating an API that looks like SQL or one that looks like C#, Scala, Java is a definite decision in favour of one or the other platform. While it will be easier to evolve SLICK in similar ways as LINQ (or QueryDSL in the Java world), SQL feature scope that clearly communicates its underlying intent will be very hard to add, later on (e.g. how would you model Oracle's partitioned outer join syntax? How would you model ANSI/ISO SQL:1999 grouping sets? How can you support scalar subquery caching? etc...).
					</p>
					<p>
						jOOQ has come to fill this gap.
					</p>

					<h3>jOOQ is different</h3>
					<p>
						SQL was never meant to be abstracted. To be confined in the narrow boundaries of heavy mappers, hiding the beauty and simplicity of relational data. SQL was never meant to be object-oriented. SQL was never meant to be anything other than... SQL!
					</p>
				</html></content>
			</section>

			<section id="getting-started">
				<title>Getting started with jOOQ</title>
				<content><html>
					<p>
						These chapters contain a quick overview of how to get started with this manual and with jOOQ. While the subsequent chapters contain a lot of reference information, this chapter here just wraps up the essentials.
					</p>
				</html></content>

				<sections>
					<section id="the-manual">
					    <title>How to read this manual</title>
						<content><html>
							<p>
								This section helps you correctly interpret this manual in the context of jOOQ.
							</p>

							<h3>Code blocks</h3>
							<p>
								The following are code blocks:
							</p>

</html><sql><![CDATA[-- A SQL code block
SELECT 1 FROM DUAL]]></sql><java><![CDATA[// A Java code block
for (int i = 0; i < 10; i++);]]></java><xml><![CDATA[<!-- An XML code block -->
<hello what="world"></hello>]]></xml><config><![CDATA[# A config file code block
org.jooq.property=value]]></config><html>

							<p>
								These are useful to provide examples in code. Often, with jOOQ, it is even more useful to compare SQL code with its corresponding Java/jOOQ code. When this is done, the blocks are aligned side-by-side, with SQL usually being on the left, and Java usually being on the right:
							</p>

</html><code-pair>
<sql><![CDATA[-- In SQL:
SELECT 1 FROM DUAL]]></sql><java><![CDATA[// Using jOOQ:
create.select()]]></java>
</code-pair><html>

							<h3>Code block contents</h3>
							<p>
								The contents of code blocks follow conventions, too. If nothing else is mentioned next to any given code block, then the following can be assumed:
							</p>


</html><sql><![CDATA[-- SQL assumptions
------------------

-- If nothing else is specified, assume that the Oracle syntax is used
SELECT 1 FROM DUAL]]></sql><java><![CDATA[// Java assumptions
// ----------------

// Whenever you see "standalone functions", assume they were static imported from org.jooq.impl.Factory
exists(); max(); min(); val(); inline(); // correspond to Factory.exists(); Factory.max(); Factory.min(); etc...

// Whenever you see BOOK/Book, AUTHOR/Author and similar entities, assume they were (static) imported from the generated schema
BOOK.TITLE, AUTHOR.LAST_NAME // correspond to com.example.generated.Tables.BOOK.TITLE, com.example.generated.Tables.BOOK.TITLE
FK_BOOK_AUTHOR               // corresponds to com.example.generated.Keys.FK_BOOK_AUTHOR

// Whenever you see "create" being used in Java code, assume that this is an instance of org.jooq.impl.Factory:
Factory create = new Factory(connection, SQLDialect.ORACLE);]]></java><html>

							<h3>Settings</h3>
							<p>
								jOOQ allows to override runtime behaviour using <reference class="org.jooq.conf.Settings"/>. If nothing is specified, the default runtime settings are assumed.
							</p>

							<h3>Sample database</h3>
							<p>
								See the manual's section about <reference id="sample-database" title="the sample database used in this manual"/> to learn more about the sample database.
							</p>
						</html></content>
					</section>

					<section id="sample-database">
					    <title>The sample database used in this manual</title>
						<content><html>
							<p>
							For the examples in this manual, the same database will always be referred to. It essentially consists of these entities created using the Oracle dialect
							</p>
</html><sql>CREATE TABLE language (
  id              NUMBER(7)     NOT NULL PRIMARY KEY,
  cd              CHAR(2)       NOT NULL,
  description     VARCHAR2(50)
)

CREATE TABLE author (
  id              NUMBER(7)     NOT NULL PRIMARY KEY,
  first_name      VARCHAR2(50),
  last_name       VARCHAR2(50)  NOT NULL,
  date_of_birth   DATE,
  year_of_birth   NUMBER(7),
  distinguished   NUMBER(1)
)

CREATE TABLE book (
  id              NUMBER(7)     NOT NULL PRIMARY KEY,
  author_id       NUMBER(7)     NOT NULL,
  title           VARCHAR2(400) NOT NULL,
  published_in    NUMBER(7)     NOT NULL,
  language_id     NUMBER(7)     NOT NULL,

  CONSTRAINT fk_book_author     FOREIGN KEY (author_id)   REFERENCES author(id),
  CONSTRAINT fk_book_language   FOREIGN KEY (language_id) REFERENCES language(id)
)

CREATE TABLE book_store (
  name            VARCHAR2(400) NOT NULL UNIQUE
)

CREATE TABLE book_to_book_store (
  name            VARCHAR2(400) NOT NULL,
  book_id         INTEGER       NOT NULL,
  stock           INTEGER,

  PRIMARY KEY(name, book_id),
  CONSTRAINT fk_b2bs_book_store FOREIGN KEY (name)        REFERENCES book_store (name) ON DELETE CASCADE,
  CONSTRAINT fk_b2bs_book       FOREIGN KEY (book_id)     REFERENCES book (id)         ON DELETE CASCADE
)</sql><html>
							<p>
								More entities, types (e.g. UDT's, ARRAY types, ENUM types, etc), stored procedures and packages are introduced for specific examples
							</p>
						</html></content>
					</section>

					<section id="use-cases">
						<title>Different use cases for jOOQ</title>
						<content><html>
							<p>
								jOOQ has originally been created as a library for complete abstraction of JDBC and all database interaction. Various best practices that are frequently encountered in pre-existing software products are applied to this library. This includes:
							</p>
							<ul>
								<li>Typesafe database object referencing through generated schema, table, column, record, procedure, type, dao, pojo artefacts (see the chapter about <reference id="code-generation" title="code generation"/>)</li>
								<li>Typesafe SQL construction through a complete API modelling SQL as a domain specific language in Java (see the chapter about <reference id="dsl-and-non-dsl" title="the DSL API"/>)</li>
								<li>Convenient query execution through an improved API for result fetching (see the chapters about <reference id="fetching" title="the various types of data fetching"/>)</li>
								<li>SQL dialect abstraction and SQL clause emulation to improve cross-database compatibility and to enable missing features in simpler databases (see the chapter about <reference id="sql-dialects" title="SQL dialects"/>)</li>
								<li>SQL logging and debugging using jOOQ as an integral part of your development process (see the chapters about <reference id="logging" title="logging"/> and about the <reference id="jooq-console" title="jOOQ Console"/>)</li>
							</ul>
							<p>
								Effectively, jOOQ was originally designed to replace any other database abstraction framework short of the ones handling connection pooling and transaction management (see also the <reference id="reference-credits" title="credits for other database abstraction libraries"/>)
							</p>

							<h3>Use jOOQ the way you prefer</h3>
							<p>
								... but open source is community-driven. And the community has shown various ways of using jOOQ that diverge from its original intent. Some use cases encountered are:
							</p>
							<ul>
								<li>Using Hibernate for 70% of the queries (i.e. <reference id="crud-with-updatablerecords" title="CRUD"/>) and jOOQ for the remaining 30% where SQL is really needed</li>
								<li>Using jOOQ for SQL building and JDBC for SQL execution</li>
								<li>Using jOOQ for SQL building and Spring Data for SQL execution</li>
								<li>Using jOOQ without the <reference id="code-generation" title="source code generator"/> to build the basis of a framework for dynamic SQL execution.</li>
							</ul>

							<p>
								The following sections explain about various use cases for using jOOQ in your application.
							</p>
						</html></content>

						<sections>
							<section id="jooq-as-a-standalone-sql-builder">
								<title>jOOQ as a SQL builder</title>
								<content><html>
									<p>
										This is the most simple of all use cases, allowing for construction of valid SQL for any database. In this use case, you will not use <reference id="jooq-as-a-sql-builder-with-code-generation" title="jOOQ's code generator"/> and probably not even <reference id="jooq-as-a-sql-executor" title="jOOQ's query execution facilities"/>. Instead, you'll use jOOQ to wrap strings, literals and other user-defined objects into an object-oriented, type-safe AST modelling your SQL statements. An example is given here:
									</p>

</html><java><![CDATA[// Fetch a SQL string from a jOOQ Query in order to manually execute it with another tool.
// For simplicity reasons, we're using the API to construct case-insensitive object references, here.
String sql = create.select(field("BOOK.TITLE"), field("AUTHOR.FIRST_NAME"), field("AUTHOR.LAST_NAME"))
                   .from(table("BOOK"))
                   .join(table("AUTHOR"))
                   .on(field("BOOK.AUTHOR_ID").equal(field("AUTHOR.ID")))
                   .where(field("BOOK.PUBLISHED_IN").equal(1948))
                   .getSQL();]]></java><html>

                   					<p>
                   						The SQL string that you can generate as such can then be executed using JDBC directly, using Spring's JdbcTemplate, using Apache DbUtils and many other tools.
                   					</p>
                   					<p>
                   						If you wish to use jOOQ only as a SQL builder, the following sections of the manual will be of interest to you:
                  					</p>
                  					<ul>
                  						<li><reference id="sql-building" title="SQL building"/>: This section contains a lot of information about creating SQL statements using the jOOQ API</li>
                  						<li><reference id="plain-sql" title="Plain SQL"/>: This section contains information useful in particular to those that want to supply <reference id="table-expressions" title="table expressions"/>, <reference id="column-expressions" title="column expressions"/>, etc. as plain SQL to jOOQ, rather than through generated artefacts</li>
                  					</ul>
								</html></content>
							</section>

							<section id="jooq-as-a-sql-builder-with-code-generation">
								<title>jOOQ as a SQL builder with code generation</title>
								<content><html>
									<p>
										In addition to using jOOQ as a <reference id="jooq-as-a-standalone-sql-builder" title="standalone SQL builder"/>, you can also use jOOQ's code generation features in order to compile your SQL statements using a Java compiler against an actual database schema. This adds a lot of power and expressiveness to just simply constructing SQL using custom strings and literals, as you can be sure that all database artefacts actually exist in the database, and that their type is correct. An example is given here:
									</p>

</html><java><![CDATA[// Fetch a SQL string from a jOOQ Query in order to manually execute it with another tool.
String sql = create.select(BOOK.TITLE, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
                   .from(BOOK)
                   .join(AUTHOR)
                   .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                   .where(BOOK.PUBLISHED_IN.equal(1948))
                   .getSQL();]]></java><html>

                   					<p>
                   						The SQL string that you can generate as such can then be executed using JDBC directly, using Spring's JdbcTemplate, using Apache DbUtils and many other tools.
                   					</p>
                   					<p>
                   						If you wish to use jOOQ only as a SQL builder with code generation, the following sections of the manual will be of interest to you:
                  					</p>
                  					<ul>
                  						<li><reference id="sql-building" title="SQL building"/>: This section contains a lot of information about creating SQL statements using the jOOQ API</li>
                  						<li><reference id="code-generation" title="Code generation"/>: This section contains the necessary information to run jOOQ's code generator against your developer database</li>
                  					</ul>
								</html></content>
							</section>

							<section id="jooq-as-a-sql-executor">
								<title>jOOQ as a SQL executor</title>
								<content><html>
									<p>
										Instead of any tool mentioned in the previous chapters, you can also use jOOQ directly to execute your jOOQ-generated SQL statements. This will add a lot of convenience on top of the previously discussed API for typesafe SQL construction, when you can re-use the information from generated classes to fetch records and custom data types. An example is given here:
									</p>

</html><java><![CDATA[// Execute the SQL statement directly with jOOQ
Result<Record> result = create.select(BOOK.TITLE, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
			                  .from(BOOK)
			                  .join(AUTHOR)
			                  .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
			                  .where(BOOK.PUBLISHED_IN.equal(1948))
			                  .fetch();]]></java><html>

									<p>
										jOOQ doesn't stop here, though! You can execute any SQL with jOOQ. In other words, you can use any other SQL building tool and run the SQL statements with jOOQ. An example is given here:
									</p>

</html><java><![CDATA[// Use your favourite tool to construct SQL strings:
String sql = "SELECT title, first_name, last_name FROM book JOIN author ON book.author_id = author.id " +
             "WHERE book.published_in = 1984";

// Fetch results using jOOQ
Result<Record> result = create.fetch(sql);

// Or execute that SQL with JDBC, fetching the ResultSet with jOOQ:
ResultSet rs = connection.createStatement().executeQuery(sql);
Result<Record> result = create.fetch(rs);]]></java><html>

									<p>
                   						If you wish to use jOOQ as a SQL executor with (or without) code generation, the following sections of the manual will be of interest to you:
                  					</p>
                  					<ul>
                  						<li><reference id="sql-building" title="SQL building"/>: This section contains a lot of information about creating SQL statements using the jOOQ API</li>
                  						<li><reference id="code-generation" title="Code generation"/>: This section contains the necessary information to run jOOQ's code generator against your developer database</li>
                  						<li><reference id="sql-execution" title="SQL execution"/>: This section contains a lot of information about executing SQL statements using the jOOQ API</li>
                  						<li><reference id="fetching"/>: This section contains some useful information about the various ways of fetching data with jOOQ</li>
                  					</ul>
								</html></content>
							</section>

							<section id="jooq-for-crud">
								<title>jOOQ for CRUD</title>
								<content><html>
									<p>
										This is probably the most complete use-case for jOOQ: Use all of jOOQ's features. Apart from jOOQ's fluent API for query construction, jOOQ can also help you execute everyday CRUD operations. An example is given here:
									</p>

</html><java><![CDATA[// Fetch all authors
for (AuthorRecord author : create.fetch(AUTHOR)) {

    // Skip previously distinguished authors
    if ((int) author.getDistinguished() == 1)
        continue;

    // Check if the author has written more than 5 books
    if (author.fetchChildren(Keys.FK_BOOK_AUTHOR).size() > 5) {

        // Mark the author as a "distinguished" author
        author.setDistinguished(1);
        author.store();
    }
}]]></java><html>

									<p>
                   						If you wish to use all of jOOQ's features, the following sections of the manual will be of interest to you (including all sub-sections):
                  					</p>
                  					<ul>
                  						<li><reference id="sql-building" title="SQL building"/>: This section contains a lot of information about creating SQL statements using the jOOQ API</li>
                  						<li><reference id="code-generation" title="Code generation"/>: This section contains the necessary information to run jOOQ's code generator against your developer database</li>
                  						<li><reference id="sql-execution" title="SQL execution"/>: This section contains a lot of information about executing SQL statements using the jOOQ API</li>
                  					</ul>
								</html></content>
							</section>

							<section id="jooq-for-pros">
								<title>jOOQ for PROs</title>
								<content><html>
									<p>
										jOOQ isn't just a library that helps you <reference id="sql-building" title="build"/> and <reference id="sql-execution" title="execute"/> SQL against your <reference id="code-generation" title="generated, compilable schema"/>. jOOQ ships with a lot of tools. Here are some of the most important tools shipped with jOOQ:
									</p>
									<ul>
										<li><reference id="jooq-console" title="jOOQ Console"/>: This small application hooks into jOOQ's execute listener support to allow for tracing, debugging and introspecting any SQL statement executed through the jOOQ API. This includes setting breakpoints, introspecting bind values, running probe SQL statements, ad-hoc patching of SQL, measuring execution times, exporting stack traces. Use this tool to better know your SQL!</li>
										<li><reference id="execute-listeners" title="jOOQ's Execute Listeners"/>: jOOQ allows you to hook your custom execute listeners into jOOQ's SQL statement execution lifecycle in order to centrally coordinate any arbitrary operation performed on SQL being executed. Use this for logging, identity generation, SQL tracing, performance measurements, etc.</li>
										<li><reference id="logging" title="Logging"/>: jOOQ has a standard DEBUG logger built-in, for logging and tracing all your executed SQL statements and fetched result sets</li>
										<li><reference id="stored-procedures" title="Stored Procedures"/>: jOOQ supports stored procedures and functions of your favourite database. All routines and user-defined types are generated and can be included in jOOQ's SQL building API as function references.</li>
										<li><reference id="exporting" title="Exporting"/> and <reference id="importing" title="Importing"/>: jOOQ ships with an API to easily export/import data in various formats</li>
									</ul>
									<p>
										If you're a power user of your favourite, feature-rich database, jOOQ will help you access all of your database's vendor-specific features, such as OLAP features, stored procedures, user-defined types, vendor-specific SQL, functions, etc. Examples are given throughout this manual.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="tutorials">
						<title>Tutorials</title>
						<content><html>
							<p>
								Don't have time to read the full manual? Here are a couple of tutorials that will get you into the most essential parts of jOOQ as quick as possible.
							</p>
						</html></content>

						<sections>
							<section id="jooq-in-7-steps">
								<title>jOOQ in 7 easy steps</title>
								<content><html>
									<p>
										This manual section is intended for new users, to help them get a running application with jOOQ, quickly.
									</p>
								</html></content>

								<sections>
									<section id="jooq-in-7-steps-step1">
										<title>Step 1: Preparation</title>
										<content><html>
											<p>
												If you haven't already downloaded it, download jOOQ:<br/>
												<a href="http://www.jooq.org/download" title="jOOQ download">http://www.jooq.org/download</a>
											</p>

											<p>
												Alternatively, you can create a Maven dependency:
											</p>
</html><xml><![CDATA[<dependency>
  <groupId>org.jooq</groupId>
  <!-- artefacts are jooq, jooq-meta, jooq-codegen -->
  <artifactId>jooq</artifactId>
  <version>{jooq-version}</version>
</dependency>]]></xml><html>

											<p>
												For this example, we'll be using MySQL. If you haven't already downloaded MySQL Connector/J, download it here:<br/>
												<a href="http://dev.mysql.com/downloads/connector/j/" target="_blank" title="MySQL JDBC driver">http://dev.mysql.com/downloads/connector/j/</a>
											</p>

											<p>
												If you don't have a MySQL instance up and running yet, get <a href="http://www.apachefriends.org/en/xampp.html" title="XAMPP">XAMPP</a> now! XAMPP is a simple installation bundle for Apache, MySQL, PHP and Perl
											</p>
										</html></content>
									</section>

									<section id="jooq-in-7-steps-step2">
										<title>Step 2: Your database</title>
										<content><html>
											<p>
												We're going to create a database called "guestbook" and a corresponding "posts" table. Connect to MySQL via your command line client and type the following:
											</p>

</html><sql>CREATE DATABASE guestbook;

CREATE TABLE `posts` (
  `id` bigint(20) NOT NULL,
  `body` varchar(255) DEFAULT NULL,
  `timestamp` datetime DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</sql></content>
									</section>

									<section id="jooq-in-7-steps-step3">
										<title>Step 3: Code generation</title>
										<content><html>
											<p>
												In this step, we're going to use jOOQ's command line tools to generate classes that map to the Posts table we just created. More detailed information about how to set up the jOOQ code generator can be found here:<br/>
												<reference id="code-generation" title="jOOQ manual pages about setting up the code generator"/>
											</p>

											<p>
												The easiest way to generate a schema is to copy the jOOQ jar files (there should be 3) and the MySQL Connector jar file to a temporary directory. Then, create a guestbook.xml that looks like this:
											</p>

</html><xml><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<configuration xmlns="http://www.jooq.org/xsd/jooq-codegen-2.5.0.xsd">
  <!-- Configure the database connection here -->
  <jdbc>
    <driver>com.mysql.jdbc.Driver</driver>
    <url>jdbc:mysql://localhost:3306/guestbook</url>
    <user>root</user>
    <password></password>
  </jdbc>

  <generator>
    <!-- The default code generator. You can override this one, to generate your own code style
         Defaults to org.jooq.util.DefaultGenerator -->
    <name>org.jooq.util.DefaultGenerator</name>

    <database>
      <!-- The database type. The format here is:
           org.util.[database].[database]Database -->
      <name>org.jooq.util.mysql.MySQLDatabase</name>

      <!-- The database schema (or in the absence of schema support, in your RDBMS this
           can be the owner, user, database name) to be generated -->
      <inputSchema>guestbook</inputSchema>

      <!-- All elements that are generated from your schema (several Java regular expressions, separated by comma)
           Watch out for case-sensitivity. Depending on your database, this might be important! -->
      <includes>.*</includes>

      <!-- All elements that are excluded from your schema (several Java regular expressions, separated by comma).
              Excludes match before includes -->
      <excludes></excludes>
    </database>

    <target>
      <!-- The destination package of your generated classes (within the destination directory) -->
      <packageName>test.generated</packageName>

      <!-- The destination directory of your generated classes. Using Maven directory layout here -->
      <directory>C:/workspace/MySQLTest/src/main/java</directory>
    </target>
  </generator>
</configuration>]]></xml><html>
											<p>
												Replace the username with whatever user has the appropriate privileges to query the database meta data. You'll also want to look at the other values and replace as necessary. Here are the two interesting properties:
											</p>
											<p>
												<code>generator.target.package</code> - set this to the parent package you want to create for the generated classes. The setting of <code>test.generated</code> will cause the <code>test.generated.Posts</code> and <code>test.generated.PostsRecord</code> to be created
											</p>
											<p>
												<code>generator.target.directory</code> - the directory to output to.
											</p>

                                            <p>
                                                Once you have the JAR files and library.xml in your temp directory, type this on a Windows machine:
                                            </p>

</html><text>java -classpath jooq-{jooq-version}.jar;jooq-meta-{jooq-version}.jar;jooq-codegen-{jooq-version}.jar;mysql-connector-java-5.1.18-bin.jar;.
  org.jooq.util.GenerationTool /library.xml
</text><html>

                                            <p>
                                                ... or type this on a UNIX / Linux / Mac system (colons instead of semi-colons):
                                            </p>

</html><text>java -classpath jooq-{jooq-version}.jar:jooq-meta-{jooq-version}.jar:jooq-codegen-{jooq-version}.jar:mysql-connector-java-5.1.18-bin.jar:.
  org.jooq.util.GenerationTool /library.xml
</text><html>

                                            <p>
                                                There are two things to note:
                                            </p>

                                            <ol>
                                                <li>The prefix slash before the <strong>/library.xml</strong>. Even though it's in our working directory, we need to prepend a slash, as the configuration file is loaded from the classpath.</li>
                                                <li>The "trailing" period in the classpath: <strong>.</strong>. We need this because we want the current directory on the classpath in order to find the above <strong>/library.xml</strong> file at the root of your classpath.</li>
                                            </ol>

                                            <p>
                                                Replace the filenames with your actual filenames. In this example, jOOQ {jooq-version} is being used. If everything has worked, you should see this in your console output:
                                            </p>

</html><text>Nov 1, 2011 7:25:06 PM org.jooq.impl.JooqLogger info
INFO: Initialising properties  : /guestbook.xml
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Database parameters
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ----------------------------------------------------------
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   dialect                : MYSQL
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   schema                 : guestbook
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   target dir             : /Users/jOOQ/Documents/workspace/MySQLTest/src
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO:   target package         : test.generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ----------------------------------------------------------
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Emptying                 : /Users/jOOQ/workspace/MySQLTest/src/test/generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating classes in    : /Users/jOOQ/workspace/MySQLTest/src/test/generated
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating schema        : Guestbook.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating factory       : GuestbookFactory.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Schema generated         : Total: 122.18ms
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Sequences fetched        : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Masterdata tables fetched: 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Tables fetched           : 5 (5 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating tables        : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: ARRAYs fetched           : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Enums fetched            : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: UDTs fetched             : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating table         : Posts.java
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Tables generated         : Total: 680.464ms, +558.284ms
Nov 1, 2011 7:25:07 PM org.jooq.impl.JooqLogger info
INFO: Generating Keys          : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Keys generated           : Total: 718.621ms, +38.157ms
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Generating records       : /Users/jOOQ/workspace/MySQLTest/src/test/generated/tables/records
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Generating record        : PostsRecord.java
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Table records generated  : Total: 782.545ms, +63.924ms
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Routines fetched         : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: Packages fetched         : 0 (0 included, 0 excluded)
Nov 1, 2011 7:25:08 PM org.jooq.impl.JooqLogger info
INFO: GENERATION FINISHED!     : Total: 791.688ms, +9.143ms
</text></content>
									</section>

									<section id="jooq-in-7-steps-step4">
										<title>Step 4: Connect to your database</title>
										<content><html>
											<p>
												Let's just write a vanilla main class in the project containing the generated classes:
											</p>

</html><java><![CDATA[// For convenience, always static import your generated tables and jOOQ functions to decrease verbosity:
import static test.generated.Tables.*;
import static org.jooq.impl.Factory.*;

import java.sql.*;

public class Main {
    public static void main(String[] args) {
        Connection conn = null;

        String userName = "root";
        String password = "";
        String url = "jdbc:mysql://localhost:3306/guestbook";

        try {
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            conn = DriverManager.getConnection(url, userName, password);
        } catch (Exception e) {
            // For the sake of this tutorial, let's keep exception handling simple
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ignore) {
                }
            }
        }
    }
}]]></java><html>

											<p>
												This is pretty standard code for establishing a MySQL connection.
											</p>
										</html></content>
									</section>

									<section id="jooq-in-7-steps-step5">
										<title>Step 5: Querying</title>
										<content><html>
											<p>
												Let's add a simple query:
											</p>

</html><java><![CDATA[Factory create = new Factory(conn, SQLDialect.MYSQL);
Result<Record> result = create.select().from(POSTS).fetch();]]></java><html>

											<p>
												First get an instance of <code>Factory</code> so we can write a simple <code>SELECT</code> query. We pass an instance of the MySQL connection to <code>Factory</code>. Note that the factory doesn't close the connection. We'll have to do that ourselves.
											</p>
											<p>
												We then use jOOQ's DSL to return an instance of Result. We'll be using this result in the next step.
											</p>
										</html></content>
									</section>

									<section id="jooq-in-7-steps-step6">
										<title>Step 6: Iterating</title>
										<content><html>
											<p>
												After the line where we retrieve the results, let's iterate over the results and print out the data:
											</p>

</html><java><![CDATA[for (Record r : result) {
    Long id = r.getValue(POSTS.ID);
    String title = r.getValue(POSTS.TITLE);
    String description = r.getValue(POSTS.BODY);

    System.out.println("ID: " + id + " title: " + title + " desciption: " + description);
}]]></java><html>

											<p>
												The full program should now look like this:
											</p>

</html><java><![CDATA[package test;

// For convenience, always static import your generated tables and
// jOOQ functions to decrease verbosity:
import static test.generated.Tables.*;
import static org.jooq.impl.Factory.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

import org.jooq.Record;
import org.jooq.Result;

import test.generated.GuestbookFactory;
import test.generated.tables.Posts;

public class Main {

    /**
     * @param args
     */
    public static void main(String[] args) {
        Connection conn = null;

        String userName = "root";
        String password = "";
        String url = "jdbc:mysql://localhost:3306/guestbook";

        try {
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            conn = DriverManager.getConnection(url, userName, password);

            GuestbookFactory create = new GuestbookFactory(conn);
            Result<Record> result = create.select().from(POSTS).fetch();

            for (Record r : result) {
                Long id = r.getValue(POSTS.ID);
                String title = r.getValue(POSTS.TITLE);
                String description = r.getValue(POSTS.BODY);

                System.out.println("ID: " + id + " title: " + title + " desciption: " + description);
            }
        } catch (Exception e) {
            // For the sake of this tutorial, let's keep exception handling simple
            e.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ignore) {
                }
            }
        }
    }
}]]></java></content>
									</section>

									<section id="jooq-in-7-steps-step7">
										<title>Step 7: Explore!</title>
										<content><html>
											<p>
												jOOQ has grown to be a comprehensive SQL library. For more information, please consider the manual:<br/>
												<a href="http://www.jooq.org/manual/" title="jOOQ Manual">http://www.jooq.org/manual/</a>
											</p>
											<p>
												... explore the Javadoc:<br/>
												<a href="http://www.jooq.org/javadoc/latest/" title="jOOQ Javadoc">http://www.jooq.org/javadoc/latest/</a>
											</p>
											<p>
												... or join the news group:<br/>
												<a href="https://groups.google.com/forum/#!forum/jooq-user" title="jOOQ news group">https://groups.google.com/forum/#!forum/jooq-user</a>
											</p>
											<p>
											    This tutorial is the courtesy of Ikai Lan. See the original source here:<br/>
											    <a href="http://ikaisays.com/2011/11/01/getting-started-with-jooq-a-tutorial/" target="_blank" title="Ikai Lan's jOOQ tutorial">http://ikaisays.com/2011/11/01/getting-started-with-jooq-a-tutorial/</a>
											</p>
										</html></content>
									</section>
								</sections>
							</section>

							<section id="jooq-in-modern-ides">
								<title>Using jOOQ in modern IDEs</title>
								<content><html>
									<p>Feel free to contribute a tutorial!</p>
								</html></content>
							</section>

							<section id="jooq-with-spring">
								<title>Using jOOQ with Spring</title>
								<content><html>
									<p>Feel free to contribute a tutorial!</p>
								</html></content>
							</section>

							<section id="a-simple-web-application">
								<title>A simple web application with jOOQ</title>
								<content><html>
									<p>Feel free to contribute a tutorial!</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="dependencies">
						<title>Dependencies</title>
						<content><html>
							<p>
								jOOQ has no dependencies on any third-party libraries. This rule has some exceptions:
							</p>
							<ul>
								<li><reference id="logging" title="logging APIs"/> are referenced as "optional dependencies". jOOQ tries to find slf4j or log4j on the classpath. If it fails, it will use the <reference class="java.util.logging.Logger"/></li>
								<li>Oracle ojdbc types used for array creation are loaded using reflection.</li>
								<li>Small libraries with compatible licenses are incorporated into jOOQ (<a href="http://code.google.com/p/joor/">jOOR</a>, <a href="http://code.google.com/p/joou/">jOOU</a>, <a href="http://opencsv.sourceforge.net/">OpenCSV</a>, <a href="http://code.google.com/p/json-simple/">json simple</a>, <a href="http://commons.apache.org/lang/">commons-lang</a>)</li>
								<li>javax.persistence and javax.validation will be needed if you activate the relevant <reference id="code-generation" title="code generation flags"/></li>
							</ul>

							<h3>Build your own</h3>
							<p>
								In order to build jOOQ, please download the sources from <a href="https://github.com/jOOQ/jOOQ">https://github.com/jOOQ/jOOQ</a> and use Maven to build it, preferably in Eclipse.
							</p>
						</html></content>
					</section>
				</sections>
			</section>

			<section id="sql-building">
				<title>SQL building</title>
				<content><html>
					<p>
					    SQL is a declarative language that is hard to integrate into procedural, object-oriented, functional or any other type of programming languages. jOOQ's philosophy is to give SQL the credit it deserves and integrate SQL itself as an <a href="http://en.wikipedia.org/wiki/Domain_Specific_Language">"internal domain specific language"</a> directly into Java.
					</p>
					<p>
						With this philosophy in mind, SQL building is the main feature of jOOQ. All other features (such as <reference id="sql-execution"/> and <reference id="code-generation"/>) are mere convenience built on top of jOOQ's SQL building capabilities.
					</p>
					<p>
						This section explains all about the various syntax elements involved with jOOQ's SQL building capabilities. For a complete overview of all syntax elements, please refer to the manual's section about <reference id="reference-bnf-notation"/>
					</p>
				</html></content>

				<sections>
					<section id="factory">
						<title>The Factory class</title>
						<content><html>
							<p>
								jOOQ exposes a lot of interfaces and hides most implementation facts from client code. The reasons for this are:
							</p>
							<ul>
								<li>Interface-driven design. This allows for modelling queries in a fluent API most efficiently</li>
								<li>Reduction of complexity for client code.</li>
								<li>API guarantee. You only depend on the exposed interfaces, not concrete (potentially dialect-specific) implementations.</li>
							</ul>
							<p>
								The <reference class="org.jooq.impl.Factory"/> class is the main class from where you will create all jOOQ objects.	The Factory serves two types of purposes:
							</p>
							<ul>
								<li>It serves as a static factory for <reference id="table-expressions" title="table expressions"/>, <reference id="column-expressions" title="column expressions"/> (or "fields"), <reference id="conditional-expressions" title="conditional expressions"/> and many other <reference id="queryparts" title="QueryParts"/>.</li>
								<li>It implements <reference class="org.jooq.Configuration"/>, an object that configures jOOQ's behaviour when executing queries (see <reference id="sql-execution"/> for more details). Factories allow for creating <reference id="sql-statements" title="SQL statements"/> that are already "configured" and ready for execution.</li>
							</ul>

							<h3>The static Factory API</h3>
							<p>
								With jOOQ 2.0, static factory methods have been introduced in order to make client code look more like SQL. Ideally, when working with jOOQ, you will simply static import all methods from the Factory class:
							</p>
							</html><java>import static org.jooq.impl.Factory.*;</java><html>
							<p>
							    Note, that when working with Eclipse, you could also add the Factory to your favourites. This will allow to access functions even more fluently:
							</p>
</html><java>concat(trim(FIRST_NAME), trim(LAST_NAME));
// ... which is in fact the same as:
Factory.concat(Factory.trim(FIRST_NAME), Factory.trim(LAST_NAME));</java><html>

							<h3>The Factory as a Configuration object</h3>
							<p>
							    As any Configuration object, a Factory can be supplied with these objects:
							</p>
							<ul>
								<li><reference class="org.jooq.SQLDialect"/> : The dialect of your database. This may be any of the currently supported database types (see <reference id="sql-dialects"/> for more details)</li>
								<li><reference class="java.sql.Connection"/> : An optional JDBC Connection that will be re-used for the whole lifecycle of your Factory (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="java.sql.DataSource"/> : An optional JDBC DataSource that will be re-used for the whole lifecycle of your Factory. If you prefer using DataSources over Connections, jOOQ will internally fetch new Connections from your DataSource, conveniently closing them again after query execution. This is particularly useful in J2EE or Spring contexts (see <reference id="connection-vs-datasource"/> for more details)</li>
    							<li><reference class="org.jooq.conf.Settings"/> : An optional runtime configuration (see <reference id="custom-settings"/> for more details)</li>
							</ul>
							<p>
								As a Configuration object, a Factory can construct <reference id="sql-statements" title="statements"/>, for later <reference id="sql-execution" title="execution"/>. An example is given here:
							</p>
</html><java><![CDATA[// The Factory is "configured" with a Connection and a SQLDialect
Factory create = new Factory(connection, dialect);

// This select statement contains an internal reference to the Factory:
Select<?> select = create.selectOne();

// Using the internally referenced Factory, the select statement can now be executed:
Result<?> result = select.fetch();]]></java></content>

						<sections>
							<section id="sql-dialects">
								<title>SQL Dialect</title>
								<content><html>
									<p>
										While jOOQ tries to represent the SQL standard as much as possible, many features are vendor-specific to a given database and to its "SQL dialect". jOOQ models this using the <reference class="org.jooq.SQLDialect"/> enum type.
									</p>
									<p>
										The SQL dialect is one of the main attributes of a <reference id="factory" title="Factory"/>. Queries created from such factories will assume dialect-specific behaviour when <reference id="sql-rendering" title="rendering SQL"/> and <reference id="variable-binding" title="binding bind values"/>.
									</p>
									<p>
										Some parts of the jOOQ API are officially supported only by a given subset of the supported SQL dialects. For instance, the <reference id="connect-by-clause" title="Oracle CONNECT BY clause"/>, which is supported by the Oracle and CUBRID databases, is annotated with a <reference class="org.jooq.Support"/> annotation, as such:
									</p>
</html><java><![CDATA[/**
 * Add an Oracle-specific <code>CONNECT BY</code> clause to the query
 */
@Support({ CUBRID })
SelectConnectByConditionStep connectBy(Condition condition);]]></java><html>
									<p>
									    jOOQ API methods which are not annotated with the <reference class="org.jooq.Support"/> annotation, or which are annotated with the Support annotation, but without any SQL dialects can be safely used in all SQL dialects. An example for this is the <reference id="select-statement" title="SELECT statement"/> factory method:
									</p>
</html><java><![CDATA[/**
 * Create a new DSL select statement.
 */
@Support
SelectSelectStep select(Field<?>... fields);]]></java><html>

									<h3>jOOQ's SQL clause emulation capabilities</h3>
									<p>
										The aforementioned Support annotation does not only designate, which databases natively support a feature. It also indicates that a feature is emulated by jOOQ for some databases lacking this feature. An example of this is the <reference id="distinct-predicate" title="DISTINCT predicate"/>, a predicate syntax defined by SQL:1999 and implemented only by H2, HSQLDB, and Postgres:
									</p>

</html><sql><![CDATA[A IS DISTINCT FROM B]]></sql><html>

									<p>
										Nevertheless, the <code>IS DISTINCT FROM</code> predicate is supported in all dialects, as its semantics can be expressed with an equivalent <reference id="case-expressions" title="CASE expression"/>. For more details, see the manual's section about the <reference id="distinct-predicate" title="DISTINCT predicate"/>.
									</p>

									<h3>jOOQ and the Oracle SQL dialect</h3>
									<p>
										Oracle SQL is much more expressive than many other SQL dialects. It features many unique keywords, clauses and functions that are out of scope for the SQL standard. Some examples for this are
									</p>
									<ul>
										<li>The <reference id="connect-by-clause" title="CONNECT BY clause"/>, for hierarchical queries</li>
										<li>The <reference id="pivot-tables" title="PIVOT"/> keyword for creating PIVOT tables</li>
										<li><reference id="oracle-packages" title="Packages"/>, <reference id="oracle-member-procedures" title="object-oriented user-defined types, member procedures"/> as described in the section about <reference id="stored-procedures" title="stored procedures and functions"/></li>
										<li>Advanced analytical functions as described in the section about <reference id="window-functions" title="window functions"/></li>
									</ul>

									<p>
										jOOQ has a historic affinity to Oracle's SQL extensions. If something is supported in Oracle SQL, it has a high probability of making it into the jOOQ API
									</p>
								</html></content>
							</section>

							<section id="connection-vs-datasource">
								<title>Connection vs. DataSource</title>
								<content><html>
									<h3>Interact with JDBC Connections</h3>
									<p>
										While you can use jOOQ for <reference id="sql-building" title="SQL building"/> only, you can also run queries against a JDBC <reference class="java.sql.Connection"/>. Internally, jOOQ creates <reference class="java.sql.Statement"/> or <reference class="java.sql.PreparedStatement"/> objects from such a Connection, in order to execute statements. The normal operation mode is to provide a <reference id="factory" title="Factory"/> with a JDBC Connection, whose lifecycle you will control yourself. This means that jOOQ will not actively close connections, rollback or commit transactions.
									</p>
									<h3>Interact with JDBC DataSources</h3>
									<p>
										If you're in a J2EE or Spring context, however, you may wish to use a <reference class="javax.sql.DataSource"/> instead. Currently, Connections obtained from such a DataSource will be closed after query execution by jOOQ. The semantics of such a close operation should be the returning of the connection into a connection pool, not the actual closing of the underlying connection. Typically, this makes sense in an environment using distributed JTA transactions. An example of using DataSources with jOOQ can be seen in the tutorial section about <reference id="jooq-with-spring" title="using jOOQ with Spring"/>.
									</p>
								</html></content>
							</section>

							<section id="custom-settings">
								<title>Custom Settings</title>
								<content><html>
									<p>
										The jOOQ Factory allows for some optional configuration elements to be used by advanced users. The <reference class="org.jooq.conf.Settings" /> class is a JAXB-annotated type, that can be provided to a Factory in several ways:
									</p>
									<ul>
										<li>In the constructor. This will override default settings below</li>
										<li>From a location specified by a JVM parameter: -Dorg.jooq.settings</li>
										<li>From the classpath at /jooq-settings.xml</li>
										<li>From the settings defaults, as specified in <a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a></li>
									</ul>
									<h3>Example</h3>
									<p>
										For example, if you want to indicate to jOOQ, that it should inline all bind variables, and execute static <reference class="java.sql.Statement"/> instead of binding its variables to <reference class="java.sql.PreparedStatement"/>, you can do so by using the following Factory:
									</p>
</html><java><![CDATA[Settings settings = new Settings();
settings.setStatementType(StatementType.STATIC_STATEMENT);
Factory create = new Factory(connection, dialect, settings);]]></java><html>
									<p>
										Subsequent sections of the manual contain some more in-depth explanations about these settings:
									</p>
									<ul>
										<li>
		     								<reference id="schema-mapping" title="Runtime schema and table mapping"/>
		   								</li>
		     							<li>
		     								<reference id="execute-listeners" title="Execute listeners and SQL tracing"/>
		     							</li>
		     							<li>
		     								<reference id="optimistic-locking" title="Execute CRUD with optimistic locking enabled"/>
		     							</li>
		     							<li>
		     								<reference id="logging" title="Enabling DEBUG logging of all executed SQL"/>
		     							</li>
		   							</ul>
		   							<p>
										Please refer to the jOOQ runtime configuration XSD for more details:<br/>
										<a href="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd" title="The jOOQ Runtime configuration XSD">http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd</a>
									</p>
								</html></content>
							</section>

							<section id="runtime-schema-mapping">
								<title>Runtime schema and table mapping</title>
								<content><html>
									<h3>Mapping your DEV schema to a productive environment</h3>
									<p>
										You may wish to design your database in a way that you have several instances of your schema. This is useful when you want to cleanly separate data belonging to several customers / organisation units / branches / users and put each of those entities' data in a separate database or schema.
									</p>

									<p>
										In our AUTHOR example this would mean that you provide a book reference database to several companies, such as My Book World and Books R Us. In that case, you'll probably have a schema setup like this:
									</p>
									<ul>
										<li>DEV: Your development schema. This will be the schema that you base code generation upon, with jOOQ </li>
										<li>MY_BOOK_WORLD: The schema instance for My Book World </li>
										<li>BOOKS_R_US: The schema instance for Books R Us </li>
									</ul>

									<h3>Mapping DEV to MY_BOOK_WORLD with jOOQ</h3>
									<p>
										When a user from My Book World logs in, you want them to access the MY_BOOK_WORLD schema using classes generated from DEV. This can be achieved with the <reference class="org.jooq.conf.RenderMapping"/> class, that you can equip your Factory's <reference id="custom-settings" title="settings"/> with. Take the following example:
									</p>

</html><java>Settings settings = new Settings()
    .withRenderMapping(new RenderMapping()
    .withSchemata(
        new MappedSchema().withInput("DEV")
                          .withOutput("MY_BOOK_WORLD")));

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries with the "mapped" factory
create.selectFrom(AUTHOR).fetch();</java><html>

									<p>
										The query executed with a Factory equipped with the above mapping will in fact produce this SQL statement:
									</p>

</html><sql>SELECT * FROM MY_BOOK_WORLD.AUTHOR</sql><html>
									<p>
										Even if AUTHOR was generated from DEV.
									</p>

									<h3>Mapping several schemata</h3>
									<p>
										Your development database may not be restricted to hold only one DEV schema. You may also have a LOG schema and a MASTER schema. Let's say the MASTER schema is shared among all customers, but each customer has their own LOG schema instance. Then you can enhance your RenderMapping like this (e.g. using an XML configuration file):
									</p>

</html><xml><![CDATA[<settings xmlns="http://www.jooq.org/xsd/jooq-runtime-2.5.0.xsd">
  <renderMapping>
    <schemata>
      <schema>
        <input>DEV</input>
        <output>MY_BOOK_WORLD</output>
      </schema>
      <schema>
        <input>LOG</input>
        <output>MY_BOOK_WORLD_LOG</output>
      </schema>
    </schemata>
  </renderMapping>
</settings>]]></xml><html>

                            		<p>
                            			Note, you can load the above XML file like this:
                           			</p>

</html><java>Settings settings = JAXB.unmarshal(new File("jooq-runtime.xml"), Settings.class);</java><html>

									<p>
										This will map generated classes from DEV to MY_BOOK_WORLD, from LOG to MY_BOOK_WORLD_LOG, but leave the MASTER schema alone. Whenever you want to change your mapping configuration, you will have to create a new Factory
									</p>


									<h3>Using a default schema</h3>
									<p>
										Another option to switch schema names is to use a default schema for the Factory's underlying Connection. Many RDBMS support a USE or SET SCHEMA command, which you can call like this:
									</p>

</html><java>// Set the default schema
Schema MY_BOOK_WORLD = ...
create.use(MY_BOOK_WORLD);

// Run queries with factory having a default schema
create.selectFrom(AUTHOR).fetch();</java><html>

									<p>
										Queries generated from the above Factory will produce this kind of SQL statement:
									</p>

</html><sql>-- the schema name is omitted from all SQL constructs.
SELECT * FROM AUTHOR</sql><html>

                            		<p>
                            			If you wish not to render any schema name at all, use the following Settings property for this:
                           			</p>


</html><java>Settings settings = new Settings()
    .withRenderSchema(false);

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries that omit rendering schema names
create.selectFrom(AUTHOR).fetch();</java><html>

									<h3>Mapping of tables</h3>
									<p>
										Not only schemata can be mapped, but also tables. If you are not the owner of the database your application connects to, you might need to install your schema with some sort of prefix to every table. In our examples, this might mean that you will have to map DEV.AUTHOR to something MY_BOOK_WORLD.MY_APP__AUTHOR, where MY_APP__ is a prefix applied to all of your tables. This can be achieved by creating the following mapping:
									</p>

</html><java>Settings settings = new Settings()
    .withRenderMapping(new RenderMapping()
    .withSchemata(
        new MappedSchema().withInput("DEV")
                          .withOutput("MY_BOOK_WORLD")
                          .withTables(
         new MappedTable().withInput("AUTHOR")
                          .withOutput("MY_APP__AUTHOR"))));

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries with the "mapped" factory
create.selectFrom(AUTHOR).fetch();</java><html>

									<p>
										The query executed with a Factory equipped with the above mapping will in fact produce this SQL statement:
									</p>

</html><sql>SELECT * FROM MY_BOOK_WORLD.MY_APP__AUTHOR</sql><html>

		                            <p>
		                           		Table mapping and schema mapping can be applied independently, by specifying several MappedSchema entries in the above configuration. jOOQ will process them in order of appearance and map at first match. Note that you can always omit a MappedSchema's output value, in case of which, only the table mapping is applied. If you omit a MappedSchema's input value, the table mapping is applied to all schemata!
		                            </p>

									<h3>Hard-wiring mappings at code-generation time</h3>
									<p>
										Note that the manual's section about <reference id="schema-mapping" title="code generation schema mapping"/> explains how you can hard-wire your schema mappings at code generation time
									</p>
								</html></content>
							</section>

							<section id="factory-subclasses">
								<title>Factory subclasses</title>
								<content><html>
									<p>
										There are a couple of subclasses for the general Factory. Each SQL dialect has its own dialect-specific factory. For instance, if you're only using the MySQL dialect, you can choose to create a new Factory using any of the following types:
									</p>
</html><java>// A general, dialect-unspecific factory
Factory create = new Factory(connection, SQLDialect.MYSQL);

// A MySQL-specific factory
MySQLFactory create = new MySQLFactory(connection);</java><html>
									<p>
										The advantage of using a dialect-specific Factory lies in the fact,	that you have access to more proprietary RDMBS functionality. This may include:
									</p>
									<ul>
		    							<li>MySQL's encryption functions</li>
		    							<li>PL/SQL constructs, pgplsql, or any other dialect's ROUTINE-language (maybe in the future)</li>
									</ul>
									<p>
										Another type of Factory subclasses are each generated schema's factories. If you generate your schema TEST, then you will have access to a TestFactory. By default, such a schema-specific Factory will not render the schema name.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="sql-statements">
						<title>SQL Statements</title>
						<content><html>
							<p>
								jOOQ currently supports 6 types of SQL statements. All of these statements are constructed from a Factory instance with an optional <reference id="connection-vs-datasource" title="JDBC Connection or DataSource"/>. If supplied with a Connection or DataSource, they can be executed. Depending on the <reference id="query-vs-resultquery" title="query type"/>, executed queries can return results.
							</p>
						</html></content>

						<sections>
							<section id="dsl-and-non-dsl">
								<title>jOOQ's DSL and non-DSL API</title>
								<content><html>
									<p>
										jOOQ ships with its own DSL (or	<a href="http://en.wikipedia.org/wiki/Domain-specific_language" title="Domain Specific Language">Domain Specific Language</a>) that	emulates SQL in Java. This means, that you can	write SQL statements almost as if Java natively supported it, just like .NET's C# does with <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL.</a>
									</p>
									<p>
										Here is an example to illustrate what that means:
									</p>

</html><code-pair><sql><![CDATA[-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:
SELECT *
  FROM author a
  JOIN book b ON a.id = b.author_id
 WHERE a.year_of_birth > 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title]]></sql><java><![CDATA[Result<Record> result =
create.select()
      .from(AUTHOR.as("a"))
      .join(BOOK.as("b")).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE)
      .fetch();]]></java></code-pair><html>

									<p>
										We'll see how the aliasing works later in the section about <reference id="aliased-tables" title="aliased tables"/>
									</p>

									<h3>jOOQ as an internal domain specific language in Java (a.k.a. the DSL-API)</h3>
									<p>
										Many other frameworks have similar APIs with similar feature sets. Yet, what makes jOOQ special is its informal <reference id="reference-bnf-notation" title="BNF notation"/> modelling a unified SQL dialect suitable for many vendor-specific dialects, and implementing that BNF notation as a hierarchy of interfaces in Java. This concept is extremely powerful, when <reference id="jooq-in-modern-ides" title="using jOOQ in modern IDEs" /> with syntax completion. Not only can you code much faster, your SQL code will be compile-checked to a certain extent. An example of a DSL query equivalent to the previous one is given here:
									</p>
</html><java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java><html>

                         			<p>
                         				Unlike other, simpler frameworks that use <a href="http://en.wikipedia.org/wiki/Fluent_interface">"fluent APIs"</a> or <a href="http://en.wikipedia.org/wiki/Method_chaining">"method chaining"</a>, jOOQ's BNF-based interface hierarchy will not allow bad query syntax. The following will not compile, for instance:
                         			</p>
</html><java><![CDATA[Factory create = new Factory(connection, dialect);
Result<?> result = create.select()
                         .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                      //  ^^^^ "join" is not possible here
                         .from(AUTHOR)
                         .fetch();

Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .fetch();
                      //  ^^^^^ "on" is missing here

Result<?> result = create.select(rowNumber())
                      //         ^^^^^^^^^ "over()" is missing here
                         .from(AUTHOR)
                         .fetch();]]></java><html>

									<h3>History of SQL building and incremental query building (a.k.a. the non-DSL API)</h3>
									<p>
										Historically, jOOQ started out as an object-oriented SQL builder library like any other. This meant that all queries and their syntactic components were modeled as so-called <reference id="queryparts" title="QueryParts"/>, which delegate <reference id="sql-rendering" title="SQL rendering"/> and <reference id="variable-binding" title="variable binding"/> to child components. This part of the API will be referred to as the non-DSL API, which is still maintained and used internally by jOOQ for incremental query building. An example of incremental query building is given here:
									</p>
</html><java><![CDATA[Factory create = new Factory(connection, dialect);
SelectQuery query = create.selectQuery();
query.addFrom(AUTHOR);

// Join books only under certain circumstances
if (join) {
    query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));
}

Result<?> result = query.fetch();]]></java><html>

									<p>
										This query is equivalent to the one shown before using the DSL syntax. In fact, internally, the DSL API constructs precisely this QueryObject. Note, that you can always access the SelectQuery object to switch between DSL and non-DSL APIs:
									</p>

</html><java><![CDATA[Factory create = new Factory(connection, dialect);
SelectFinalStep select = create.select().from(AUTHOR);

// Add the JOIN clause on the internal QueryObject representation
SelectQuery query = select.getQuery();
query.addJoin(BOOK, BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java><html>

									<h3>Mutability</h3>
									<p>
										Note, that for historic reasons, the DSL API mixes mutable and immutable behaviour with respect to the internal representation of the <reference id="queryparts" title="QueryPart"/> being constructed. While creating <reference id="conditional-expressions" title="conditional expressions"/>, <reference id="column-expressions" title="column expressions"/> (such as functions) assumes immutable behaviour, creating <reference id="sql-statements" title="SQL statements"/> does not. In other words, the following can be said:
									</p>

</html><java><![CDATA[// Conditional expressions (immutable)
// -----------------------------------
Condition a = BOOK.TITLE.equal("1984");
Condition b = BOOK.TITLE.equal("Animal Farm");

// The following can be said
a       != a.or(b); // or() does not modify a
a.or(b) != a.or(b); // or() always creates new objects

// Statements (mutable)
// --------------------
SelectFromStep s1 = create.select();
SelectJoinStep s2 = s1.from(BOOK);
SelectJoinStep s3 = s1.from(AUTHOR);

// The following can be said
s1 == s2; // The internal object is always the same
s2 == s3; // The internal object is always the same]]></java><html>

									<p>
										Mutability may be removed in a future version of jOOQ.
									</p>
								</html></content>
							</section>

							<section id="select-statement">
								<title>The SELECT statement</title>
								<content><html>
									<p>
										When you don't just perform <reference id="crud-with-updatablerecords" title="CRUD"/> (i.e. SELECT * FROM your_table WHERE ID = ?), you're usually generating new record types using custom projections. With jOOQ, this is as intuitive, as if using SQL directly. A more or less complete example of the "standard" SQL syntax, plus some extensions, is provided by a query like this:
									</p>
</html><code-pair>
<sql><![CDATA[-- get all authors' first and last names, and the number
-- of books they've written in German, if they have written
-- more than five books in German in the last three years
-- (from 2011), and sort those authors by last names
-- limiting results to the second and third row, locking
-- the rows for a subsequent update... whew!

  SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)
    FROM AUTHOR
    JOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_ID
   WHERE BOOK.LANGUAGE = 'DE'
     AND BOOK.PUBLISHED > '2008-01-01'
GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME
  HAVING COUNT(*) > 5
ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRST
   LIMIT 2
  OFFSET 1
     FOR UPDATE]]></sql><java><![CDATA[// And with jOOQ...




Factory create = new Factory(connection, dialect);

create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
      .from(AUTHOR)
      .join(BOOK).on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
      .where(BOOK.LANGUAGE.equal("DE"))
      .and(BOOK.PUBLISHED.greaterThan("2008-01-01"))
      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .having(count().greaterThan(5))
      .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(2)
      .offset(1)
      .forUpdate();]]></java>
</code-pair><html>

									<p>
										Details about the various clauses of this query will be provided in subsequent sections
									</p>

									<h3>SELECT from single tables</h3>
									<p>
										A very similar, but limited API is available, if you want to select from single tables in order to retrieve <reference id="crud-with-updatablerecords" title="TableRecords or even UpdatableRecords"/>. The decision, which type of select to create is already made at the very first step, when you create the SELECT statement with the Factory:
									</p>

</html><java><![CDATA[public <R extends Record> SimpleSelectWhereStep<R> selectFrom(Table<R> table);]]></java><html>
									<p>
										As you can see, there is no way to further restrict/project the selected fields. This just selects all known TableFields in the supplied Table, and it also binds &lt;R extends Record&gt; to your Table's associated Record. An example of such a Query would then be:
									</p>
</html><java><![CDATA[BookRecord book = create.selectFrom(BOOK)
                        .where(BOOK.LANGUAGE.equal("DE"))
                        .orderBy(BOOK.TITLE)
                        .fetchAny();]]></java><html>

                   					<p>
                   						The simple SELECT API is limited in the way that it does not support any of these clauses:
                   					</p>
                   					<ul>
                   						<li><reference id="select-clause"/></li>
                   						<li><reference id="join-clause"/></li>
                   						<li><reference id="group-by-clause"/></li>
                   						<li><reference id="having-clause"/></li>
                   					</ul>
                   					<p>
                   						In most parts of this manual, it is assumed that you do not use the simple SELECT API. For more information about the simple SELECT API, see the manual's section about <reference id="record-vs-tablerecord" title="fetching strongly or weakly typed records"/>.
                   					</p>
								</html></content>

								<sections>
									<section id="select-clause">
										<title>The SELECT clause</title>
										<content><html>
											<p>
												The SELECT clause lets you project your own record types, referencing table fields, functions, arithmetic expressions, etc. The Factory provides several methods for expressing a SELECT clause:
											</p>

</html><code-pair>
<sql><![CDATA[-- The SELECT clause
SELECT BOOK.ID, BOOK.TITLE
SELECT BOOK.ID, TRIM(BOOK.TITLE)
]]></sql><java><![CDATA[// Provide a varargs Fields list to the SELECT clause:
Select<?> s1 = create.select(BOOK.ID, BOOK.TITLE);
Select<?> s2 = create.select(BOOK.ID, trim(BOOK.TITLE));]]></java>
</code-pair><html>

											<p>
												Some commonly used projections can be easily created using convenience methods:
											</p>

</html><code-pair>
<sql><![CDATA[-- Simple SELECTs
SELECT COUNT(*)
SELECT 0 -- Not a bind variable
SELECT 1 -- Not a bind variable
]]></sql><java><![CDATA[// Select commonly used values
Select<?> select1 = create.selectCount();
Select<?> select2 = create.selectZero();
Select<?> select2 = create.selectOne();]]></java>
</code-pair><html>

											<p>
												See more details about functions and expressions in the manual's section about <reference id="column-expressions"/>
											</p>

											<h3>The SELECT DISTINCT clause</h3>
											<p>
												The DISTINCT keyword can be included in the method name, constructing a SELECT clause
											</p>

</html><code-pair>
<sql><![CDATA[SELECT DISTINCT BOOK.TITLE]]></sql><java><![CDATA[Select<?> select1 = create.selectDistinct(BOOK.TITLE);]]></java>
</code-pair><html>
										</html></content>
									</section>

									<section id="from-clause">
										<title>The FROM clause</title>
										<content><html>
											<p>
												The SQL FROM clause allows for specifying any number of <reference id="table-expressions" title="table expressions"/> to select data from. The following are examples of how to form normal FROM clauses:
											</p>

</html><code-pair>
	<sql><![CDATA[SELECT 1 FROM BOOK
SELECT 1 FROM BOOK, AUTHOR
SELECT 1 FROM BOOK "b", AUTHOR "a"]]></sql><java><![CDATA[create.selectOne().from(BOOK);
create.selectOne().from(BOOK, AUTHOR);
create.selectOne().from(BOOK.as("b"), AUTHOR.as("a"));]]></java>
</code-pair><html>

											<p>
												Read more about aliasing in the manual's section about <reference id="aliased-tables" title="aliased tables"/>.
											</p>

											<h3>More advanced table expressions</h3>
											<p>
												Apart from simple tables, you can pass any arbitrary <reference id="table-expressions" title="table expression"/> to the jOOQ FROM clause. This may include <reference id="array-and-cursor-unnesting" title="unnested cursors"/> in Oracle:
											</p>

</html><code-pair>
	<sql><![CDATA[SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS'));]]></sql><java><![CDATA[create.select()
      .from(table(DbmsXplan.displayCursor(null, null, "ALLSTATS"));]]></java>
</code-pair><html>

											<p>
												Note, in order to access the DbmsXplan package, you can use the <reference id="code-generation" title="code generator"/> to generate Oracle's SYS schema.
											</p>


											<h3>Selecting FROM DUAL with jOOQ</h3>
											<p>
												In many SQL dialects, FROM is a mandatory clause, in some it isn't. jOOQ allows you to omit the FROM clause, returning just one record. An example:
											</p>

</html><code-pair>
	<sql><![CDATA[SELECT 1 FROM DUAL
SELECT 1]]></sql><java><![CDATA[new Factory(SQLDialect.ORACLE).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES).selectOne().getSQL();]]></java>
</code-pair><html>

											<p>
												Read more about dual or dummy tables in the manual's section about <reference id="dual" title="the DUAL table"/>. The following are examples of how to form normal FROM clauses:
											</p>
										</html></content>
									</section>

									<section id="join-clause">
										<title>The JOIN clause</title>
										<content><html>
											<p>
												jOOQ supports many different types of standard SQL JOIN operations:
											</p>
											<ul>
												<li>[ INNER ] JOIN</li>
												<li>LEFT [ OUTER ] JOIN</li>
												<li>RIGHT [ OUTER ] JOIN</li>
												<li>FULL OUTER JOIN</li>
												<li>CROSS JOIN</li>
												<li>NATURAL JOIN</li>
												<li>NATURAL LEFT [ OUTER ] JOIN</li>
												<li>NATURAL RIGHT [ OUTER ] JOIN</li>
											</ul>

											<p>
												All of these JOIN methods can be called on <reference class="org.jooq.Table"/> types, or directly after the FROM clause for convenience. The following example joins AUTHOR and BOOK
											</p>

</html><java><![CDATA[Factory create = new Factory(connection, dialect);

// Call "join" directly on the AUTHOR table
Result<?> result = create.select()
                         .from(AUTHOR.join(BOOK)
                                     .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)))
                         .fetch();

// Call "join" on the type returned by "from"
Result<?> result = create.select()
                         .from(AUTHOR)
                         .join(BOOK)
                         .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
                         .fetch();]]></java><html>

											<p>
												The two syntaxes will produce the same SQL statement. However, calling "join" on <reference class="org.jooq.Table"/> objects allows for more powerful, nested JOIN expressions (if you can handle the parentheses):
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN (
  BOOK JOIN BOOK_TO_BOOK_STORE
       ON BOOK_TO_BOOK_STORE.BOOK_ID = BOOK.ID
)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql><java><![CDATA[// Nest joins and provide JOIN conditions only at the end
create.select()
      .from(AUTHOR
      .leftOuterJoin(BOOK
        .join(BOOK_TO_BOOK_STORE)
        .on(BOOK_TO_BOOK_STORE.BOOK_ID.equal(BOOK.ID)))
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)));]]></java></code-pair><html>

      										<ul>
      											<li>See the section about <reference id="conditional-expressions" title="conditional expressions"/> to learn more about the many ways to create <reference class="org.jooq.Condition"/> objects in jOOQ.</li>
      											<li>See the section about <reference id="table-expressions" title="table expressions"/> to learn about the various ways of referencing <reference class="org.jooq.Table"/> objects in jOOQ</li>
      										</ul>

											<h3>JOIN ON KEY, convenience provided by jOOQ</h3>
											<p>
												Surprisingly, SQL does not allow to formally JOIN on well-known foreign key relationship information. Naturally, when you join BOOK to AUTHOR, you will want to do that based on the BOOK.AUTHOR_ID foreign key to AUTHOR.ID primary key relation. Not being able to do this in SQL leads to a lot of repetitive code, re-writing the same JOIN predicate again and again - especially, when your foreign keys contain more than one column. With jOOQ, when you use <reference id="code-generation" title="code generation"/>, you can use foreign key constraint information in JOIN expressions as such:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
JOIN BOOK ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql><java><![CDATA[create.select()
      .from(AUTHOR)
      .join(BOOK).onKey();]]></java></code-pair><html>

      										<p>
      											In case of ambiguity, you can also supply field references for your foreign keys, or the generated foreign key reference to the onKey() method.
      										</p>

											<h3>The JOIN USING syntax</h3>
											<p>
												Most often, you will provide jOOQ with JOIN conditions in the JOIN .. ON clause. SQL supports a different means of specifying how two tables are to be joined. This is the JOIN .. USING clause. Instead of a condition, you supply a set of fields whose names are common to both tables to the left and right of a JOIN operation. This can be useful when your database schema has a high degree of <a href="http://en.wikipedia.org/wiki/Database_normalization">relational normalisation</a>. An example:
											</p>

</html><code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
JOIN BOOK USING (AUTHOR_ID)]]></sql><java><![CDATA[// join(...).using(...)
create.select()
      .from(AUTHOR)
      .join(BOOK).using(AUTHOR.AUTHOR_ID);]]></java></code-pair><html>

											<p>
												In schemas with high degrees of normalisation, you may also choose to use NATURAL JOIN, which takes no JOIN arguments as it joins using all fields that are common to the table expressions to the left and to the right of the JOIN operator. An example:
											</p>

</html><code-pair>
<sql><![CDATA[-- Assuming that both tables contain AUTHOR_ID columns
SELECT *
FROM AUTHOR
NATURAL JOIN BOOK]]></sql><java><![CDATA[// naturalJoin(...)
create.select()
      .from(AUTHOR)
      .naturalJoin(BOOK);]]></java></code-pair><html>

											<h3>Oracle's partitioned OUTER JOIN</h3>
											<p>
												Oracle SQL ships with a special syntax available for OUTER JOIN clauses. According to the <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_10002.htm#i2196190">Oracle documentation about partitioned outer joins</a> this can be used to fill gaps for simplified analytical calculations. jOOQ only supports putting the PARTITION BY clause to the right of the OUTER JOIN clause. The following example will create at least one record per AUTHOR and per existing value in BOOK.PUBLISHED_IN, regardless if an AUTHOR has actually published a book in that year.
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR
LEFT OUTER JOIN BOOK
PARTITION BY (PUBLISHED_IN)
ON BOOK.AUTHOR_ID = AUTHOR.ID]]></sql><java><![CDATA[create.select()
      .from(AUTHOR)
      .leftOuterJoin(BOOK)
      .partitionBy(BOOK.PUBLISHED_IN)
      .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID));]]></java></code-pair><html>

										</html></content>
									</section>

									<section id="where-clause">
										<title>The WHERE clause</title>
										<content><html>
											<p>
												The WHERE clause can be used for JOIN or filter predicates, in order to restrict the data returned by the <reference id="table-expressions" title="table expressions"/> supplied to the previously specified <reference id="from-clause" title="from clause"/> and <reference id="join-clause" title="join clause"/>. Here is an example:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql><java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1))
      .and(BOOK.TITLE.equal("1984"));]]></java></code-pair><html>

											<p>
												The above syntax is convenience provided by jOOQ, allowing you to connect the <reference class="org.jooq.Condition"/> supplied in the WHERE clause with another condition using an AND operator. You can of course also create a more complex condition and supply that to the WHERE clause directly (observe the different placing of parentheses). The results will be the same:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE AUTHOR_ID = 1
AND TITLE = '1984']]></sql><java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(1).and(
             BOOK.TITLE.equal("1984")));]]></java></code-pair><html>

											<p>
												You will find more information about creating <reference id="conditional-expressions" title="conditional expressions"/> later in the manual.
											</p>
										</html></content>
									</section>

									<section id="connect-by-clause">
										<title>The CONNECT BY clause</title>
										<content><html>
											<p>
												The Oracle database knows a very succinct syntax for creating hierarchical queries: the CONNECT BY clause, which is fully supported by jOOQ, including all related functions and pseudo-columns. A more or less formal definition of this clause is given here:
											</p>
</html><sql>--   SELECT ..
--     FROM ..
--    WHERE ..
 CONNECT BY [NOCYCLE] condition [AND condition, ...] [START WITH condition]
-- GROUP BY ..</sql><html>

											<p>
												An example for an iterative query, iterating through values between 1 and 5 is this:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT LEVEL
FROM DUAL
CONNECT BY LEVEL <= 5]]></sql><java><![CDATA[// Get a table with elements 1, 2, 3, 4, 5
create.select(level())
      .connectBy(level().lessOrEqual(5));]]></java></code-pair><html>

											<p>
												Here's a more complex example where you can recursively fetch directories in your database, and concatenate them to a path:
											</p>
</html><code-pair>
<sql><![CDATA[SELECT
  SUBSTR(SYS_CONNECT_BY_PATH(DIRECTORY.NAME, '/'), 2)
FROM DIRECTORY
CONNECT BY
  PRIOR DIRECTORY.ID = DIRECTORY_PARENT_ID
START WITH DIRECTORY.PARENT_ID IS NULL
ORDER BY 1]]></sql><java><![CDATA[.select(
   sysConnectByPath(DIRECTORY.NAME, "/").substring(2))
.from(DIRECTORY)
.connectBy(
   prior(DIRECTORY.ID).equal(DIRECTORY.PARENT_ID))
.startWith(DIRECTORY.PARENT_ID.isNull())
.orderBy(1);]]></java>
</code-pair><html>

    										<p>
    											The output might then look like this
   											</p>

</html><text>+------------------------------------------------+
|substring                                       |
+------------------------------------------------+
|C:                                              |
|C:/eclipse                                      |
|C:/eclipse/configuration                        |
|C:/eclipse/dropins                              |
|C:/eclipse/eclipse.exe                          |
+------------------------------------------------+
|...21 record(s) truncated...
</text><html>

											<p>
												Some of the supported functions and pseudo-columns are these (available from the <reference id="factory" title="Factory"/>):
											</p>

											<ul>
												<li>LEVEL</li>
												<li>CONNECT_BY_IS_CYCLE</li>
												<li>CONNECT_BY_IS_LEAF</li>
												<li>CONNECT_BY_ROOT</li>
												<li>SYS_CONNECT_BY_PATH</li>
												<li>PRIOR</li>
											</ul>

											<p>
												Note that this syntax is also supported in the CUBRID database.
											</p>
										</html></content>
									</section>

									<section id="group-by-clause">
										<title>The GROUP BY clause</title>
										<content><html>
											<p>
												GROUP BY can be used to create unique groups of data, to form aggregations, to remove duplicates and for other reasons. It will transform your previously defined <reference id="table-expressions" title="set of table expressions"/>, and return only one record per unique group as specified in this clause. For instance, you can group books by BOOK.AUTHOR_ID:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID]]></sql><java><![CDATA[create.select(BOOK.AUTHOR_ID, count())
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair><html>

											<p>
												As defined in the SQL standard, when grouping, you may no longer project any columns that are not a formal part of the GROUP BY clause, or <reference id="aggregate-functions" title="aggregate functions"/>. The above example counts all books per author
											</p>

											<h3>MySQL's deviation from the SQL standard</h3>
											<p>
												MySQL has a peculiar way of not adhering to this standard behaviour. This is documented in the <a href="http://dev.mysql.com/doc/refman/5.6/en/group-by-hidden-columns.html">MySQL manual</a>. In short, with MySQL, you can also project any other field that are not part of the GROUP BY clause. The projected values will just be arbitrary values from within the group. You cannot rely on any ordering. For example:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
GROUP BY AUTHOR_ID]]></sql><java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .groupBy(AUTHOR_ID);]]></java></code-pair><html>

											<p>
												This will return an arbitrary title per author. jOOQ supports this syntax, as jOOQ is not doing any checks internally, about the consistence of tables/fields/functions that you provide it.
											</p>

											<h3>Empty GROUP BY clauses</h3>
											<p>
												jOOQ supports empty <code>GROUP BY ()</code> clauses as well. This will result in <reference id="select-statement" title="SELECT statements"/> that return only one record.
											</p>

</html><code-pair>
<sql><![CDATA[SELECT COUNT(*)
FROM BOOK
GROUP BY ()]]></sql><java><![CDATA[create.selectCount()
      .from(BOOK)
      .groupBy();]]></java></code-pair><html>


											<h3>ROLLUP(), CUBE() and GROUPING SETS()</h3>
											<p>
												Some databases support the SQL standard grouping functions and some extensions thereof. See the manual's section about <reference id="grouping-functions" title="grouping functions"/> for more details.
											</p>
										</html></content>
									</section>

									<section id="having-clause">
										<title>The HAVING clause</title>
										<content><html>
											<p>
												The HAVING clause is commonly used to further restrict data resulting from a previously issued <reference id="group-by-clause" title="GROUP BY clause"/>. An example, selecting only those authors that have written at least two books:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID
HAVING COUNT(*) >= 2]]></sql><java><![CDATA[create.select(BOOK.AUTHOR_ID, count(*))
      .from(BOOK)
      .groupBy(AUTHOR_ID)
      .having(count().greaterOrEqual(2));]]></java></code-pair><html>

											<p>
												According to the SQL standard, you may omit the GROUP BY clause and still issue a HAVING clause. This will implicitly GROUP BY (). jOOQ also supports this syntax. The following example selects one record, only if there are at least 4 books in the books table:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT COUNT(*)
FROM BOOK
HAVING COUNT(*) >= 4]]></sql><java><![CDATA[create.select(count(*))
      .from(BOOK)
      .having(count().greaterOrEqual(4));]]></java></code-pair><html>

										</html></content>
									</section>

									<section id="order-by-clause">
										<title>The ORDER BY clause</title>
										<content><html>
											<p>
												Databases are allowed to return data in any arbitrary order, unless you explicitly declare that order in the ORDER BY clause. In jOOQ, this is straight-forward:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY AUTHOR_ID ASC, TITLE DESC]]></sql><java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(BOOK.AUTHOR_ID.asc(), BOOK.TITLE.desc());]]></java></code-pair><html>

											<p>
												Any jOOQ <reference id="column-expressions" title="column expression (or field)"/> can be transformed into an <reference class="org.jooq.SortField"/> by calling the asc() and desc() methods.
											</p>

											<h3>Ordering by field index</h3>
											<p>
												The SQL standard allows for specifying integer literals (<reference id="inlined-parameters" title="literals"/>, not <reference id="bind-values" title="bind values"/>!) to reference column indexes from the projection (<reference id="select-clause" title="SELECT clause"/>). This may be useful if you do not want to repeat a lengthy expression, by which you want to order - although most databases also allow for referencing <reference id="aliased-columns" title="aliased column references"/> in the ORDER BY clause. An example of this is given here:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT AUTHOR_ID, TITLE
FROM BOOK
ORDER BY 1 ASC, 2 DESC]]></sql><java><![CDATA[create.select(BOOK.AUTHOR_ID, BOOK.TITLE)
      .from(BOOK)
      .orderBy(one().asc(), inline(2).desc());]]></java></code-pair><html>

											<p>
												Note, how one() is used as a convenience short-cut for inline(1)
											</p>

											<h3>Ordering and NULLS</h3>
											<p>
												A few databases support the SQL standard "null ordering" clause in sort specification lists, to define whether NULL values should come first or last in an ordered result.
											</p>

</html><code-pair>
<sql><![CDATA[SELECT
  AUTHOR.FIRST_NAME,
  AUTHOR.LAST_NAME
FROM AUTHOR
ORDER BY LAST_NAME ASC,
         FIRST_NAME ASC NULLS LAST]]></sql>
<java><![CDATA[create.select(
         AUTHOR.FIRST_NAME,
         AUTHOR.LAST_NAME)
      .from(AUTHOR)
      .orderBy(AUTHOR.LAST_NAME.asc(),
               AUTHOR.FIRST_NAME.asc().nullsLast());]]></java></code-pair><html>

                                            <p>
                                                If your database doesn't support this syntax, jOOQ emulates it using a <reference id="case-expressions" title="CASE expression"/> as follows
                                            </p>
</html>
<sql><![CDATA[SELECT
  AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME
FROM AUTHOR
ORDER BY LAST_NAME ASC,
         CASE WHEN FIRST_NAME IS NULL
              THEN 1 ELSE 0 END ASC,
         FIRST_NAME ASC]]></sql><html>


											<h3>Ordering using CASE expressions</h3>
											<p>
												Using <reference id="case-expressions" title="CASE expressions"/> in SQL ORDER BY clauses is a common pattern, if you want to introduce some sort indirection / sort mapping into your queries. As with SQL, you can add any type of <reference id="column-expressions" title="column expression"/> into your ORDER BY clause. For instance, if you have two favourite books that you always want to appear on top, you could write:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
ORDER BY CASE TITLE
         WHEN '1984' THEN 0
         WHEN 'Animal Farm' THEN 1
         ELSE 2 END ASC]]></sql><java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(decode().value(BOOK.TITLE)
                       .when("1984", 0)
                       .when("Animal Farm", 1)
                       .otherwise(2).asc());]]></java></code-pair><html>

											<p>
												But writing these things can become quite verbose. jOOQ supports a convenient syntax for specifying sort mappings. The same query can be written in jOOQ as such:
											</p>

</html><java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm"));]]></java><html>

											<p>
												More complex sort indirections can be provided using a Map:
											</p>

</html><java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sort(new HashMap<String, Integer>() {{
          put("1984", 1);
          put("Animal Farm", 13);
          put("The jOOQ book", 10);
      }}));]]></java><html>

      										<p>
      											Of course, you can combine this feature with the previously discussed NULLS FIRST / NULLS LAST feature. So, if in fact these two books are the ones you like least, you can put all NULLS FIRST (all the other books):
      										</p>

</html><java><![CDATA[create.select()
      .from(BOOK)
      .orderBy(BOOK.TITLE.sortAsc("1984", "Animal Farm").nullsFirst());]]></java><html>

											<h3>jOOQ's understanding of SELECT .. ORDER BY</h3>
											<p>
												The SQL standard defines that a "query expression" can be ordered, and that query expressions can contain <reference id="union-clause" title="UNION, INTERSECT and EXCEPT clauses"/>, whose subqueries cannot be ordered. While this is defined as such in the SQL standard, many databases allowing for the non-standard <reference id="limit-clause" title="LIMIT clause"/> in one way or another, do not adhere to this part of the SQL standard. Hence, jOOQ allows for ordering all SELECT statements, regardless whether they are constructed as a part of a UNION or not. Corner-cases are handled internally by jOOQ, by introducing synthetic subselects to adhere to the correct syntax, where this is needed.
											</p>
										</html></content>
									</section>

									<section id="limit-clause">
										<title>The LIMIT .. OFFSET clause</title>
										<content><html>
											<p>
												While being extremely useful for every application that does paging, or just to limit result sets to reasonable sizes, this clause is not yet part of any SQL standard (up until SQL:2008). Hence, there exist a variety of possible implementations in various SQL dialects, concerning this limit clause. jOOQ chose to implement the LIMIT .. OFFSET clause as understood and supported by MySQL, H2, HSQLDB, Postgres, and SQLite. Here is an example of how to apply limits with jOOQ:
											</p>

</html><java><![CDATA[create.select().from(BOOK).limit(1).offset(2);]]></java><html>

                                            <p>
                                                This will limit the result to 1 books starting with the 2nd book (starting at offset 0!). limit() is supported in all dialects, offset() in all but Sybase ASE, which has no reasonable means to emulate it. This is how jOOQ trivially emulates the above query in various SQL dialects with native <code>OFFSET</code> pagination support:
                                            </p>

</html><sql><![CDATA[-- MySQL, H2, HSQLDB, Postgres, and SQLite
SELECT * FROM BOOK LIMIT 1 OFFSET 2

-- CUBRID supports a MySQL variant of the LIMIT .. OFFSET clause
SELECT * FROM BOOK LIMIT 2, 1

-- Derby, SQL Server 2012, Oracle 12c, the SQL:2008 standard
SELECT * FROM BOOK OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY

-- Ingres (almost the SQL:2008 standard)
SELECT * FROM BOOK OFFSET 2 FETCH FIRST 1 ROWS ONLY

-- Firebird
SELECT * FROM BOOK ROWS 2 TO 3

-- Sybase SQL Anywhere
SELECT TOP 1 ROWS START AT 3 * FROM BOOK

-- DB2 (almost the SQL:2008 standard, without OFFSET)
SELECT * FROM BOOK FETCH FIRST 1 ROWS ONLY

-- Sybase ASE, SQL Server 2008 (without OFFSET)
SELECT TOP 1 * FROM BOOK
]]></sql><html>

                                            <p>
                                                Things get a little more tricky in those databases that have no native idiom for <code>OFFSET</code> pagination (actual queries may vary):
                                            </p>

</html><sql><![CDATA[
-- DB2 (with OFFSET), SQL Server 2008 (with OFFSET)
SELECT * FROM (
  SELECT BOOK.*,
    ROW_NUMBER() OVER (ORDER BY ID ASC) AS RN
  FROM BOOK
) AS X
WHERE RN > 1
AND RN <= 3

-- DB2 (with OFFSET), SQL Server 2008 (with OFFSET)
SELECT * FROM (
  SELECT DISTINCT BOOK.ID, BOOK.TITLE
    DENSE_RANK() OVER (ORDER BY ID ASC, TITLE ASC) AS RN
  FROM BOOK
) AS X
WHERE RN > 1
AND RN <= 3

-- Oracle 11g and less
SELECT *
FROM (
  SELECT b.*, ROWNUM RN
  FROM (
    SELECT *
    FROM BOOK
    ORDER BY ID ASC
  ) b
  WHERE ROWNUM <= 3
)
WHERE RN > 1]]></sql><html>

											<p>
												As you can see, jOOQ will take care of the incredibly painful ROW_NUMBER() OVER() (or ROWNUM for Oracle) filtering in subselects for you, you'll just have to write limit(1).offset(2) in any dialect.
											</p>

											<h3>SQL Server's ORDER BY, TOP and subqueries</h3>
											<p>
												As can be seen in the above example, writing correct SQL can be quite tricky, depending on the SQL dialect. For instance, with SQL Server, you cannot have an ORDER BY clause in a subquery, unless you also have a TOP clause. This is illustrated by the fact that jOOQ renders a TOP 100 PERCENT clause for you. The same applies to the fact that ROW_NUMBER() OVER() needs an ORDER BY windowing clause, even if you don't provide one to the jOOQ query. By default, jOOQ adds ordering by the first column of your projection.
											</p>
										</html></content>
									</section>

									<section id="for-update-clause">
										<title>The FOR UPDATE clause</title>
										<content><html>
											<p>
												For inter-process synchronisation and other reasons, you may choose to use the SELECT .. FOR UPDATE clause to indicate to the database, that a set of cells or records should be locked by a given transaction for subsequent updates. With jOOQ, this can be achieved as such:
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE]]></sql><java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate();]]></java></code-pair><html>

											<p>
												The above example will produce a record-lock, locking the whole record for updates. Some databases also support cell-locks using FOR UPDATE OF ..
											</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM BOOK
WHERE ID = 3
FOR UPDATE OF TITLE]]></sql><java><![CDATA[create.select()
      .from(BOOK)
      .where(BOOK.ID.equal(3))
      .forUpdate().of(BOOK.TITLE);]]></java></code-pair><html>

											<p>
												Oracle goes a bit further and also allows to specify the actual locking behaviour. It features these additional clauses, which are all supported by jOOQ:
											</p>
											<ul>
												<li>FOR UPDATE NOWAIT: This is the default behaviour. If the lock cannot be acquired, the query fails immediately</li>
												<li>FOR UPDATE WAIT n: Try to wait for [n] seconds for the lock acquisition. The query will fail only afterwards</li>
												<li>FOR UPDATE SKIP LOCKED: This peculiar syntax will skip all locked records. This is particularly useful when implementing queue tables with multiple consumers</li>
											</ul>
											<p>
												With jOOQ, you can use those Oracle extensions as such:
											</p>

</html><java><![CDATA[create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().nowait();
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().wait(5);
create.select().from(BOOK).where(BOOK.ID.equal(3)).forUpdate().skipLocked();]]></java><html>

											<h3>FOR UPDATE in CUBRID and SQL Server</h3>
											<p>
												The SQL standard specifies a FOR UPDATE clause to be applicable for cursors. Most databases interpret this as being applicable for all SELECT statements. An exception to this rule are the CUBRID and SQL Server databases, that do not allow for any FOR UPDATE clause in a regular SQL SELECT statement. jOOQ emulates the FOR UPDATE behaviour, by locking record by record with JDBC. JDBC allows for specifying the flags TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE for any statement, and then using ResultSet.updateXXX() methods to produce a cell-lock / row-lock. Here's a simplified example in JDBC:
											</p>
</html><java><![CDATA[try (
    PreparedStatement stmt = connection.prepareStatement(
        "SELECT * FROM author WHERE id IN (3, 4, 5)",
        ResultSet.TYPE_SCROLL_SENSITIVE,
        ResultSet.CONCUR_UPDATABLE);
    ResultSet rs = stmt.executeQuery()
) {
    while (rs.next()) {
        // UPDATE the primary key for row-locks, or any other columns for cell-locks
        rs.updateObject(1, rs.getObject(1));
        rs.updateRow();

        // Do more stuff with this record
    }
}]]></java><html>

											<p>
												The main drawback of this approach is the fact that the database has to maintain a scrollable cursor, whose records are locked one by one. This can cause a major risk of deadlocks or race conditions if the JDBC driver can recover from the unsuccessful locking, if two Java threads execute the following statements:
											</p>

</html><sql><![CDATA[-- thread 1
SELECT * FROM author ORDER BY id ASC;

-- thread 2
SELECT * FROM author ORDER BY id DESC;]]></sql><html>

											<p>
												So use this technique with care, possibly only ever locking single rows!
											</p>

											<h3>Pessimistic (shared) locking with the FOR SHARE clause</h3>
											<p>
												Some databases (MySQL, Postgres) also allow to issue a non-exclusive lock explicitly using a FOR SHARE clause. This is also supported by jOOQ
											</p>

											<h3>Optimistic locking in jOOQ</h3>
											<p>
												Note, that jOOQ also supports optimistic locking, if you're doing simple CRUD. This is documented in the section's manual about <reference id="optimistic-locking" title="optimistic locking"/>.
											</p>
										</html></content>
									</section>

									<section id="union-clause">
										<title>UNION, INTERSECTION and EXCEPT</title>
										<content><html>
											<p>
												SQL allows to perform set operations as understood in standard set theory on result sets. These operations include unions, intersections, subtractions. For two subselects to be combinable by such a set operator, each subselect must return a <reference id="table-expressions" title="table expression"/> of the same arity and type.
											</p>

											<h3>UNION and UNION ALL</h3>
											<p>
												These operators combine two results into one. While UNION removes all duplicate records resulting from this combination, UNION ALL leaves subselect results as they are. Typically, you should prefer UNION ALL over UNION, if you don't really need to remove duplicates. The following example shows how to use such a UNION operation in jOOQ.
											</p>

</html><code-pair>
<sql><![CDATA[SELECT * FROM BOOK WHERE ID = 3
UNION ALL
SELECT * FROM BOOK WHERE ID = 5]]></sql><java><![CDATA[create.selectFrom(BOOK).where(BOOK.ID.equal(3))
      .unionAll(
create.selectFrom(BOOK).where(BOOK.ID.equal(5)));]]></java></code-pair><html>

											<h3>INTERSECT [ ALL ] and EXCEPT [ ALL ]</h3>
											<p>
												INTERSECT is the operation that produces only those tuples that are returned by both subselects. EXCEPT is the operation that returns only those tuples that are returned exclusively in the first subselect. Both operators will remove duplicates from their results. The SQL standard allows to specify the ALL keyword for both of these operators as well, but this is hardly supported in any database. jOOQ does not support INTERSECT ALL, EXEPT ALL operations either.
											</p>

											<h3>jOOQ's set operators and how they're different from standard SQL</h3>
											<p>
												As previously mentioned in the manual's section about the <reference id="order-by-clause" title="ORDER BY clause"/>, jOOQ has slightly changed the semantics of these set operators. While in SQL, a subselect may not contain any <reference id="order-by-clause" title="ORDER BY clause"/> or <reference id="limit-clause" title="LIMIT clause"/> (unless you wrap the subselect into a <reference id="nested-selects" title="nested SELECT"/>), jOOQ allows you to do so. In order to select both the youngest and the oldest author from the database, you can issue the following statement with jOOQ (rendered to the MySQL dialect):
											</p>

</html><code-pair>
<sql><![CDATA[  (SELECT * FROM AUTHOR
   ORDER BY DATE_OF_BIRTH ASC LIMIT 1)
UNION
  (SELECT * FROM AUTHOR
   ORDER BY DATE_OF_BIRTH DESC LIMIT 1)]]></sql><java><![CDATA[create.selectFrom(AUTHOR)
      .orderBy(AUTHOR.DATE_OF_BIRTH.asc()).limit(1)
      .union(
create.selectFrom(AUTHOR)
      .orderBy(AUTHOR.DATE_OF_BIRTH.desc()).limit(1));]]></java></code-pair><html>

										</html></content>
									</section>

									<section id="oracle-hints">
										<title>Oracle-style hints</title>
										<content><html>
											<p>
												If you are closely coupling your application to an Oracle (or CUBRID) database,	you might need to be able to pass hints of the form /*+HINT*/ with your SQL statements to the Oracle database. For example:
											</p>

</html><sql>SELECT /*+ALL_ROWS*/ FIRST_NAME, LAST_NAME
  FROM AUTHOR</sql><html>

				  							<p>
				  								This can be done in jOOQ using the .hint() clause in your SELECT statement:
			  								</p>

</html><java>create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .hint("/*+ALL_ROWS*/")
      .from(AUTHOR);</java><html>

											<p>
												Note that you can pass any string in the .hint() clause. If you use that clause, the passed string will always be put in between the SELECT [DISTINCT] keywords and the actual projection list
											</p>
										</html></content>
									</section>
								</sections>
							</section>

							<section id="insert-statement">
								<title>The INSERT statement</title>
								<content><html>
									<p>
										The INSERT statement is used to insert new records into a database table. Records can either be supplied using a VALUES() constructor, or a SELECT statement. jOOQ supports both types of INSERT statements. An example of an INSERT statement using a VALUES() constructor is given here:
									</p>


</html><code-pair>
<sql>INSERT INTO AUTHOR
       (ID, FIRST_NAME, LAST_NAME)
VALUES (100, 'Hermann', 'Hesse');</sql><java>create.insertInto(AUTHOR,
        AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse");</java></code-pair><html>

									<h3>INSERT multiple rows with the VALUES() constructor</h3>
									<p>
										The SQL standard specifies that multiple rows can be supplied to the VALUES() constructor in an INSERT statement. Here's an example of a multi-record INSERT
									</p>
</html><code-pair>
<sql>INSERT INTO AUTHOR
       (ID, FIRST_NAME, LAST_NAME)
VALUES (100, 'Hermann', 'Hesse'),
       (101, 'Alfred', 'Dblin');</sql><java>create.insertInto(AUTHOR,
        AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Dblin");</java></code-pair><html>

									<p>
										jOOQ tries to stay close to actual SQL. In detail, however, Java's expressiveness is limited. That's why the values() clause is repeated for every record in multi-record inserts.
									</p>
									<p>
										Some RDBMS do not support inserting several records in a single statement. In those cases, jOOQ emulates multi-record INSERTs using the following SQL:
									</p>

</html><code-pair>
<sql>INSERT INTO AUTHOR
    (ID, FIRST_NAME, LAST_NAME)
SELECT 100, 'Hermann', 'Hesse' FROM DUAL UNION ALL
SELECT 101, 'Alfred', 'Dblin' FROM DUAL;</sql><java>create.insertInto(AUTHOR,
        AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(100, "Hermann", "Hesse")
      .values(101, "Alfred", "Dblin");
</java></code-pair><html>

									<h3>INSERT using jOOQ's alternative syntax</h3>
									<p>
										MySQL (and some other RDBMS) allow for using a non-SQL-standard, UPDATE-like syntax for INSERT statements. This is also supported in jOOQ, should you prefer that syntax. The above INSERT statement can also be expressed as follows:
									</p>

</html><java>create.insertInto(AUTHOR)
      .set(AUTHOR.ID, 100)
      .set(AUTHOR.FIRST_NAME, "Hermann")
      .set(AUTHOR.LAST_NAME, "Hesse")
      .newRecord()
      .set(AUTHOR.ID, 101)
      .set(AUTHOR.FIRST_NAME, "Alfred")
      .set(AUTHOR.LAST_NAME, "Dblin");</java><html>

									<p>
										As you can see, this syntax is a bit more verbose, but also more type-safe, as every field can be matched with its value. Internally, the two syntaxes are strictly equivalent.
									</p>

									<h3>MySQL's INSERT .. ON DUPLICATE KEY UPDATE</h3>
									<p>
										The MySQL database supports a very convenient way to INSERT or UPDATE a record. This is a non-standard extension to the SQL syntax, which is supported by jOOQ and emulated in other RDBMS, where this is possible (i.e. if they support the SQL standard <reference id="merge-statement" title="MERGE statement"/>). Here is an example how to use the ON DUPLICATE KEY UPDATE clause:
									</p>

</html><java>// Add a new author called "Koontz" with ID 3.
// If that ID is already present, update the author's name
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyUpdate()
      .set(AUTHOR.LAST_NAME, "Koontz");</java><html>

									<h3>The synthetic ON DUPLICATE KEY IGNORE clause</h3>

									<p>
										The MySQL database also supports an INSERT IGNORE INTO clause. This is supported by jOOQ using the more convenient SQL syntax variant of ON DUPLICATE KEY IGNORE, which can be equally emulated in other databases using a <reference id="merge-statement" title="MERGE statement"/>:
									</p>

</html><java>// Add a new author called "Koontz" with ID 3.
// If that ID is already present, ignore the INSERT statement
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.LAST_NAME)
      .values(3, "Koontz")
      .onDuplicateKeyIgnore();</java><html>

      								<h3>Postgres's INSERT .. RETURNING</h3>
									<p>
										The Postgres database has native support for an INSERT .. RETURNING clause. This is a very powerful concept that is emulated for all other dialects using JDBC's <reference class="java.sql.Statement" anchor="#getGeneratedKeys()" title="getGeneratedKeys()"/> method. Take this example:
									</p>

</html><java><![CDATA[// Add another author, with a generated ID
Record<?> record =
create.insertInto(AUTHOR, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values("Charlotte", "Roche")
      .returning(AUTHOR.ID)
      .fetchOne();

System.out.println(record.getValue(AUTHOR.ID));

// For some RDBMS, this also works when inserting several values
// The following should return a 2x2 table
Result<?> result =
create.insertInto(AUTHOR, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values("Johann Wolfgang", "von Goethe")
      .values("Friedrich", "Schiller")
      // You can request any field. Also trigger-generated values
      .returning(AUTHOR.ID, AUTHOR.CREATION_DATE)
      .fetch();]]></java><html>

		      						<p>
		      							Some databases have poor support for returning generated keys after INSERTs. In those cases, jOOQ might need to issue another <reference id="select-statement" title="SELECT statement"/> in order to fetch an @@identity value. Be aware, that this can lead to race-conditions in those databases that cannot properly return generated ID values. For more information, please consider the jOOQ Javadoc for the returning() clause.
		      						</p>

									<h3>The INSERT SELECT statement</h3>

									<p>
										In some occasions, you may prefer the INSERT SELECT syntax, for instance, when you copy records from one table to another:
									</p>

</html><java>create.insertInto(AUTHOR_ARCHIVE)
      .select(create.selectFrom(AUTHOR).where(AUTHOR.DECEASED.isTrue()));</java></content>
							</section>

							<section id="update-statement">
								<title>The UPDATE statement</title>
								<content><html>
									<p>
										The UPDATE statement is used to modify one or several pre-existing records in a database table. UPDATE statements are only possible on single tables. Support for multi-table updates will be implemented in the near future. An example update query is given here:
									</p>

</html><code-pair>
<sql>UPDATE AUTHOR
   SET FIRST_NAME = 'Hermann',
       LAST_NAME = 'Hesse'
 WHERE ID = 3;</sql><java>create.update(AUTHOR)
      .set(AUTHOR.FIRST_NAME, "Hermann")
      .set(AUTHOR.LAST_NAME, "Hesse")
      .where(AUTHOR.ID.equal(3));</java>
</code-pair><html>

								</html></content>
							</section>

							<section id="delete-statement">
								<title>The DELETE statement</title>
								<content><html>
									<p>
										The DELETE statement removes records from a database table. DELETE statements are only possible on single tables. Support for multi-table deletes will be implemented in the near future. An example delete query is given here:
									</p>

</html><code-pair>
<sql>DELETE AUTHOR
 WHERE ID = 100;</sql><java>create.delete(AUTHOR)
      .where(AUTHOR.ID.equal(100));</java>
</code-pair><html>

								</html></content>
							</section>

							<section id="merge-statement">
								<title>The MERGE statement</title>
								<content><html>
									<p>
										The MERGE statement is one of the most advanced standardised SQL constructs, which is supported by DB2, HSQLDB, Oracle, SQL Server and Sybase (MySQL has the similar INSERT .. ON DUPLICATE KEY UPDATE construct)
									</p>
									<p>
										The point of the standard MERGE statement is to take a TARGET table, and merge (INSERT, UPDATE) data from a SOURCE table into it. DB2, Oracle, SQL Server and Sybase also allow for DELETING some data and for adding many additional clauses. With jOOQ {jooq-version}, only Oracle's MERGE extensions are supported. Here is an example:
									</p>

</html><code-pair>
<sql>-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.
MERGE INTO AUTHOR
USING (SELECT 1 FROM DUAL)
ON (LAST_NAME = 'Hitchcock')
WHEN MATCHED THEN UPDATE SET FIRST_NAME = 'John'
WHEN NOT MATCHED THEN INSERT (LAST_NAME) VALUES ('Hitchcock')</sql><java>create.mergeInto(AUTHOR)
      .using(create.selectOne())
      .on(AUTHOR.LAST_NAME.equal("Hitchcock"))
      .whenMatchedThenUpdate()
      .set(AUTHOR.FIRST_NAME, "John")
      .whenNotMatchedThenInsert(AUTHOR.LAST_NAME)
      .values("Hitchcock");

</java></code-pair><html>

		                            <h3>MERGE Statement (H2-specific syntax)</h3>
									<p>
									    The H2 database ships with a somewhat less powerful but a little more intuitive syntax for its own version of the MERGE statement. An example more or less equivalent to the previous one can be seen here:
									</p>

</html><code-pair>
<sql>-- Check if there is already an author called 'Hitchcock'
-- If there is, rename him to John. If there isn't add him.

MERGE INTO AUTHOR (FIRST_NAME, LAST_NAME)
KEY (LAST_NAME)
VALUES ('John', 'Hitchcock')</sql><java>create.mergeInto(AUTHOR,
                 AUTHOR.FIRST_NAME,
                 AUTHOR.LAST_NAME)
      .key(AUTHOR.LAST_NAME)
      .values("John", "Hitchcock")
      .execute();
</java></code-pair><html>

		                            <p>
		                                This syntax can be fully emulated by jOOQ for all other databases that support the SQL standard MERGE statement. For more information about the H2 MERGE syntax, see the documentation here:<br/>
		                                <a href="http://www.h2database.com/html/grammar.html#merge">http://www.h2database.com/html/grammar.html#merge</a>
		                            </p>

								</html></content>
							</section>

							<section id="truncate-statement">
								<title>The TRUNCATE statement</title>
								<content><html>
									<p>
										The TRUNCATE statement is the only DDL statement supported by jOOQ so far. It is popular in many databases when you want to bypass constraints for table truncation. Databases may behave differently, when a truncated table is referenced by other tables. For instance, they may fail if records from a truncated table are referenced, even with ON DELETE CASCADE clauses in place. Please, consider your database manual to learn more about its TRUNCATE implementation.
									</p>
									<p>
										The TRUNCATE syntax is trivial:
									</p>

</html><code-pair>
	<sql>TRUNCATE TABLE AUTHOR;</sql><java>create.truncate(AUTHOR).execute();</java>
</code-pair><html>

									<p>
										TRUNCATE is not supported by Ingres and SQLite. jOOQ will execute a DELETE FROM AUTHOR statement instead.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="table-expressions">
						<title>Table expressions</title>
						<content><html>
							<p>
								The following sections explain the various types of table expressions supported by jOOQ
							</p>
						</html></content>

						<sections>
							<section id="generated-tables">
								<title>Generated Tables</title>
								<content><html>
									<p>
										Most of the times, when thinking about a <reference id="table-expressions" title="table expression"/> you're probably thinking about an actual table in your database schema. If you're using jOOQ's <reference id="code-generation" title="code generator"/>, you will have all tables from your database schema available to you as type safe Java objects. You can then use these tables in SQL <reference id="from-clause" title="FROM clauses"/>, <reference id="join-clause" title="JOIN clauses"/> or in other <reference id="sql-statements" title="SQL statements"/>, just like any other table expression. An example is given here:
									</p>

</html><code-pair>
<sql><![CDATA[SELECT *
FROM AUTHOR -- Table expression AUTHOR
JOIN BOOK   -- Table expression BOOK
ON (AUTHOR.ID = BOOK.AUTHOR_ID)]]></sql><java><![CDATA[create.select()
      .from(AUTHOR) // Table expression AUTHOR
      .join(BOOK)   // Table expression BOOK
      .on(AUTHOR.ID.equal(BOOK.AUTHOR_ID));]]></java></code-pair><html>

									<p>
										The above example shows how AUTHOR and BOOK tables are joined in a <reference id="select-statement" title="SELECT statement"/>. It also shows how you can access <reference id="table-columns" title="table columns"/> by dereferencing the relevant Java attributes of their tables.
									</p>
									<p>
										See the manual's section about <reference id="codegen-tables" title="generated tables"/> for more information about what is really generated by the <reference id="code-generation" title="code generator"/>
									</p>
								</html></content>
							</section>

							<section id="aliased-tables">
								<title>Aliased Tables</title>
								<content><html>
									<p>
										The strength of jOOQ's <reference id="code-generation" title="code generator"/> becomes more obvious when you perform table aliasing and dereference fields from generated aliased tables. This can best be shown by example:
									</p>

</html><code-pair><sql><![CDATA[-- Select all books by authors born after 1920,
-- named "Paulo" from a catalogue:



SELECT *
  FROM author a
  JOIN book b ON a.id = b.author_id
 WHERE a.year_of_birth > 1920
   AND a.first_name = 'Paulo'
 ORDER BY b.title]]></sql><java><![CDATA[// Declare your aliases before using them in SQL:
Author a = AUTHOR.as("a");
Book b = BOOK.as("b");

// Use aliased tables in your statement
create.select()
      .from(a)
      .join(b).on(a.ID.equal(b.AUTHOR_ID))
      .where(a.YEAR_OF_BIRTH.greaterThan(1920)
      .and(a.FIRST_NAME.equal("Paulo")))
      .orderBy(b.TITLE);]]></java></code-pair><html>

									<p>
										As you can see in the above example, calling as() on generated tables returns an object of the same type as the table. This means that the resulting object can be used to dereference fields from the aliased table. This is quite powerful in terms of having your Java compiler check the syntax of your SQL statements. If you remove a column from a table, dereferencing that column from that table alias will cause compilation errors.
									</p>

									<h3>Dereferencing columns from other table expressions</h3>
									<p>
										TODO document this
									</p>
								</html></content>
							</section>

							<section id="joined-tables">
								<title>Joined tables</title>
								<content><html>
									<p>
										The <reference id="join-clause" title="JOIN operators"/> that can be used in <reference id="select-statement" title="SQL SELECT statements"/> are the most powerful and best supported means of creating new <reference id="table-expressions" title="table expressions"/> in SQL. Informally, the following can be said:
									</p>

</html><text>A(colA1, ..., colAn) "join" B(colB1, ..., colBm) "produces" C(colA1, ..., colAn, colB1, ..., colBm)</text><html>

									<p>
										SQL and relational algebra distinguish between at least the following JOIN types (upper-case: SQL, lower-case: relational algebra):
									</p>
									<ul>
										<li><strong>CROSS JOIN or cartesian product</strong>: The basic JOIN in SQL, producing a relational cross product, combining every record of table A with every record of table B. Note that cartesian products can also be produced by listing comma-separated <reference id="table-expressions" title="table expressions"/> in the <reference id="from-clause" title="FROM clause"/> of a <reference id="select-statement" title="SELECT statement"/></li>
										<li><strong>NATURAL JOIN</strong>: The basic JOIN in relational algebra, yet a rarely used JOIN in databases with everyday degree of normalisation. This JOIN type unconditionally equi-joins two tables by all columns with the same name (requiring foreign keys and primary keys to share the same name). Note that the JOIN columns will only figure once in the resulting <reference id="table-expressions" title="table expression"/>.</li>
										<li><strong>INNER JOIN or equi-join</strong>: This JOIN operation performs a cartesian product (CROSS JOIN) with a <reference id="conditional-expressions" title="filtering predicate"/> being applied to the resulting <reference id="table-expressions" title="table expression"/>. Most often, a <reference id="comparison-predicate" title="equal comparison predicate"/> comparing foreign keys and primary keys will be applied as a filter, but any other predicate will work, too.</li>
										<li><strong>OUTER JOIN</strong>: This JOIN operation performs a cartesian product (CROSS JOIN) with a <reference id="conditional-expressions" title="filtering predicate"/> being applied to the resulting <reference id="table-expressions" title="table expression"/>. Most often, a <reference id="comparison-predicate" title="equal comparison predicate"/> comparing foreign keys and primary keys will be applied as a filter, but any other predicate will work, too. Unlike the INNER JOIN, an OUTER JOIN will add "empty records" to the left (table A) or right (table B) or both tables, in case the conditional expression fails to produce a tuple.</li>
										<li><strong>semi-join</strong>: In SQL, this JOIN operation can only be expressed implicitly using <reference id="in-predicate" title="IN predicates"/> or <reference id="exists-predicate" title="EXISTS predicates"/>. The <reference id="table-expressions" title="table expression"/> resulting from a semi-join will only contain the left-hand side table A</li>
										<li><strong>anti-join</strong>: In SQL, this JOIN operation can only be expressed implicitly using <reference id="in-predicate" title="NOT IN predicates"/> or <reference id="exists-predicate" title="NOT EXISTS predicates"/>. The <reference id="table-expressions" title="table expression"/> resulting from a semi-join will only contain the left-hand side table A</li>
										<li><strong>division</strong>: This JOIN operation is hard to express at all, in SQL. See the manual's chapter about <reference id="relational-division" title="relational division"/> for details on how jOOQ emulates this operation.</li>
									</ul>
									<p>
										jOOQ supports all of these JOIN types (except semi-join and anti-join) directly on any <reference id="table-expressions" title="table expression"/>:
									</p>

</html><java><![CDATA[// jOOQ's relational division convenience syntax
DivideByOnStep divideBy(Table<?> table)

// Various overloaded INNER JOINs
TableOnStep join(TableLike<?>)
TableOnStep join(String)
TableOnStep join(String, Object...)
TableOnStep join(String, QueryPart...)

// Various overloaded OUTER JOINs (supporting Oracle's partitioned OUTER JOIN)
// Overloading is similar to that of INNER JOIN
TablePartitionByStep leftOuterJoin(TableLike<?>)
TablePartitionByStep rightOuterJoin(TableLike<?>)

// Various overloaded FULL OUTER JOINs
TableOnStep fullOuterJoin(TableLike<?>)

// Various overloaded CROSS JOINs
Table<Record> crossJoin(TableLike<?>)

// Various overloaded NATURAL JOINs
Table<Record> naturalJoin(TableLike<?>)
Table<Record> naturalLeftOuterJoin(TableLike<?>)
Table<Record> naturalRightOuterJoin(TableLike<?>)]]></java><html>

									<p>
										Note that most of jOOQ's JOIN operations give way to a similar DSL API hierarchy as previously seen in the manual's section about the <reference id="join-clause" title="JOIN clause"/>
									</p>
								</html></content>
							</section>

							<section id="nested-selects">
								<title>Nested SELECTs</title>
								<content><html>
									<p>
										A <reference id="select-statement" title="SELECT statement"/> can appear almost anywhere a <reference id="table-expressions" title="table expression"/> can. Such a "nested SELECT" is often called a "derived table". Apart from many convenience methods accepting <reference class="org.jooq.Select"/> objects directly, a SELECT statement can always be transformed into a <reference class="org.jooq.Table"/> object using the asTable() method.
									</p>

									<h3>Example: Scalar subquery</h3>

</html><code-pair>
<sql>SELECT *
  FROM BOOK
 WHERE BOOK.AUTHOR_ID = (
 		SELECT ID
          FROM AUTHOR
         WHERE LAST_NAME = 'Orwell')</sql><java>create.select()
      .from(BOOK)
      .where(BOOK.AUTHOR_ID.equal(create
             .select(AUTHOR.ID)
             .from(AUTHOR)
             .where(AUTHOR.LAST_NAME.equal("Orwell"))));</java>
</code-pair><html>

									<h3>Example: Derived table</h3>

</html><code-pair>
<sql><![CDATA[SELECT nested.* FROM (
      SELECT AUTHOR_ID, count(*) books
        FROM BOOK
    GROUP BY AUTHOR_ID
) nested
ORDER BY nested.books DESC



]]></sql><java><![CDATA[Table<Record> nested =
    create.select(BOOK.AUTHOR_ID, count().as("books"))
          .from(BOOK)
          .groupBy(BOOK.AUTHOR_ID).asTable("nested");

create.select(nested.getFields())
      .from(nested)
      .orderBy(nested.getField("books"));]]></java>
</code-pair><html>

									<h3>Example: Correlated subquery</h3>
</html><code-pair>
<sql><![CDATA[  SELECT LAST_NAME, (
      SELECT COUNT(*)
       FROM BOOK
      WHERE BOOK.AUTHOR_ID = AUTHOR.ID) books
    FROM AUTHOR
ORDER BY books DESC



]]></sql><java><![CDATA[// The type of books cannot be inferred from the Select<?>
Field<Object> books =
    create.selectCount()
          .from(BOOK)
          .where(BOOK.AUTHOR_ID.equal(AUTHOR.ID))
          .asField("books");
create.select(AUTHOR.ID, books)
      .from(AUTHOR)
      .orderBy(books, AUTHOR.ID));]]></java>
</code-pair><html>
								</html></content>
							</section>

							<section id="pivot-tables">
								<title>The Oracle 11g PIVOT clause</title>
								<content><html>
									<p>
										If you are closely coupling your application to an Oracle database, you can take advantage of some Oracle-specific features, such as the PIVOT clause, used for statistical analyses. The formal syntax definition is as follows:
									</p>

</html><sql>-- SELECT ..
     FROM table PIVOT (aggregateFunction [, aggregateFunction] FOR column IN (expression [, expression]))
--  WHERE ..</sql><html>

									<p>
										The PIVOT clause is available from the <reference class="org.jooq.Table"/> type, as pivoting is done directly on a table. Currently, only Oracle's PIVOT clause is supported. Support for SQL Server's slightly different PIVOT clause will be added later. Also, jOOQ may emulate PIVOT for other dialects in the future.
									</p>
								</html></content>
							</section>

							<section id="relational-division">
								<title>jOOQ's relational division syntax</title>
								<content><html>
									<p>
									    There is one operation in relational algebra that is not given a lot of attention, because it is rarely used in real-world applications. It is the relational division, the opposite operation of the cross product (or, relational multiplication). The following is an approximate definition of a relational division:
									</p>

</html><config>Assume the following cross join / cartesian product
C = A  B

Then it can be said that
A = C  B
B = C  A</config><html>

									<p>
									   With jOOQ, you can simplify using relational divisions by using the following syntax:
									</p>

</html><java>C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT)</java><html>

									<p>
										The above roughly translates to
									</p>

</html><sql>SELECT DISTINCT C.TEXT FROM C "c1"
WHERE NOT EXISTS (
  SELECT 1 FROM B
  WHERE NOT EXISTS (
    SELECT 1 FROM C "c2"
    WHERE "c2".TEXT = "c1".TEXT
    AND "c2".ID = B.C_ID
  )
)</sql><html>

									<p>
										Or in plain text: Find those TEXT values in C whose ID's correspond to all ID's in B. Note that from the above SQL statement, it is immediately clear that proper indexing is of the essence. Be sure to have indexes on all columns referenced from the on(...) and returning(...) clauses.
									</p>

									<p>
										For more information about relational division and some nice, real-life examples, see
									</p>

									<ul>
										<li><a href="http://en.wikipedia.org/wiki/Relational_algebra#Division" title="Wikipedia article on relational division">http://en.wikipedia.org/wiki/Relational_algebra#Division</a></li>
										<li><a href="http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/" title="A nice summary of what relational division is and how it is best implemented in SQL">http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a></li>
									</ul>
								</html></content>

							</section>

							<section id="array-and-cursor-unnesting">
								<title>Array and cursor unnesting</title>
								<content><html>
									<p>
										The SQL standard specifies how SQL databases should implement ARRAY and TABLE types, as well as CURSOR types. Put simply, a CURSOR is a pointer to any materialised <reference id="table-expressions" title="table expression"/>. Depending on the cursor's features, this table expression can be scrolled through in both directions, records can be locked, updated, removed, inserted, etc. Often, CURSOR types contain tuples, whereas ARRAY and TABLE types contain simple scalar values, although that is not a requirement
									</p>

									<p>
										ARRAY types in SQL are similar to Java's array types. They contain a "component type" or "element type" and a "dimension". This sort of ARRAY type is implemented in H2, HSQLDB and Postgres and supported by jOOQ as such. Oracle uses strongly-typed arrays, which means that an ARRAY type (VARRAY or TABLE type) has a name and possibly a maximum capacity associated with it.
									</p>

									<h3>Unnesting array and cursor types</h3>
									<p>
										The real power of these types become more obvious when you fetch them from <reference id="stored-procedures" title="stored procedures"/> to unnest them as <reference id="table-expressions" title="table expressions"/> and use them in your <reference id="from-clause" title="FROM clause"/>. An example is given here, where Oracle's DBMS_XPLAN package is used to fetch a cursor containing data about the most recent execution plan:
									</p>

</html><code-pair>
	<sql><![CDATA[SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(null, null, 'ALLSTATS'));]]></sql><java><![CDATA[create.select()
      .from(table(DbmsXplan.displayCursor(null, null, "ALLSTATS"));]]></java>
</code-pair><html>
									<p>
										Note, in order to access the DbmsXplan package, you can use the <reference id="code-generation" title="code generator"/> to generate Oracle's SYS schema.
									</p>
								</html></content>
							</section>

							<section id="dual">
								<title>The DUAL table</title>
								<content><html>
									<p>
										The SQL standard specifies that the <reference id="from-clause" title="FROM clause"/> is optional in a <reference id="select-statement" title="SELECT statement"/>. However, according to the standard, you may then no longer use some other clauses, such as the <reference id="where-clause" title="WHERE clause"/>. In the real world, there exist three types of databases:
									</p>
									<ul>
                                        <li>The ones that always require a <code>FROM</code> clause (as required by the SQL standard)</li>
                                        <li>The ones that never require a <code>FROM</code> clause (and still allow a <code>WHERE</code> clause)</li>
                                        <li>The ones that require a <code>FROM</code> clause only with a <code>WHERE</code> clause, <code>GROUP BY</code> clause, or <code>HAVING</code> clause</li>
									</ul>
									<p>
										With jOOQ, you don't have to worry about the above distinction of SQL dialects. jOOQ never requires a FROM clause, but renders the necessary "DUAL" table, if needed. The following program shows how jOOQ renders "DUAL" tables
									</p>

</html><code-pair>
	<sql><![CDATA[SELECT 1
SELECT 1 FROM "db_root"
SELECT 1 FROM "SYSIBM"."DUAL"
SELECT 1 FROM "SYSIBM"."SYSDUMMY1"
SELECT 1 FROM dual
SELECT 1 FROM "INFORMATION_SCHEMA"."SYSTEM_USERS"
SELECT 1 FROM (select 1 as dual) as dual
SELECT 1 FROM dual
SELECT 1 FROM dual
SELECT 1
SELECT 1
SELECT 1
SELECT 1 FROM [SYS].[DUMMY]
]]></sql><java><![CDATA[new Factory(SQLDialect.ASE      ).selectOne().getSQL();
new Factory(SQLDialect.CUBRID   ).selectOne().getSQL();
new Factory(SQLDialect.DB2      ).selectOne().getSQL();
new Factory(SQLDialect.DERBY    ).selectOne().getSQL();
new Factory(SQLDialect.H2       ).selectOne().getSQL();
new Factory(SQLDialect.HSQLDB   ).selectOne().getSQL();
new Factory(SQLDialect.INGRES   ).selectOne().getSQL();
new Factory(SQLDialect.MYSQL    ).selectOne().getSQL();
new Factory(SQLDialect.ORACLE   ).selectOne().getSQL();
new Factory(SQLDialect.POSTGRES ).selectOne().getSQL();
new Factory(SQLDialect.SQLITE   ).selectOne().getSQL();
new Factory(SQLDialect.SQLSERVER).selectOne().getSQL();
new Factory(SQLDialect.SYBASE   ).selectOne().getSQL();]]></java>
</code-pair><html>

									<p>
										Note, that some databases (H2, MySQL) can normally do without "dual". However, there exist some corner-cases with complex nested SELECT statements, where this will cause syntax errors (or parser bugs). To stay on the safe side, jOOQ will always render "dual" in those dialects.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="column-expressions">
						<title>Column expressions</title>
						<content><html>
							<p>
								jOOQ allows you to freely create arbitrary column expressions using a fluent expression construction API. Many expressions can be formed as functions from <reference id="factory" title="Factory methods"/>, other expressions can be formed based on a pre-existing column expression. For example:
							</p>

</html><java><![CDATA[// A regular table column expression
Field<String> field1 = BOOK.TITLE;

// A function created from the Factory using "prefix" notation
Field<String> field2 = trim(BOOK.TITLE);

// The same function created from a pre-existing Field using "postfix" notation
Field<String> field3 = BOOK.TITLE.trim();

// More complex function with advanced DSL syntax
Field<String> field4 = listAgg(BOOK.TITLE)
                          .withinGroupOrderBy(BOOK.ID.asc())
                          .over().partitionBy(AUTHOR.ID);]]></java><html>

							<p>
								In general, it is up to you whether you want to use the "prefix" notation or the "postfix" notation to create new column expressions based on existing ones. The "SQL way" would be to use the "prefix notation", with functions created from the <reference id="factory" title="Factory"/>. The "Java way" or "object-oriented way" would be to use the "postfix" notation with functions created from <reference class="org.jooq.Field"/> objects. Both ways ultimately create the same query part, though.
							</p>
						</html></content>

						<sections>
							<section id="table-columns">
								<title>Table columns</title>
								<content><html>
									<p>
										Table columns are the most simple implementations of a <reference id="column-expressions" title="column expression"/>. They are mainly produced by jOOQ's <reference id="code-generation" title="code generator"/> and can be dereferenced from the generated tables. This manual is full of examples involving table columns. Another example is given in this query:
									</p>

</html><code-pair>
	<sql><![CDATA[SELECT BOOK.ID, BOOK.TITLE
FROM BOOK
WHERE BOOK.TITLE LIKE '%SQL%'
ORDER BY BOOK.TITLE]]></sql><java><![CDATA[create.select(BOOK.ID, BOOK.TITLE)
	  .from(BOOK)
	  .where(BOOK.TITLE.like("%SQL%"))
	  .orderBy(BOOK.TITLE);]]></java>
</code-pair><html>

									<p>
										Table columns implement a more specific interface called <reference class="org.jooq.TableField"/>, which is parameterised with its associated &lt;R extends Record&gt; record type.
									</p>
									<p>
										See the manual's section about <reference id="codegen-tables" title="generated tables"/> for more information about what is really generated by the <reference id="code-generation" title="code generator"/>
									</p>
								</html></content>
							</section>

							<section id="aliased-columns">
								<title>Aliased columns</title>
								<content><html>
									<p>
										Just like <reference id="aliased-tables" title="tables"/>, columns can be renamed using aliases. Here is an example:
									</p>

</html><sql>  SELECT FIRST_NAME || ' ' || LAST_NAME author, COUNT(*) books
    FROM AUTHOR
    JOIN BOOK ON AUTHOR.ID = AUTHOR_ID
GROUP BY FIRST_NAME, LAST_NAME;</sql><html>

									<p>
										Here is how it's done with jOOQ:
									</p>

</html><java>Record record = create.select(
         concat(AUTHOR.FIRST_NAME, val(" "), AUTHOR.LAST_NAME).as("author"),
         count().as("books"))
      .from(AUTHOR)
      .join(BOOK).on(AUTHOR.ID.equal(BOOK.AUTHOR_ID))
      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME).fetchAny();</java><html>

      								<p>
      									When you alias Fields like above, you can access those Fields' values using the alias name:
  									</p>

</html><java>System.out.println("Author : " + record.getValue("author"));
System.out.println("Books  : " + record.getValue("books"));</java></content>
							</section>

							<section id="cast-expressions">
								<title>Cast expressions</title>
								<content><html>
									<p>
										jOOQ's source code generator tries to find the most accurate type mapping between your vendor-specific data types and a matching Java type. For instance, most VARCHAR, CHAR, CLOB types will map to String. Most BINARY, BYTEA, BLOB types will map to byte[]. NUMERIC types will default to java.math.BigDecimal, but can also be any of java.math.BigInteger, Long, Integer, Short, Byte, Double, Float.
									</p>
									<p>
										Sometimes, this automatic mapping might not be what you needed, or jOOQ cannot know the type of a field. In those cases you would write SQL type CASTs like this:
									</p>

</html><sql>-- Let's say, your Postgres column LAST_NAME was VARCHAR(30)
-- Then you could do this:
SELECT CAST(AUTHOR.LAST_NAME AS TEXT) FROM DUAL</sql><html>

									<p>
										in jOOQ, you can write something like that:
									</p>

</html><java>create.select(TAuthor.LAST_NAME.cast(PostgresDataType.TEXT));</java><html>

									<p>
										The same thing can be achieved by casting a Field directly to String.class, as TEXT is the default data type in Postgres to map to Java's String
									</p>

</html><java>create.select(TAuthor.LAST_NAME.cast(String.class));</java><html>

									<p>
										The complete CAST API in Field consists of these three methods:
									</p>

</html><java><![CDATA[public interface Field<T> {

    // Cast this field to the type of another field
    <Z> Field<Z> cast(Field<Z> field);

    // Cast this field to a given DataType
    <Z> Field<Z> cast(DataType<Z> type);

    // Cast this field to the default DataType for a given Class
    <Z> Field<Z> cast(Class<? extends Z> type);
}

// And additional convenience methods in the Factory:
public class Factory {
    <T> Field<T> cast(Object object, Field<T> field);
    <T> Field<T> cast(Object object, DataType<T> type);
    <T> Field<T> cast(Object object, Class<? extends T> type);
    <T> Field<T> castNull(Field<T> field);
    <T> Field<T> castNull(DataType<T> type);
    <T> Field<T> castNull(Class<? extends T> type);
}]]></java></content>
							</section>

							<section id="arithmetic-expressions">
								<title>Arithmetic expressions</title>
								<content><html>
									<h3>Numeric arithmetic expressions</h3>
									<p>
										Your database can do the math for you. Arithmetic operations are implemented just like <reference id="numeric-functions" title="numeric functions"/>, with similar limitations as far as type restrictions are concerned. You can use any of these operators:
									</p>

</html><config>  +  -  *  /  %</config><html>

									<p>
										In order to express a SQL query like this one:
									</p>

</html><sql>SELECT ((1 + 2) * (5 - 3) / 2) % 10 FROM DUAL</sql><html>

									<p>
										You can write something like this in jOOQ:
									</p>

</html><java>create.select(val(1).add(2).mul(val(5).sub(3)).div(2).mod(10);</java><html>

									<h3>Datetime arithmetic expressions</h3>
									<p>
										jOOQ also supports the Oracle-style syntax for adding days to a Field&lt;? extends java.util.Date&gt;
									</p>

</html><code-pair>
	<sql>SELECT SYSDATE + 3 FROM DUAL;</sql><java>create.select(currentTimestamp().add(3));</java>
</code-pair><html>

									<p>
										For more advanced datetime arithmetic, use the Factory's timestampDiff() and dateDiff() functions, as well as jOOQ's built-in SQL standard INTERVAL data type support:
									</p>
									<ul>
										<li>INTERVAL YEAR TO MONTH: <reference class="org.jooq.types.YearToMonth"/></li>
										<li>INTERVAL DAY TO SECOND: <reference class="org.jooq.types.DayToSecond"/></li>
									</ul>
								</html></content>
							</section>

							<section id="string-concatenation">
								<title>String concatenation</title>
								<content><html>
									<p>
										The SQL standard defines the concatenation operator to be an infix operator, similar to the ones we've seen in the chapter about <reference id="arithmetic-expressions" title="arithmetic expressions"/>. This operator looks like this: <code>||</code>. Some other dialects do not support this operator, but expect a <code>concat()</code> function, instead. jOOQ renders the right operator / function, depending on your <reference id="sql-dialects" title="SQL dialect"/>:
									</p>

</html><code-pair>
<sql>SELECT 'A' || 'B' || 'C' FROM DUAL
-- Or in MySQL:
SELECT concat('A', 'B', 'C') FROM DUAL</sql><java>&#160;
// For all RDBMS, including MySQL:
create.select(concat("A", "B", "C"));
</java>
</code-pair><html>
								</html></content>
							</section>

							<section id="general-functions">
								<title>General functions</title>
								<content><html>
									<p>
										There are a variety of general functions supported by jOOQ As discussed in the chapter about <reference id="sql-dialects" title="SQL dialects"/> functions are mostly emulated in your database, in case they are not natively supported.
									</p>
									<p>
										This is a list of general functions supported by jOOQ's <reference id="factory" title="Factory"/>:
									</p>
									<ul>
										<li><strong>COALESCE</strong>: Get the first non-null value in a list of arguments.</li>
										<li><strong>NULLIF</strong>: Return NULL if both arguments are equal, or the first argument, otherwise.</li>
										<li><strong>NVL</strong>: Get the first non-null value among two arguments.</li>
										<li><strong>NVL2</strong>: Get the second argument if the first is null, or the third argument, otherwise.</li>
									</ul>

									<p>
										Please refer to the <reference class="org.jooq.impl.Factory" title="Factory Javadoc"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="numeric-functions">
								<title>Numeric functions</title>
								<content><html>
									<p>
										Math can be done efficiently in the database before returning results to your Java application. In addition to the <reference id="arithmetic-expressions" title="arithmetic expressions" /> discussed previously, jOOQ also supports a variety of numeric functions. As discussed in the chapter about <reference id="sql-dialects" title="SQL dialects"/> numeric functions (as any function type) are mostly emulated in your database, in case they are not natively supported.
									</p>
									<p>
										This is a list of numeric functions supported by jOOQ's <reference id="factory" title="Factory"/>:
									</p>

									<ul>
										<li><strong>ABS</strong>: Get the absolute value of a value.</li>
										<li><strong>ACOS</strong>: Get the arc cosine of a value.</li>
										<li><strong>ASIN</strong>: Get the arc sine of a value.</li>
										<li><strong>ATAN</strong>: Get the arc tangent of a value.</li>
										<li><strong>ATAN2</strong>: Get the atan2 function of two values.</li>
										<li><strong>CEIL</strong>: Get the smalles integer value larger than a given numeric value.</li>
										<li><strong>COS</strong>: Get the cosine of a value.</li>
										<li><strong>COSH</strong>: Get the hyperbolic cosine of a value.</li>
										<li><strong>COT</strong>: Get the cotangent of a value.</li>
										<li><strong>COTH</strong>: Get the hyperbolic cotangent of a value.</li>
										<li><strong>DEG</strong>: Transform radians into degrees.</li>
										<li><strong>EXP</strong>: Calculate e^value.</li>
										<li><strong>FLOOR</strong>: Get the largest integer value smaller than a given numeric value.</li>
										<li><strong>GREATEST</strong>: Finds the greatest among all argument values (can also be used with non-numeric values).</li>
										<li><strong>LEAST</strong>: Finds the least among all argument values (can also be used with non-numeric values).</li>
										<li><strong>LN</strong>: Get the natural logarithm of a value.</li>
										<li><strong>LOG</strong>: Get the logarithm of a value given a base.</li>
										<li><strong>POWER</strong>: Calculate value^exponent.</li>
										<li><strong>RAD</strong>: Transform degrees into radians.</li>
										<li><strong>RAND</strong>: Get a random number.</li>
										<li><strong>ROUND</strong>: Rounds a value to the nearest integer.</li>
										<li><strong>SIGN</strong>: Get the sign of a value (-1, 0, 1).</li>
										<li><strong>SIN</strong>: Get the sine of a value.</li>
										<li><strong>SINH</strong>: Get the hyperbolic sine of a value.</li>
										<li><strong>SQRT</strong>: Calculate the square root of a value.</li>
										<li><strong>TAN</strong>: Get the tangent of a value.</li>
										<li><strong>TANH</strong>: Get the hyperbolic tangent of a value.</li>
										<li><strong>TRUNC</strong>: Truncate the decimals off a given value.</li>
									</ul>

									<p>
										Please refer to the <reference class="org.jooq.impl.Factory" title="Factory Javadoc"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="bitwise-functions">
								<title>Bitwise functions</title>
								<content><html>
									<p>
										Interestingly, bitwise functions and bitwise arithmetic is not very popular among SQL databases. Most databases only support a few bitwise operations, while others ship with the full set of operators. jOOQ's API includes most bitwise operations as listed below. In order to avoid ambiguities with <reference id="conditional-expressions" title="conditional operators"/>, all bitwise functions are prefixed with "bit"
									</p>
									<ul>
										<li><strong>BIT_COUNT</strong>: Count the number of bits set to 1 in a number</li>
										<li><strong>BIT_AND</strong>: Set only those bits that are set in two numbers</li>
										<li><strong>BIT_OR</strong>: Set all bits that are set in at least one number</li>
										<li><strong>BIT_NAND</strong>: Set only those bits that are set in two numbers, and inverse the result</li>
										<li><strong>BIT_NOR</strong>: Set all bits that are set in at least one number, and inverse the result</li>
										<li><strong>BIT_NOT</strong>: Inverse the bits in a number</li>
										<li><strong>BIT_XOR</strong>: Set all bits that are set in at exactly one number</li>
										<li><strong>BIT_XNOR</strong>: Set all bits that are set in at exactly one number, and inverse the result</li>
										<li><strong>SHL</strong>: Shift bits to the left</li>
										<li><strong>SHR</strong>: Shift bits to the right</li>
									</ul>

									<h3>Some background about bitwise operation emulation</h3>
									<p>
										As stated before, not all databases support all of these bitwise operations. jOOQ emulates them wherever this is possible. More details can be seen in this blog post: <br/>
										<a href="http://blog.jooq.org/2011/10/30/the-comprehensive-sql-bitwise-operations-compatibility-list/">http://blog.jooq.org/2011/10/30/the-comprehensive-sql-bitwise-operations-compatibility-list/</a>
									</p>

								</html></content>
							</section>

							<section id="string-functions">
								<title>String functions</title>
								<content><html>
									<p>
										String formatting can be done efficiently in the database before returning results to your Java application. As discussed in the chapter about <reference id="sql-dialects" title="SQL dialects"/> string functions (as any function type) are mostly emulated in your database, in case they are not natively supported.
									</p>
									<p>
										This is a list of numeric functions supported by jOOQ's <reference id="factory" title="Factory"/>:
									</p>

									<ul>
										<li><strong>ASCII</strong>: Get the ASCII code of a character.</li>
										<li><strong>BIT_LENGTH</strong>: Get the length of a string in bits.</li>
										<li><strong>CHAR_LENGTH</strong>: Get the length of a string in characters.</li>
										<li><strong>CONCAT</strong>: Concatenate several strings.</li>
										<li><strong>ESCAPE</strong>: Escape a string for use with the <reference id="like-predicate" title="LIKE predicate"/>.</li>
										<li><strong>LENGTH</strong>: Get the length of a string.</li>
										<li><strong>LOWER</strong>: Get a string in lower case letters.</li>
										<li><strong>LPAD</strong>: Pad a string on the left side.</li>
										<li><strong>LTRIM</strong>: Trim a string on the left side.</li>
										<li><strong>OCTET_LENGTH</strong>: Get the length of a string in octets.</li>
										<li><strong>POSITION</strong>: Find a string within another string.</li>
										<li><strong>REPEAT</strong>: Repeat a string a given number of times.</li>
										<li><strong>REPLACE</strong>: Replace a string within another string.</li>
										<li><strong>RPAD</strong>: Pad a string on the right side.</li>
										<li><strong>RTRIM</strong>: Trim a string on the right side.</li>
										<li><strong>SUBSTRING</strong>: Get a substring of a string.</li>
										<li><strong>TRIM</strong>: Trim a string on both sides.</li>
										<li><strong>UPPER</strong>: Get a string in upper case letters.</li>
									</ul>

									<p>
										Please refer to the <reference class="org.jooq.impl.Factory" title="Factory Javadoc"/> for more details.
									</p>

									<h3>Regular expressions, REGEXP, REGEXP_LIKE, etc.</h3>
									<p>
										Various databases have some means of searching through columns using regular expressions if the <reference id="like-predicate" title="LIKE predicate"/> does not provide sufficient pattern matching power. While there are many different functions and operators in the various databases, jOOQ settled for the SQL:2008 standard REGEX_LIKE operator. Being an operator (and not a function), you should use the corresponding method on <reference class="org.jooq.Field"/>:
									</p>

</html><java><![CDATA[create.selectFrom(BOOK).where(TITLE.likeRegex("^.*SQL.*$"));]]></java><html>

									<p>
										Note that the SQL standard specifies that patterns should follow the XQuery standards. In the real world, the POSIX regular expression standard is the most used one, some use Java regular expressions, and only a few ones use Perl regular expressions. jOOQ does not make any assumptions about regular expression syntax. For cross-database compatibility, please read the relevant database manuals carefully, to learn about the appropriate syntax. Please refer to the <reference class="org.jooq.impl.Factory" title="Factory Javadoc"/> for more details.
									</p>
								</html></content>
								<!-- don't forget regex here! -->
							</section>

							<section id="date-and-time-functions">
								<title>Date and time functions</title>
								<content><html>
									<p>
										This is a list of date and time functions supported by jOOQ's <reference id="factory" title="Factory"/>:
									</p>

									<ul>
										<li><strong>CURRENT_DATE</strong>: Get current date as a DATE object.</li>
										<li><strong>CURRENT_TIME</strong>: Get current time as a TIME object.</li>
										<li><strong>CURRENT_TIMESTAMP</strong>: Get current date as a TIMESTAMP object.</li>
										<li><strong>DATE_ADD</strong>: Add a number of days or an interval to a date.</li>
										<li><strong>DATE_DIFF</strong>: Get the difference in days between two dates.</li>
										<li><strong>TIMESTAMP_ADD</strong>: Add a number of days or an interval to a timestamp.</li>
										<li><strong>TIMESTAMP_DIFF</strong>: Get the difference as an INTERVAL DAY TO SECOND between two dates.</li>
									</ul>

									<h3>Intervals in jOOQ</h3>
									<p>
										jOOQ fills a gap opened by JDBC, which neglects an important SQL data type as defined by the SQL standards: INTERVAL types. See the manual's section about <reference id="data-types-intervals" title="INTERVAL data types"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="system-functions">
								<title>System functions</title>
								<content><html>
									<p>
										This is a list of system functions supported by jOOQ's <reference id="factory" title="Factory"/>:
									</p>
									<ul>
										<li><strong>CURRENT_USER</strong>: Get current user.</li>
									</ul>
								</html></content>
							</section>

							<section id="aggregate-functions">
								<title>Aggregate functions</title>
								<content><html>
									<p>
										Aggregate functions work just like functions, even if they have a slightly different semantics. Here are some example aggregate functions from the <reference id="factory" title="Factory"/>:
									</p>

</html><java><![CDATA[// Every-day, SQL standard aggregate functions
AggregateFunction<Integer> count();
AggregateFunction<Integer> count(Field<?> field);
AggregateFunction<T> max(Field<T> field);
AggregateFunction<T> min(Field<T> field);
AggregateFunction<BigDecimal> sum(Field<? extends Number> field);
AggregateFunction<BigDecimal> avg(Field<? extends Number> field);

// DISTINCT keyword in aggregate functions
AggregateFunction<Integer> countDistinct(Field<?> field);
AggregateFunction<T> maxDistinct(Field<T> field);
AggregateFunction<T> minDistinct(Field<T> field);
AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field);
AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field);

// String aggregate functions
AggregateFunction<String> groupConcat(Field<?> field);
AggregateFunction<String> groupConcatDistinct(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field);
OrderedAggregateFunction<String> listAgg(Field<?> field, String separator);

// Statistical functions
AggregateFunction<BigDecimal> median(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field);
AggregateFunction<BigDecimal> varPop(Field<? extends Number> field);
AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field);]]></java><html>

									<p>
										Here's an example, counting the number of books any author has written:
									</p>

</html><code-pair>
<sql>SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY AUTHOR_ID</sql><java>create.select(BOOK.AUTHOR_ID, count())
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID);</java>
</code-pair><html>

									<p>
										Aggregate functions have strong limitations about when they may be used and when not. For instance, you can use aggregate functions in scalar queries. Typically, this means you only select aggregate functions, no <reference id="table-columns" title="regular columns"/> or other <reference id="column-expressions" title="column expressions"/>. Another use case is to use them along with a <reference id="group-by-clause" title="GROUP BY clause"/> as seen in the previous example. Note, that jOOQ does not check whether your using of aggregate functions is correct according to the SQL standards, or according to your database's behaviour.
									</p>

		                            <h3>Ordered-set aggregate functions</h3>
		                            <p>
		                            	Oracle and some other databases support "ordered-set aggregate functions". This means you can provide an ORDER BY clause to an aggregate function, which will be taken into consideration when aggregating. The best example for this is Oracle's <code>LISTAGG()</code> (also known as <code>GROUP_CONCAT</code> in other <reference id="sql-dialects" title="SQL dialects"/>). The following query groups by authors and concatenates their books' titles
		                           	</p>
</html><code-pair>
<sql>SELECT   LISTAGG(TITLE, ', ')
         WITHIN GROUP (ORDER BY TITLE)
FROM     BOOK
GROUP BY AUTHOR_ID</sql><java>create.select(listAgg(BOOK.TITLE, ", ")
      .withinGroupOrderBy(BOOK.TITLE))
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID)</java>
</code-pair><html>

									<p>
										The above query might yield:
									</p>

</html><text>+---------------------+
| LISTAGG             |
+---------------------+
| 1984, Animal Farm   |
| O Alquimista, Brida |
+---------------------+</text><html>

									<h3>FIRST and LAST: Oracle's "ranked" aggregate functions</h3>
									<p>
										Oracle allows for restricting aggregate functions using the <code>KEEP()</code> clause, which is supported by jOOQ. In Oracle, some aggregate functions (MIN, MAX, SUM, AVG, COUNT, VARIANCE, or STDDEV) can be restricted by this clause, hence <reference class="org.jooq.AggregateFunction"/> also allows for specifying it. Here are a couple of examples using this clause:
									</p>

</html><code-pair>
<sql>SUM(BOOK.AMOUNT_SOLD)
  KEEP(DENSE_RANK FIRST ORDER BY BOOK.AUTHOR_ID)</sql><java>sum(BOOK.AMOUNT_SOLD)
  .keepDenseRankFirstOrderBy(BOOK.AUTHOR_ID)</java>
</code-pair><html>

									<h3>User-defined aggregate functions</h3>
									<p>
										jOOQ also supports using your own user-defined aggregate functions. See the manual's section about <reference id="user-defined-aggregate-functions" title="user-defined aggregate functions"/> for more details.
									</p>

									<h3>Window functions / analytical functions</h3>
									<p>
										In those databases that support <reference id="window-functions" title="window functions"/>, jOOQ's <reference class="org.jooq.AggregateFunction"/> can be transformed into a window function / analytical function by calling <code>over()</code> on it. See the manual's section about <reference id="window-functions" title="window functions"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="window-functions">
								<title>Window functions</title>
								<content><html>
									<p>
										Most major RDBMS support the concept of window functions. jOOQ knows of implementations in DB2, Oracle, Postgres, SQL Server, and Sybase SQL Anywhere, and supports most of their specific syntaxes. Note, that H2 and HSQLDB have implemented <code>ROW_NUMBER()</code> functions, without true windowing support.
									</p>
									<p>
										As previously discussed, any <reference class="org.jooq.AggregateFunction"/> can be transformed into a window function using the <code>over()</code> method. See the chapter about <reference id="aggregate-functions" title="aggregate functions"/> for details. In addition to those, there are also some more window functions supported by jOOQ, as declared in the <reference id="factory" title="Factory"/>:
									</p>

</html><java><![CDATA[// Ranking functions
    WindowOverStep<Integer>    rowNumber();
    WindowOverStep<Integer>    rank();
    WindowOverStep<Integer>    denseRank();
    WindowOverStep<BigDecimal> percentRank();

// Windowing functions
<T> WindowIgnoreNullsStep<T>   firstValue(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lastValue(Field<T> field)
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset, T defaultValue);
<T> WindowIgnoreNullsStep<T>   lead(Field<T> field, int offset, Field<T> defaultValue);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset, T defaultValue);
<T> WindowIgnoreNullsStep<T>   lag(Field<T> field, int offset, Field<T> defaultValue);

// Statistical functions
    WindowOverStep<BigDecimal> cumeDist();
    WindowOverStep<Integer>    ntile(int number);]]></java><html>

    								<p>
    									SQL distinguishes between various window function types (e.g. "ranking functions"). Depending on the function, SQL expects mandatory <code>PARTITION BY</code> or <code>ORDER BY</code> clauses within the <code>OVER()</code> clause. jOOQ does not enforce those rules for two reasons:
    								</p>
    								<ul>
    									<li>Your JDBC driver or database already checks SQL syntax semantics</li>
    									<li>Not all databases behave correctly according to the SQL standard</li>
    								</ul>
    								<p>
    									If possible, however, jOOQ tries to render missing clauses for you, if a given <reference id="sql-dialects" title="SQL dialect"/> is more restrictive.
    								</p>
    								<h3>Some examples</h3>
									<p>
										 Here are some simple examples of window functions with jOOQ:
									</p>

</html><code-pair>
<sql>-- Sample uses of ROW_NUMBER()
ROW_NUMBER() OVER()
ROW_NUMBER() OVER(PARTITION BY 1)
ROW_NUMBER() OVER(ORDER BY BOOK.ID)
ROW_NUMBER() OVER(PARTITION BY BOOK.AUTHOR_ID ORDER BY BOOK.ID)

-- Sample uses of FIRST_VALUE
FIRST_VALUE(BOOK.ID) OVER()
FIRST_VALUE(BOOK.ID IGNORE NULLS) OVER()
FIRST_VALUE(BOOK.ID RESPECT NULLS) OVER()
</sql><java>// Sample uses of rowNumber()
rowNumber().over()
rowNumber().over().partitionByOne()
rowNumber().over().partitionBy(BOOK.AUTHOR_ID)
rowNumber().over().partitionBy(BOOK.AUTHOR_ID).orderBy(BOOK.ID)

// Sample uses of firstValue()
firstValue(BOOK.ID).over()
firstValue(BOOK.ID).ignoreNulls().over()
firstValue(BOOK.ID).respectNulls().over()
</java>
</code-pair><html>

									<h3>An advanced window function example</h3>
									<p>
										Window functions can be used for things like calculating a "running total". The following example fetches transactions and the running total for every transaction going back to the beginning of the transaction table (ordered by booked_at). Window functions are accessible from the previously seen <reference class="org.jooq.AggregateFunction"/> type using the <code>over()</code> method:
									</p>

</html><code-pair>
<sql>SELECT booked_at, amount,
   SUM(amount) OVER (PARTITION BY 1
                     ORDER BY booked_at
                     ROWS BETWEEN UNBOUNDED PRECEDING
                     AND CURRENT ROW) AS total
  FROM transactions</sql><java>create.select(t.BOOKED_AT, t.AMOUNT,
         sum(t.AMOUNT).over().partitionByOne()
                      .orderBy(t.BOOKED_AT)
                      .rowsBetweenUnboundedPreceding()
                      .andCurrentRow().as("total")
      .from(TRANSACTIONS.as("t"));</java>
</code-pair><html>


									<h3>Window functions created from ordered-set aggregate functions</h3>
									<p>
										In the previous chapter about <reference id="aggregate-functions" title="aggregate functions"/>, we have seen the concept of "ordered-set aggregate functions", such as Oracle's <code>LISTAGG()</code>. These functions have a window function / analytical function variant, as well. For example:
									</p>

</html><code-pair>
<sql>SELECT   LISTAGG(TITLE, ', ')
         WITHIN GROUP (ORDER BY TITLE)
         OVER (PARTITION BY BOOK.AUTHOR_ID)
FROM     BOOK</sql><java>create.select(listAgg(BOOK.TITLE, ", ")
      .withinGroupOrderBy(BOOK.TITLE)
      .over().partitionBy(BOOK.AUTHOR_ID))
      .from(BOOK)</java>
</code-pair><html>

									<h3>Window functions created from Oracle's FIRST and LAST aggregate functions</h3>
									<p>
										In the previous chapter about <reference id="aggregate-functions" title="aggregate functions"/>, we have seen the concept of "FIRST and LAST aggregate functions". These functions have a window function / analytical function variant, as well. For example:
									</p>

</html><code-pair>
<sql>SUM(BOOK.AMOUNT_SOLD)
  KEEP(DENSE_RANK FIRST ORDER BY BOOK.AUTHOR_ID)
  OVER(PARTITION BY 1)</sql><java>sum(BOOK.AMOUNT_SOLD)
  .keepDenseRankFirstOrderBy(BOOK.AUTHOR_ID)
  .over().partitionByOne()</java>
</code-pair><html>


									<h3>Window functions created from user-defined aggregate functions</h3>
									<p>
										User-defined aggregate functions also implement <reference class="org.jooq.AggregateFunction"/>, hence they can also be transformed into window functions using <code>over()</code>. This is supported by Oracle in particular. See the manual's section about <reference id="user-defined-aggregate-functions" title="user-defined aggregate functions"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="grouping-functions">
								<title>Grouping functions</title>
								<content><html>
									<h3>ROLLUP() explained in SQL</h3>
									<p>
										The SQL standard defines special functions that can be used in the <reference id="group-by-clause" title="GROUP BY clause"/>: the grouping functions. These functions can be used to generate several groupings in a single clause. This can best be explained in SQL. Let's take ROLLUP() for instance:
									</p>

</html><code-pair>
<sql><![CDATA[-- ROLLUP() with one argument
SELECT AUTHOR_ID, COUNT(*)
FROM BOOK
GROUP BY ROLLUP(AUTHOR_ID)


-- ROLLUP() with two arguments
SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
FROM BOOK
GROUP BY ROLLUP(AUTHOR_ID, PUBLISHED_IN)







]]></sql><sql><![CDATA[-- The same query using UNION ALL:
  SELECT AUTHOR_ID, COUNT(*) FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, COUNT(*) FROM BOOK GROUP BY ()
ORDER BY 1 NULLS LAST

-- The same query using UNION ALL:
  SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
  FROM BOOK GROUP BY (AUTHOR_ID, PUBLISHED_IN)
UNION ALL
  SELECT AUTHOR_ID, NULL, COUNT(*)
  FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, NULL, COUNT(*)
  FROM BOOK GROUP BY ()
ORDER BY 1 NULLS LAST, 2 NULLS LAST
]]></sql>
</code-pair><html>

									<p>
										In English, the <code>ROLLUP()</code> grouping function provides <code>N+1</code> groupings, when <code>N</code> is the number of arguments to the <code>ROLLUP()</code> function. Each grouping has an additional group field from the <code>ROLLUP()</code> argument field list. The results of the second query might look something like this:
									</p>

</html><text><![CDATA[+-----------+--------------+----------+
| AUTHOR_ID | PUBLISHED_IN | COUNT(*) |
+-----------+--------------+----------+
|         1 |         1945 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         1948 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         2 |         1988 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         1990 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|      NULL |         NULL |        4 | <- GROUP BY ()
+-----------+--------------+----------+]]></text><html>

									<h3>CUBE() explained in SQL</h3>
									<p>
										<code>CUBE()</code> is different from <code>ROLLUP()</code> in the way that it doesn't just create <code>N+1</code> groupings, it creates all <code>2^N</code> possible combinations between all group fields in the <code>CUBE()</code> function argument list. Let's re-consider our second query from before:
									</p>

</html><code-pair>
<sql><![CDATA[-- CUBE() with two arguments
SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
FROM BOOK
GROUP BY CUBE(AUTHOR_ID, PUBLISHED_IN)










]]></sql><sql><![CDATA[-- The same query using UNION ALL:
  SELECT AUTHOR_ID, PUBLISHED_IN, COUNT(*)
  FROM BOOK GROUP BY (AUTHOR_ID, PUBLISHED_IN)
UNION ALL
  SELECT AUTHOR_ID, NULL, COUNT(*)
  FROM BOOK GROUP BY (AUTHOR_ID)
UNION ALL
  SELECT NULL, PUBLISHED_IN, COUNT(*)
  FROM BOOK GROUP BY (PUBLISHED_IN)
UNION ALL
  SELECT NULL, NULL, COUNT(*)
  FROM BOOK GROUP BY ()
ORDER BY 1 NULLS FIRST, 2 NULLS FIRST
]]></sql>
</code-pair><html>

									<p>
										The results would then hold:
									</p>

</html><text><![CDATA[+-----------+--------------+----------+
| AUTHOR_ID | PUBLISHED_IN | COUNT(*) |
+-----------+--------------+----------+
|      NULL |         NULL |        2 | <- GROUP BY ()
|      NULL |         1945 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1948 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1988 |        1 | <- GROUP BY (PUBLISHED_IN)
|      NULL |         1990 |        1 | <- GROUP BY (PUBLISHED_IN)
|         1 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         1 |         1945 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         1 |         1948 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         NULL |        2 | <- GROUP BY (AUTHOR_ID)
|         2 |         1988 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
|         2 |         1990 |        1 | <- GROUP BY (AUTHOR_ID, PUBLISHED_IN)
+-----------+--------------+----------+]]></text><html>

									<h3>GROUPING SETS()</h3>
									<p>
										<code>GROUPING SETS()</code> are the generalised way to create multiple groupings. From our previous examples
									</p>
									<ul>
										<li><code>ROLLUP(AUTHOR_ID, PUBLISHED_IN)</code> corresponds to <code>GROUPING SETS((AUTHOR_ID, PUBLISHED_IN), (AUTHOR_ID), ())</code></li>
										<li><code>CUBE(AUTHOR_ID, PUBLISHED_IN)</code> corresponds to <code>GROUPING SETS((AUTHOR_ID, PUBLISHED_IN), (AUTHOR_ID), (PUBLISHED_IN), ())</code></li>
									</ul>
									<p>
										This is nicely explained in the SQL Server manual pages about <code>GROUPING SETS()</code> and other grouping functions:<br/>
										<a href="http://msdn.microsoft.com/en-us/library/bb510427(v=sql.105)">http://msdn.microsoft.com/en-us/library/bb510427(v=sql.105)</a>
									</p>

									<h3>jOOQ's support for ROLLUP(), CUBE(), GROUPING SETS()</h3>
									<p>
										jOOQ fully supports all of these functions, as well as the utility functions <code>GROUPING()</code> and <code>GROUPING_ID()</code>, used for identifying the grouping set ID of a record. The <reference id="factory" title="Factory API"/> thus includes:
									</p>

</html><java><![CDATA[// The various grouping function constructors
Field<?> rollup(Field<?>... fields);
Field<?> cube(Field<?>... fields);
Field<?> groupingSets(Field<?>... fields);
Field<?> groupingSets(Field<?>[]... fields);
Field<?> groupingSets(Collection<Field<?>>... fields);

// The utility functions generating IDs per GROUPING SET
Field<Integer> grouping(Field<?>);
Field<Integer> groupingId(Field<?>...);]]></java><html>

									<h3>MySQL's and CUBRID's WITH ROLLUP syntax</h3>
									<p>
										MySQL and CUBRID don't know any grouping functions, but they support a <code>WITH ROLLUP</code> clause, that is equivalent to simple <code>ROLLUP()</code> grouping functions. jOOQ emulates <code>ROLLUP()</code> in MySQL and CUBRID, by rendering this <code>WITH ROLLUP</code> clause. The following two statements mean the same:
									</p>

</html><code-pair>
<sql><![CDATA[-- Statement 1: SQL standard
GROUP BY ROLLUP(A, B, C)

-- Statement 2: SQL standard
GROUP BY A, ROLLUP(B, C)]]></sql><sql><![CDATA[-- Statement 1: MySQL
GROUP BY A, B, C WITH ROLLUP

-- Statement 2: MySQL
-- This is not supported in MySQL]]></sql>
</code-pair><html>
								</html></content>
							</section>

							<section id="user-defined-functions">
								<title>User-defined functions</title>
								<content><html>
									<p>
										Some databases support user-defined functions, which can be embedded in any SQL statement, if you're using jOOQ's <reference id="code-generation" title="code generator"/>. Let's say you have the following simple function in Oracle SQL:
									</p>

</html><sql><![CDATA[CREATE OR REPLACE FUNCTION echo (INPUT NUMBER)
RETURN NUMBER
IS
BEGIN
    RETURN INPUT;
END echo;
]]></sql><html>

                                    <p>
                                    	The above function will be made available from a generated <reference id="codegen-procedures" title="Routines"/> class. You can use it like any other <reference id="column-expressions" title="column expression"/>:
                                    </p>

</html><code-pair>
<sql><![CDATA[SELECT echo(1) FROM DUAL WHERE echo(2) = 2]]></sql><java><![CDATA[create.select(echo(1)).where(echo(2).equal(2));]]></java>
</code-pair><html>

                                	<p>
                                		Note that user-defined functions returning <reference id="data-types-cursors" title="CURSOR"/> or <reference id="data-types-arrays" title="ARRAY"/> data types can also be used wherever <reference id="table-expressions" title="table expressions"/> can be used, if they are <reference id="array-and-cursor-unnesting" title="unnested"/>
                                	</p>
								</html></content>
							</section>

							<section id="user-defined-aggregate-functions">
								<title>User-defined aggregate functions</title>
								<content><html>
									<p>
										Some databases support user-defined aggregate functions, which can then be used along with <reference id="group-by-clause" title="GROUP BY clauses"/> or as <reference id="window-functions" title="window functions"/>. An example for such a database is Oracle. With Oracle, you can define the following OBJECT type (the example was taken from the <a href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28425/ext_agg_ref.htm">Oracle 11g documentation</a>):
									</p>

</html><sql><![CDATA[CREATE TYPE U_SECOND_MAX AS OBJECT
(
  MAX NUMBER, -- highest value seen so far
  SECMAX NUMBER, -- second highest value seen so far
  STATIC FUNCTION ODCIAggregateInitialize(sctx IN OUT U_SECOND_MAX) RETURN NUMBER,
  MEMBER FUNCTION ODCIAggregateIterate(self IN OUT U_SECOND_MAX, value IN NUMBER) RETURN NUMBER,
  MEMBER FUNCTION ODCIAggregateTerminate(self IN U_SECOND_MAX, returnValue OUT NUMBER, flags IN NUMBER) RETURN NUMBER,
  MEMBER FUNCTION ODCIAggregateMerge(self IN OUT U_SECOND_MAX, ctx2 IN U_SECOND_MAX) RETURN NUMBER
);

CREATE OR REPLACE TYPE BODY U_SECOND_MAX IS
STATIC FUNCTION ODCIAggregateInitialize(sctx IN OUT U_SECOND_MAX)
RETURN NUMBER IS
BEGIN
  SCTX := U_SECOND_MAX(0, 0);
  RETURN ODCIConst.Success;
END;

MEMBER FUNCTION ODCIAggregateIterate(self IN OUT U_SECOND_MAX, value IN NUMBER) RETURN NUMBER IS
BEGIN
  IF VALUE > SELF.MAX THEN
    SELF.SECMAX := SELF.MAX;
    SELF.MAX := VALUE;
  ELSIF VALUE > SELF.SECMAX THEN
    SELF.SECMAX := VALUE;
  END IF;
  RETURN ODCIConst.Success;
END;

MEMBER FUNCTION ODCIAggregateTerminate(self IN U_SECOND_MAX, returnValue OUT NUMBER, flags IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURNVALUE := SELF.SECMAX;
  RETURN ODCIConst.Success;
END;

MEMBER FUNCTION ODCIAggregateMerge(self IN OUT U_SECOND_MAX, ctx2 IN U_SECOND_MAX) RETURN NUMBER IS
BEGIN
  IF CTX2.MAX > SELF.MAX THEN
    IF CTX2.SECMAX > SELF.SECMAX THEN
      SELF.SECMAX := CTX2.SECMAX;
    ELSE
      SELF.SECMAX := SELF.MAX;
    END IF;
    SELF.MAX := CTX2.MAX;
  ELSIF CTX2.MAX > SELF.SECMAX THEN
    SELF.SECMAX := CTX2.MAX;
  END IF;
  RETURN ODCIConst.Success;
END;
END;]]></sql><html>

									<p>
										The above OBJECT type is then available to function declarations as such:
									</p>

</html><sql><![CDATA[
CREATE FUNCTION SECOND_MAX (input NUMBER) RETURN NUMBER
PARALLEL_ENABLE AGGREGATE USING U_SECOND_MAX;]]></sql><html>

									<h3>Using the generated aggregate function</h3>
									<p>
										jOOQ's <reference id="code-generation" title="code generator"/> will detect such aggregate functions and generate them differently from regular <reference id="user-defined-functions" title="user-defined functions"/>. They implement the <reference class="org.jooq.AggregateFunction"/> type, as mentioned in the manual's section about <reference id="aggregate-functions" title="aggregate functions"/>. Here's how you can use the SECOND_MAX() aggregate function with jOOQ:
									</p>

</html><code-pair>
<sql><![CDATA[-- Get the second-latest publishing date by author
SELECT SECOND_MAX(PUBLISHED_IN)
FROM BOOK
GROUP BY AUTHOR_ID]]></sql><java><![CDATA[// Routines.secondMax() can be static-imported
create.select(secondMax(BOOK.PUBLISHED_IN))
      .from(BOOK)
      .groupBy(BOOK.AUTHOR_ID)]]></java>
</code-pair><html>
								</html></content>
							</section>

							<section id="case-expressions">
								<title>The CASE expression</title>
								<content><html>
									<p>
										The CASE expression is part of the standard SQL syntax. While some RDBMS also offer an IF expression, or a DECODE function, you can always rely on the two types of CASE syntax:
									</p>

</html><code-pair>
<sql><![CDATA[CASE WHEN AUTHOR.FIRST_NAME = 'Paulo'  THEN 'brazilian'
     WHEN AUTHOR.FIRST_NAME = 'George' THEN 'english'
                                       ELSE 'unknown'
END

-- OR:

CASE AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                       WHEN 'George' THEN 'english'
                                     ELSE 'unknown'
END]]></sql><java><![CDATA[create.decode()
      .when(AUTHOR.FIRST_NAME.equal("Paulo"), "brazilian")
      .when(AUTHOR.FIRST_NAME.equal("George"), "english")
      .otherwise("unknown");

// OR:

create.decode().value(AUTHOR.FIRST_NAME)
               .when("Paulo", "brazilian")
               .when("George", "english")
               .otherwise("unknown");]]></java>
</code-pair><html>

								<p>
									In jOOQ, both syntaxes are supported (The second one is emulated in Derby, which only knows the first one). Unfortunately, both case and else are reserved words in Java. jOOQ chose to use decode() from the Oracle DECODE function, and otherwise(), which means the same as else.
								</p>

								<p>
									A CASE expression can be used anywhere where you can place a <reference id="column-expressions" title="column expression (or Field)"/>. For instance, you can SELECT the above expression, if you're selecting from AUTHOR:
							 	</p>

</html><sql>SELECT AUTHOR.FIRST_NAME, [... CASE EXPR ...] AS nationality
  FROM AUTHOR</sql><html>

								<h3>The Oracle DECODE() function</h3>
								<p>
									Oracle knows a more succinct, but maybe less readable DECODE() function with a variable number of arguments. This function roughly does the same as the second case expression syntax. jOOQ supports the DECODE() function and emulates it using CASE expressions in all dialects other than Oracle:
								</p>

</html><code-pair>
<sql><![CDATA[-- Oracle:
DECODE(FIRST_NAME, 'Paulo', 'brazilian',
                   'George', 'english',
                   'unknown');

-- Other SQL dialects
CASE AUTHOR.FIRST_NAME WHEN 'Paulo'  THEN 'brazilian'
                       WHEN 'George' THEN 'english'
                                     ELSE 'unknown'
END]]></sql><java><![CDATA[




// Use the Oracle-style DECODE() function with jOOQ.
// Note, that you will not be able to rely on type-safety
create.decode(AUTHOR.FIRST_NAME,
    "Paulo", "brazilian",
    "George", "english",
    "unknown");]]></java>
</code-pair><html>

		  							<h3>CASE clauses in an ORDER BY clause</h3>
									<p>
										Sort indirection is often implemented with a CASE clause of a SELECT's ORDER BY clause. See the manual's section about the <reference id="order-by-clause" title="ORDER BY clause"/> for more details.
									</p>
								</html></content>
							</section>

							<section id="sequences-and-serials">
								<title>Sequences and serials</title>
								<content><html>
									<p>
										Sequences implement the <reference class="org.jooq.Sequence"/> interface, providing essentially this functionality:
									</p>

</html><java><![CDATA[// Get a field for the CURRVAL sequence property
Field<T> currval();

// Get a field for the NEXTVAL sequence property
Field<T> nextval();]]></java><html>

									<p>
										So if you have a sequence like this in Oracle:
									</p>

</html><sql>CREATE SEQUENCE s_author_id</sql><html>

									<p>
										You can then use your <reference id="codegen-sequences" title="generated sequence"/> object directly in a SQL statement as such:
									</p>

</html><java><![CDATA[// Reference the sequence in a SELECT statement:
BigInteger nextID = create.select(s).fetchOne(S_AUTHOR_ID.nextval());

// Reference the sequence in an INSERT statement:
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(S_AUTHOR_ID.nextval(), val("William"), val("Shakespeare"));
]]></java><html>

									<ul>
										<li>For more information about generated sequences, refer to the manual's section about <reference id="codegen-sequences" title="generated sequences"/></li>
										<li>For more information about executing standalone calls to sequences, refer to the manual's section about <reference id="sequence-execution" title="sequence execution"/></li>
									</ul>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="conditional-expressions">
					    <title>Conditional expressions</title>
						<content><html>
							<p>
								Conditions or conditional expressions are widely used in SQL and in the jOOQ API. They can be used in
							</p>
							<ul>
								<li>The <reference id="case-expressions" title="CASE expression"/></li>
								<li>The <reference id="join-clause" title="JOIN clause"/> (or JOIN .. ON clause, to be precise) of a <reference id="select-statement" title="SELECT statement"/>, <reference id="update-statement" title="UPDATE statement"/>, <reference id="delete-statement" title="DELETE statement"/></li>
								<li>The <reference id="where-clause" title="WHERE clause"/> of a <reference id="select-statement" title="SELECT statement"/>, <reference id="update-statement" title="UPDATE statement"/>, <reference id="delete-statement" title="DELETE statement"/></li>
								<li>The <reference id="connect-by-clause" title="CONNECT BY clause"/> of a <reference id="select-statement" title="SELECT statement"/></li>
								<li>The <reference id="having-clause" title="HAVING clause"/> of a <reference id="select-statement" title="SELECT statement"/></li>
								<li>The <reference id="merge-statement" title="MERGE statement"/>'s ON clause</li>
							</ul>

							<h3>Boolean types in SQL</h3>
							<p>
								Before SQL:1999, boolean types did not really exist in SQL. They were modelled by 0 and 1 numeric/char values. With SQL:1999, true booleans were introduced and are now supported by most databases. In short, these are possible boolean values:
							</p>
							<ul>
								<li>1 or TRUE</li>
								<li>0 or FALSE</li>
								<li>NULL or UNKNOWN</li>
							</ul>
							<p>
								It is important to know that SQL differs from many other languages in the way it interprets the NULL boolean value. Most importantly, the following facts are to be remembered:
							</p>
							<ul>
								<li>[ANY] = NULL yields NULL (not FALSE)</li>
								<li>[ANY] != NULL yields NULL (not TRUE)</li>
								<li>NULL = NULL yields NULL (not TRUE)</li>
								<li>NULL != NULL yields NULL (not FALSE)</li>
							</ul>
							<p>
								For simplified NULL handling, please refer to the section about the <reference id="distinct-predicate" title="DISTINCT predicate"/>.
							</p>
							<p>
								Note that jOOQ does not model these values as actual <reference id="column-expressions" title="column expression"/> compatible.
							</p>
						</html></content>

						<sections>
						    <section id="condition-building">
							    <title>Condition building</title>
								<content><html>
									<p>
										With jOOQ, most <reference id="conditional-expressions" title="conditional expressions"/> are built from <reference id="column-expressions" title="column expressions"/>, calling various methods on them. For instance, to build a <reference id="comparison-predicate" title="comparison predicate"/>, you can write the following expression:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE  = 'Animal Farm'
TITLE != 'Animal Farm']]></sql><java><![CDATA[BOOK.TITLE.equal("Animal Farm")
BOOK.TITLE.notEqual("Animal Farm")]]></java>
</code-pair><html>

									<h3>Create conditions from the Factory</h3>
									<p>
										There are a few types of conditions, that can be created statically from the <reference id="factory" title="Factory"/>. These are:
									</p>
									<ul>
										<li><reference id="plain-sql" title="plain SQL conditions"/>, that allow you to phrase your own SQL string <reference id="conditional-expressions" title="conditional expression"/></li>
										<li>The <reference id="exists-predicate" title="EXISTS predicate"/>, a standalone predicate that creates a conditional expression</li>
										<li>Constant TRUE and FALSE conditional expressions</li>
									</ul>

									<h3>Connect conditions using boolean operators</h3>
									<p>
										Conditions can also be connected using <reference id="boolean-operators" title="boolean operators"/> as will be discussed in a subsequent chapter.
									</p>
								</html></content>
							</section>

						    <section id="boolean-operators">
							    <title>AND, OR, NOT boolean operators</title>
								<content><html>
									<p>
										In SQL, as in most other languages, <reference id="conditional-expressions" title="conditional expressions"/> can be connected using the AND and OR binary operators, as well as the NOT unary operator, to form new conditional expressions. In jOOQ, this is modelled as such:
									</p>

</html><code-pair>
<sql><![CDATA[-- A simple conditional expression
TITLE = 'Animal Farm' OR TITLE = '1984'

-- A more complex conditional expression
        (TITLE = 'Animal Farm' OR TITLE = '1984')
AND NOT (AUTHOR.LAST_NAME = 'Orwell')]]></sql><java><![CDATA[// A simple boolean connection
BOOK.TITLE.equal("Animal Farm").or(BOOK.TITLE.equal("1984"))

// A more complex conditional expression
BOOK.TITLE.equal("Animal Farm").or(BOOK.TITLE.equal("1984"))
    .andNot(AUTHOR.LAST_NAME.equal("Orwell"))]]></java>
</code-pair><html>

									<p>
										The above example shows that the number of parentheses in Java can quickly explode. Proper indentation may become crucial in making such code readable. In order to understand how jOOQ composes combined conditional expressions, let's assign component expressions first:
									</p>

</html><java><![CDATA[Condition a = BOOK.TITLE.equal("Animal Farm");
Condition b = BOOK.TITLE.equal("1984");
Condition c = AUTHOR.LAST_NAME.equal("Orwell");

Condition combined1 = a.or(b);             // These OR-connected conditions form a new condition, wrapped in parentheses
Condition combined2 = combined1.andNot(c); // The left-hand side of the AND NOT () operator is already wrapped in parentheses]]></java><html>

									<h3>The Condition API</h3>
									<p>
										Here are all boolean operators on the <reference class="org.jooq.Condition"/> interface:
									</p>

</html><java><![CDATA[and(Condition)            // Combine conditions with AND
and(String)               // Combine conditions with AND. Convenience for adding plain SQL to the right-hand side
and(String, Object...)    // Combine conditions with AND. Convenience for adding plain SQL to the right-hand side
and(String, QueryPart...) // Combine conditions with AND. Convenience for adding plain SQL to the right-hand side
andExists(Select<?>)      // Combine conditions with AND. Convenience for adding an exists predicate to the rhs
andNot(Condition)         // Combine conditions with AND. Convenience for adding an inverted condition to the rhs
andNotExists(Select<?>)   // Combine conditions with AND. Convenience for adding an inverted exists predicate to the rhs

or(Condition)             // Combine conditions with OR
or(String)                // Combine conditions with OR. Convenience for adding plain SQL to the right-hand side
or(String, Object...)     // Combine conditions with OR. Convenience for adding plain SQL to the right-hand side
or(String, QueryPart...)  // Combine conditions with OR. Convenience for adding plain SQL to the right-hand side
orExists(Select<?>)       // Combine conditions with OR. Convenience for adding an exists predicate to the rhs
orNot(Condition)          // Combine conditions with OR. Convenience for adding an inverted condition to the rhs
orNotExists(Select<?>)    // Combine conditions with OR. Convenience for adding an inverted exists predicate to the rhs

not()                     // Invert a condition (synonym for Factory.not(Condition)]]></java></content>
							</section>

						    <section id="comparison-predicate">
							    <title>Comparison predicate</title>
								<content><html>
									<p>
										In SQL, comparison predicates are formed using common comparison operators:
									</p>
									<ul>
										<li><strong>=</strong> to test for equality</li>
										<li><strong>&lt;&gt;</strong> or <strong>!=</strong> to test for non-equality</li>
										<li><strong>&gt;</strong> to test for being strictly greater</li>
										<li><strong>&gt;=</strong> to test for being greater or equal</li>
										<li><strong>&lt;</strong> to test for being strictly less</li>
										<li><strong>&lt;=</strong> to test for being less or equal</li>
									</ul>

									<p>
										Unfortunately, Java does not support operator overloading, hence these operators are also implemented as methods in jOOQ, like any other SQL syntax elements. The relevant parts of the <reference class="org.jooq.Field"/> interface are these:
									</p>

</html><java><![CDATA[eq or equal(T);                  // =  (some bind value)
eq or equal(Field<T>);           // =  (some column expression)
eq or equal(Select<T>);          // =  (some scalar SELECT statement)
ne or notEqual(T);               // <> (some bind value)
ne or notEqual(Field<T>);        // <> (some column expression)
ne or notEqual(Select<T>);       // <> (some scalar SELECT statement)
lt or lessThan(T);               // <  (some bind value)
lt or lessThan(Field<T>);        // <  (some column expression)
lt or lessThan(Select<T>);       // <  (some scalar SELECT statement)
le or lessOrEqual(T);            // <= (some bind value)
le or lessOrEqual(Field<T>);     // <= (some column expression)
le or lessOrEqual(Select<T>);    // <= (some scalar SELECT statement)
gt or greaterThan(T);            // >  (some bind value)
gt or greaterThan(Field<T>);     // >  (some column expression)
gt or greaterThan(Select<T>);    // >  (some scalar SELECT statement)
ge or greaterOrEqual(T);         // >= (some bind value)
ge or greaterOrEqual(Field<T>);  // >= (some column expression)
ge or greaterOrEqual(Select<T>); // >= (some scalar SELECT statement)]]></java><html>

									<p>
										Note that every operator is represented by two methods. A verbose one (such as equal()) and a two-character one (such as eq()). Both methods are the same. You may choose either one, depending on your taste. The manual will always use the more verbose one.
									</p>

									<h3>NULL in jOOQ's comparison predicates</h3>
									<p>
										jOOQ has a special way of dealing with null bind values, when you pass them to comparison predicates equal() and notEqual(). For convenience, jOOQ will render <reference id="null-predicate" title="IS NULL or IS NOT NULL"/> predicates.
									</p>

									<h3>jOOQ's convenience methods using comparison operators</h3>
									<p>
										In addition to the above, jOOQ provides a few convenience methods for common operations performed on strings using comparison predicates:
									</p>

</html><code-pair>
<sql><![CDATA[-- case insensitivity
LOWER(TITLE)  = LOWER('animal farm')
LOWER(TITLE) <> LOWER('animal farm')]]></sql><java><![CDATA[// case insensitivity
BOOK.TITLE.equalIgnoreCase("animal farm")
BOOK.TITLE.notEqualIgnoreCase("animal farm")]]></java>
</code-pair><html>
								</html></content>
							</section>

						    <section id="quantified-comparison-predicate">
							    <title>Quantified comparison predicate</title>
								<content><html>
									<p>
										If the right-hand side of a <reference id="comparison-predicate" title="comparison predicate"/> turns out to be a non-scalar table subquery, you can wrap that subquery in a quantifier, such as ALL, ANY, or SOME. Note that the SQL standard defines ANY and SOME to be equivalent. jOOQ settled for the more intuitive ANY and doesn't support SOME. Here are some examples, supported by jOOQ:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE = ANY('Animal Farm', '1982')
PUBLISHED_IN > ALL(1920, 1940)]]></sql><java><![CDATA[BOOK.TITLE.equalAny("Animal Farm", "1982");
BOOK.PUBLISHED_IN.greaterThanAll(1920, 1940);]]></java>
</code-pair><html>

									<p>
										For the example, the right-hand side of the quantified comparison predicates were filled with argument lists. But it is easy to imagine that the source of values results from a <reference id="nested-selects" title="subselect"/>.
									</p>

									<h3>ANY and the IN predicate</h3>
									<p>
										It is interesting to note that the SQL standard defines the <reference id="in-predicate" title="IN predicate"/> in terms of the ANY-quantified predicate. The following two expressions are equivalent:
									</p>

</html><code-pair>
<sql><![CDATA[[ROW VALUE EXPRESSION] IN [IN PREDICATE VALUE]]]></sql><sql><![CDATA[[ROW VALUE EXPRESSION] = ANY [IN PREDICATE VALUE]]]></sql>
</code-pair><html>

									<p>
										Typically, the <reference id="in-predicate" title="IN predicate"/> is more readable than the quantified comparison predicate.
									</p>
								</html></content>
							</section>

						    <section id="null-predicate">
							    <title>NULL predicate</title>
								<content><html>
									<p>
										In SQL, you cannot compare NULL with any value using <reference id="comparison-predicate" title="comparison predicates"/>, as the result would yield NULL again, which is neither TRUE nor FALSE (see also the manual's section about <reference id="conditional-expressions" title="conditional expressions"/>). In order to test a <reference id="column-expressions" title="column expression"/> for NULL, use the NULL predicate as such:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE IS NULL
TITLE IS NOT NULL]]></sql><java><![CDATA[BOOK.TITLE.isNull()
BOOK.TITLE.isNotNull()]]></java>
</code-pair><html>

								</html></content>
							</section>

						    <section id="distinct-predicate">
							    <title>DISTINCT predicate</title>
								<content><html>
									<p>
										Some databases support the DISTINCT predicate, which serves as a convenient, NULL-safe <reference id="comparison-predicate" title="comparison predicate"/>. With the DISTINCT predicate, the following truth table can be assumed:
									</p>
									<ul>
										<li>[ANY] IS DISTINCT FROM NULL yields TRUE</li>
										<li>[ANY] IS NOT DISTINCT FROM NULL yields FALSE</li>
										<li>NULL IS DISTINCT FROM NULL yields FALSE</li>
										<li>NULL IS NOT DISTINCT FROM NULL yields TRUE</li>
									</ul>
									<p>
										For instance, you can compare two fields for distinctness, ignoring the fact that any of the two could be NULL, which would lead to funny results. This is supported by jOOQ as such:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE IS DISTINCT FROM SUB_TITLE
TITLE IS NOT DISTINCT FROM SUB_TITLE]]></sql><java><![CDATA[BOOK.TITLE.isDistinctFrom(BOOK.SUB_TITLE)
BOOK.TITLE.isNotDistinctFrom(BOOK.SUB_TITLE)]]></java>
</code-pair><html>

									<p>
										If your database does not natively support the DISTINCT predicate, jOOQ emulates it with an equivalent <reference id="case-expressions" title="CASE expression"/>, modelling the above truth table:
									</p>

</html><code-pair>
<sql><![CDATA[-- [A] IS DISTINCT FROM [B]
CASE WHEN [A] IS     NULL AND [B] IS     NULL THEN FALSE
     WHEN [A] IS     NULL AND [B] IS NOT NULL THEN TRUE
     WHEN [A] IS NOT NULL AND [B] IS     NULL THEN TRUE
     WHEN [A] =               [B]             THEN FALSE
     ELSE                                          TRUE
END
]]></sql><sql><![CDATA[-- [A] IS NOT DISTINCT FROM [B]
CASE WHEN [A] IS     NULL AND [B] IS     NULL THEN TRUE
     WHEN [A] IS     NULL AND [B] IS NOT NULL THEN FALSE
     WHEN [A] IS NOT NULL AND [B] IS     NULL THEN FALSE
     WHEN [A] =               [B]             THEN TRUE
     ELSE                                          FALSE
END
]]></sql>
</code-pair><html>
								</html></content>
							</section>

						    <section id="between-predicate">
							    <title>BETWEEN predicate</title>
								<content><html>
									<p>
										The BETWEEN predicate can be seen as syntactic sugar for a pair of <reference id="comparison-predicate" title="comparison predicates"/>. According to the SQL standard, the following two predicates are equivalent:
									</p>

</html><code-pair>
<sql><![CDATA[[A] BETWEEN [B] AND [C]]]></sql><sql><![CDATA[[A] >= [B] AND [A] <= [C]]]></sql>
</code-pair><html>

									<p>
										Note the inclusiveness of range boundaries in the definition of the BETWEEN predicate. Intuitively, this is supported in jOOQ as such:
									</p>

</html><code-pair>
<sql><![CDATA[PUBLISHED_IN     BETWEEN 1920 AND 1940
PUBLISHED_IN NOT BETWEEN 1920 AND 1940]]></sql><java><![CDATA[BOOK.PUBLISHED_IN.between(1920, 1940)
BOOK.PUBLISHED_IN.notBetween(1920, 1940)]]></java>
</code-pair><html>

									<h3>BETWEEN SYMMETRIC</h3>
									<p>
										The SQL standard defines the SYMMETRIC keyword to be used along with BETWEEN to indicate that you do not care which bound of the range is larger than the other. A database system should simply swap range bounds, in case the first bound is greater than the second one. jOOQ supports this keyword as well, emulating it if necessary.
									</p>

</html><code-pair>
<sql><![CDATA[PUBLISHED_IN     BETWEEN SYMMETRIC 1940 AND 1920
PUBLISHED_IN NOT BETWEEN SYMMETRIC 1940 AND 1920]]></sql><java><![CDATA[BOOK.PUBLISHED_IN.betweenSymmetric(1940, 1920)
BOOK.PUBLISHED_IN.notBetweenSymmetric(1940, 1920)]]></java>
</code-pair><html>

									<p>
										The emulation is done trivially:
									</p>

</html><code-pair>
<sql><![CDATA[[A] BETWEEN SYMMETRIC [B] AND [C]]]></sql><sql><![CDATA[([A] BETWEEN [B] AND [C]) OR ([A] BETWEEN [C] AND [B])]]></sql>
</code-pair><html>

								</html></content>
							</section>

						    <section id="like-predicate">
							    <title>LIKE predicate</title>
								<content><html>
									<p>
										LIKE predicates are popular for simple wildcard-enabled pattern matching. Supported wildcards in all SQL databases are:
									</p>
									<ul>
										<li><strong>_</strong>: (single-character wildcard)</li>
										<li><strong>%</strong>: (multi-character wildcard)</li>
									</ul>
									<p>
										With jOOQ, the LIKE predicate can be created from any <reference id="column-expressions" title="column expression"/> as such:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE     LIKE '%abc%'
TITLE NOT LIKE '%abc%']]></sql><java><![CDATA[BOOK.TITLE.like("%abc%")
BOOK.TITLE.notLike("%abc%")]]></java>
</code-pair><html>

									<h3>Escaping operands with the LIKE predicate</h3>
									<p>
										Often, your pattern may contain any of the wildcard characters "_" and "%", in case of which you may want to escape them. jOOQ does not automatically escape patterns in like() and notLike() methods. Instead, you can explicitly define an escape character as such:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE     LIKE '%The !%-Sign Book%' ESCAPE '!'
TITLE NOT LIKE '%The !%-Sign Book%' ESCAPE '!']]></sql><java><![CDATA[BOOK.TITLE.like("%The !%-Sign Book%", '!')
BOOK.TITLE.notLike("%The !%-Sign Book%", '!')]]></java>
</code-pair><html>

									<p>
										In the above predicate expressions, the exclamation mark character is passed as the escape character to escape wildcard characters "!_" and "!%", as well as to escape the escape character itself: "!!"
									</p>
									<p>
										Please refer to your database manual for more details about escaping patterns with the LIKE predicate.
									</p>

									<h3>jOOQ's convenience methods using the LIKE predicate</h3>
									<p>
										In addition to the above, jOOQ provides a few convenience methods for common operations performed on strings using the LIKE predicate. Typical operations are "contains predicates", "starts with predicates", "ends with predicates", etc. Here is the full convenience API wrapping LIKE predicates:
									</p>

</html><code-pair>
<sql><![CDATA[-- case insensitivity
LOWER(TITLE) LIKE LOWER('%abc%')
LOWER(TITLE) NOT LIKE LOWER('%abc%')

-- contains and similar methods
TITLE LIKE '%' || 'abc' || '%'
TITLE LIKE 'abc' || '%'
TITLE LIKE '%' || 'abc']]></sql><java><![CDATA[// case insensitivity
BOOK.TITLE.likeIgnoreCase("%abc%")
BOOK.TITLE.notLikeIgnoreCase("%abc%")

// contains and similar methods
BOOK.TITLE.contains("abc")
BOOK.TITLE.startsWith("abc")
BOOK.TITLE.endsWith("abc")]]></java>
</code-pair><html>

									<p>
										Note, that jOOQ escapes % and _ characters in value in some of the above predicate implementations. For simplicity, this has been omitted in this manual.
									</p>
								</html></content>
							</section>

						    <section id="in-predicate">
							    <title>IN predicate</title>
								<content><html>
									<p>
										In SQL, apart from comparing a value against several values, the IN predicate can be used to create semi-joins or anti-joins. jOOQ knows the following methods on the <reference class="org.jooq.Field" /> interface, to construct such IN predicates:
									</p>

</html><java><![CDATA[in(Collection<T>)    // Construct an IN predicate from a collection of bind values
in(T...)             // Construct an IN predicate from bind values
in(Field<?>...)      // Construct an IN predicate from column expressions
in(Select<?>)        // Construct an IN predicate from a subselect
notIn(Collection<T>) // Construct a NOT IN predicate from a collection of bind values
notIn(T...)          // Construct a NOT IN predicate from bind values
notIn(Field<?>...)   // Construct a NOT IN predicate from column expressions
notIn(Select<?>)     // Construct a NOT IN predicate from a subselect]]></java><html>

									<p>
										A sample IN predicate might look like this:
									</p>

</html><code-pair>
<sql><![CDATA[TITLE     IN ('Animal Farm', '1984')
TITLE NOT IN ('Animal Farm', '1984')]]></sql><java><![CDATA[BOOK.TITLE.in("Animal Farm", "1984")
BOOK.TITLE.notIn("Animal Farm", "1984")]]></java>
</code-pair><html>


									<h3>NOT IN and NULL values</h3>
									<p>
										Beware that you should probably not have any NULL values in the right hand side of a NOT IN predicate, as the whole expression would evaluate to NULL, which is rarely desired. This can be shown informally using the following reasoning:
									</p>

</html><sql>-- The following conditional expressions are formally or informally equivalent
A NOT IN (B, C)
A != ANY(B, C)
A != B AND A != C

-- Substitute C for NULL, you'll get
A NOT IN (B, NULL)   -- Substitute C for NULL
A != B AND A != NULL -- From the above rules
A != B AND NULL      -- [ANY] != NULL yields NULL
NULL                 -- [ANY] AND NULL yields NULL</sql><html>

									<p>
										A good way to prevent this from happening is to use the <reference id="exists-predicate" title="EXISTS predicate"/> for anti-joins, which is NULL-value insensitive. See the manual's section about <reference id="conditional-expressions" title="conditional expressions"/> to see a boolean truth table.
									</p>
								</html></content>
							</section>

						    <section id="exists-predicate">
							    <title>EXISTS predicate</title>
								<content><html>
									<p>
										Slightly less intuitive, yet more powerful than the previously discussed <reference id="in-predicate" title="IN predicate"/> is the EXISTS predicate, that can be used to form semi-joins or anti-joins. With jOOQ, the EXISTS predicate can be formed in various ways:
									</p>
									<ul>
										<li>From the <reference id="factory" title="Factory"/>, using static methods. This is probably the most used case</li>
										<li>From a <reference id="conditional-expressions" title="conditional expression"/> using <reference id="boolean-operators" title="convenience methods attached to boolean operators"/></li>
										<li>From a <reference id="select-statement" title="SELECT statement"/> using <reference id="where-clause" title="convenience methods attached to the where clause"/>, and from other clauses</li>
									</ul>

									<p>
										An example of an EXISTS predicate can be seen here:
									</p>

</html><code-pair>
<sql><![CDATA[    EXISTS (SELECT 1 FROM BOOK
            WHERE AUTHOR_ID = 3)
NOT EXISTS (SELECT 1 FROM BOOK
            WHERE AUTHOR_ID = 3)]]></sql><java><![CDATA[   exists(create.selectOne().from(BOOK)
                .where(BOOK.AUTHOR_ID.equal(3)));
notExists(create.selectOne().from(BOOK)
                .where(BOOK.AUTHOR_ID.equal(3)));]]></java>
</code-pair><html>

									<p>
										Note that in SQL, the projection of a subselect in an EXISTS predicate is irrelevant. To help you write queries like the above, you can use jOOQ's selectZero() or selectOne() <reference id="factory" title="Factory"/> methods
									</p>

									<h3>Performance of IN vs. EXISTS</h3>
									<p>
										In theory, the two types of predicates can perform equally well. If your database system ships with a sophisticated cost-based optimiser, it will be able to transform one predicate into the other, if you have all necessary constraints set (e.g. referential constraints, not null constraints). However, in reality, performance between the two might differ substantially. An interesting blog post investigating this topic on the MySQL database can be seen here:<br/>
										<a href="http://blog.jooq.org/2012/07/27/not-in-vs-not-exists-vs-left-join-is-null-mysql/">http://blog.jooq.org/2012/07/27/not-in-vs-not-exists-vs-left-join-is-null-mysql/</a>
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="plain-sql">
						<title>Plain SQL</title>
						<content><html>
							<p>
								A DSL is a nice thing to have, it feels "fluent" and "natural", especially if it models a well-known language, such as SQL. But a DSL is always expressed in a host language (Java in this case), which was not made for exactly the same purposes as its hosted DSL. If it were, then jOOQ would be implemented on a compiler-level, similar to LINQ in .NET. But it's not, and so, the DSL is limited by language constraints of its host language. We have seen many functionalities where the DSL becomes a bit verbose. This can be especially true for:
							</p>
							<ul>
								<li><reference id="aliased-columns" title="aliasing"/></li>
								<li><reference id="nested-selects" title="nested selects"/></li>
								<li><reference id="arithmetic-expressions" title="arithmetic expressions"/></li>
								<li><reference id="cast-expressions" title="casting"/></li>
							</ul>

							<p>
								You'll probably find other examples. If verbosity scares you off, don't worry. The verbose use-cases for jOOQ are rather rare, and when they come up, you do have an option. Just write SQL the way you're used to!
							</p>
							<p>
								jOOQ allows you to embed SQL as a String into any supported <reference id="sql-statements" title="statement"/> in these contexts:
							</p>
							<ul>
								<li>Plain SQL as a <reference id="conditional-expressions" title="conditional expression"/></li>
								<li>Plain SQL as a <reference id="column-expressions" title="column expression"/></li>
								<li>Plain SQL as a <reference id="column-expressions" title="function"/></li>
								<li>Plain SQL as a <reference id="table-expressions" title="table expression"/></li>
								<li>Plain SQL as a <reference id="query-vs-resultquery" title="query"/></li>
							</ul>

							<h3>The Factory plain SQL API</h3>
							<p>
								Plain SQL API methods are usually overloaded in three ways. Let's look at the <code>condition</code> query part constructor:
							</p>
</html><java><![CDATA[// Construct a condition without bind values
// Example: condition("a = b")
Condition condition(String sql);

// Construct a condition with bind values
// Example: condition("a = ?", 1);
Condition condition(String sql, Object... bindings);

// Construct a condition taking other jOOQ object arguments
// Example: condition("a = {0}", val(1));
Condition condition(String sql, QueryPart... parts);]]></java><html>

							<p>
								Please refer to the <reference class="org.jooq.impl.Factory"/> Javadoc for more details. The following is a more complete listing of plain SQL construction methods from the Factory:
							</p>

</html><java><![CDATA[// A condition
Condition condition(String sql);
Condition condition(String sql, Object... bindings);
Condition condition(String sql, QueryPart... parts);

// A field with an unknown data type
Field<Object> field(String sql);
Field<Object> field(String sql, Object... bindings);
Field<Object> field(String sql, QueryPart... parts);

// A field with a known data type
<T> Field<T> field(String sql, Class<T> type);
<T> Field<T> field(String sql, Class<T> type, Object... bindings);
<T> Field<T> field(String sql, Class<T> type, QueryPart... parts);
<T> Field<T> field(String sql, DataType<T> type);
<T> Field<T> field(String sql, DataType<T> type, Object... bindings);
<T> Field<T> field(String sql, DataType<T> type, QueryPart... parts);

// A field with a known name (properly escaped)
Field<Object> fieldByName(String... fieldName);
<T> Field<T>  fieldByName(Class<T> type, String... fieldName);
<T> Field<T>  fieldByName(DataType<T> type, String... fieldName)

// A function
<T> Field<T> function(String name, Class<T> type, Field<?>... arguments);
<T> Field<T> function(String name, DataType<T> type, Field<?>... arguments);

// A table
Table<?> table(String sql);
Table<?> table(String sql, Object... bindings);
Table<?> table(String sql, QueryPart... parts);

// A table with a known name (properly escaped)
Table<Record> tableByName(String... fieldName);

// A query without results (update, insert, etc)
Query query(String sql);
Query query(String sql, Object... bindings);
Query query(String sql, QueryPart... parts);

// A query with results
ResultQuery<Record> resultQuery(String sql);
ResultQuery<Record> resultQuery(String sql, Object... bindings);
ResultQuery<Record> resultQuery(String sql, QueryPart... parts);

// A query with results. This is the same as resultQuery(...).fetch();
Result<Record> fetch(String sql);
Result<Record> fetch(String sql, Object... bindings);
Result<Record> fetch(String sql, QueryPart... parts);]]></java><html>

							<p>
								Apart from the general factory methods, plain SQL is also available in various other contexts. For instance, when adding a .where("a = b") clause to a query. Hence, there exist several convenience methods where plain SQL can be inserted usefully. This is an example displaying all various use-cases in one single query:
							</p>

</html><java><![CDATA[// You can use your table aliases in plain SQL fields
// As long as that will produce syntactically correct SQL
Field<?> LAST_NAME    = create.field("a.LAST_NAME");

// You can alias your plain SQL fields
Field<?> COUNT1       = create.field("count(*) x");

// If you know a reasonable Java type for your field, you
// can also provide jOOQ with that type
Field<Integer> COUNT2 = create.field("count(*) y", Integer.class);

       // Use plain SQL as select fields
create.select(LAST_NAME, COUNT1, COUNT2)

       // Use plain SQL as aliased tables (be aware of syntax!)
      .from("author a")
      .join("book b")

       // Use plain SQL for conditions both in JOIN and WHERE clauses
      .on("a.id = b.author_id")

       // Bind a variable in plain SQL
      .where("b.title != ?", "Brida")

       // Use plain SQL again as fields in GROUP BY and ORDER BY clauses
      .groupBy(LAST_NAME)
      .orderBy(LAST_NAME);]]></java><html>

							<h3>Important things to note about plain SQL!</h3>
							<p>
								There are some important things to keep in mind when using plain SQL:
							</p>
							<ul>
								<li>jOOQ doesn't know what you're doing. You're on your own again!</li>
								<li>You have to provide something that will be syntactically correct. If it's not, then jOOQ won't know. Only your JDBC driver or your RDBMS will detect the syntax error.</li>
								<li>You have to provide consistency when you use variable binding. The number of ? must match the number of variables</li>
								<li>Your SQL is inserted into jOOQ queries without further checks. Hence, jOOQ can't prevent SQL injection. </li>
							</ul>
						</html></content>
					</section>

					<section id="bind-values">
					    <title>Bind values and parameters</title>
						<content><html>
							<p>
								Bind values are used in SQL / JDBC for various reasons. Among the most obvious ones are:
							</p>
							<ul>
								<li>
									Protection against SQL injection. Instead of inlining values possibly originating from user input, you bind those values to your prepared statement and let the JDBC driver / database take care of handling security aspects.
								</li>
								<li>
									Increased speed. Advanced databases such as Oracle can keep execution plans of similar queries in a dedicated cache to prevent hard-parsing your query again and again. In many cases, the actual value of a bind variable does not influence the execution plan, hence it can be reused. Preparing a statement will thus be faster
								</li>
								<li>
									On a JDBC level, you can also reuse the SQL string and prepared statement object instead of constructing it again, as you can bind new values to the prepared statement. jOOQ currently does not cache prepared statements, internally.
								</li>
							</ul>

							<p>
								The following sections explain how you can introduce bind values in jOOQ, and how you can control the way they are rendered and bound to SQL.
							</p>
						</html></content>

						<sections>
						    <section id="indexed-parameters">
							    <title>Indexed parameters</title>
								<content><html>
									<p>
										JDBC only knows indexed bind values. A typical example for using bind values with JDBC is this:
									</p>

</html><java><![CDATA[
try (PreparedStatement stmt = connection.prepareStatement("SELECT * FROM BOOK WHERE ID = ? AND TITLE = ?")) {

    // bind values to the above statement for appropriate indexes
    stmt.setInt(1, 5);
    stmt.setString(2, "Animal Farm");
    stmt.executeQuery();
}]]></java><html>

									<p>
										With dynamic SQL, keeping track of the number of question marks and their corresponding index may turn out to be hard. jOOQ abstracts this and lets you provide the bind value right where it is needed. A trivial example is this:
									</p>

</html><java><![CDATA[create.select().from(BOOK).where(BOOK.ID.equal(5)).and(BOOK.TITLE.equal("Animal Farm"));

// This notation is in fact a short form for the equivalent:
create.select().from(BOOK).where(BOOK.ID.equal(val(5))).and(BOOK.TITLE.equal(val("Animal Farm")));]]></java><html>

									<p>
										Note the using of <reference class="org.jooq.impl.Factory" anchor="#val(java.lang.Object)" title="Factory.val()"/> to explicitly create an indexed bind value. You don't have to worry about that index. When the query is <reference id="sql-rendering" title="rendered"/>, each bind value will render a question mark. When the query <reference id="variable-binding" title="binds its variables"/>, each bind value will generate the appropriate bind value index.
									</p>

									<h3>Extract bind values from a query</h3>
									<p>
										Should you decide to run the above query outside of jOOQ, using your own <reference class="java.sql.PreparedStatement"/>, you can do so as follows:
									</p>

</html><java><![CDATA[Select<?> select = create.select().from(BOOK).where(BOOK.ID.equal(5)).and(BOOK.TITLE.equal("Animal Farm"));

// Render the SQL statement:
String sql = select.getSQL();
assertEquals("SELECT * FROM BOOK WHERE ID = ? AND TITLE = ?", sql);

// Get the bind values:
List<Object> values = select.getBindValues();
assertEquals(2, values.size());
assertEquals(5, values.get(0));
assertEquals("Animal Farm", values.get(1));]]></java><html>

									<p>
										You can also extract specific bind values by index from a query, if you wish to modify their underlying value after creating a query. This can be achieved as such:
									</p>

</html><java><![CDATA[Select<?> select = create.select().from(BOOK).where(BOOK.ID.equal(5)).and(BOOK.TITLE.equal("Animal Farm"));
Param<?> param = select.getParam("2");

// You could now modify the Query's underlying bind value:
if ("Animal Farm".equals(param.getValue())) {
    param.setConverted("1984");
}]]></java><html>

									<p>
										For more details about jOOQ's internals, see the manual's section about <reference id="queryparts" title="QueryParts"/>.
									</p>
								</html></content>
							</section>

						    <section id="named-parameters">
							    <title>Named parameters</title>
								<content><html>
									<p>
										Some SQL access abstractions that are built on top of JDBC, or some that bypass JDBC may support named parameters. jOOQ allows you to give names to your parameters as well, although those names are not rendered to SQL strings by default. Here is an example of how to create named parameters using the <reference class="org.jooq.Param"/> type:
									</p>

</html><java><![CDATA[// Create a query with a named parameter. You can then use that name for accessing the parameter again
Query query1 = create.select().from(AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
Param<?> param1 = query.getParam("lastName");

// Or, keep a reference to the typed parameter in order not to lose the <T> type information:
Param<String> param2 = param("lastName", "Poe");
Query query2 = create.select().from(AUTHOR).where(LAST_NAME.equal(param2));

// You can now change the bind value directly on the Param reference:
param2.setValue("Orwell");]]></java><html>

									<p>
										The <reference class="org.jooq.Query"/> interface also allows for setting new bind values directly, without accessing the Param type:
									</p>

</html><java><![CDATA[Query query1 = create.select().from(AUTHOR).where(LAST_NAME.equal("Poe"));
query1.bind(1, "Orwell");

// Or, with named parameters
Query query2 = create.select().from(AUTHOR).where(LAST_NAME.equal(param("lastName", "Poe")));
query2.bind("lastName", "Orwell");]]></java><html>

									<p>
										In order to actually render named parameter names in generated SQL, use the <reference class="org.jooq.impl.Factory" anchor="#renderNamedParams(org.jooq.QueryPart)" title="Factory.renderNamedParams()"/> method:
									</p>

</html><code-pair>
<java><![CDATA[create.renderNamedParams(
    create.select()
          .from(AUTHOR)
          .where(LAST_NAME.equal(
                 param("lastName", "Poe"))));]]></java><sql><![CDATA[-- The named bind variable can be rendered

SELECT *
FROM AUTHOR
WHERE LAST_NAME = :lastName]]></sql>
</code-pair><html>
								</html></content>
							</section>

						    <section id="inlined-parameters">
							    <title>Inlined parameters</title>
								<content><html>
									<p>
										Sometimes, you may wish to avoid rendering bind variables while still using custom values in SQL. jOOQ refers to that as "inlined" bind values. When bind values are inlined, they render the actual value in SQL rather than a JDBC question mark. Bind value inlining can be achieved in two ways:
									</p>
									<ul>
										<li>
											By using the <reference id="custom-settings" title="Settings"/> and setting the <reference class="org.jooq.conf.StatementType"/> to STATIC_STATEMENT. This will inline all bind values for SQL statements rendered from such a Factory.
										</li>
										<li>
											By using <reference class="org.jooq.impl.Factory" anchor="#inline(java.lang.Object)" title="Factory.inline()"/> methods.
										</li>
									</ul>
									<p>
										In both cases, your inlined bind values will be properly escaped to avoid SQL syntax errors and SQL injection. Some examples:
									</p>

</html><java><![CDATA[
// Use dedicated calls to inline() in order to specify
// single bind values to be rendered as inline values
// --------------------------------------------------
create.select()
      .from(AUTHOR)
      .where(LAST_NAME.equal(inline("Poe")));

// Or render the whole query with inlined values
// --------------------------------------------------
Settings settings = new Settings()
    .withStatementType(StatementType.STATIC_STATEMENT);

// Add the settings to the factory
Factory create = new Factory(connection, SQLDialect.ORACLE, settings);

// Run queries that omit rendering schema names
create.select()
      .from(AUTHOR)
      .where(LAST_NAME.equal("Poe"));]]></java></content>
							</section>

						    <section id="sql-injection-and-plain-sql-queryparts">
							    <title>SQL injection and plain SQL QueryParts</title>
								<content><html>
									<p>
										Special care needs to be taken when using <reference id="plain-sql" title="plain SQL QueryParts"/>. While jOOQ's API allows you to specify bind values for use with plain SQL, you're not forced to do that. For instance, both of the following queries will lead to the same, valid result:
									</p>

</html><java><![CDATA[// This query will use bind values, internally.
create.fetch("SELECT * FROM BOOK WHERE ID = ? AND TITLE = ?", 5 "Animal Farm");

// This query will not use bind values, internally.
create.fetch("SELECT * FROM BOOK WHERE ID = 5 AND TITLE = 'Animal Farm'");]]></java><html>

									<p>
										All methods in the jOOQ API that allow for plain (unescaped, untreated) SQL contain a warning message in their relevant Javadoc, to remind you of the risk of SQL injection in what is otherwise a SQL-injection-safe API.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="queryparts">
					    <title>QueryParts</title>
						<content><html>
							<p>
								A <reference class="org.jooq.Query" /> and all its contained objects is a <reference class="org.jooq.QueryPart" />. QueryParts essentially provide this functionality:
							</p>
							<ul>
								<li>they can <reference id="sql-rendering" title="render SQL"/> using the <reference class="org.jooq.QueryPartInternal" anchor="#toSQL(org.jooq.RenderContext)" title="toSQL(RenderContext)"/> method</li>
								<li>they can <reference id="variable-binding" title="bind variables"/> using the <reference class="org.jooq.QueryPartInternal" anchor="#bind(org.jooq.BindContext)" title="bind(BindContext)"/> method</li>
							</ul>

							<p>
								Both of these methods are contained in jOOQ's internal API's <reference class="org.jooq.QueryPartInternal"/>, which is internally implemented by every QueryPart.
							</p>

							<p>
								The following sections explain some more details about <reference id="sql-rendering" title="SQL rendering"/> and <reference id="variable-binding" title="variable binding"/>, as well as other implementation details about QueryParts in general.
							</p>
						</html></content>

						<sections>
						    <section id="sql-rendering">
							    <title>SQL rendering</title>
								<content><html>
									<p>
										Every <reference class="org.jooq.QueryPart"/> must implement the <reference class="org.jooq.QueryPartInternal" anchor="#toSQL(org.jooq.RenderContext)" title="toSQL(RenderContext)"/> method to render its SQL string to a <reference class="org.jooq.RenderContext"/>. This RenderContext has two purposes:
									</p>
									<ul>
										<li>It provides some information about the "state" of SQL rendering.</li>
										<li>It provides a common API for constructing SQL strings on the context's internal <reference class="java.lang.StringBuilder"/></li>
									</ul>
									<p>
										An overview of the <reference class="org.jooq.RenderContext"/> API is given here:
									</p>

</html><java><![CDATA[// These methods are useful for generating unique aliases within a RenderContext (and thus within a Query)
String peekAlias();
String nextAlias();

// These methods return rendered SQL
String render();
String render(QueryPart part);

// These methods allow for fluent appending of SQL to the RenderContext's internal StringBuilder
RenderContext keyword(String keyword);
RenderContext literal(String literal);
RenderContext sql(String sql);
RenderContext sql(char sql);
RenderContext sql(int sql);
RenderContext sql(QueryPart part);

// These methods allow for controlling formatting of SQL, if the relevant Setting is active
RenderContext formatNewLine();
RenderContext formatSeparator();
RenderContext formatIndentStart();
RenderContext formatIndentStart(int indent);
RenderContext formatIndentLockStart();
RenderContext formatIndentEnd();
RenderContext formatIndentEnd(int indent);
RenderContext formatIndentLockEnd();

// These methods control the RenderContext's internal state
boolean       inline();
RenderContext inline(boolean inline);
boolean       qualify();
RenderContext qualify(boolean qualify);
boolean       namedParams();
RenderContext namedParams(boolean renderNamedParams);
CastMode      castMode();
RenderContext castMode(CastMode mode);
Boolean       cast();
RenderContext castModeSome(SQLDialect... dialects);]]></java><html>

									<p>
										The following additional methods are inherited from a common <reference class="org.jooq.Context"/>, which is shared among <reference class="org.jooq.RenderContext"/> and <reference class="org.jooq.BindContext"/>:
									</p>

</html><java><![CDATA[// These methods indicate whether fields or tables are being declared (MY_TABLE AS MY_ALIAS) or referenced (MY_ALIAS)
boolean declareFields();
Context declareFields(boolean declareFields);
boolean declareTables();
Context declareTables(boolean declareTables);

// These methods indicate whether a top-level query is being rendered, or a subquery
boolean subquery();
Context subquery(boolean subquery);

// These methods provide the bind value indices within the scope of the whole Context (and thus of the whole Query)
int nextIndex();
int peekIndex();]]></java><html>

									<h3>An example of rendering SQL</h3>
								   	<p>
								   		A simple example can be provided by checking out jOOQ's internal representation of a (simplified) <reference id="comparison-predicate" title="CompareCondition"/>. It is used for any <reference class="org.jooq.Condition"/> comparing two fields as for example the AUTHOR.ID = BOOK.AUTHOR_ID condition here:
							   		</p>

</html><sql>-- [...]
FROM AUTHOR
JOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_ID
-- [...]</sql><html>

									<p>
										This is how jOOQ renders such a condition:
									</p>

</html><java><![CDATA[@Override
public final void toSQL(RenderContext context) {
    // The CompareCondition delegates rendering of the Fields to the Fields
    // themselves and connects them using the Condition's comparator operator:
    context.sql(field1)
           .sql(" ");

    // If the second field is null, some convenience behaviour can be
    // implemented here
    if (field2.isNullLiteral()) {
        switch (comparator) {
            case EQUALS:
                context.sql("is null");
                break;

            case NOT_EQUALS:
                context.sql("is not null");
                break;

            default:
                throw new IllegalStateException("Cannot compare null with " + comparator);
        }
    }

    // By default, also delegate the right hand side's SQL rendering to the
    // underlying field
    else {
        context.sql(comparator.toSQL())
               .sql(" ")
               .sql(field2);
    }
}]]></java><html>

									<p>
										See the manual's sections about <reference id="custom-queryparts" title="custom QueryParts"/> and <reference id="plain-sql-queryparts" title="plain SQL QueryParts"/> to learn about how to write your own query parts in order to extend jOOQ.
									</p>
								</html></content>
							</section>

						    <section id="variable-binding">
							    <title>Variable binding</title>
								<content><html>
									<p>
										Every <reference class="org.jooq.QueryPart"/> must implement the <reference class="org.jooq.QueryPartInternal" anchor="#bind(org.jooq.BindContext)" title="bind(BindContext)"/> method. This BindContext has two purposes:
									</p>
									<ul>
										<li>It provides some information about the "state" of the variable binding in process.</li>
										<li>It provides a common API for binding values to the context's internal <reference class="java.sql.PreparedStatement"/></li>
									</ul>
									<p>
										An overview of the <reference class="org.jooq.RenderContext"/> API is given here:
									</p>

</html><java><![CDATA[// This method provides access to the PreparedStatement to which bind values are bound
PreparedStatement statement();

// These methods provide convenience to delegate variable binding
BindContext bind(QueryPart part) throws DataAccessException;
BindContext bind(Collection<? extends QueryPart> parts) throws DataAccessException;
BindContext bind(QueryPart[] parts) throws DataAccessException;

// These methods perform the actual variable binding
BindContext bindValue(Object value, Class<?> type) throws DataAccessException;
BindContext bindValues(Object... values) throws DataAccessException;]]></java><html>

									<p>
										Some additional methods are inherited from a common <reference class="org.jooq.Context"/>, which is shared among <reference class="org.jooq.RenderContext"/> and <reference class="org.jooq.BindContext"/>. Details are documented in the previous chapter about <reference id="sql-rendering" title="SQL rendering"/>
									</p>

									<h3>An example of binding values to SQL</h3>
								   	<p>
								   		A simple example can be provided by checking out jOOQ's internal representation of a (simplified) <reference id="comparison-predicate" title="CompareCondition"/>. It is used for any <reference class="org.jooq.Condition"/> comparing two fields as for example the AUTHOR.ID = BOOK.AUTHOR_ID condition here:
							   		</p>

</html><sql>-- [...]
WHERE AUTHOR.ID = ?
-- [...]</sql><html>

									<p>
										This is how jOOQ binds values on such a condition:
									</p>
</html><java><![CDATA[@Override
public final void bind(BindContext context) throws DataAccessException {
    // The CompareCondition itself does not bind any variables.
    // But the two fields involved in the condition might do so...
    context.bind(field1).bind(field2);
}]]></java><html>

									<p>
										See the manual's sections about <reference id="custom-queryparts" title="custom QueryParts"/> and <reference id="plain-sql-queryparts" title="plain SQL QueryParts"/> to learn about how to write your own query parts in order to extend jOOQ.
									</p>
								</html></content>
							</section>

						    <section id="custom-queryparts">
							    <title>Extend jOOQ with custom types</title>
								<content><html>
									<p>
										If a SQL clause is too complex to express with jOOQ, you can extend either one of the following types for use directly in a jOOQ query:
									</p>

</html><java><![CDATA[public abstract class CustomField<T> extends AbstractField<T> {}
public abstract class CustomCondition extends AbstractCondition {}
public abstract class CustomTable<R extends TableRecord<R>> extends TableImpl<R> {}
public abstract class CustomRecord<R extends TableRecord<R>> extends TableRecordImpl<R> {}]]></java><html>

									<p>
										These classes are declared public and covered by jOOQ's integration tests. When you extend these classes, you will have to provide your own implementations for the <reference id="queryparts" title="QueryParts'"/> <reference id="sql-rendering" title="toSQL()"/> and <reference id="variable-binding" title="bind()"/> methods, as discussed before:
									</p>

</html><java><![CDATA[// This method must produce valid SQL. If your QueryPart contains other parts, you may delegate SQL generation to them
// in the correct order, passing the render context.
//
// If context.inline() is true, you must inline all bind variables
// If context.inline() is false, you must generate ? for your bind variables
public void toSQL(RenderContext context);

// This method must bind all bind variables to a PreparedStatement. If your QueryPart contains other QueryParts, $
// you may delegate variable binding to them in the correct order, passing the bind context.
//
// Every QueryPart must ensure, that it starts binding its variables at context.nextIndex().
public void bind(BindContext context) throws DataAccessException;]]></java><html>

									<p>
										The above contract may be a bit tricky to understand at first. The best thing is to check out jOOQ source code and have a look at a couple of QueryParts, to see how it's done. Here's an example <reference class="org.jooq.impl.CustomField"/> showing how to create a field multiplying another field by 2
									</p>

</html><java><![CDATA[// Create an anonymous CustomField, initialised with BOOK.ID arguments
final Field<Integer> IDx2 = new CustomField<Integer>(BOOK.ID.getName(), BOOK.ID.getDataType()) {
    @Override
    public void toSQL(RenderContext context) {

        // In inline mode, render the multiplication directly
        if (context.inline()) {
            context.sql(BOOK.ID).sql(" * 2");
        }

        // In non-inline mode, render a bind value
        else {
            context.sql(BOOK.ID).sql(" * ?");
        }
    }

    @Override
    public void bind(BindContext context) {
        try {

            // Manually bind the value 2
            context.statement().setInt(context.nextIndex(), 2);

            // Alternatively, you could also write:
            // context.bind(Factory.val(2));
        }
        catch (SQLException e) {
            throw translate(getSQL(), e);
        }
    }
};

// Use the above field in a SQL statement:
create.select(IDx2).from(BOOK);]]></java></content>
							</section>

						    <section id="plain-sql-queryparts">
							    <title>Plain SQL QueryParts</title>
								<content><html>
									<p>
										If you don't need the integration of rather complex QueryParts into jOOQ, then you might be safer using simple <reference id="plain-sql" title="Plain SQL"/> functionality, where you can provide jOOQ with a simple String representation of your embedded SQL. Plain SQL methods in jOOQ's API come in two flavours.
									</p>
									<ul>
										<li><strong>method(String, Object...)</strong>: This is a method that accepts a SQL string and a list of bind values that are to be bound to the variables contained in the SQL string</li>
										<li><strong>method(String, QueryPart...)</strong>: This is a method that accepts a SQL string and a list of QueryParts that are "injected" at the position of their respective placeholders in the SQL string</li>
									</ul>
									<p>
										The above distinction is best explained using an example:
									</p>

</html><java><![CDATA[// Plain SQL using bind values. The value 5 is bound to the first variable, "Animal Farm" to the second variable:
create.selectFrom(BOOK).where("BOOK.ID = ? AND TITLE = ?", 5, "Animal Farm");

// Plain SQL using placeholders (counting from zero).
// The QueryPart "id" is substituted for the placeholder {0}, the QueryPart "title" for {1}
Field<Integer> id   = val(5);
Field<String> title = val("Animal Farm");
create.selectFrom(BOOK).where("BOOK.ID = {0} AND TITLE = {1}", id, title);]]></java><html>

									<p>
										The above technique allows for creating rather complex SQL clauses that are currently not supported by jOOQ, without extending any of the <reference id="custom-queryparts" title="custom QueryParts"/> as indicated in the previous chapter.
									</p>
								</html></content>
							</section>

						    <section id="serializability">
							    <title>Serializability</title>
								<content><html>
									<p>
										The only transient, non-serializable element in any jOOQ object is the <reference id="factory" title="Factory's"/> underlying <reference class="java.sql.Connection"/>. When you want to execute queries after de-serialisation, or when you want to store/refresh/delete <reference id="crud-with-updatablerecords" title="Updatable Records"/>, you will have to "re-attach" them to a Factory
									</p>

</html><java><![CDATA[// Deserialise a SELECT statement
ObjectInputStream in = new ObjectInputStream(...);
Select<?> select = (Select<?>) in.readObject();

// This will throw a DetachedException:
select.execute();

// In order to execute the above select, attach it first
Factory create = new Factory(connection, SQLDialect.ORACLE);
create.attach(select);]]></java><html>

									<h3>Automatically attaching QueryParts</h3>
									<p>
										Another way of attaching QueryParts automatically, or rather providing them with a new <reference class="java.sql.Connection"/> at will, is to hook into the <reference id="execute-listeners" title="Execute Listener support"/>. More details about this can be found in the manual's chapter about <reference id="execute-listeners" title="ExecuteListeners"/>
									</p>
								</html></content>
							</section>
						</sections>
					</section>
				</sections>
			</section>

			<section id="sql-execution">
				<title>SQL execution</title>
				<content><html>
					<p>
						In a previous section of the manual, we've seen how jOOQ can be used to <reference id="sql-building" title="build SQL"/> that can be executed with any API including JDBC or ... jOOQ. This section of the manual deals with various means of actually executing SQL with jOOQ.
					</p>

					<h3>SQL execution with JDBC</h3>
					<p>
						JDBC calls executable objects "<reference class="java.sql.Statement"/>". It distinguishes between three types of statements:
					</p>
					<ul>
						<li><reference class="java.sql.Statement"/>, or "static statement": This statement type is used for any arbitrary type of SQL statement. It is particularly useful with <reference id="inlined-parameters" title="inlined parameters"/></li>
						<li><reference class="java.sql.PreparedStatement"/>: This statement type is used for any arbitrary type of SQL statement. It is particularly useful with <reference id="indexed-parameters" title="indexed parameters"/> (note that JDBC does not support <reference id="named-parameters" title="named parameters"/>)</li>
						<li><reference class="java.sql.CallableStatement"/>: This statement type is used for SQL statements that are "called" rather than "executed". In particular, this includes calls to <reference id="stored-procedures" title="stored procedures"/>. Callable statements can register OUT parameters</li>
					</ul>
					<p>
						Today, the JDBC API may look weird to users being used to object-oriented design. While statements hide a lot of SQL dialect-specific implementation details quite well, they assume a lot of knowledge about the internal state of a statement. For instance, you can use the <reference class="java.sql.PreparedStatement" anchor="#addBatch()" title="PreparedStatement.addBatch()"/> method, to add a the prepared statement being created to an "internal list" of batch statements. Instead of returning a new type, this method forces user to reflect on the prepared statement's internal state or "mode".
					</p>

					<h3>jOOQ is wrapping JDBC</h3>
					<p>
						These things are abstracted away by jOOQ, which exposes such concepts in a more object-oriented way. For more details about jOOQ's batch query execution, see the manual's section about <reference id="batch-execution" title="batch execution"/>.
					</p>
					<p>
						The following sections of this manual will show how jOOQ is wrapping JDBC for SQL execution
					</p>
				</html></content>

				<sections>
					<section id="comparison-with-jdbc">
						<title>Comparison between jOOQ and JDBC</title>
						<content><html>
							<h3>Similarities with JDBC</h3>
							<p>
								Even if there are <reference id="query-vs-resultquery" title="two general types of Query"/>, there are a lot of similarities between JDBC and jOOQ. Just to name a few:
							</p>
							<ul>
								<li>Both APIs return the number of affected records in non-result queries. JDBC: <reference class="java.sql.Statement" anchor="#executeUpdate(java.lang.String)" title="Statement.executeUpdate()"/>, jOOQ: <reference class="org.jooq.Query" anchor="#execute()" title="Query.execute()"/></li>
								<li>Both APIs return a scrollable result set type from result queries. JDBC: <reference class="java.sql.ResultSet"/>, jOOQ: <reference class="org.jooq.Result"/></li>
							</ul>

							<h3>Differences to JDBC</h3>
							<p>
								Some of the most important differences between JDBC and jOOQ are listed here:
							</p>
							<ul>
								<li><reference id="query-vs-resultquery" title="Query vs. ResultQuery"/>: JDBC does not formally distinguish between queries that can return results, and queries that cannot. The same API is used for both. This greatly reduces the possibility for <reference id="fetching" title="fetching convenience methods"/></li>
								<li><reference id="exception-handling" title="Exception handling"/>: While SQL uses the checked <reference class="java.sql.SQLException"/>, jOOQ wraps all exceptions in an unchecked <reference class="org.jooq.exception.DataAccessException"/></li>
								<li><reference class="org.jooq.Result"/>: Unlike its JDBC counter-part, this type implements <reference class="java.util.List"/> and is fully loaded into Java memory, freeing resources as early as possible. Just like statements, this means that users don't have to deal with a "weird" internal result set state.</li>
								<li><reference class="org.jooq.Cursor"/>: If you want more fine-grained control over how many records are fetched into memory at once, you can still do that using jOOQ's <reference id="lazy-fetching" title="lazy fetching"/> feature</li>
								<li><reference id="statement-type" title="Statement type"/>: jOOQ does not formally distinguish between static statements and prepared statements. By default, all statements are prepared statements in jOOQ, internally. Executing a statement as a static statement can be done simply using a <reference id="custom-settings" title="custom settings flag"/></li>
							</ul>
						</html></content>
					</section>

				    <section id="query-vs-resultquery">
						<title>Query vs. ResultQuery</title>
						<content><html>
							<p>
								Unlike JDBC, jOOQ has a lot of knowledge about a SQL query's structure and internals (see the manual's section about <reference id="sql-building" title="SQL building"/>). Hence, jOOQ distinguishes between these two fundamental types of queries. While every <reference class="org.jooq.Query"/> can be executed, only <reference class="org.jooq.ResultQuery"/> can return results (see the manual's section about <reference id="fetching" title="fetching"/> to learn more about fetching results). With plain SQL, the distinction can be made clear most easily:
							</p>

</html><java><![CDATA[// Create a Query object and execute it:
Query query = create.query("DELETE FROM BOOK");
query.execute();

// Create a ResultQuery object and execute it, fetching results:
ResultQuery<Record> resultQuery = create.resultQuery("SELECT * FROM BOOK");
Result<Record> result = resultQuery.fetch();]]></java></content>
					</section>

				    <section id="fetching">
						<title>Fetching</title>
						<content><html>
							<p>
								Fetching is something that has been completely neglegted by JDBC and also by various other database abstraction libraries. Fetching is much more than just looping or listing records or mapped objects. There are so many ways you may want to fetch data from a database, it should be considered a first-class feature of any database abstraction API. Just to name a few, here are some of jOOQ's fetching modes:
							</p>
							<ul>
								<li><reference id="record-vs-tablerecord" title="Untyped vs. typed fetching"/>: Sometimes you care about the returned type of your records, sometimes (with arbitrary projections) you don't.</li>
								<li><reference id="arrays-maps-and-lists" title="Fetching arrays, maps, or lists"/>: Instead of letting you transform your result sets into any more suitable data type, a library should do that work for you.</li>
								<li><reference id="recordhandler" title="Fetching through callbacks"/>: This is an entirely different fetching paradigm. With Java 8's lambda expressions, this will become even more powerful.</li>
								<li><reference id="pojos" title="Fetching custom POJOs"/>: This is what made Hibernate and JPA so strong. Automatic mapping of tables to custom POJOs.</li>
								<li><reference id="lazy-fetching" title="Lazy vs. eager fetching"/>: It should be easy to distinguish these two fetch modes.</li>
								<li><reference id="many-fetching" title="Fetching many results"/>: Some databases allow for returning many result sets from a single query. JDBC can handle this but it's very verbose. A list of results should be returned instead.</li>
								<li><reference id="later-fetching" title="Fetching data asynchronously"/>: Some queries take too long to execute to wait for their results. You should be able to spawn query execution in a separate process.</li>
							</ul>

							<h3>Convenience and how ResultQuery, Result, and Record share API</h3>
							<p>
								The term "fetch" is always reused in jOOQ when you can fetch data from the database. An <reference class="org.jooq.ResultQuery"/> provides many overloaded means of fetching data:
							</p>

							<h3>Various modes of fetching</h3>
							<p>
								These modes of fetching are also documented in subsequent sections of the manual
							</p>

</html><java><![CDATA[// The "standard" fetch
Result<R> fetch();

// The "standard" fetch when you know your query returns only one record
R fetchOne();

// The "standard" fetch when you only want to fetch the first record
R fetchAny();

// Create a "lazy" Cursor, that keeps an open underlying JDBC ResultSet
Cursor<R> fetchLazy();
Cursor<R> fetchLazy(int fetchSize);

// Create a java.util.concurrent.Future, to handle asynchronous execution of the ResultQuery
FutureResult<R> fetchLater();
FutureResult<R> fetchLater(ExecutorService executor);

// Fetch several results at once
List<Result<Record>> fetchMany();

// Fetch records into a custom callback
<H extends RecordHandler<R>> H fetchInto(H handler);

// Execute a ResultQuery with jOOQ, but return a JDBC ResultSet, not a jOOQ object
ResultSet fetchResultSet();]]></java><html>

							<h3>Fetch convenience</h3>
							<p>
								These means of fetching are also available from <reference class="org.jooq.Result"/> and <reference class="org.jooq.Record"/> APIs
							</p>

</html><java><![CDATA[// These methods are convenience for fetching only a single field,
// possibly converting results to another type
<T>    List<T> fetch(Field<T> field);
<T>    List<T> fetch(Field<?> field, Class<? extends T> type);
<T, U> List<U> fetch(Field<T> field, Converter<? super T, U> converter);
       List<?> fetch(int fieldIndex);
<T>    List<T> fetch(int fieldIndex, Class<? extends T> type);
<U>    List<U> fetch(int fieldIndex, Converter<?, U> converter);
       List<?> fetch(String fieldName);
<T>    List<T> fetch(String fieldName, Class<? extends T> type);
<U>    List<U> fetch(String fieldName, Converter<?, U> converter);

// These methods are convenience for fetching only a single field, possibly converting results to another type
// Instead of returning lists, these return arrays
<T>    T[]      fetchArray(Field<T> field);
<T>    T[]      fetchArray(Field<?> field, Class<? extends T> type);
<T, U> U[]      fetchArray(Field<T> field, Converter<? super T, U> converter);
       Object[] fetchArray(int fieldIndex);
<T>    T[]      fetchArray(int fieldIndex, Class<? extends T> type);
<U>    U[]      fetchArray(int fieldIndex, Converter<?, U> converter);
       Object[] fetchArray(String fieldName);
<T>    T[]      fetchArray(String fieldName, Class<? extends T> type);
<U>    U[]      fetchArray(String fieldName, Converter<?, U> converter);

// These methods are convenience for fetching only a single field from a single record,
// possibly converting results to another type
<T>    T      fetchOne(Field<T> field);
<T>    T      fetchOne(Field<?> field, Class<? extends T> type);
<T, U> U      fetchOne(Field<T> field, Converter<? super T, U> converter);
       Object fetchOne(int fieldIndex);
<T>    T      fetchOne(int fieldIndex, Class<? extends T> type);
<U>    U      fetchOne(int fieldIndex, Converter<?, U> converter);
       Object fetchOne(String fieldName);
<T>    T      fetchOne(String fieldName, Class<? extends T> type);
<U>    U      fetchOne(String fieldName, Converter<?, U> converter);]]></java><html>

							<h3>Fetch transformations</h3>
							<p>
								These means of fetching are also available from <reference class="org.jooq.Result"/> and <reference class="org.jooq.Record"/> APIs
							</p>

</html><java><![CDATA[// Transform your Records into arrays, Results into matrices
       Object[][] fetchArrays();
       Object[]   fetchOneArray();

// Transform your Result object into maps
<K>    Map<K, R> fetchMap(Field<K> key);
<K, V> Map<K, V> fetchMap(Field<K> key, Field<V> value);
       List<Map<String, Object>> fetchMaps();
       Map<String, Object> fetchOneMap();

// Transform your Result object into groups
<K>    Map<K, Result<R>> fetchGroups(Field<K> key);
<K, V> Map<K, List<V>>   fetchGroups(Field<K> key, Field<V> value);

// Transform your Records into custom POJOs
<E>    List<E> fetchInto(Class<? extends E> type), MappingException;

// Transform your records into another table type
<Z extends Record> Result<Z> fetchInto(Table<Z> table);]]></java><html>

							<p>
								Note, that apart from the <reference class="org.jooq.ResultQuery" anchor="#fetchLazy()" title="fetchLazy()"/> methods, all fetch() methods will immediately close underlying JDBC result sets.
							</p>
						</html></content>

						<sections>
							<section id="record-vs-tablerecord">
								<title>Record vs. TableRecord</title>
								<content><html>
									<p>
										jOOQ understands that SQL is much more expressive than Java, when it comes to the declarative typing of <reference id="table-expressions" title="table expressions"/>. As a declarative language, SQL allows for creating ad-hoc tuples (records with indexed columns) and records (records with named columns). In Java, this is not possible to the same extent. Yet, still, sometimes you wish to use strongly typed records, when you know that you're selecting only from a single table
									</p>

									<h3>Fetching strongly or weakly typed records</h3>
									<p>
										When fetching data only from a single table, the <reference id="table-expressions" title="table expression's"/> type is known to jOOQ if you use jOOQ's <reference id="code-generation" title="code generator"/> to generate <reference id="codegen-records" title="TableRecords"/> for your database tables. In order to fetch such strongly typed records, you will have to use the <reference id="select-statement" title="simple select API"/>:
									</p>

</html><java><![CDATA[// Use the selectFrom() method:
BookRecord book = create.selectFrom(BOOK).where(BOOK.ID.equal(1)).fetchOne();

// Typesafe field access is now possible:
System.out.println("Title       : " + book.getTitle());
System.out.println("Published in: " + book.getPublishedIn());]]></java><html>

									<p>
										When you use the <reference class="org.jooq.FactoryOperations" anchor="#selectFrom(org.jooq.Table)" title="Factory.selectFrom()"/> method, jOOQ will return the record type supplied with the argument table. Beware though, that you will no longer be able to use any clause that modifies the type of your <reference id="table-expressions" title="table expression"/>. This includes:
									</p>
									<ul>
                   						<li><reference id="select-clause" title="The SELECT clause"/></li>
                   						<li><reference id="join-clause" title="The JOIN clause"/></li>
                   						<li><reference id="group-by-clause" title="The GROUP BY clause"/></li>
                   						<li><reference id="having-clause" title="The HAVING clause"/></li>
                   					</ul>

									<h3>Scala's tuple classes</h3>
									<p>
										With the introduction of generics in Java 5, it is possible in principle, to pre-define a set of tuple types. This is what Scala does. In essence, tuple types look something like this:
									</p>

</html><java><![CDATA[// Tuple with arity 1
public interface Tuple1<T1> extends Tuple {
    T1 get1(); void set1(T1 t1);
}

// Tuple with arity 2
public interface Tuple2<T1, T2> extends Tuple {
    T1 get1(); void set1(T1 t1);
    T2 get2(); void set2(T2 t2);
}

// Tuple with arity 3
public interface Tuple3<T1, T2, T3> extends Tuple {
    T1 get1(); void set1(T1 t1);
    T2 get2(); void set2(T2 t2);
    T3 get3(); void set3(T3 t3);
}

// Fictional sample application with Java:
for (Tuple<Integer, String, Date>> tuple : create
        .select(BOOK.ID, BOOK.TITLE, BOOK.PUBLICATION_DATE)
        .from(BOOK)
        .orderBy(BOOK.ID)
        .fetch()) {

    Integer id           = tuple.get1();
    String title         = tuple.get2();
    Date publicationDate = tuple.get3();
}

// Fictional sample application with Scala:
for (tuple <- create
              select (BOOK.ID, BOOK.TITLE, BOOK.PUBLICATION_DATE)
              from BOOK
              orderBy BOOK.ID
              fetch) {

    val id              = tuple._1; // Type is Int
    val title           = tuple._2; // Type is String
    val publicationDate = tuple._3; // Type is Date
}]]></java><html>

									<p>
										It is worth mentioning that Scala is much stronger in inferring types than Java. Yet still, this becomes quickly impracticable as
									</p>
									<ul>
										<li>We will run out of pre-defined tuple types for large arities</li>
										<li>Tuples are not as expressive as records (named tuples)</li>
										<li>With Java's weak type inference (no val/var keywords), tuples quickly become very verbose in Java</li>
									</ul>
									<p>
										For these reasons jOOQ does not support generic tuples.
									</p>
								</html></content>
							</section>

							<section id="arrays-maps-and-lists">
								<title>Arrays, Maps and Lists</title>
								<content><html>
									<p>
										By default, jOOQ returns an <reference class="org.jooq.Result"/> object, which is essentially a <reference class="java.util.List"/> of <reference class="org.jooq.Record"/>. Often, you will find yourself wanting to transform this result object into a type that corresponds more to your specific needs. Or you just want to list all values of one specific column. Here are some examples to illustrate those use cases:
									</p>

</html><java><![CDATA[// Fetching only book titles (the two calls are equivalent):
List<String> titles1 = create.select().from(BOOK).fetch().getValues(BOOK.TITLE);
List<String> titles2 = create.select().from(BOOK).fetch(BOOK.TITLE);
String[]     titles3 = create.select().from(BOOK).fetchArray(BOOK.TITLE);

// Fetching only book IDs, converted to Long
List<Long> ids1 = create.select().from(BOOK).fetch().getValues(BOOK.ID, Long.class);
List<Long> ids2 = create.select().from(BOOK).fetch(BOOK.ID, Long.class);
Long[]     ids3 = create.select().from(BOOK).fetchArray(BOOK.ID, Long.class);

// Fetching book IDs and mapping each ID to their records or titles
Map<Integer, BookRecord> map1 = create.selectFrom(BOOK).fetch().intoMap(BOOK.ID);
Map<Integer, BookRecord> map2 = create.selectFrom(BOOK).fetchMap(BOOK.ID);
Map<Integer, String>     map3 = create.selectFrom(BOOK).fetch().intoMap(BOOK.ID, BOOK.TITLE);
Map<Integer, String>     map4 = create.selectFrom(BOOK).fetchMap(BOOK.ID, BOOK.TITLE);

// Group by AUTHOR_ID and list all books written by any author:
Map<Integer, Result<BookRecord>> group1 = create.selectFrom(BOOK).fetch().intoGroups(BOOK.AUTHOR_ID);
Map<Integer, Result<BookRecord>> group2 = create.selectFrom(BOOK).fetchGroups(BOOK.AUTHOR_ID);
Map<Integer, List<String>>       group3 = create.selectFrom(BOOK).fetch().intoGroups(BOOK.AUTHOR_ID, BOOK.TITLE);
Map<Integer, List<String>>       group4 = create.selectFrom(BOOK).fetchGroups(BOOK.AUTHOR_ID, BOOK.TITLE);]]></java><html>

									<p>
										Note that most of these convenience methods are available both through <reference class="org.jooq.ResultQuery"/> and <reference class="org.jooq.Result"/>, some are even available through <reference class="org.jooq.Record"/> as well.
									</p>
								</html></content>
							</section>

							<section id="recordhandler">
								<title>RecordHandler</title>
								<content><html>
									<p>
										In a more functional operating mode, you might want to write callbacks that receive records from your select statement results in order to do some processing. This is a common data access pattern in Spring's JdbcTemplate, and it is also available in jOOQ. With jOOQ, you can implement your own <reference class="org.jooq.RecordHandler"/> classes and plug them into jOOQ's <reference class="org.jooq.ResultQuery"/>:
									</p>

</html><java><![CDATA[// Write callbacks to receive records from select statements
create.selectFrom(BOOK)
      .orderBy(BOOK.ID)
      .fetch()
      .into(new RecordHandler<BookRecord>() {
          @Override
          public void next(BookRecord book) {
              Util.doThingsWithBook(book);
          }
      });

// Or more concisely
create.selectFrom(BOOK)
      .orderBy(BOOK.ID)
      .fetchInto(new RecordHandler<BookRecord>() {...});

// Or even more concisely with Java 8's lambda expressions:
create.selectFrom(BOOK)
      .orderBy(BOOK.ID)
      .fetchInto(book -> { Util.doThingsWithBook(book); }; );
]]></java></content>
							</section>

							<section id="pojos">
								<title>POJOs</title>
								<content><html>
									<p>
										Fetching data in records is fine as long as your application is not really layered, or as long as you're still writing code in the DAO layer. But if you have a more advanced application architecture, you may not want to allow for jOOQ artefacts to leak into other layers. You may choose to write POJOs (Plain Old Java Objects) as your primary DTOs (Data Transfer Objects), without any dependencies on jOOQ's <reference class="org.jooq.Record"/> types, which may even potentially hold a reference to a <reference id="factory" title="Factory"/>, and thus a JDBC <reference class="java.sql.Connection"/>. Like Hibernate/JPA, jOOQ allows you to operate with POJOs. Unlike Hibernate/JPA, jOOQ does not "attach" those POJOs or create proxies with any magic in them.
									</p>
									<p>
										If you're using jOOQ's <reference id="code-generation" title="code generator"/>, you can configure it to <reference id="codegen-pojos" title="generate POJOs"/> for you, but you're not required to use those generated POJOs. You can use your own.
									</p>

									<h3>Using JPA-annotated POJOs</h3>
									<p>
										jOOQ tries to find JPA annotations on your POJO types. If it finds any, they are used as the primary source for mapping meta-information. Only the <reference class="javax.persistence.Column"/> annotation is used and understood by jOOQ. An example:
									</p>

</html><java><![CDATA[// A JPA-annotated POJO class
public class MyBook {
  @Column(name = "ID")
  public int myId;

  @Column(name = "TITLE")
  public String myTitle;
}

// The various "into()" methods allow for fetching records into your custom POJOs:
MyBook myBook        = create.select().from(BOOK).fetchAny().into(MyBook.class);
List<MyBook> myBooks = create.select().from(BOOK).fetch().into(MyBook.class);
List<MyBook> myBooks = create.select().from(BOOK).fetchInto(MyBook.class);]]></java><html>

									<p>
										Just as with any other JPA implementation, you can put the <reference class="javax.persistence.Column"/> annotation on any class member, including attributes, setters and getters. Please refer to the <reference class="org.jooq.Record" anchor="#into(java.lang.Class)" title="Record.into()"/> Javadoc for more details.
									</p>

									<h3>Using simple POJOs</h3>
									<p>
										If jOOQ does not find any JPA-annotations, columns are mapped to the "best-matching" constructor, attribute or setter. An example illustrates this:
									</p>

</html><java><![CDATA[// A "mutable" POJO class
public class MyBook1 {
  public int id;
  public String title;
}

// The various "into()" methods allow for fetching records into your custom POJOs:
MyBook1 myBook        = create.select().from(BOOK).fetchAny().into(MyBook1.class);
List<MyBook1> myBooks = create.select().from(BOOK).fetch().into(MyBook1.class);
List<MyBook1> myBooks = create.select().from(BOOK).fetchInto(MyBook1.class);

// An "immutable" POJO class
public class MyBook2 {
  public final int id;
  public final String title;

  public MyBook2(int id, String title) {
    this.id = id;
    this.title = title;
  }
}

// With "immutable" POJO classes, there must be an exact match between projected fields and available constructors:
MyBook2 myBook        = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetchAny().into(MyBook2.class);
List<MyBook2> myBooks = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetch().into(MyBook2.class);
List<MyBook2> myBooks = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetchInto(MyBook2.class);]]></java><html>

									<p>
										Please refer to the <reference class="org.jooq.Record" anchor="#into(java.lang.Class)" title="Record.into()"/> Javadoc for more details.
									</p>

									<h3>Using proxyable types</h3>
									<p>
										jOOQ also allows for fetching data into abstract classes or interfaces, or in other words, "proxyable" types. This means that jOOQ will return a <reference class="java.util.HashMap"/> wrapped in a <reference class="java.lang.reflect.Proxy"/> implementing your custom type. An example of this is given here:
									</p>

</html><java><![CDATA[// A "proxyable" type
public interface MyBook3 {
  int getId();
  void setId(int id);

  String getTitle();
  void setTitle(String title);
}

// The various "into()" methods allow for fetching records into your custom POJOs:
MyBook3 myBook        = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetchAny().into(MyBook3.class);
List<MyBook3> myBooks = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetch().into(MyBook3.class);
List<MyBook3> myBooks = create.select(BOOK.ID, BOOK.TITLE).from(BOOK).fetchInto(MyBook3.class);]]></java><html>

									<p>
										Please refer to the <reference class="org.jooq.Record" anchor="#into(java.lang.Class)" title="Record.into()"/> Javadoc for more details.
									</p>

									<h3>Loading POJOs back into Records to store them</h3>
									<p>
										The above examples show how to fetch data into your own custom POJOs / DTOs. When you have modified the data contained in POJOs, you probably want to store those modifications back to the database. An example of this is given here:
									</p>

</html><java><![CDATA[// A "mutable" POJO class
public class MyBook {
  public int id;
  public String title;
}

// Create a new POJO instance
MyBook myBook = new MyBook();
myBook.id = 10;
myBook.title = "Animal Farm";

// Load a jOOQ-generated BookRecord from your POJO
BookRecord book = create.newRecord(BOOK, myBook);

// Insert it (implicitly)
book.store();

// Insert it (explicitly)
create.executeInsert(book);

// or update it (ID = 10)
create.executeUpdate(book);]]></java><html>

									<p>
										Note: Because of your manual setting of ID = 10, jOOQ's store() method will asume that you want to insert a new record. See the manual's section about <reference id="crud-with-updatablerecords" title="CRUD with UpdatableRecords"/> for more details on this.
									</p>

									<h3>Interaction with DAOs</h3>
									<p>
										If you're using jOOQ's <reference id="code-generation" title="code generator"/>, you can configure it to <reference id="codegen-daos" title="generate DAOs"/> for you. Those DAOs operate on <reference id="codegen-pojos" title="generated POJOs"/>. An example of using such a DAO is given here:
									</p>

</html><java><![CDATA[// Initialise a Factory
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Initialise the DAO with the Factory
BookDao bookDao = new BookDao(create);

// Start using the DAO
Book book = bookDao.findById(5);

// Modify and update the POJO
book.setTitle("1984");
book.setPublishedIn(1948);
bookDao.update(book);

// Delete it again
bookDao.delete(book);]]></java><html>

									<h3>More complex data structures</h3>
									<p>
										jOOQ currently doesn't support more complex data structures, the way Hibernate/JPA attempt to map relational data onto POJOs. While future developments in this direction are not excluded, jOOQ claims that generic mapping strategies lead to an enormous additional complexity that only serves very few use cases. You are likely to find a solution using any of jOOQ's various <reference id="fetching" title="fetching modes"/>, with only little boiler-plate code on the client side.
									</p>
								</html></content>
							</section>

							<section id="lazy-fetching">
								<title>Lazy fetching</title>
								<content><html>
									<p>
										Unlike JDBC's <reference class="java.sql.ResultSet"/>, jOOQ's <reference class="org.jooq.Result"/> does not represent an open database cursor with various fetch modes and scroll modes, that needs to be closed after usage. jOOQ's results are simple in-memory Java <reference class="java.util.List"/> objects, containing all of the result values. If your result sets are large, or if you have a lot of network latency, you may wish to fetch records one-by-one, or in small chunks. jOOQ supports a <reference class="org.jooq.Cursor"/> type for that purpose. In order to obtain such a reference, use the <reference class="org.jooq.ResultQuery" anchor="#fetchLazy()" title="ResultQuery.fetchLazy()"/> method. An example is given here:
									</p>

</html><java><![CDATA[// Obtain a Cursor reference:
Cursor<BookRecord> cursor = null;

try {
    cursor = create.selectFrom(BOOK).fetchLazy();

    // Cursor has similar methods as Iterator<R>
    while (cursor.hasNext()) {
        BookRecord book = cursor.fetchOne();

        Util.doThingsWithBook(book);
    }
}

// Close the cursor and the cursor's underlying JDBC ResultSet
finally {
    if (cursor != null) {
        cursor.close();
    }
}]]></java><html>

									<p>
										As a <reference class="org.jooq.Cursor"/> holds an internal reference to an open <reference class="java.sql.ResultSet"/>, it may need to be closed at the end of iteration. If a cursor is completely scrolled through, it will conveniently close the underlying ResultSet. However, you should not rely on that.
									</p>

									<h3>Cursors ship with all the other fetch features</h3>
									<p>
										Like <reference class="org.jooq.ResultQuery"/> or <reference class="org.jooq.Result"/>, <reference class="org.jooq.Cursor"/> gives access to all of the other fetch features that we've seen so far, i.e.
									</p>
									<ul>
										<li><reference id="record-vs-tablerecord" title="Strongly or weakly typed records"/>: Cursors are also typed with the &lt;R&gt; type, allowing to fetch custom, generated <reference class="org.jooq.TableRecord"/> or plain <reference class="org.jooq.Record"/> types.</li>
										<li><reference id="recordhandler" title="RecordHandler callbacks"/>: You can use your own <reference class="org.jooq.RecordHandler"/> callbacks to receive lazily fetched records.</li>
										<li><reference id="pojos" title="POJOs"/>: You can fetch data into your own custom POJO types.</li>
									</ul>
								</html></content>
							</section>

							<section id="many-fetching">
								<title>Many fetching</title>
								<content><html>
									<p>
										Many databases support returning several result sets, or cursors, from single queries. An example for this is Sybase ASE's sp_help command:
									</p>
</html><text><![CDATA[> sp_help 'author'

+--------+-----+-----------+-------------+-------------------+
|Name    |Owner|Object_type|Object_status|Create_date        |
+--------+-----+-----------+-------------+-------------------+
|  author|dbo  |user table | -- none --  |Sep 22 2011 11:20PM|
+--------+-----+-----------+-------------+-------------------+

+-------------+-------+------+----+-----+-----+
|Column_name  |Type   |Length|Prec|Scale|...  |
+-------------+-------+------+----+-----+-----+
|id           |int    |     4|NULL| NULL|    0|
|first_name   |varchar|    50|NULL| NULL|    1|
|last_name    |varchar|    50|NULL| NULL|    0|
|date_of_birth|date   |     4|NULL| NULL|    1|
|year_of_birth|int    |     4|NULL| NULL|    1|
+-------------+-------+------+----+-----+-----+]]></text><html>


									<p>
										The correct (and verbose) way to do this with JDBC is as follows:
									</p>

</html><java><![CDATA[ResultSet rs = statement.executeQuery();

// Repeat until there are no more result sets
for (;;) {

  // Empty the current result set
  while (rs.next()) {
    // [ .. do something with it .. ]
  }

  // Get the next result set, if available
  if (statement.getMoreResults()) {
    rs = statement.getResultSet();
  }
  else {
    break;
  }
}

// Be sure that all result sets are closed
statement.getMoreResults(Statement.CLOSE_ALL_RESULTS);
statement.close();]]></java><html>

									<p>
										As previously discussed in the chapter about <reference id="comparison-with-jdbc" title="differences between jOOQ and JDBC"/>, jOOQ does not rely on an internal state of any JDBC object, which is "externalised" by Javadoc. Instead, it has a straight-forward API allowing you to do the above in a one-liner:
									</p>

</html><java><![CDATA[// Get some information about the author table, its columns, keys, indexes, etc
List<Result<Record>> results = create.fetchMany("sp_help 'author'");]]></java><html>

									<p>
										Using generics, the resulting structure is immediately clear.
									</p>
								</html></content>
							</section>

							<section id="later-fetching">
								<title>Later fetching</title>
								<content><html>
									<p>
										Some queries take very long to execute, yet they are not crucial for the continuation of the main program. For instance, you could be generating a complicated report in a Swing application, and while this report is being calculated in your database, you want to display a background progress bar, allowing the user to pursue some other work. This can be achived simply with jOOQ, by creating a <reference class="org.jooq.FutureResult"/>, a type that extends <reference class="java.util.concurrent.Future"/>. An example is given here:
									</p>

</html><java><![CDATA[// Spawn off this query in a separate process:
FutureResult<BookRecord> future = create.selectFrom(BOOK).where(... complex predicates ...).fetchLater();

// This example actively waits for the result to be done
while (!future.isDone()) {
    progressBar.increment(1);
    Thread.sleep(50);
}

// The result should be ready, now
Result<BookRecord> result = future.get();]]></java><html>

									<p>
										Note, that instead of letting jOOQ spawn a new thread, you can also provide jOOQ with your own <reference class="java.util.concurrent.ExecutorService"/>:
									</p>

</html><java><![CDATA[// Spawn off this query in a separate process:
ExecutorService service = // [...]
FutureResult<BookRecord> future = create.selectFrom(BOOK).where(... complex predicates ...).fetchLater(service);]]></java></content>
							</section>

							<section id="resultset-fetching">
								<title>ResultSet fetching</title>
								<content><html>
									<p>
										When interacting with legacy applications, you may prefer to have jOOQ return a <reference class="java.sql.ResultSet"/>, rather than jOOQ's own <reference class="org.jooq.Result"/> types. This can be done simply, in two ways:
									</p>

</html><java><![CDATA[// jOOQ's Cursor type exposes the underlying ResultSet:
ResultSet rs1 = create.selectFrom(BOOK).fetchLazy().resultSet();

// But you can also directly access that ResultSet from ResultQuery:
ResultSet rs2 = create.selectFrom(BOOK).fetchResultSet();

// Don't forget to close these, though!
rs1.close();
rs2.close();]]></java><html>

									<h3>Transform jOOQ's Result into a JDBC ResultSet</h3>
									<p>
										Instead of operating on a JDBC ResultSet holding an open resource from your database, you can also let jOOQ's <reference class="org.jooq.Result"/> wrap itself in a <reference class="java.sql.ResultSet"/>. The advantage of this is that the so-created ResultSet has no open connection to the database. It is a completely in-memory ResultSet:
									</p>

</html><java><![CDATA[// Transform a jOOQ Result into a ResultSet
Result<BookRecord> result = create.selectFrom(BOOK).fetch();
ResultSet rs = result.intoResultSet();]]></java><html>

									<h3>The inverse: Fetch data from a legacy ResultSet using jOOQ</h3>
									<p>
										The inverse of the above is possible too. Maybe, a legacy part of your application produces JDBC <reference class="java.sql.ResultSet"/>, and you want to turn them into a <reference class="org.jooq.Result"/>:
									</p>

</html><java><![CDATA[// Transform a JDBC ResultSet into a jOOQ Result
ResultSet rs = connection.createStatement().executeQuery("SELECT * FROM BOOK");

// As a Result:
Result<Record> result = create.fetch(rs);

// As a Cursor
Cursor<Record> cursor = create.fetchLazy(rs);]]></java></content>
							</section>

							<section id="data-type-conversion">
								<title>Data type conversion</title>
								<content><html>
									<p>
										Apart from a few extra features (see the manual's section about <reference id="master-data-types" title="master data types"/> and <reference id="codegen-udts" title="user-defined types"/>), jOOQ only supports basic types as supported by the JDBC API. In your application, you may choose to transform these data types into your own ones, without writing too much boiler-plate code. This can be done using jOOQ's <reference class="org.jooq.Converter"/> types. A converter essentially allows for two-way conversion between two Java data types &lt;T&gt; and &lt;U&gt;. By convention, the &lt;T&gt; type corresponds to the type in your database whereas the &gt;U&gt; type corresponds to your own user type. The Converter API is given here:
									</p>

</html><java><![CDATA[public interface Converter<T, U> extends Serializable {

    /**
     * Convert a database object to a user object
     */
    U from(T databaseObject);

    /**
     * Convert a user object to a database object
     */
    T to(U userObject);

    /**
     * The database type
     */
    Class<T> fromType();

    /**
     * The user type
     */
    Class<U> toType();
}]]></java><html>

									<p>
										Such a converter can be used in many parts of the jOOQ API. Some examples have been illustrated in the manual's section about <reference id="fetching" title="fetching"/>.
									</p>

									<h3>A Converter for GregorianCalendar</h3>
									<p>
										Here is a some more elaborate example involving a Converter for <reference class="java.util.GregorianCalendar"/>:
									</p>

</html><java><![CDATA[// You may prefer Java Calendars over JDBC Timestamps
public class CalendarConverter implements Converter<Timestamp, GregorianCalendar> {

    @Override
    public GregorianCalendar from(Timestamp databaseObject) {
        GregorianCalendar calendar = (GregorianCalendar) Calendar.getInstance();
        calendar.setTimeInMillis(databaseObject.getTime());
        return calendar;
    }

    @Override
    public Timestamp to(GregorianCalendar userObject) {
        return new Timestamp(userObject.getTime().getTime());
    }

    @Override
    public Class<Timestamp> fromType() {
        return Timestamp.class;
    }

    @Override
    public Class<GregorianCalendar> toType() {
        return GregorianCalendar.class;
    }
}

// Now you can fetch calendar values from jOOQ's API:
List<GregorianCalendar> dates1 = create.selectFrom(BOOK).fetch().getValues(BOOK.PUBLISHING_DATE, new CalendarConverter());
List<GregorianCalendar> dates2 = create.selectFrom(BOOK).fetch(BOOK.PUBLISHING_DATE, new CalendarConverter());
]]></java><html>

									<h3>Enum Converters</h3>
									<p>
										jOOQ ships with a built-in default <reference class="org.jooq.impl.EnumConverter"/>, that you can use to map VARCHAR values to enum literals or NUMBER values to enum ordinals (both modes are supported). Let's say, you want to map a YES / NO / MAYBE column to a custom Enum:
									</p>

</html><java><![CDATA[// Define your Enum
public enum YNM {
    YES, NO, MAYBE
}

// Define your converter
public class YNMConverter extends EnumConverter<String, YNM> {
    public YNMConverter() {
        super(String.class, YNM.class);
    }
}

// And you're all set for converting records to your custom Enum:
for (BookRecord book : create.selectFrom(BOOK).fetch()) {
    switch (book.getValue(BOOK.I_LIKE, new YNMConverter())) {
        case YES:    System.out.println("I like this book             : " + book.getTitle()); break;
        case NO:     System.out.println("I didn't like this book      : " + book.getTitle()); break;
        case MAYBE:  System.out.println("I'm not sure about this book : " + book.getTitle()); break;
    }
}]]></java><html>

									<h3>Using Converters in generated source code</h3>
									<p>
										jOOQ also allows for generated source code to reference your own custom converters, in order to permanently replace a <reference id="table-columns" title="table column's"/> &lt;T&gt; type by your own, custom &lt;U&gt; type. See the manual's section about <reference id="custom-data-types" title="custom data types"/> for details.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="statement-type">
						<title>Static statements vs. Prepared Statements</title>
						<content><html>
							<p>
								With JDBC, you have full control over your SQL statements. You can decide yourself, if you want to execute a static <reference class="java.sql.Statement"/> without bind values, or a <reference class="java.sql.PreparedStatement"/> with (or without) bind values. But you have to decide early, which way to go. And you'll have to prevent SQL injection and syntax errors manually, when inlining your bind variables.
							</p>
							<p>
								With jOOQ, this is easier. As a matter of fact, it is plain simple. With jOOQ, you can just set a flag in your <reference id="factory" title="Factory's"/> <reference id="custom-settings" title="Settings"/>, and all queries produced by that factory will be executed as static statements, with all bind values inlined. An example is given here:
							</p>

</html><code-pair>
<sql><![CDATA[






-- These statements are rendered by the two factories:
SELECT ? FROM DUAL WHERE ? = ?
SELECT 1 FROM DUAL WHERE 1 = 1]]></sql><java><![CDATA[// This Factory executes PreparedStatements
Factory prepare = new Factory(connection, SQLDialect.ORACLE);

// This Factory exeecutes static Statements
Factory inlined = new Factory(connection, SQLDialect.ORACLE,
  new Settings().withStatementType(StatementType.STATIC_STATEMENT));

prepare.select(val(1)).where(val(1).equal(1)).fetch();
inlined.select(val(1)).where(val(1).equal(1)).fetch();]]></java>
</code-pair><html>

							<h3>Reasons for choosing one or the other</h3>
							<p>
								Not all databases are equal. Some databases show improved performance if you use <reference class="java.sql.PreparedStatement"/>, as the database will then be able to re-use execution plans for identical SQL statements, regardless of actual bind values. This heavily improves the time it takes for soft-parsing a SQL statement. In other situations, assuming that bind values are irrelevant for SQL execution plans may be a bad idea, as you might run into "bind value peeking" issues. You may be better off spending the extra cost for a new hard-parse of your SQL statement and instead having the database fine-tune the new plan to the concrete bind values.
							</p>
							<p>
								Whichever aproach is more optimal for you cannot be decided by jOOQ. In most cases, prepared statements are probably better. But you always have the option of forcing jOOQ to render inlined bind values.
							</p>

							<h3>Inlining bind values on a per-bind-value basis</h3>
							<p>
								Note that you don't have to inline all your bind values at once. If you know that a bind value is not really a variable and should be inlined explicitly, you can do so by using <reference class="org.jooq.impl.Factory" anchor="#inline(Object)" title="Factory.inline()"/>, as documented in the manual's section about <reference id="inlined-parameters" title="inlined parameters"/>
							</p>
						</html></content>
					</section>

				    <section id="batch-execution">
						<title>Using JDBC batch operations</title>
						<content><html>
							<p>
								With JDBC, you can easily execute several statements at once using the addBatch() method. Essentially, there are two modes in JDBC
							</p>

							<ul>
								<li>Execute several queries without bind values</li>
								<li>Execute one query several times with bind values</li>
							</ul>

							<p>
								In code, this looks like the following snippet:
							</p>
</html><java><![CDATA[// 1. several queries
// ------------------
try (Statement stmt = connection.createStatement()) {
    stmt.addBatch("INSERT INTO author(id, first_name, last_name) VALUES (1, 'Erich', 'Gamma')");
    stmt.addBatch("INSERT INTO author(id, first_name, last_name) VALUES (2, 'Richard', 'Helm')");
    stmt.addBatch("INSERT INTO author(id, first_name, last_name) VALUES (3, 'Ralph', 'Johnson')");
    stmt.addBatch("INSERT INTO author(id, first_name, last_name) VALUES (4, 'John', 'Vlissides')");
    int[] result = stmt.executeBatch();
}

// 2. a single query
// -----------------
try (PreparedStatement stmt = connection.prepareStatement("INSERT INTO author(id, first_name, last_name) VALUES (?, ?, ?)")) {
    stmt.setInt(1, 1);
    stmt.setString(2, "Erich");
    stmt.setString(3, "Gamma");
    stmt.addBatch();

    stmt.setInt(1, 2);
    stmt.setString(2, "Richard");
    stmt.setString(3, "Helm");
    stmt.addBatch();

    stmt.setInt(1, 3);
    stmt.setString(2, "Ralph");
    stmt.setString(3, "Johnson");
    stmt.addBatch();

    stmt.setInt(1, 4);
    stmt.setString(2, "John");
    stmt.setString(3, "Vlissides");
    stmt.addBatch();

    int[] result = stmt.executeBatch();
}]]></java><html>


							<h3>This will also be supported by jOOQ</h3>
							<p>
								jOOQ supports executing queries in batch mode as follows:
							</p>

</html><java><![CDATA[// 1. several queries
// ------------------
create.batch(
	create.insertInto(AUTHOR, ID, NAME).values(1, "Erich Gamma"),
	create.insertInto(AUTHOR, ID, NAME).values(2, "Richard Helm"),
	create.insertInto(AUTHOR, ID, NAME).values(3, "Ralph Johnson"),
	create.insertInto(AUTHOR, ID, NAME).values(4, "John Vlissides"))
.execute();

// 2. a single query
// -----------------
create.batch(create.insertInto(AUTHOR, ID, NAME).values("?", "?"))
	  .bind(1, "Erich Gamma")
	  .bind(2, "Richard Helm")
	  .bind(3, "Ralph Johnson")
	  .bind(4, "John Vlissides")
	  .execute();]]></java></content>
					</section>

				    <section id="sequence-execution">
						<title>Sequence execution</title>
						<content><html>
							<p>
								Most databases support sequences of some sort, to provide you with unique values to be used for primary keys and other enumerations. If you're using jOOQ's <reference id="code-generation" title="code generator"/>, it will generate a sequence object per sequence for you. There are two ways of using such a sequence object:
							</p>

							<h3>Standalone calls to sequences</h3>
							<p>
								Instead of actually phrasing a select statement, you can also use the <reference id="factory" title="Factory's"/> convenience methods:
							</p>

</html><java><![CDATA[// Fetch the next value from a sequence
BigInteger nextID = create.nextval(S_AUTHOR_ID);

// Fetch the current value from a sequence
BigInteger currID = create.currval(S_AUTHOR_ID);]]></java><html>

							<h3>Inlining sequence references in SQL</h3>
							<p>
								You can inline sequence references in jOOQ SQL statements. The following are examples of how to do that:
							</p>

</html><java><![CDATA[// Reference the sequence in a SELECT statement:
BigInteger nextID = create.select(s).fetchOne(S_AUTHOR_ID.nextval());

// Reference the sequence in an INSERT statement:
create.insertInto(AUTHOR, AUTHOR.ID, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .values(S_AUTHOR_ID.nextval(), val("William"), val("Shakespeare"));
]]></java><html>

							<p>
								For more info about inlining sequence references in SQL statements, please refer to the manual's section about <reference id="sequences-and-serials" title="sequences and serials"/>.
							</p>
						</html></content>
					</section>

				    <section id="stored-procedures">
						<title>Stored procedures and functions</title>
						<content><html>
							<p>
								Many RDBMS support the concept of "routines", usually calling them procedures and/or functions. These concepts have been around in programming languages for a while, also outside of databases. Famous languages distinguishing procedures from functions are:
							</p>
							<ul>
								<li>Ada</li>
								<li>BASIC</li>
								<li>Pascal</li>
								<li>etc...</li>
							</ul>
							<p>
								The general distinction between (stored) procedures and (stored) functions can be summarised like this:
							</p>

							<h3>Procedures</h3>
							<ul>
								<li>Are called using JDBC CallableStatement</li>
								<li>Have no return value</li>
								<li>Usually support OUT parameters</li>
							</ul>

							<h3>Functions</h3>
							<ul>
								<li>Can be used in SQL statements</li>
								<li>Have a return value</li>
								<li>Usually don't support OUT parameters</li>
							</ul>

							<h3>Exceptions to these rules</h3>
							<ul>
								<li>DB2, H2, and HSQLDB don't allow for JDBC escape syntax when calling functions. Functions must be used in a SELECT statement</li>
								<li>H2 only knows functions (without OUT parameters)</li>
								<li>Oracle functions may have OUT parameters</li>
								<li>Oracle knows functions that must not be used in SQL statements for transactional reasons</li>
								<li>Postgres only knows functions (with all features combined). OUT parameters can also be interpreted as return values, which is quite elegant/surprising, depending on your taste</li>
								<li>The Sybase jconn3 JDBC driver doesn't handle null values correctly when using the JDBC escape syntax on functions</li>
							</ul>
							<p>
								In general, it can be said that the field of routines (procedures / functions) is far from being standardised in modern RDBMS even if the SQL:2008 standard specifies things quite well. Every database has its ways and JDBC only provides little abstraction over the great variety of procedures / functions implementations, especially when advanced data types such as cursors / UDT's / arrays are involved.
							</p>
							<p>
								To simplify things a little bit, jOOQ handles both procedures and functions the same way, using a more general <reference class="org.jooq.Routine"/> type.
							</p>

							<h3>Using jOOQ for standalone calls to stored procedures and functions</h3>
							<p>
								If you're using jOOQ's <reference id="code-generation" title="code generator"/>, it will generate <reference class="org.jooq.Routine"/> objects for you. Let's consider the following example:
							</p>

</html><sql><![CDATA[-- Check whether there is an author in AUTHOR by that name and get his ID
CREATE OR REPLACE PROCEDURE author_exists (author_name VARCHAR2, result OUT NUMBER, id OUT NUMBER);]]></sql><html>

							<p>
								The generated artefacts can then be used as follows:
							</p>

</html><java><![CDATA[// Make an explicit call to the generated procedure object:
AuthorExists procedure = new AuthorExists();

// All IN and IN OUT parameters generate setters
procedure.setAuthorName("Paulo");
procedure.execute(configuration);

// All OUT and IN OUT parameters generate getters
assertEquals(new BigDecimal("1"), procedure.getResult());
assertEquals(new BigDecimal("2"), procedure.getId();]]></java><html>

							<p>
								But you can also call the procedure using a generated convenience method in a global Routines class:
							</p>

</html><java><![CDATA[// The generated Routines class contains static methods for every procedure.
// Results are also returned in a generated object, holding getters for every OUT or IN OUT parameter.
AuthorExists procedure = Routines.authorExists(configuration, "Paulo");

// All OUT and IN OUT parameters generate getters
assertEquals(new BigDecimal("1"), procedure.getResult());
assertEquals(new BigDecimal("2"), procedure.getId();]]></java><html>

							<p>
								For more details about <reference id="code-generation" title="code generation"/> for procedures, see the manual's section about <reference id="codegen-procedures" title="procedures and code generation"/>.
							</p>

							<h3>Inlining stored function references in SQL</h3>
							<p>
								Unlike procedures, functions can be inlined in SQL statements to generate <reference id="column-expressions" title="column expressions"/> or <reference id="table-expressions" title="table expressions"/>, if you're using <reference id="array-and-cursor-unnesting" title="unnesting operators"/>. Assume you have a function like this:
							</p>

</html><sql><![CDATA[-- Check whether there is an author in AUTHOR by that name and get his ID
CREATE OR REPLACE FUNCTION author_exists (author_name VARCHAR2) RETURN NUMBER;]]></sql><html>

							<p>
								The generated artefacts can then be used as follows:
							</p>

</html><code-pair>
<sql><![CDATA[-- This is the rendered SQL

SELECT AUTHOR_EXISTS('Paulo') FROM DUAL]]></sql><java><![CDATA[// Use the static-imported method from Routines:
boolean exists =
create.select(authorExists("Paulo")).fetchOne(0, boolean.class);]]></java>
</code-pair><html>

							<p>
								For more info about inlining stored function references in SQL statements, please refer to the manual's section about <reference id="user-defined-functions" title="user-defined functions"/>.
							</p>
						</html></content>

						<sections>
							<section id="oracle-packages">
								<title>Oracle Packages</title>
								<content><html>
									<p>
										Oracle uses the concept of a PACKAGE to group several procedures/functions into a sort of namespace. The <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" title="SQL 92 standard">SQL 92 standard</a> talks about "modules", to represent this concept, even if this is rarely implemented as such. This is reflected in jOOQ by the use of Java sub-packages in the <reference id="code-generation" title="source code generation"/> destination package. Every Oracle package will be reflected by
									</p>
									<ul>
										<li>A Java package holding classes for formal Java representations of the procedure/function in that package</li>
										<li>A Java class holding convenience methods to facilitate calling those procedures/functions</li>
									</ul>
									<p>
										Apart from this, the generated source code looks exactly like the one for standalone procedures/functions.
									</p>
									<p>
										For more details about <reference id="code-generation" title="code generation"/> for procedures and packages see the manual's section about <reference id="codegen-procedures" title="procedures and code generation"/>.
									</p>
								</html></content>
							</section>

							<section id="oracle-member-procedures">
								<title>Oracle member procedures</title>
								<content><html>
									<p>
										Oracle UDTs can have object-oriented structures including member functions and procedures. With Oracle, you can do things like this:
									</p>

</html><sql><![CDATA[CREATE OR REPLACE TYPE u_author_type AS OBJECT (
  id NUMBER(7),
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),

  MEMBER PROCEDURE LOAD,
  MEMBER FUNCTION counBOOKs RETURN NUMBER
)

-- The type body is omitted for the example]]></sql><html>

									<p>
										These member functions and procedures can simply be mapped to Java methods:
									</p>

</html><java><![CDATA[// Create an empty, attached UDT record from the Factory
UAuthorType author = create.newRecord(U_AUTHOR_TYPE);

// Set the author ID and load the record using the LOAD procedure
author.setId(1);
author.load();

// The record is now updated with the LOAD implementation's content
assertNotNull(author.getFirstName());
assertNotNull(author.getLastName());]]></java><html>

									<p>
										For more details about <reference id="code-generation" title="code generation"/> for UDTs see the manual's section about <reference id="codegen-udts" title="user-defined types and code generation"/>.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

				    <section id="exporting">
						<title>Exporting to XML, CSV, JSON, HTML, Text</title>
						<content><html>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's exporting functionality (see also the <reference id="importing" title="importing functionality"/>). You can export any Result&lt;Record&gt; into the formats discussed in the subsequent chapters of the manual
							</p>
						</html></content>

						<sections>
							<section id="exporting-xml">
								<title>Exporting XML</title>
								<content><java>// Fetch books and format them as XML
String xml = create.selectFrom(BOOK).fetch().formatXML();</java><html>

									<p>
										The above query will result in an XML document looking like the following one:
									</p>

</html><xml><![CDATA[<result xmlns="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">
  <fields>
    <field name="ID"/>
    <field name="AUTHOR_ID"/>
    <field name="TITLE"/>
  </fields>
  <records>
    <record>
      <value field="ID">1</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">1984</value>
    </record>
    <record>
      <value field="ID">2</value>
      <value field="AUTHOR_ID">1</value>
      <value field="TITLE">Animal Farm</value>
    </record>
  </records>
</result>]]></xml><html>

									<p>
										The same result as an <reference class="org.w3c.dom.Document"/> can be obtained using the Result.intoXML() method:
									</p>


</html><java>// Fetch books and format them as XML
Document xml = create.selectFrom(BOOK).fetch().intoXML();</java><html>

									<p>
										See the XSD schema definition here, for a formal definition of the XML export format:<br/>
										<a href="http://www.jooq.org/xsd/jooq-export-1.6.2.xsd">http://www.jooq.org/xsd/jooq-export-1.6.2.xsd</a>
									</p>
								</html></content>
							</section>

							<section id="exporting-csv">
								<title>Exporting CSV</title>
								<content><java>// Fetch books and format them as CSV
String csv = create.selectFrom(BOOK).fetch().formatCSV();</java><html>

									<p>
										The above query will result in a CSV document looking like the following one:
									</p>

</html><text>ID,AUTHOR_ID,TITLE
1,1,1984
2,1,Animal Farm</text><html>

									<p>
										In addition to the standard behaviour, you can also specify a separator character, as well as a special string to represent NULL values (which cannot be represented in standard CSV):
									</p>

</html><java>// Use ";" as the separator character
String csv = create.selectFrom(BOOK).fetch().formatCSV(';');

// Specify "{null}" as a representation for NULL values
String csv = create.selectFrom(BOOK).fetch().formatCSV(';', "{null}");</java></content>
							</section>

							<section id="exporting-json">
								<title>Exporting JSON</title>
								<content><java>// Fetch books and format them as JSON
String json = create.selectFrom(BOOK).fetch().formatJSON();</java><html>

									<p>
										The above query will result in a JSON document looking like the following one:
									</p>

</html><text>{fields:["ID","AUTHOR_ID","TITLE"],
 records:[[1,1,"1984"],[2,1,"Animal Farm"]]}</text></content>
							</section>

							<section id="exporting-html">
								<title>Exporting HTML</title>
								<content><java>// Fetch books and format them as HTML
String html = create.selectFrom(BOOK).fetch().formatHTML();</java><html>

									<p>
										The above query will result in an HTML document looking like the following one
									</p>

</html><xml><![CDATA[<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>AUTHOR_ID</th>
      <th>TITLE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1984</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>Animal Farm</td>
    </tr>
  </tbody>
</table>]]></xml></content>
							</section>

							<section id="exporting-text">
								<title>Exporting Text</title>
								<content><java>// Fetch books and format them as text
String text = create.selectFrom(BOOK).fetch().format();</java><html>

									<p>
										The above query will result in a text document looking like the following one
									</p>

</html><text>+---+---------+-----------+
| ID|AUTHOR_ID|TITLE      |
+---+---------+-----------+
|  1|        1|1984       |
|  2|        1|Animal Farm|
+---+---------+-----------+</text><html>

									<p>
										A simple text representation can also be obtained by calling toString() on a Result object. See also the manual's section about <reference id="logging" title="DEBUG logging"/>
									</p>
								</html></content>
							</section>
						</sections>
					</section>

				    <section id="importing">
						<title>Importing data</title>
						<content><html>
							<p>
								If you are using jOOQ for scripting purposes or in a slim, unlayered application server, you might be interested in using jOOQ's importing functionality (see also exporting functionality). You can import data directly into a table from the formats described in the subsequent sections of this manual.
							</p>
						</html></content>

						<sections>
							<section id="importing-csv">
								<title>Importing CSV</title>
								<content><html>

									<p>
										The below CSV data represents two author records that may have been exported previously, by jOOQ's <reference id="exporting" title="exporting functionality"/>, and then modified in Microsoft Excel or any other spreadsheet tool:
									</p>

</html><text><![CDATA[ID,AUTHOR_ID,TITLE <-- Note the CSV header. By default, the first line is ignored
1,1,1984
2,1,Animal Farm]]></text><html>

									<p>
										With jOOQ, you can load this data using various parameters from the	loader API. A simple load may look like this:
									</p>

</html><java>Factory create = new Factory(connection, dialect);

// Load data into the AUTHOR table from an input stream
// holding the CSV data.
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, AUTHOR_ID, TITLE)
      .execute();</java><html>

      								<p>
      									Here are various other examples:
   									</p>

</html><java>// Ignore the AUTHOR_ID column from the CSV file when inserting
create.loadInto(AUTHOR)
      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour for duplicate records.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onDuplicateKeyUpdate()
      .onDuplicateKeyIgnore()
      .onDuplicateKeyError() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify behaviour when errors occur.
create.loadInto(AUTHOR)

      // choose any of these methods
      .onErrorIgnore()
      .onErrorAbort() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();

// Specify transactional behaviour where this is possible
// (e.g. not in container-managed transactions)
create.loadInto(AUTHOR)

      // choose any of these methods
      .commitEach()
      .commitAfter(10)
      .commitAll()
      .commitNone() // the default

      .loadCSV(inputstream)
      .fields(ID, null, TITLE)
      .execute();</java><html>

									<p>
										Any of the above configuration methods can be combined to achieve the type of load you need. Please refer to the API's Javadoc to learn about more details. Errors that occur during the load are reported by the execute method's result:
									</p>

</html><java><![CDATA[Loader<Author> loader = /* .. */ .execute();

// The number of processed rows
int processed = loader.processed();

// The number of stored rows (INSERT or UPDATE)
int stored = loader.stored();

// The number of ignored rows (due to errors, or duplicate rule)
int ignored = loader.ignored();

// The errors that may have occurred during loading
List<LoaderError> errors = loader.errors();
LoaderError error = errors.get(0);

// The exception that caused the error
DataAccessException exception = error.exception();

// The row that caused the error
int rowIndex = error.rowIndex();
String[] row = error.row();

// The query that caused the error
Query query = error.query();]]></java></content>
							</section>

							<section id="importing-xml">
								<title>Importing XML</title>
								<content><html>
									<p>This is not yet supported</p>
								</html></content>
							</section>
						</sections>
					</section>

				    <section id="crud-with-updatablerecords">
						<title>CRUD with UpdatableRecords</title>
						<content><html>
							<p>
								Your database application probably consists of 50% - 80% CRUD, whereas only the remaining 20% - 50% of querying is actual querying. Most often, you will operate on records of tables without using any advanced relational concepts. This is called CRUD for
							</p>
							<ul>
								<li>Create (<reference id="insert-statement" title="INSERT"/>)</li>
								<li>Read (<reference id="select-statement" title="SELECT"/>)</li>
								<li>Update (<reference id="update-statement" title="UPDATE"/>)</li>
								<li>Delete (<reference id="delete-statement" title="DELETE"/>)</li>
							</ul>
							<p>
								CRUD always uses the same patterns, regardless of the nature of underlying tables. This again, leads to a lot of boilerplate code, if you have to issue your statements yourself. Like Hibernate / JPA and other ORMs, jOOQ facilitates CRUD using a specific API involving <reference class="org.jooq.UpdatableRecord"/> types.
							</p>

							<h3>Primary keys and updatability</h3>
							<p>
								In normalised databases, every table has a primary key by which a tuple/record within that table can be uniquely identified. In simple cases, this is a (possibly auto-generated) number called ID. But in many cases, primary keys include several non-numeric columns. An important feature of such keys is the fact that in most databases, they are enforced using an index that allows for very fast random access to the table. A typical way to access / modify / delete a book is this:
							</p>

</html><sql><![CDATA[-- Inserting uses a previously generated key value or generates it afresh
INSERT INTO BOOK (ID, TITLE) VALUES (5, 'Animal Farm');

-- Other operations can use a previously generated key value
SELECT * FROM BOOK WHERE ID = 5;
UPDATE BOOK SET TITLE = '1984' WHERE ID = 5;
DELETE FROM BOOK WHERE ID = 5;]]></sql><html>

							<p>
								Normalised databases assume that a primary key is unique "forever", i.e. that a key, once inserted into a table, will never be changed or re-inserted after deletion. In order to use jOOQ's <reference id="simple-crud" title="CRUD"/> operations correctly, you should design your database accordingly.
							</p>

							<h3>Main UNIQUE keys</h3>
							<p>
								In SQL, a primary key is always also a unique key. In fact, unique keys have very similar properties as primary keys. For instance, they can be referenced from other tables' foreign keys in most databases. In the absence of a formal primary key, jOOQ assumes that the first unique key it encounters will serve as a primary key substitute. This is called the "main key" in jOOQ. In other words, a main key is:
							</p>
							<ul>
								<li>The primary key, if available</li>
								<li>The first unique key, otherwise</li>
							</ul>

							<p>
								For simplicity, the term "primary key" will be used in the sense of such a "main unique key" in this manual.
							</p>
						</html></content>

						<sections>
							<section id="simple-crud">
								<title>Simple CRUD</title>
								<content><html>
									<p>
										If you're using jOOQ's <reference id="code-generation" title="code generator"/>, it will generate <reference class="org.jooq.UpdatableRecord"/> implementations for every table that has a primary key. When <reference id="fetching" title="fetching"/> such a record form the database, these records are "attached" to the <reference id="factory" title="Factory" /> that created them. This means that they hold an internal reference to the same database connection that was used to fetch them. This connection is used internally by any of the following methods of the UpdatableRecord:
									</p>

</html><java><![CDATA[// Refresh a record from the database.
void refresh() throws DataAccessException;

// Store (insert or update) a record to the database.
int store() throws DataAccessException;

// Delete a record from the database
int delete() throws DataAccessException;]]></java><html>

									<p>
										See the manual's section about <reference id="serializability" title="serializability"/> for some more insight on "attached" objects.
									</p>

									<h3>Storing</h3>
									<p>
										Storing a record will perform an <reference id="insert-statement" title="INSERT statement"/> or an <reference id="update-statement" title="UPDATE statement"/>. In general, new records are always inserted, whereas records loaded from the database are always updated. This is best visualised in code:
									</p>

</html><java><![CDATA[// Create a new record
BookRecord book1 = create.newRecord(BOOK);

// Insert the record: INSERT INTO BOOK (TITLE) VALUES ('1984');
book1.setTitle("1984");
book1.store();

// Update the record: UPDATE BOOK SET PUBLISHED_IN = 1984 WHERE ID = [id]
book1.setPublishedIn(1948);
book1.store();

// Get the (possibly) auto-generated ID from the record
Integer id = book1.getId();

// Get another instance of the same book
BookRecord book2 = create.fetchOne(BOOK, BOOK.ID.equal(id));

// Update the record: UPDATE BOOK SET TITLE = 'Animal Farm' WHERE ID = [id]
book2.setTitle("Animal Farm");
book2.store();]]></java><html>

									<p>
										Some remarks about storing:
									</p>
									<ul>
										<li>jOOQ sets only modified values in <reference id="insert-statement" title="INSERT statements"/> or <reference id="update-statement" title="UPDATE statements"/>. This allows for default values to be applied to inserted records, as specified in CREATE TABLE DDL statements.</li>
										<li>When store() performs an <reference id="insert-statement" title="INSERT statement"/>, jOOQ attempts to load any generated keys from the database back into the record. For more details, see the manual's section about <reference id="identity-values" title="IDENTITY values"/>.</li>
										<li>When loading records from <reference id="pojos" title="POJOs"/>, jOOQ will assume the record is a new record. It will hence attempt to INSERT it.</li>
										<li>When you activate <reference id="optimistic-locking" title="optimistic locking"/>, storing a record may fail, if the underlying database record has been changed in the mean time.</li>
									</ul>

									<h3>Deleting</h3>
									<p>
										Deleting a record will remove it from the database. Here's how you delete records:
									</p>

</html><java><![CDATA[// Get a previously inserted book
BookRecord book = create.fetchOne(BOOK, BOOK.ID.equal(5));

// Delete the book
book.delete();]]></java><html>

									<h3>Refreshing</h3>
									<p>
										Refreshing a record from the database means that jOOQ will issue a <reference id="select-statement" title="SELECT statement"/> to refresh all record values that are not the primary key. This is particularly useful when you use jOOQ's <reference id="optimistic-locking" title="optimistic locking"/> feature, in case a modified record is "stale" and cannot be stored to the database, because the underlying database record has changed in the mean time.
									</p>
									<p>
										In order to perform a refresh, use the following Java code:
									</p>

</html><java><![CDATA[// Fetch an updatable record from the database
BookRecord book = create.fetchOne(BOOK, BOOK.ID.equal(5));

// Refresh the record
book.refresh();]]></java><html>

									<h3>CRUD and SELECT statements</h3>
									<p>
										CRUD operations can be combined with regular querying, if you select records from single database tables, as explained in the manual's section about <reference id="select-statement" title="SELECT statements"/>. For this, you will need to use the selectFrom() method from the <reference id="factory" title="Factory"/>:
									</p>

</html><java><![CDATA[// Loop over records returned from a SELECT statement
for (BookRecord book : create.fetch(BOOK, BOOK.PUBLISHED_IN.equal(1948))) {

  // Perform actions on BookRecords depending on some conditions
  if ("Orwell".equals(book.fetchAuthorByAuthorId().getLastName())) {
    book.delete();
  }
}]]></java></content>
							</section>

							<section id="identity-values">
								<title>IDENTITY values</title>
								<content><html>
									<p>
										Many databases support the concept of IDENTITY values, or <reference id="sequence-execution" title="SEQUENCE-generated"/> key values. This is reflected by JDBC's <reference class="java.sql.Statement" anchor="#getGeneratedKeys()" title="getGeneratedKeys()"/> method. jOOQ abstracts using this method as many databases and JDBC drivers behave differently with respect to generated keys. Let's assume the following SQL Server BOOK table:
									</p>

</html><sql><![CDATA[CREATE TABLE book (
  ID INTEGER IDENTITY(1,1) NOT NULL,

  -- [...]

  CONSTRAINT pk_book PRIMARY KEY (id)
)]]></sql><html>

									<p>
										If you're using jOOQ's <reference id="code-generation" title="code generator"/>, the above table will generate a <reference class="org.jooq.UpdatableRecord"/> with an IDENTITY column. This information is used by jOOQ internally, to update IDs after calling <reference id="crud-with-updatablerecords" title="store()"/>:
									</p>

</html><java><![CDATA[BookRecord book = create.newRecord(BOOK);
book.setTitle("1984");
book.store();

// The generated ID value is fetched after the above INSERT statement
System.out.println(book.getId());]]></java><html>

									<h3>Database compatibility</h3>
									<p>
										<strong>DB2, Derby, HSQLDB, Ingres</strong>
									</p>
									<p>
										These SQL dialects implement the standard very neatly.
									</p>
</html><sql><![CDATA[id INTEGER GENERATED BY DEFAULT AS IDENTITY
id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1)]]></sql><html>

									<p>
										<strong>H2, MySQL, Postgres, SQL Server, Sybase ASE, Sybase SQL Anywhere</strong>
									</p>
									<p>
										These SQL dialects implement identites, but the DDL syntax doesnt follow the standard
									</p>
</html><sql><![CDATA[-- H2 mimicks MySQL's and SQL Server's syntax
ID INTEGER IDENTITY(1,1)
ID INTEGER AUTO_INCREMENT
-- MySQL and SQLite
ID INTEGER NOT NULL AUTO_INCREMENT

-- Postgres serials implicitly create a sequence
-- Postgres also allows for selecting from custom sequences
-- That way, sequences can be shared among tables
id SERIAL NOT NULL

-- SQL Server
ID INTEGER IDENTITY(1,1) NOT NULL
-- Sybase ASE
id INTEGER IDENTITY NOT NULL
-- Sybase SQL Anywhere
id INTEGER NOT NULL IDENTITY]]></sql><html>

									<p>
										<strong>Oracle</strong>
									</p>
									<p>
										Oracle does not know any identity columns at all. Instead, you will have to use a trigger and update the ID column yourself, using a custom sequence. Something along these lines:
									</p>
</html><sql><![CDATA[CREATE OR REPLACE TRIGGER my_trigger
BEFORE INSERT
ON my_table
REFERENCING NEW AS new
FOR EACH ROW
BEGIN
  SELECT my_sequence.nextval
  INTO :new.id
  FROM dual;
END my_trigger;]]></sql><html>

									<p>
										Note, that this approach can be employed in most databases supporting sequences and triggers! It is a lot more flexible than standard identities
									</p>
								</html></content>
							</section>

							<section id="navigation-methods">
								<title>Navigation methods</title>
								<content><html>
									<p>
										When using jOOQ's <reference id="code-generation" title="code generator"/> along with its <reference id="codegen-records" title="record generation capabilities"/>, generated records can have navigation methods contained in them, if properly <reference id="codegen-advanced" title="configured"/>. These navigation methods allow for "navigating" inbound or outbound foreign key references by executing an appropriate query. An example is given here:
									</p>

</html><code-pair>
<sql><![CDATA[CREATE TABLE book (
  AUTHOR_ID NUMBER(7) NOT NULL,

  -- [...]

  FOREIGN KEY (AUTHOR_ID) REFERENCES author(ID)
)]]></sql><java><![CDATA[BookRecord book = create.fetch(BOOK, BOOK.ID.equal(5));

// Find the author of a book
AuthorRecord author = book.fetchAuthor();

// Find other books by that author
List<BookRecord> books = author.fetchBookList();]]></java>
</code-pair><html>

									<p>
										These methods are safe for use with several foreign keys referencing the same tables:
									</p>

</html><code-pair>
<sql><![CDATA[CREATE TABLE book (
  AUTHOR_ID NUMBER(7) NOT NULL,
  CO_AUTHOR_ID NUMBER(7) NOT NULL,

  -- [...]

  FOREIGN KEY (AUTHOR_ID) REFERENCES author(ID),
  FOREIGN KEY (CO_AUTHOR_ID) REFERENCES author(ID)
)]]></sql><java><![CDATA[BookRecord book = create.fetch(BOOK, BOOK.ID.equal(5));

// Find the author of a book
AuthorRecord author   = book.fetchAuthorByAuthorId();
AuthorRecord coAuthor = book.fetchAuthorByCoAuthorId();

// Find other books by those authors
List<BookRecord> books = author.fetchBookListByAuthorId();
List<BookRecord> books = coAuthor.fetchBookListByCoAuthorId();]]></java>
</code-pair><html>

									<p>
										Note that, unlike in Hibernate, jOOQ's generated navigation methods will always lazy-fetch relevant records, without caching any results. In other words, every time you run such a fetch method, a new query will be issued.
									</p>
									<p>
										These fetch methods only work on "attached" records. See the manual's section about <reference id="serializability" title="serializability"/> for some more insight on "attached" objects.
									</p>
								</html></content>
							</section>

							<section id="non-updatable-records">
								<title>Non-updatable records</title>
								<content><html>
									<p>
										Tables without UNIQUE keys are considered non-updatable by jOOQ, as jOOQ has no way of uniquely identifying such a record within the database. If you're using jOOQ's <reference id="code-generation" title="code generator"/>, such tables will generate <reference class="org.jooq.TableRecord"/> classes, instead of <reference class="org.jooq.UpdatableRecord"/> classes. When you fetch <reference id="record-vs-tablerecord" title="typed records"/> from such a table, the returned records will not allow for calling any of the <reference id="crud-with-updatablerecords" title="store(), refresh(), delete()"/> methods.
									</p>

									<p>
										Note, that some databases use internal rowid or object-id values to identify such records. jOOQ does not support these vendor-specific record meta-data.
									</p>
								</html></content>
							</section>

							<section id="optimistic-locking">
								<title>Optimistic locking</title>
								<content><html>
									<p>
										jOOQ allows you to perform <reference id="crud-with-updatablerecords" title="CRUD"/> operations using optimistic locking. You can immediately take advantage of this feature by activating the relevant <reference id="custom-settings" title="executeWithOptimisticLocking Setting"/>. Without any further knowledge of the underlying data semantics, this will have the following impact on store() and delete() methods:
									</p>
									<ul>
										<li>INSERT statements are not affected by this Setting flag</li>
										<li>Prior to UPDATE or DELETE statements, jOOQ will run a <reference id="for-update-clause" title="SELECT .. FOR UPDATE"/> statement, pessimistically locking the record for the subsequent UPDATE / DELETE</li>
										<li>The data fetched with the previous SELECT will be compared against the data in the record being stored or deleted</li>
										<li>An <reference class="org.jooq.exception.DataChangedException"/> is thrown if the record had been modified in the mean time</li>
										<li>The record is successfully stored / deleted, if the record had not been modified in the mean time.</li>
									</ul>
									<p>
										The above changes to jOOQ's behaviour are transparent to the API, the only thing you need to do for it to be activated is to set the Settings flag. Here is an example illustrating optimistic locking:
									</p>

</html><java><![CDATA[// Properly configure the Factory
Factory optimistic = new Factory(connection, SQLDialect.ORACLE,
  new Settings().withExecuteWithOptimisticLocking(true));

// Fetch a book two times
BookRecord book1 = optimistic.fetch(BOOK, BOOK.ID.equal(5));
BookRecord book2 = optimistic.fetch(BOOK, BOOK.ID.equal(5));

// Change the title and store this book. The underlying database record has not been modified, it can be safely updated.
book1.setTitle("Animal Farm");
book1.store();

// Book2 still references the original TITLE value, but the database holds a new value from book1.store().
// This store() will thus fail:
book2.setTitle("1984");
book2.store();]]></java><html>

									<h3>Optimised optimistic locking using TIMESTAMP fields</h3>
									<p>
										If you're using jOOQ's <reference id="code-generation" title="code generator"/>, you can take indicate TIMESTAMP or UPDATE COUNTER fields for every generated table in the <reference id="codegen-advanced" title="code generation configuration"/>. Let's say we have this table:
									</p>

</html><sql><![CDATA[CREATE TABLE book (

  -- This column indicates when each book record was modified for the last time
  MODIFIED TIMESTAMP NOT NULL,
  -- [...]
)]]></sql><html>

									<p>
										The MODIFIED column will contain a timestamp indicating the last modification timestamp for any book in the BOOK table. If you're using jOOQ and it's <reference id="crud-with-updatablerecords" title="store() methods on UpdatableRecords"/>, jOOQ will then generate this TIMESTAMP value for you, automatically. However, instead of running an additional <reference id="for-update-clause" title="SELECT .. FOR UPDATE"/> statement prior to an UPDATE or DELETE statement, jOOQ adds a WHERE-clause to the UPDATE or DELETE statement, checking for TIMESTAMP's integrity. This can be best illustrated with an example:
									</p>

</html><java><![CDATA[// Properly configure the Factory
Factory optimistic = new Factory(connection, SQLDialect.ORACLE,
  new Settings().withExecuteWithOptimisticLocking(true));

// Fetch a book two times
BookRecord book1 = optimistic.fetch(BOOK, BOOK.ID.equal(5));
BookRecord book2 = optimistic.fetch(BOOK, BOOK.ID.equal(5));

// Change the title and store this book. The MODIFIED value has not been changed since the book was fetched.
// It can be safely updated
book1.setTitle("Animal Farm");
book1.store();

// Book2 still references the original MODIFIED value, but the database holds a new value from book1.store().
// This store() will thus fail:
book2.setTitle("1984");
book2.store();]]></java><html>

									<p>
										As before, without the added TIMESTAMP column, optimistic locking is transparent to the API.
									</p>

									<h3>Optimised optimistic locking using VERSION fields</h3>
									<p>
										Instead of using TIMESTAMPs, you may also use numeric VERSION fields, containing version numbers that are incremented by jOOQ upon store() calls.
									</p>

									<p>
										Note, for explicit pessimistic locking, please consider the manual's section about the <reference id="for-update-clause" title="FOR UPDATE clause"/>. For more details about how to configure TIMESTAMP or VERSION fields, consider the manual's section about <reference id="codegen-advanced" title="advanced code generator configuration"/>.
									</p>
								</html></content>
							</section>

							<section id="batch-execution-for-crud">
								<title>Batch execution</title>
								<content><html>
									<p>
										When inserting, updating, deleting a lot of records, you may wish to profit from JDBC batch operations, which can be performed by jOOQ. These are available through jOOQ's <reference id="factory" title="Factory"/> as shown in the following example:
									</p>

</html><java><![CDATA[// Fetch a bunch of books
List<BookRecord> books = create.fetch(BOOK);

// Modify the above books, and add some new ones:
modify(books);
addMore(books);

// Batch-update and/or insert all of the above books
create.batchStore(books);]]></java><html>

									<p>
										Internally, jOOQ will render all the required SQL statements and execute them as a regular <reference id="batch-execution" title="JDBC batch execution"/>.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

				    <section id="daos">
						<title>DAOs</title>
						<content><html>
							<p>
								If you're using jOOQ's <reference id="code-generation" title="code generator"/>, you can configure it to generate <reference id="pojos" title="POJOs" /> and DAOs for you. jOOQ then generates one DAO per <reference id="crud-with-updatablerecords" title="UpdatableRecord"/>, i.e. per table with a single-column primary key. Generated DAOs implement a common jOOQ type called <reference class="org.jooq.DAO"/>. This type contains the following methods:
							</p>

</html><java><![CDATA[// <R> corresponds to the DAO's related table
// <P> corresponds to the DAO's related generated POJO type
// <T> corresponds to the DAO's related table's primary key type.
// Note that multi-column primary keys are not yet supported by DAOs
public interface DAO<R extends TableRecord<R>, P, T> {

    // These methods allow for inserting POJOs
    void insert(P object) throws DataAccessException;
    void insert(P... objects) throws DataAccessException;
    void insert(Collection<P> objects) throws DataAccessException;

    // These methods allow for updating POJOs based on their primary key
    void update(P object) throws DataAccessException;
    void update(P... objects) throws DataAccessException;
    void update(Collection<P> objects) throws DataAccessException;

    // These methods allow for deleting POJOs based on their primary key
    void delete(P... objects) throws DataAccessException;
    void delete(Collection<P> objects) throws DataAccessException;
    void deleteById(T... ids) throws DataAccessException;
    void deleteById(Collection<T> ids) throws DataAccessException;

    // These methods allow for checking record existence
    boolean exists(P object) throws DataAccessException;
    boolean existsById(T id) throws DataAccessException;
    long count() throws DataAccessException;

    // These methods allow for retrieving POJOs by primary key or by some other field
    List<P> findAll() throws DataAccessException;
    P findById(T id) throws DataAccessException;
    <Z> List<P> fetch(Field<Z> field, Z... values) throws DataAccessException;
    <Z> P fetchOne(Field<Z> field, Z value) throws DataAccessException;

    // These methods provide DAO meta-information
    Table<R> getTable();
    Class<P> getType();
}]]></java><html>

							<p>
								Besides these base methods, generated DAO classes implement various useful fetch methods. An incomplete example is given here, for the BOOK table:
							</p>

</html><java><![CDATA[// An example generated BookDao class
public class BookDao extends DAOImpl<BookRecord, Book, Integer> {

    // Columns with primary / unique keys produce fetchOne() methods
    public Book fetchOneById(Integer value) { ... }

    // Other columns produce fetch() methods, returning several records
    public List<Book> fetchByAuthorId(Integer... values) { ... }
    public List<Book> fetchByTitle(String... values) { ... }
}]]></java><html>
							<p>
								Note that you can further subtype those pre-generated DAO classes, to add more useful DAO methods to them. Using such a DAO is simple:
							</p>

</html><java><![CDATA[// Initialise a Factory
Factory create = new Factory(connection, SQLDialect.ORACLE);

// Initialise the DAO with the Factory
BookDao bookDao = new BookDao(create);

// Start using the DAO
Book book = bookDao.findById(5);

// Modify and update the POJO
book.setTitle("1984");
book.setPublishedIn(1948);
bookDao.update(book);

// Delete it again
bookDao.delete(book);]]></java></content>
					</section>

				    <section id="exception-handling">
						<title>Exception handling</title>
						<content><html>
							<h3>Checked vs. unchecked exceptions</h3>
							<p>
								This is an eternal and religious debate. Pros and cons have been discussed time and again, and it still is a matter of taste, today. In this case, jOOQ clearly takes a side. jOOQ's exception strategy is simple:
							</p>
							<ul>
								<li>All "system exceptions" are unchecked. If in the middle of a transaction involving business logic, there is no way that you can recover sensibly from a lost database connection, or a constraint violation that indicates a bug in your understanding of your database model.</li>
								<li>All "business exceptions" are checked. Business exceptions are true exceptions that you should handle (e.g. not enough funds to complete a transaction).</li>
							</ul>
							<p>
								With jOOQ, it's simple. All of jOOQ's exceptions are "system exceptions", hence they are all unchecked.
							</p>

							<h3>jOOQ's DataAccessException</h3>
							<p>
								jOOQ uses its own <reference class="org.jooq.exception.DataAccessException"/> to wrap any underlying <reference class="java.sql.SQLException"/> that might have occurred. Note that all methods in jOOQ that may cause such a DataAccessException document this both in the Javadoc as well as in their method signature.
							</p>
							<p>
								DataAccessException is subtyped several times as follows:
							</p>
							<ul>
								<li><strong>DataAccessException</strong>: General exception usually originating from a <reference class="java.sql.SQLException"/></li>
								<li><strong>DataChangedException</strong>: An exception indicating that the database's underlying record has been changed in the mean time (see <reference id="optimistic-locking" title="optimistic locking"/>)</li>
								<li><strong>DataTypeException</strong>: Something went wrong during type conversion</li>
								<li><strong>DetachedException</strong>: A SQL statement was executed on a "detached" <reference id="crud-with-updatablerecords" title="UpdatableRecord"/> or a "detached" <reference id="sql-statements" title="SQL statement"/>.</li>
								<li><strong>InvalidResultException</strong>: An operation was performed expecting only one result, but several results were returned.</li>
								<li><strong>MappingException</strong>: Something went wrong when loading a record from a <reference id="pojos" title="POJO"/> or when mapping a record into a POJO</li>
							</ul>

							<h3>Override jOOQ's exception handling</h3>
							<p>
								The following section about <reference id="execute-listeners" title="execute listeners"/> documents means of overriding jOOQ's exception handling, if you wish to deal separately with some types of constraint violations, or if you raise business errors from your database, etc.
							</p>
						</html></content>
					</section>

				    <section id="execute-listeners">
						<title>ExecuteListeners</title>
						<content><html>
							<p>
								The <reference id="custom-settings" title="jOOQ Factory Settings"/> let you specify a list of <reference class="org.jooq.ExecuteListener"/> classes. The ExecuteListener is essentially an event listener for Query, Routine, or ResultSet render, prepare, bind, execute, fetch steps. It is a base type for loggers, debuggers, profilers, data collectors, triggers, etc. Advanced ExecuteListeners can also provide custom implementations of Connection, PreparedStatement and ResultSet to jOOQ in apropriate methods.
							</p>
							<p>
								For convenience and better backwards-compatibility, consider extending <reference class="org.jooq.impl.DefaultExecuteListener"/> instead of implementing this interface.
							</p>
							<p>
								Here is a sample implementation of an ExecuteListener, that is simply counting the number of queries per type that are being executed using jOOQ:
							</p>

</html><java><![CDATA[package com.example;

// Extending DefaultExecuteListener, which provides empty implementations for all methods...
public class StatisticsListener extends DefaultExecuteListener {
    public static Map<ExecuteType, Integer> STATISTICS = new HashMap<ExecuteType, Integer>();

    // Count "start" events for every type of query executed by jOOQ
    @Override
    public void start(ExecuteContext ctx) {
        synchronized (STATISTICS) {
            Integer count = STATISTICS.get(ctx.type());

            if (count == null) {
                count = 0;
            }

            STATISTICS.put(ctx.type(), count + 1);
        }
    }
}]]></java><html>

							<p>
								Now, configure jOOQ's runtime to load your listener
							</p>

</html><xml><![CDATA[<settings>
  <executeListeners>
    <executeListener>com.example.StatisticsListener</executeListener>
  </executeListeners>
</settings>]]></xml><html>

							<p>
								And log results any time with a snippet like this:
							</p>

</html><java><![CDATA[log.info("STATISTICS");
log.info("----------");

for (ExecuteType type : ExecuteType.values()) {
    log.info(type.name(), StatisticsListener.STATISTICS.get(type) + " executions");
}]]></java><html>
                            <p>
                            	This may result in the following log output:
                            </p>

</html><config>15:16:52,982  INFO - TEST STATISTICS
15:16:52,982  INFO - ---------------
15:16:52,983  INFO - READ                     : 919 executions
15:16:52,983  INFO - WRITE                    : 117 executions
15:16:52,983  INFO - DDL                      : 2 executions
15:16:52,983  INFO - BATCH                    : 4 executions
15:16:52,983  INFO - ROUTINE                  : 21 executions
15:16:52,983  INFO - OTHER                    : 30 executions</config><html>

							<p>
								Please read the <reference class="org.jooq.ExecuteListener" title="ExecuteListener Javadoc"/> for more details
							</p>
							<p>
								See also the manual's sections about <reference id="logging" title="logging"/> and the <reference id="jooq-console" title="jOOQ Console"/> for more sample implementations of actual ExecuteListeners.
							</p>
						</html></content>
					</section>

				    <section id="logging">
						<title>Logging</title>
						<content><html>
							<p>
								jOOQ logs all SQL queries and fetched result sets to its internal DEBUG logger, which is implemented as an <reference id="execute-listeners" title="execute listener"/>. By default, execute logging is activated in the <reference id="custom-settings" title="jOOQ Factory Settings"/>. In order to see any DEBUG log output, put either log4j or slf4j on jOOQ's classpath along with their respective configuration. A sample log4j configuration can be seen here:
							</p>

</html><xml><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<log4j:configuration>
    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%m%n" />
        </layout>
    </appender>

    <root>
        <priority value="debug" />
        <appender-ref ref="stdout" />
    </root>
</log4j:configuration>]]></xml><html>

							<p>
								With the above configuration, let's fetch some data with jOOQ
							</p>

</html><java><![CDATA[// Using H2, this time
create.select(BOOK.ID, BOOK.TITLE).from(BOOK).orderBy(BOOK.ID).limit(1, 2).fetch();]]></java><html>

							<p>
								The above query may result in the following log output:
							</p>

</html><text><![CDATA[Executing query          : select "BOOK"."ID", "BOOK"."TITLE" from "BOOK" order by "BOOK"."ID" asc, limit ? offset ?
-> with bind values      : select "BOOK"."ID", "BOOK"."TITLE" from "BOOK" order by "BOOK"."ID" asc, limit 2 offset 1
Query executed           : Total: 1.439ms
Fetched result           : +----+------------+
                         : |  ID|TITLE       |
                         : +----+------------+
                         : |   2|Animal Farm |
                         : |   3|O Alquimista|
                         : +----+------------+
Finishing                : Total: 4.814ms, +3.375ms
]]></text><html>

							<p>
								Essentially, jOOQ will log
							</p>
							<ul>
								<li>The SQL statement as rendered to the prepared statement</li>
								<li>The SQL statement with inlined bind values (for improved debugging)</li>
								<li>The query execution time</li>
								<li>The first 5 records of the result. This is formatted using <reference id="exporting-text" title="jOOQ's text export"/></li>
								<li>The total execution + fetching time</li>
							</ul>

							<p>
								If you wish to use your own logger (e.g. avoiding printing out sensitive data), you can deactivate jOOQ's logger using <reference id="custom-settings" title="your custom settings"/> and implement your own <reference id="execute-listeners" title="execute listener logger"/>.
							</p>
						</html></content>
					</section>

				    <section id="performance-considerations">
						<title>Performance considerations</title>
						<content><html>
							<p>
								Many users may have switched from higher-level abstractions such as Hibernate to jOOQ, because of Hibernate's hard-to-manage performance, when it comes to large database schemas and complex second-level caching strategies. jOOQ is not a lightweight database abstraction framework, and it comes with its own overhead. Please be sure to consider the following points:
							</p>
							<ul>
								<li>It takes some time to construct jOOQ queries. If you can reuse the same queries, you might cache them. Beware of thread-safety issues, though, as jOOQ's <reference id="factory" title="Factory"/> is not threadsafe, and queries are "attached" to their creating Factory</li>
								<li>It takes some time to render SQL strings. Internally, jOOQ reuses the same <reference class="java.lang.StringBuilder"/> for the complete query, but some rendering elements may take their time. You could, of course, cache SQL generated by jOOQ and prepare your own <reference class="java.sql.PreparedStatement"/> objects</li>
								<li>It takes some time to bind values to prepared statements. jOOQ does not keep any open prepared statements, internally. Use a sophisticated connection pool, that will cache prepared statements and inject them into jOOQ through the standard JDBC API</li>
								<li>It takes some time to fetch results. By default, jOOQ will always fetch the complete <reference class="java.sql.ResultSet"/> into memory. Use <reference id="lazy-fetching" title="lazy fetching"/> to prevent that, and scroll over an open underlying database cursor</li>
							</ul>

							<h3>Optimise wisely</h3>
							<p>
								Don't be put off by the above paragraphs. You should optimise wisely, i.e. only in places where you really need very high throughput to your database. jOOQ's overhead compared to plain JDBC is typically less than 1ms per query.
							</p>
						</html></content>
					</section>
				</sections>
			</section>

			<section id="code-generation">
				<title>Code generation</title>
				<content><html>
					<p>
						While optional, source code generation is one of jOOQ's main assets if you wish to increase developer productivity. jOOQ's code generator takes your database schema and reverse-engineers it into a set of Java classes modelling <reference id="table-expressions" title="tables"/>, <reference id="record-vs-tablerecord" title="records"/>, <reference id="sequence-execution" title="sequences"/>, <reference id="pojos" title="POJOs"/>, <reference id="daos" title="DAOs"/>, <reference id="stored-procedures" title="stored procedures"/>, user-defined types and many more.
					</p>
					<p>
						The essential ideas behind source code generation are these:
					</p>
					<ul>
						<li><strong>Increased IDE support</strong>: Type your Java code directly against your database schema, with all type information available</li>
						<li><strong>Type-safety</strong>: When your database schema changes, your generated code will change as well. Removing columns will lead to compilation errors, which you can detect early.</li>
					</ul>
					<p>
						The following chapters will show how to configure the code generator and how to generate various artefacts.
					</p>
				</html></content>

				<sections>
				    <section id="codegen-configuration">
						<title>Configuration and setup of the generator</title>
						<content><html>
							<p>
								There are three binaries available with jOOQ, to be downloaded from <a href="http://www.jooq.org/download" title="jOOQ download">http://www.jooq.org/download</a> or from Maven central:
							</p>
							<ul>
								<li>
									<strong>jooq-{jooq-version}.jar</strong>
									<br />
									The main library that you will include in your application to run jOOQ
								</li>
								<li>
									<strong>jooq-meta-{jooq-version}.jar</strong>
									<br />
									The utility that you will include in your build to navigate your database schema for code generation. This can be used as a schema crawler as well.
								</li>
								<li>
									<strong>jooq-codegen-{jooq-version}.jar</strong>
									<br />
									The utility that you will include in your build to generate your database schema
								</li>
							</ul>

							<h3>Configure jOOQ's code generator</h3>
							<p>
								You need to tell jOOQ some things about your database connection. Here's an example of how to do it for an Oracle database
							</p>

</html><xml><![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<configuration>
  <!-- Configure the database connection here -->
  <jdbc>
    <driver>oracle.jdbc.OracleDriver</driver>
    <url>jdbc:oracle:thin:@[your jdbc connection parameters]</url>
    <user>[your database user]</user>
    <password>[your database password]</password>

    <!-- You can also pass user/password and other JDBC properties in the optional properties tag: -->
    <properties>
      <property><key>user</key><value>[db-user]</value></property>
      <property><key>password</key><value>[db-password]</value></property>
    </properties>
  </jdbc>

  <generator>
    <database>
      <!-- The database dialect from jooq-meta. Available dialects are
           named org.util.[database].[database]Database. Known values are:

           org.jooq.util.ase.ASEDatabase (to be used with Sybase ASE)
           org.jooq.util.cubrid.CUBRIDDatabase
           org.jooq.util.db2.DB2Database
           org.jooq.util.derby.DerbyDatabase
           org.jooq.util.h2.H2Database
           org.jooq.util.hsqldb.HSQLDBDatabase
           org.jooq.util.ingres.IngresDatabase
           org.jooq.util.mysql.MySQLDatabase
           org.jooq.util.oracle.OracleDatabase
           org.jooq.util.postgres.PostgresDatabase
           org.jooq.util.sqlite.SQLiteDatabase
           org.jooq.util.sqlserver.SQLServerDatabase
           org.jooq.util.sybase.SybaseDatabase (to be used with Sybase SQL Anywhere)

           You can also provide your own org.jooq.util.Database implementation
           here, if your database is currently not supported or if you wish to
           read the database schema from a file, such as a Hibernate .hbm.xml file -->
      <name>org.jooq.util.oracle.OracleDatabase</name>

      <!-- All elements that are generated from your schema (several Java
           regular expressions, separated by comma) Watch out for
           case-sensitivity. Depending on your database, this might be
           important! You can create case-insensitive regular expressions
           using this syntax: (?i:expr)A comma-separated list of regular
           expressions -->
      <includes>.*</includes>

      <!-- All elements that are excluded from your schema (several Java
           regular expressions, separated by comma). Excludes match before
           includes -->
      <excludes></excludes>

      <!-- The schema that is used locally as a source for meta information.
           This could be your development schema or the production schema, etc
           This cannot be combined with the schemata element.

           If left empty, jOOQ will generate all available schemata. See the
           manual's next section to learn how to generate several schemata -->
      <inputSchema>[your database schema / owner / name]</inputSchema>
    </database>

    <generate>
      <!-- Generation flags: See advanced configuration properties -->
    </generate>

    <target>
      <!-- The destination package of your generated classes (within the
           destination directory) -->
      <packageName>[org.jooq.your.packagename]</packageName>

      <!-- The destination directory of your generated classes -->
      <directory>[/path/to/your/dir]</directory>
    </target>
  </generator>
</configuration>]]></xml><html>

							<p>
								There are also lots of advanced configuration parameters, which will be treated in the <reference id="codegen-advanced" title="manual's section about advanced code generation features"/> Note, you can find the official XSD file for a formal specification at:<br/>
							    <a href="http://www.jooq.org/xsd/jooq-codegen-2.5.0.xsd" title="The jOOQ-codegen configuration XSD">http://www.jooq.org/xsd/jooq-codegen-2.5.0.xsd</a>
						    </p>

							<h3>Run jOOQ code generation</h3>
							<p>
								Code generation works by calling this class with the above property file as argument.
							</p>

</html><config>org.jooq.util.GenerationTool /jooq-config.xml</config><html>

							<p>
								Be sure that these elements are located on the classpath:
							</p>

							<ul>
								<li>The XML configuration file</li>
								<li>jooq-{jooq-version}.jar, jooq-meta-{jooq-version}.jar, jooq-codegen-{jooq-version}.jar</li>
								<li>The JDBC driver you configured</li>
							</ul>

							<h3>A command-line example (For Windows, unix/linux/etc will be similar)</h3>
							<ul>
								<li>Put the property file, jooq*.jar and the JDBC driver into a directory, e.g. C:\temp\jooq</li>
							    <li>Go to C:\temp\jooq</li>
							    <li>Run java -cp jooq-{jooq-version}.jar;jooq-meta-{jooq-version}.jar;jooq-codegen-{jooq-version}.jar;[JDBC-driver].jar;. org.jooq.util.GenerationTool /[XML file] </li>
							</ul>
							<p>
								Note that the property file must be passed as a classpath resource
							</p>

							<h3>Run code generation from Eclipse</h3>
							<p>
								Of course, you can also run code generation from your IDE. In Eclipse, set up a project like this. Note that this example uses jOOQ's log4j support by adding log4j.xml and log4j.jar to the project classpath:
							</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-01.png" alt="Eclipse configuration"/>
							</div>

							<p>
								Once the project is set up correctly with all required artefacts on the classpath, you can configure an Eclipse Run Configuration for org.jooq.util.GenerationTool.
							</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-02.png" alt="Eclipse configuration"/>
							</div>

							<p>
								With the XML file as an argument
							</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-03.png" alt="Eclipse configuration"/>
							</div>

							<p>
								And the classpath set up correctly
							</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-04.png" alt="Eclipse configuration"/>
							</div>

							<p>
								Finally, run the code generation and see your generated artefacts
							</p>
							<div class="screenshot">
							<img class="screenshot" src="&lt;?=$root?&gt;/img/eclipse-example-05.png" alt="Eclipse configuration"/>
							</div>

							<h3>Run generation with ant</h3>
							<p>
								You can also use an ant task to generate your classes. As a rule of thumb, remove the dots "." and dashes "-" from the .properties file's property names to get the ant task's arguments:
							</p>

</html><xml><![CDATA[<!-- Task definition -->
<taskdef name="generate-classes" classname="org.jooq.util.GenerationTask">
  <classpath>
    <fileset dir="${path.to.jooq.distribution}">
      <include name="jooq-{jooq-version}.jar"/>
      <include name="jooq-meta-{jooq-version}.jar"/>
      <include name="jooq-codegen-{jooq-version}.jar"/>
    </fileset>
    <fileset dir="${path.to.mysql.driver}">
      <include name="${mysql.driver}.jar"/>
    </fileset>
  </classpath>
</taskdef>

<!-- Run the code generation task -->
<target name="generate-test-classes">
  <generate-classes
      jdbcurl="jdbc:mysql://localhost/test"
      jdbcuser="root"
      jdbcpassword=""
      generatordatabaseinputschema="test"
      generatortargetpackage="org.jooq.test.generatedclasses"
      generatortargetdirectory="${basedir}/src"/>
</target>]]></xml><html>

							<p>
								Note that when running code generation with ant's &lt;java/&gt; task, you may have to set fork="true":
							</p>

</html><xml><![CDATA[<!-- Run the code generation task -->
<target name="generate-test-classes">
  <java fork="true" classname="org.jooq.util.GenerationTool">
    [...]
  </java>
</target>
]]></xml><html>

							<h3>Integrate generation with Maven</h3>
							<p>
								Using the official jOOQ-codegen-maven plugin, you can integrate source code generation in your Maven build process:
							</p>

</html><xml><![CDATA[<plugin>

  <!-- Specify the maven code generator plugin -->
  <groupId>org.jooq</groupId>
  <artifactId>jooq-codegen-maven</artifactId>
  <version>{jooq-version}</version>

  <!-- The plugin should hook into the generate goal -->
  <executions>
    <execution>
      <goals>
        <goal>generate</goal>
      </goals>
    </execution>
  </executions>

  <!-- Manage the plugin's dependency. In this example, we'll use a PostgreSQL database -->
  <dependencies>
    <dependency>
      <groupId>postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>8.4-702.jdbc4</version>
    </dependency>
  </dependencies>

  <!-- Specify the plugin configuration.
       The configuration format is the same as for the standalone code generator -->
  <configuration>

    <!-- JDBC connection parameters -->
    <jdbc>
      <driver>org.postgresql.Driver</driver>
      <url>jdbc:postgresql:postgres</url>
      <user>postgres</user>
      <password>test</password>
    </jdbc>

    <!-- Generator parameters -->
    <generator>
      <name>org.jooq.util.DefaultGenerator</name>
      <database>
        <name>org.jooq.util.postgres.PostgresDatabase</name>
        <includes>.*</includes>
        <excludes></excludes>
        <inputSchema>public</inputSchema>
      </database>
      <target>
        <packageName>org.jooq.util.maven.example</packageName>
        <directory>target/generated-sources/jooq</directory>
      </target>
    </generator>
  </configuration>
</plugin>
]]></xml><html>

                            <h3>Migrate properties files from jOOQ 1.7, early versions of jOOQ 2.0.x:</h3>
                            <p>
                                Before jOOQ 2.0.4, the code generator was configured using properties files. These files are still supported for source code generation, but their syntax won't be maintained any longer. If you wish to migrate to XML, you can migrate the file using this command on the command line
                            </p>

</html><config>org.jooq.util.GenerationTool /jooq-config.properties migrate</config><html>

							<p>
								Using the migrate flag, jOOQ will read the properties file and output a corresponding XML file on system out
							</p>

							<h3>Use jOOQ generated classes in your application</h3>
							<p>
								Be sure, both jooq-{jooq-version}.jar and your generated package (see configuration) are located on your classpath. Once this is done, you can execute SQL statements with your generated classes.
							</p>
						</html></content>
					</section>

				    <section id="codegen-advanced">
						<title>Advanced generator configuration</title>
						<content><html>
							<p>
								In the <reference id="codegen-configuration" title="previous section"/> we have seen how jOOQ's source code generator is configured and run within a few steps. In this chapter we'll cover some advanced settings
							</p>

</html><xml><![CDATA[<!-- These properties can be added directly to the generator element: -->
<generator>
  <!-- The default code generator. You can override this one, to generate your own code style
       Defaults to org.jooq.util.DefaultGenerator -->
  <name>org.jooq.util.DefaultGenerator</name>

  <!-- The naming strategy used for class and field names.
       You may override this with your custom naming strategy. Some examples follow
       Defaults to org.jooq.util.DefaultGeneratorStrategy -->
  <strategy>
    <name>org.jooq.util.DefaultGeneratorStrategy</name>
  </strategy>
</generator>]]></xml><html>

							<p>
								The following example shows how you can override the DefaultGeneratorStrategy to render table and column names the way they are defined in the database, rather than switching them to camel case:
							</p>

</html><java><![CDATA[/**
 * It is recommended that you extend the DefaultGeneratorStrategy. Most of the
 * GeneratorStrategy API is already declared final. You only need to override any
 * of the following methods, for whatever generation behaviour you'd like to achieve
 *
 * Beware that most methods also receive a "Mode" object, to tell you whether a
 * TableDefinition is being rendered as a Table, Record, POJO, etc. Depending on
 * that information, you can add a suffix only for TableRecords, not for Tables
 */
public class AsInDatabaseStrategy extends DefaultGeneratorStrategy {

    /**
     * Override this to specifiy what identifiers in Java should look like.
     * This will just take the identifier as defined in the database.
     */
    @Override
    public String getJavaIdentifier(Definition definition) {
        return definition.getOutputName();
    }

    /**
     * Override these to specify what a setter in Java should look like. Setters
     * are used in TableRecords, UDTRecords, and POJOs. This example will name
     * setters "set[NAME_IN_DATABASE]"
     */
    @Override
    public String getJavaSetterName(Definition definition, Mode mode) {
        return "set" + definition.getOutputName();
    }

    /**
     * Just like setters...
     */
    @Override
    public String getJavaGetterName(Definition definition, Mode mode) {
        return "get" + definition.getOutputName();
    }

    /**
     * Override this method to define what a Java method generated from a database
     * Definition should look like. This is used mostly for convenience methods
     * when calling stored procedures and functions. This example shows how to
     * set a prefix to a CamelCase version of your procedure
     */
    @Override
    public String getJavaMethodName(Definition definition, Mode mode) {
        return "call" + org.jooq.tools.StringUtils.toCamelCase(definition.getOutputName());
    }

    /**
     * Override this method to define how your Java classes and Java files should
     * be named. This example applies no custom setting and uses CamelCase versions
     * instead
     */
    @Override
    public String getJavaClassName(Definition definition, Mode mode) {
        return super.getJavaClassName(definition, mode);
    }

    /**
     * Override this method to re-define the package names of your generated
     * artefacts.
     */
    @Override
    public String getJavaPackageName(Definition definition, Mode mode) {
        return super.getJavaPackageName(definition, mode);
    }

    /**
     * Override this method to define how Java members should be named. This is
     * used for POJOs and method arguments
     */
    @Override
    public String getJavaMemberName(Definition definition, Mode mode) {
        return definition.getOutputName();
    }

    /**
     * Override this method to define the base class for those artefacts that
     * allow for custom base classes
     */
    @Override
    public String getJavaClassExtends(Definition definition, Mode mode) {
        return Object.class.getName();
    }

    /**
     * Override this method to define the interfaces to be implemented by those
     * artefacts that allow for custom interface implementation
     */
    @Override
    public List<String> getJavaClassImplements(Definition definition, Mode mode) {
        return Arrays.asList(Serializable.class.getName(), Cloneable.class.getName());
    }

    /**
     * Override this method to define the suffix to apply to routines when
     * they are overloaded.
     *
     * Use this to resolve compile-time conflicts in generated source code, in
     * case you make heavy use of procedure overloading
     */
    @Override
    public String getOverloadSuffix(Definition definition, Mode mode, String overloadIndex) {
        return "_OverloadIndex_" + overloadIndex;
    }
}]]></java><html>

                            <h3>jooq-meta configuration</h3>
							<p>
								Within the &lt;generator/&gt; element, there are other configuration elements:
							</p>

</html><xml><![CDATA[<!-- These properties can be added to the database element: -->
<database>

  <!-- All table and view columns that are used as "version" fields for
       optimistic locking (several Java regular expressions, separated by comma).
       See UpdatableRecord.store() and UpdatableRecord.delete() for details -->
  <recordVersionFields>REC_VERSION</recordVersionFields/>

  <!-- All table and view columns that are used as "timestamp" fields for
       optimistic locking (several Java regular expressions, separated by comma).
       See UpdatableRecord.store() and UpdatableRecord.delete() for details -->
  <recordTimestampFields>REC_TIMESTAMP</recordTimestampFields/>

  <!-- Generate java.sql.Timestamp fields for DATE columns. This is
       particularly useful for Oracle databases.
       Defaults to false -->
  <dateAsTimestamp>false</dateAsTimestamp>

  <!-- Generate jOOU data types for your unsigned data types, which are
       not natively supported in Java.
       Defaults to true -->
  <unsignedTypes>true</unsignedTypes>

  <!-- The schema that is used in generated source code. This will be the
       production schema. Use this to override your local development
       schema name for source code generation. If not specified, this
       will be the same as the input-schema. -->
  <outputSchema>[your database schema / owner / name]</outputSchema>

  <!-- A configuration element to configure several input and/or output
       schemata for jooq-meta, in case you're using jooq-meta in a multi-
       schema environment.
       This cannot be combined with the above inputSchema / outputSchema -->
  <schemata>
    <schema>
      <inputSchema>...</inputSchema>
      <outputSchema>...</outputSchema>
    </schema>
    [ <schema>...</schema> ... ]
  </schemata>

  <!-- A configuration element to configure master data table enum classes -->
  <masterDataTables>...</masterDataTables>

  <!-- A configuration element to configure custom data types -->
  <customTypes>...</customTypes>

  <!-- A configuration element to configure type overrides for generated
       artefacts (e.g. in combination with customTypes) -->
  <forcedTypes>...</forcedTypes>
</database>]]></xml><html>

							<p>
								Check out the some of the manual's "advanced" sections to find out more about the advanced configuration parameters.
							</p>
							<ul>
								<li><reference id="schema-mapping" title="Schema mapping"/></li>
								<li><reference id="master-data-types" title="Master data types"/></li>
								<li><reference id="custom-data-types" title="Custom types"/></li>
							</ul>

							<h3>jooq-codegen configuration</h3>
                            <p>
                            	Also, you can add some optional advanced configuration parameters for the generator:
                           	</p>

</html><xml><![CDATA[<!-- These properties can be added to the generate element: -->
<generate>
  <!-- Primary key / foreign key relations should be generated and used.
       This is a prerequisite for various advanced features.
       Defaults to true -->
  <relations>true</relations>

  <!-- Generate navigation methods to navigate foreign key relationships
       directly from Record classes. This is only relevant if relations
       is set to true, too.
       Defaults to true -->
  <navigationMethods>true</navigationMethods>

  <!-- Generate deprecated code for backwards compatibility
       Defaults to true -->
  <deprecated>true</deprecated>

  <!-- Generate instance fields in your tables, as opposed to static
       fields. This simplifies aliasing.
       Defaults to true -->
  <instanceFields>true</instanceFields>

  <!-- Generate the javax.annotation.Generated annotation to indicate
       jOOQ version used for source code.
       Defaults to true -->
  <generatedAnnotation>true</generatedAnnotation>

  <!-- Generate jOOQ Record classes for type-safe querying. You can
       turn this off, if you don't need "active records" for CRUD
       Defaults to true -->
  <records>true</records>

  <!-- Generate POJOs in addition to Record classes for usage of the
       ResultQuery.fetchInto(Class) API
       Defaults to false -->
  <pojos>false</pojos>

  <!-- Generate immutable POJOs for usage of the ResultQuery.fetchInto(Class) API
       This overrides any value set in <pojos/>
       Defaults to false -->
  <immutablePojos>false</immutablePojos>

  <!-- Generate interfaces that will be implemented by records and/or pojos.
       You can also use these interfaces in Record.into(Class<?>) and similar
       methods, to let jOOQ return proxy objects for them.
       Defaults to false -->
  <interfaces>false</interfaces>

  <!-- Generate DAOs in addition to POJO classes
       Defaults to false -->
  <daos>false</daos>

  <!-- Annotate POJOs and Records with JPA annotations for increased
       compatibility and better integration with JPA/Hibernate, etc
       Defaults to false -->
  <jpaAnnotations>false</jpaAnnotations>

  <!-- Annotate POJOs and Records with JSR-303 validation annotations
       Defaults to false -->
  <validationAnnotations>false</validationAnnotations>
</generate>]]></xml></content>
					</section>

				    <section id="codegen-globals">
						<title>Generated global artefacts</title>
						<content><html>
							<p>
								For increased convenience at the use-site, jOOQ generates "global" artefacts at the code generation root location, referencing tables, routines, sequences, etc. In detail, these global artefacts include the following:
							</p>
							<ul>
								<li><strong>Keys.java</strong>: This file contains all of the required primary key, unique key, foreign key and identity references in the form of static members of type <reference class="org.jooq.Key"/>.</li>
								<li><strong>Routines.java</strong>: This file contains all standalone routines (not in packages) in the form of static factory methods for <reference class="org.jooq.Routine"/> types.</li>
								<li><strong>Sequences.java</strong>: This file contains all sequence objects in the form of static members of type <reference class="org.jooq.Sequence"/>.</li>
								<li><strong>Tables.java</strong>: This file contains all table objects in the form of static member references to the actual singleton <reference class="org.jooq.Table"/> object</li>
								<li><strong>UDTs.java</strong>: This file contains all UDT objects in the form of static member references to the actual singleton <reference class="org.jooq.UDT"/> object</li>
							</ul>

							<h3>Referencing global artefacts</h3>
							<p>
								When referencing global artefacts from your client application, you would typically static import them as such:
							</p>

</html><java><![CDATA[// Static imports for all global artefacts (if they exist)
import static com.example.generated.Keys.*;
import static com.example.generated.Routines.*;
import static com.example.generated.Sequences.*;
import static com.example.generated.Tables.*;

// You could then reference your artefacts as follows:
create.insertInto(MY_TABLE)
      .values(MY_SEQUENCE.nextval(), myFunction())

// as a more concise form of this:
create.insertInto(com.example.generated.Tables.MY_TABLE)
      .values(com.example.generated.Sequences.MY_SEQUENCE.nextval(), com.example.generated.Routines.myFunction())]]></java></content>
					</section>

				    <section id="codegen-tables">
						<title>Generated tables</title>
						<content><html>
							<p>
								Every table in your database will generate a <reference class="org.jooq.Table"/> implementation that looks like this:
							</p>

</html><java><![CDATA[public class Book extends UpdatableTableImpl<BookRecord> {

    // The singleton instance
    public static final Book BOOK = new Book();

    // Generated columns
    public final TableField<BookRecord, Integer> ID        = createField("ID",        SQLDataType.INTEGER, this);
    public final TableField<BookRecord, Integer> AUTHOR_ID = createField("AUTHOR_ID", SQLDataType.INTEGER, this);
    public final TableField<BookRecord, String>  ITLE      = createField("TITLE",     SQLDataType.VARCHAR, this);

    // Covariant aliasing method, returning a table of the same type as BOOK
    @Override
    public Book as(java.lang.String alias) {
        return new Book(alias);
    }

    // [...]
}]]></java><html>

							<h3>Flags influencing generated tables</h3>
							<p>
								These flags from the <reference id="codegen-advanced" title="code generation configuration"/> influence generated tables:
							</p>
							<ul>
								<li><strong>recordVersionFields</strong>: Relevant methods from super classes are overridden to return the VERSION field</li>
								<li><strong>recordTimestampFields</strong>: Relevant methods from super classes are overridden to return the TIMESTAMP field</li>
								<li><strong>dateAsTimestamp</strong>: This influences all relevant columns</li>
								<li><strong>unsignedTypes</strong>: This influences all relevant columns</li>
								<li><strong>relations</strong>: Relevant methods from super classes are overridden to provide primary key, unique key, foreign key and identity information</li>
								<li><strong>instanceFields</strong>: This flag controls the "static" keyword on table columns, as well as aliasing convenience</li>
								<li><strong>records</strong>: The generated record type is referenced from tables allowing for type-safe single-table record fetching</li>
							</ul>

							<h3>Flags controlling table generation</h3>
							<p>
								Table generation cannot be deactivated
							</p>
						</html></content>
					</section>

				    <section id="codegen-records">
						<title>Generated records</title>
						<content><html>
							<p>
								Every table in your database will generate an <reference class="org.jooq.Record"/> implementation that looks like this:
							</p>

</html><java><![CDATA[// JPA annotations can be generated, optionally
@Entity
@Table(name = "BOOK", schema = "TEST")
public class BookRecord extends UpdatableRecordImpl<BookRecord>

// An interface common to records and pojos can be generated, optionally
implements IBook {

    // Every column generates a setter and a getter
    @Override
    public void setId(Integer value) {
        setValue(BOOK.ID, value);
    }

    @Id
    @Column(name = "ID", unique = true, nullable = false, precision = 7)
    @Override
    public Integer getId() {
        return getValue(BOOK.ID);
    }

    // More setters and getters
    public void setAuthorId(Integer value) {...}
    public Integer getAuthorId() {...}

    // Convenience methods for foreign key methods
    public void setAuthorId(AuthorRecord value) {
        if (value == null) {
            setValue(BOOK.AUTHOR_ID, null);
        }
        else {
            setValue(BOOK.AUTHOR_ID, value.getValue(AUTHOR.ID));
        }
    }

    // Navigation methods
    public AuthorRecord fetchAuthor() {
        return create.selectFrom(AUTHOR).where(AUTHOR.ID.equal(getValue(BOOK.AUTHOR_ID))).fetchOne();
    }

    // [...]
}]]></java><html>

							<h3>Flags influencing generated records</h3>
							<p>
								These flags from the <reference id="codegen-advanced" title="code generation configuration"/> influence generated records:
							</p>
							<ul>
								<li><strong>dateAsTimestamp</strong>: This influences all relevant getters and setters</li>
								<li><strong>unsignedTypes</strong>: This influences all relevant getters and setters</li>
								<li><strong>relations</strong>: This is needed as a prerequisite for navigation methods</li>
								<li><strong>navigationMethods</strong>: This controls whether navigation methods will be generated or not</li>
								<li><strong>daos</strong>: Records are a pre-requisite for DAOs. If DAOs are generated, records are generated as well</li>
								<li><strong>interfaces</strong>: If interfaces are generated, records will implement them</li>
								<li><strong>jpaAnnotations</strong>: JPA annotations are used on generated records</li>
							</ul>

							<h3>Flags controlling record generation</h3>
							<p>
								Record generation can be deactivated using the <strong>records</strong> flag
							</p>
						</html></content>
					</section>

				    <section id="codegen-pojos">
						<title>Generated POJOs</title>
						<content><html>
							<p>
								Every table in your database will generate a POJO implementation that looks like this:
							</p>

</html><java><![CDATA[// JPA annotations can be generated, optionally
@javax.persistence.Entity
@javax.persistence.Table(name = "BOOK", schema = "TEST")
public class Book implements java.io.Serializable

// An interface common to records and pojos can be generated, optionally
, IBook {

    // JSR-303 annotations can be generated, optionally
    @NotNull
    private Integer id;

    @NotNull
    private Integer authorId;

    @NotNull
    @Size(max = 400)
    private String title;

    // Every column generates a getter and a setter
    @Id
    @Column(name = "ID", unique = true, nullable = false, precision = 7)
    @Override
    public Integer getId() {
        return this.id;
    }

    @Override
    public void setId(Integer id) {
        this.id = id;
    }

    // [...]
}]]></java><html>

							<h3>Flags influencing generated POJOs</h3>
							<p>
								These flags from the <reference id="codegen-advanced" title="code generation configuration"/> influence generated POJOs:
							</p>
							<ul>
								<li><strong>dateAsTimestamp</strong>: This influences all relevant getters and setters</li>
								<li><strong>unsignedTypes</strong>: This influences all relevant getters and setters</li>
								<li><strong>interfaces</strong>: If interfaces are generated, POJOs will implement them</li>
								<li><strong>immutablePojos</strong>: Immutable POJOs have final members and no setters. All members must be passed to the constructor</li>
								<li><strong>daos</strong>: POJOs are a pre-requisite for DAOs. If DAOs are generated, POJOs are generated as well</li>
								<li><strong>jpaAnnotations</strong>: JPA annotations are used on generated records</li>
								<li><strong>validationAnnotations</strong>: JSR-303 validation annotations are used on generated records</li>
							</ul>

							<h3>Flags controlling POJO generation</h3>
							<p>
								POJO generation can be activated using the <strong>pojos</strong> flag
							</p>
						</html></content>
					</section>

				    <section id="codegen-interfaces">
						<title>Generated Interfaces</title>
						<content><html>
							<p>
								Every table in your database will generate an interface that looks like this:
							</p>

</html><java><![CDATA[public interface IBook extends java.io.Serializable {

    // Every column generates a getter and a setter
    public void setId(Integer value);
    public Integer getId();

    // [...]
}]]></java><html>

							<h3>Flags influencing generated interfaces</h3>
							<p>
								These flags from the <reference id="codegen-advanced" title="code generation configuration"/> influence generated interfaces:
							</p>
							<ul>
								<li><strong>dateAsTimestamp</strong>: This influences all relevant getters and setters</li>
								<li><strong>unsignedTypes</strong>: This influences all relevant getters and setters</li>
							</ul>

							<h3>Flags controlling POJO generation</h3>
							<p>
								POJO generation can be activated using the <strong>interfaces</strong> flag
							</p>
						</html></content>
					</section>

				    <section id="codegen-daos">
						<title>Generated DAOs</title>
						<content><html>
							<h3>Generated DAOs</h3>
							<p>
								Every table in your database will generate a <reference class="org.jooq.DAO"/> implementation that looks like this:
							</p>

</html><java><![CDATA[public class BookDao extends DAOImpl<BookRecord, Book, Integer> {

    // Generated constructors
    public BookDao() {
        super(BOOK, Book.class);
    }

    public BookDao(Factory factory) {
        super(BOOK, Book.class, factory);
    }

    // Every column generates at least one fetch method
    public List<Book> fetchById(Integer... values) {
        return fetch(BOOK.ID, values);
    }

    public Book fetchOneById(Integer value) {
        return fetchOne(BOOK.ID, value);
    }

    public List<Book> fetchByAuthorId(Integer... values) {
        return fetch(BOOK.AUTHOR_ID, values);
    }

    // [...]
}]]></java><html>

							<h3>Flags controlling DAO generation</h3>
							<p>
								DAO generation can be activated using the <strong>daos</strong> flag
							</p>
						</html></content>
					</section>

				    <section id="codegen-sequences">
						<title>Generated sequences</title>
						<content><html>
							<p>
								Every sequence in your database will generate a <reference class="org.jooq.Sequence"/> implementation that looks like this:
							</p>

</html><java><![CDATA[public final class Sequences {

    // Every sequence generates a member
    public static final Sequence<Integer> S_AUTHOR_ID = new SequenceImpl<Integer>("S_AUTHOR_ID", TEST, SQLDataType.INTEGER);
}]]></java><html>

							<h3>Flags controlling sequence generation</h3>
							<p>
								Sequence generation cannot be deactivated
							</p>
						</html></content>
					</section>

				    <section id="codegen-procedures">
						<title>Generated procedures</title>
						<content><html>
							<p>
								Every procedure or function (routine) in your database will generate a <reference class="org.jooq.Routine"/> implementation that looks like this:
							</p>

</html><java><![CDATA[public class AuthorExists extends AbstractRoutine<java.lang.Void> {

    // All IN, IN OUT, OUT parameters and function return values generate a static member
    public static final Parameter<String>     AUTHOR_NAME = createParameter("AUTHOR_NAME", SQLDataType.VARCHAR);
    public static final Parameter<BigDecimal> RESULT      = createParameter("RESULT",      SQLDataType.NUMERIC);

    // A constructor for a new "empty" procedure call
    public AuthorExists() {
        super("AUTHOR_EXISTS", TEST);

        addInParameter(AUTHOR_NAME);
        addOutParameter(RESULT);
    }

    // Every IN and IN OUT parameter generates a setter
    public void setAuthorName(String value) {
        setValue(AUTHOR_NAME, value);
    }

    // Every IN OUT, OUT and RETURN_VALUE generates a getter
    public BigDecimal getResult() {
        return getValue(RESULT);
    }

    // [...]
}]]></java><html>

							<h3>Package and member procedures or functions</h3>
							<p>
								Procedures or functions contained in packages or UDTs are generated in a sub-package that corresponds to the package or UDT name.
							</p>

							<h3>Flags controlling routine generation</h3>
							<p>
								Routine generation cannot be deactivated
							</p>
						</html></content>
					</section>

				    <section id="codegen-udts">
						<title>Generated UDTs</title>
						<content><html>
							<p>
								Every UDT in your database will generate a <reference class="org.jooq.UDT"/> implementation that looks like this:
							</p>

</html><java><![CDATA[public class AddressType extends UDTImpl<AddressTypeRecord> {

    // The singleton UDT instance
    public static final UAddressType U_ADDRESS_TYPE = new UAddressType();

    // Every UDT attribute generates a static member
    public static final UDTField<AddressTypeRecord, String> ZIP     =
      createField("ZIP",     SQLDataType.VARCHAR, U_ADDRESS_TYPE);
    public static final UDTField<AddressTypeRecord, String> CITY    =
      createField("CITY",    SQLDataType.VARCHAR, U_ADDRESS_TYPE);
    public static final UDTField<AddressTypeRecord, String> COUNTRY =
      createField("COUNTRY", SQLDataType.VARCHAR, U_ADDRESS_TYPE);

    // [...]
}]]></java><html>

							<p>
								Besides the <reference class="org.jooq.UDT"/> implementation, a <reference class="org.jooq.UDTRecord"/> implementation is also generated
							</p>

</html><java><![CDATA[public class AddressTypeRecord extends UDTRecordImpl<AddressTypeRecord> {

    // Every attribute generates a getter and a setter

    public void setZip(String value) {...}
    public String getZip() {...}
    public void setCity(String value) {...}
    public String getCity() {...}
    public void setCountry(String value) {...}
    public String getCountry() {...}

    // [...]
}]]></java><html>

							<h3>Flags controlling UDT generation</h3>
							<p>
								UDT generation cannot be deactivated
							</p>
						</html></content>
					</section>

				    <section id="master-data-types">
						<title>Master data and enumeration tables</title>
						<content><html>
							<p>
								<strong>NOTE</strong>: This feature is deprecated in jOOQ 2.5.0 and will be removed as of jOOQ 3.0
							</p>
							<p>
								Only MySQL and Postgres databases support true ENUM types natively. Some other RDBMS allow you to map the concept of an ENUM data type to a CHECK constraint, but those constraints can contain arbitrary SQL. With jOOQ, you can "emulate" ENUM types by declaring a table as a "master data table" in the configuration. At code-generation time, this table will be treated specially, and a Java enum type is generated from its data.
							</p>

							<h3>Configure master data tables</h3>
							<p>
								As previously discussed, you can configure master data tables as follows:
							</p>

</html><xml><![CDATA[<!-- These properties can be added to the database element: -->
<database>
  <masterDataTables>
    <masterDataTable>
      <!-- The name of a master data table -->
      <name>[a table name]</name>

      <!-- The column used for enum literals -->
      <literal>[a column name]</literal>

      <!-- The column used for documentation -->
      <description>[a column name]</description>
    </masterDataTable>

    [ <masterDataTable>...</masterDataTable> ... ]
  </masterDataTables>
 </database>]]></xml><html>

							<p>
								The results of this will be a Java enum that looks similar to this:
							</p>

</html><java><![CDATA[public enum Language implements MasterDataType<Integer> {

  /**
   * English
   */
  en(1, "en", "English"),

  /**
   * Deutsch
   */
  de(2, "de", "Deutsch"),

  /**
   * Franais
   */
  fr(3, "fr", "Franais"),

  /**
   * null
   */
  pt(4, "pt", null),
  ;

  private final Integer id;
  private final String cd;
  private final String description;

  // [ ... constructor and getters for the above properties ]
}]]></java><html>

							<p>
								In the above example, you can see how the configured primary key is mapped to the id member, the configured literal column is mapped to the cd member and the configured description member is mapped to the description member and output as Javadoc. In other words, LANGUAGE is a table with 4 rows and at least three columns.
							</p>

							<p>
								The general contract is that there must be
							</p>
							<ul>
								<li>A single-column primary key column of character or integer type</li>
								<li>An optional unique literal column of character or integer type (otherwise, the primary key is used as enum literal) </li>
								<li>An optional description column of any type </li>
							</ul>

							<h3>Using MasterDataTypes</h3>
							<p>
								The point of MasterDataTypes in jOOQ is that they behave exactly like true ENUM types. When the above LANGUAGE table is referenced by BOOK, instead of generating foreign key navigation methods and a LANGUAGE_ID Field&lt;Integer&gt;, a Field&lt;TLanguage&gt; is generated:
							</p>

</html><java><![CDATA[public class Book extends UpdatableTableImpl<BookRecord> {

  // [...]
  public static final TableField<BookRecord, Language> LANGUAGE_ID =
                  new TableFieldImpl<BookRecord, Language>( /* ... */ );
}]]></java><html>

							<p>
								Which can then be used in the BookRecord directly:
							</p>

</html><java><![CDATA[public class BookRecord extends UpdatableRecordImpl<BookRecord> {

  // [...]
  public Language getLanguageId() { // [...]
  public void setLanguageId(Language value) { // [...]
}]]></java><html>

							<h3>When to use MasterDataTypes</h3>
							<p>
								You can use master data types when you're actually mapping master data to a Java enum. When the underlying table changes frequently, those updates will not be reflected by the statically generated code. Also, be aware that it will be difficult to perform actual JOIN operations on the underlying table with jOOQ, once the master data type is generated.
							</p>
						</html></content>
					</section>

				    <section id="custom-data-types">
						<title>Custom data types and type conversion</title>
						<content><html>
							<p>
								When using a custom type in jOOQ, you need to let jOOQ know about its associated <reference class="org.jooq.Converter"/>. Ad-hoc usages of such converters has been discussed in the chapter about <reference id="data-type-conversion" title="data type conversion"/>. A more common use-case, however, is to let jOOQ know about custom types at code generation time. Use the following configuration elements to specify, that you'd like to use GregorianCalendar for all database fields that start with DATE_OF_
      						</p>

</html><xml><![CDATA[<database>
  <!-- First, register your custom types here -->
  <customTypes>
    <customType>
      <!-- Specify the fully-qualified class name of your custom type -->
      <name>java.util.GregorianCalendar</name>

      <!-- Associate that custom type with your converter. Note, a
           custom type can only have one converter in jOOQ -->
      <converter>com.example.CalendarConverter</converter>
    </customType>
  </customTypes>

  <!-- Then, associate custom types with database columns -->
  <forcedTypes>
    <forcedType>
      <!-- Specify again he fully-qualified class name of your custom type -->
      <name>java.util.GregorianCalendar</name>

      <!-- Add a list of comma-separated regular expressions matching columns -->
      <expressions>.*\.DATE_OF_.*</expressions>
    </forcedType>
  </forcedTypes>
</database>]]></xml><html>

                            <p>
                            	The above configuration will lead to AUTHOR.DATE_OF_BIRTH being generated like this:
                            </p>

</html><java><![CDATA[public class TAuthor extends UpdatableTableImpl<TAuthorRecord> {

    // [...]
    public final TableField<TAuthorRecord, GregorianCalendar> DATE_OF_BIRTH =    // [...]
    // [...]

}]]></java><html>

                            <p>
                            	This means that the bound type of &lt;T&gt; will be GregorianCalendar, wherever you reference DATE_OF_BIRTH. jOOQ will use your custom converter when binding variables and when fetching data from <reference class="java.util.ResultSet"/>:
                            </p>

</html><java><![CDATA[// Get all date of births of authors born after 1980
List<GregorianCalendar> result =
create.selectFrom(AUTHOR)
      .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
      .fetch(AUTHOR.DATE_OF_BIRTH);]]></java></content>
					</section>

				    <section id="schema-mapping">
						<title>Mapping generated schemata and tables</title>
						<content><html>
							<p>
								We've seen previously in the chapter about <reference id="runtime-schema-mapping" title="runtime schema mapping"/>, that schemata and tables can be mapped at runtime to other names. But you can also hard-wire schema mapping in generated artefacts at code generation time, e.g. when you have 5 developers with their own dedicated developer databases, and a common integration database. In the code generation configuration, you would then write.
							</p>

</html><xml><![CDATA[<schemata>
  <schema>
    <!-- Use this as the developer's schema: -->
    <inputSchema>LUKAS_DEV_SCHEMA</inputSchema>

    <!-- Use this as the integration / production database: -->
    <outputSchema>PROD</outputSchema>
  </schema>
</schemata>]]></xml></content>
					</section>
				</sections>
			</section>

			<section id="tools">
				<title>Tools</title>
				<content><html>
					<p>
						These chapters hold some information about tools to be used with jOOQ
					</p>
				</html></content>

				<sections>
                    <section id="jooq-console">
                        <title>jOOQ Console</title>
                        <content><html>
                            <p>
                                The jOOQ Console is no longer supported or shipped with jOOQ 3.2+. You may still use the jOOQ 3.1 Console with new versions of jOOQ, at your own risk.
                            </p>
                        </html></content>
                    </section>
				</sections>
			</section>

			<section id="reference">
				<title>Reference</title>
				<content><html>
					<p>
						These chapters hold some general jOOQ reference information
					</p>
				</html></content>

				<sections>
					<section id="supported-rdbms">
						<title>Supported RDBMS</title>
						<content><html>
							<h3>A list of supported databases</h3>
							<p>
						   		Every RDMBS out there has its own little specialties. jOOQ considers those specialties as much as possible, while trying to standardise the behaviour in jOOQ. In order to increase the quality of jOOQ, some 70 unit tests are run for syntax and variable binding verification, as well as some 180 integration tests with an overall of around 1200 queries for any of these databases:
					   		</p>
							<ul>
							    <li>CUBRID 8.4.1</li>
							    <li>DB2 9.7</li>
							    <li>Derby 10.8</li>
							    <li>Firebird 2.5.1</li>
							    <li>H2 1.3.161</li>
							    <li>HSQLDB 2.2.5</li>
							    <li>Ingres 10.1.0</li>
							    <li>MySQL 5.1.41 and 5.5.8</li>
                                <li>Oracle 10g</li>
							    <li>PostgreSQL 9.0</li>
							    <li>SQLite with inofficial JDBC driver v056</li>
							    <li>SQL Server 2008 R8</li>
							    <li>Sybase Adaptive Server Enterprise 15.5</li>
							    <li>Sybase SQL Anywhere 12</li>
							</ul>
							<p>
								These platforms have been observed to work as well, but are not integration-tested
							</p>
							<ul>
								<li>Google Cloud SQL (MySQL)</li>
							</ul>

							<h3>Databases planned for support</h3>
							<p>
								Any of the following databases might be available in the future
							</p>
						    <ul>
							    <li>Informix</li>
							    <li>Interbase</li>
							    <li>MS Access</li>
							    <li>MS Excel</li>
							    <li>SQL Azure</li>
							    <li>Sybase SQL Anywhere OnDemand</li>
							    <li>Teradata</li>
						    </ul>

							<h3>Databases being watched</h3>
							<p>
								Any of the following databases are being observed for a potential integration
							</p>
							<ul>
								<li>Mondrian</li>
								<li>Netezza</li>
								<li>SQLFire</li>
								<li>Vectorwise</li>
								<li>Vertica</li>
								<li>VoltDB</li>
							</ul>

							<h3>Feature matrix</h3>
							<p>
								This section will soon contain a feature matrix, documenting what feature is available for which database.
							</p>
						</html></content>
					</section>

					<section id="reference-data-types">
						<title>Data types</title>
						<content><html>
							<p>
								There is always a small mismatch between SQL data types and Java data types. This is for two reasons:
							</p>
							<ul>
								<li>SQL data types are insufficiently covered by the JDBC API.</li>
								<li>Java data types are often less expressive than SQL data types</li>
							</ul>
							<p>
								This chapter should document the most important notes about SQL, JDBC and jOOQ data types.
							</p>
						</html></content>

						<sections>
							<section id="data-types-lobs">
								<title>BLOBs and CLOBs</title>
								<content><html>
									<p>
										jOOQ currently doesn't explicitly support JDBC BLOB and CLOB data types. If you use any of these data types in your database, jOOQ will map them to byte[] and String instead. In simple cases (small data), this simplification is sufficient. In more sophisticated cases, you may have to bypass jOOQ, in order to deal with these data types and their respective resources. True support for LOBs is on the roadmap, though.
									</p>
								</html></content>
							</section>

							<section id="data-types-unsigned">
								<title>Unsigned integer types</title>
								<content><html>
									<p>
										Some databases explicitly support unsigned integer data types. In most normal JDBC-based applications, they would just be mapped to their signed counterparts letting bit-wise shifting and tweaking to the user. jOOQ ships with a set of unsigned <reference class="java.lang.Number"/> implementations modelling the following types:
									</p>
									<ul>
										<li><reference class="org.jooq.tools.unsigned.UByte"/>: Unsigned byte, an 8-bit unsigned integer</li>
										<li><reference class="org.jooq.tools.unsigned.UShort"/>: Unsigned short, a 16-bit unsigned integer</li>
										<li><reference class="org.jooq.tools.unsigned.UInteger"/>: Unsigned int, a 32-bit unsigned integer</li>
										<li><reference class="org.jooq.tools.unsigned.ULong"/>: Unsigned long, a 64-bit unsigned integer</li>
									</ul>
									<p>
										Each of these wrapper types extends <reference class="java.lang.Number"/>, wrapping a higher-level integer type, internally:
									</p>
									<ul>
										<li>UByte wraps <reference class="java.lang.Short"/></li>
										<li>UShort wraps <reference class="java.lang.Integer"/></li>
										<li>UInteger wraps <reference class="java.lang.Long"/></li>
										<li>ULong wraps <reference class="java.math.BigInteger"/></li>
									</ul>
								</html></content>
							</section>

							<section id="data-types-intervals">
								<title>INTERVAL data types</title>
								<content><html>
									<p>
										jOOQ fills a gap opened by JDBC, which neglects an important SQL data type as defined by the SQL standards: INTERVAL types. SQL knows two different types of intervals:
									</p>
									<ul>
										<li><strong>YEAR TO MONTH</strong>: This interval type models a number of months and years</li>
										<li><strong>DAY TO SECOND</strong>: This interval type models a number of days, hours, minutes, seconds and milliseconds</li>
									</ul>

									<p>
										Both interval types ship with a variant of subtypes, such as DAY TO HOUR, HOUR TO SECOND, etc. jOOQ models these types as Java objects extending <reference class="java.lang.Number"/>: <reference class="org.jooq.types.YearToMonth"/> (where Number.intValue() corresponds to the absolute number of months) and <reference class="org.jooq.types.DayToSecond"/> (where Number.intValue() corresponds to the absolute number of milliseconds)
									</p>

									<h3>Interval arithmetic</h3>
									<p>
										In addition to the <reference id="arithmetic-expressions" title="arithmetic expressions"/> documented previously, interval arithmetic is also supported by jOOQ. Essentially, the following operations are supported:
									</p>
									<ul>
										<li>DATETIME - DATETIME => INTERVAL</li>
										<li>DATETIME + or - INTERVAL => DATETIME</li>
										<li>INTERVAL + DATETIME => DATETIME</li>
										<li>INTERVAL + - INTERVAL => INTERVAL</li>
										<li>INTERVAL * or / NUMERIC => INTERVAL</li>
										<li>NUMERIC * INTERVAL => INTERVAL</li>
									</ul>
								</html></content>
							</section>

							<section id="data-types-xml">
								<title>XML data types</title>
								<content><html>
									<p>
										XML data types are currently not supported
									</p>
								</html></content>
							</section>

							<section id="data-types-geospacial">
								<title>Geospacial data types</title>
								<content><html>
									<h3>Geospacial data types</h3>
									<p>
										Geospacial data types are currently not supported
									</p>
								</html></content>
							</section>

							<section id="data-types-cursors">
								<title>CURSOR data types</title>
								<content><html>
									<p>
										Some databases support cursors returned from stored procedures. They are mapped to the following jOOQ data type:
									</p>

</html><java><![CDATA[Field<Result<Record>> cursor;]]></java><html>

									<p>
										In fact, such a cursor will be fetched immediately by jOOQ and wrapped in an <reference class="org.jooq.Result"/> object.
									</p>
								</html></content>
							</section>

							<section id="data-types-arrays">
								<title>ARRAY and TABLE data types</title>
								<content><html>
									<p>
										The SQL standard specifies ARRAY data types, that can be mapped to Java arrays as such:
									</p>

</html><java><![CDATA[Field<Integer[]> intArray;]]></java><html>

									<p>
										The above array type is supported by these SQL dialects:
									</p>
									<ul>
										<li>H2</li>
										<li>HSQLDB</li>
										<li>Postgres</li>
									</ul>

									<h3>Oracle typed arrays</h3>
									<p>
										Oracle has strongly-typed arrays and table types (as opposed to the previously seen anonymously typed arrays). These arrays are wrapped by <reference class="org.jooq.ArrayRecord"/> types.
									</p>
								</html></content>
							</section>
						</sections>
					</section>

					<section id="reference-bnf-notation">
						<title>jOOQ's BNF pseudo-notation</title>
						<content><html>
							<p>
								This chapter will soon contain an overview over jOOQ's API using a pseudo BNF notation.
							</p>
						</html></content>
					</section>

					<section id="reference-credits">
						<title>Credits</title>
						<content><html>
							<p>
								jOOQ lives in a very challenging ecosystem. The Java to SQL interface is still one of the most important system interfaces. Yet there are still a lot of open questions, best practices and no "true" standard has been established. This situation gave way to a lot of tools, APIs, utilities which essentially tackle the same problem domain as jOOQ. jOOQ has gotten great inspiration from pre-existing tools and this section should give them some credit. Here is a list of inspirational tools in alphabetical order:
							</p>
							<ul>
								<li><a href="http://avaje.org">Avaj EBean</a>: Play! Framework's preferred ORM has a feature called asynchronous query execution. This idea made it into jOOQ as <reference class="org.jooq.ResultQuery" anchor="#fetchLater()"/></li>
								<li><a href="http://www.hibernate.org">Hibernate</a>: The de-facto standard (JPA) with its useful table-to-POJO mapping features have influenced jOOQ's <reference class="org.jooq.ResultQuery" anchor="#fetchInto(java.lang.Class)"/> facilities</li>
								<li><a href="http://www.h2database.com/html/jaqu.html">JaQu</a>: H2's own fluent API for querying databases</li>
								<li><a href="http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html">JPA</a>: The de-facto standard in the javax.persistence packages, supplied by Oracle. Its annotations are useful to jOOQ as well.</li>
								<li><a href="http://onewebsql.com">OneWebSQL</a>: A commercial SQL abstraction API with support for DAO source code generation, which was integrated also in jOOQ</li>
								<li><a href="http://www.querydsl.com">QueryDSL</a>: A "LINQ-port" to Java. It has a similar fluent API, a similar code-generation facility, yet quite a different purpose. While jOOQ is all about SQL, QueryDSL (like LINQ) is mostly about querying.</li>
								<li><a href="http://www.springsource.org/features/data-access">Spring Data</a>: Spring's JdbcTemplate knows RowMappers, which are reflected by jOOQ's <reference class="org.jooq.RecordHandler"/></li>
							</ul>
						</html></content>
					</section>
				</sections>
			</section>
		</sections>
	</section>
</manual>
