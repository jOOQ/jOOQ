/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Other licenses:
 * -----------------------------------------------------------------------------
 * Commercial licenses for this work are available. These replace the above
 * ASL 2.0 and offer limited warranties, support, maintenance, and commercial
 * database integrations.
 *
 * For more information, please visit: http://www.jooq.org/licenses
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
package org.jooq.impl;

import static java.util.Arrays.asList;
import static org.jooq.Operator.AND;
import static org.jooq.Operator.OR;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.CUBRID;
// ...
// ...
import static org.jooq.SQLDialect.DEFAULT;
import static org.jooq.SQLDialect.DERBY;
// ...
import static org.jooq.SQLDialect.FIREBIRD;
// ...
import static org.jooq.SQLDialect.H2;
// ...
import static org.jooq.SQLDialect.HSQLDB;
import static org.jooq.SQLDialect.IGNITE;
// ...
// ...
import static org.jooq.SQLDialect.MARIADB;
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.MYSQL;
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.POSTGRES;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.SQLDialect.SQLITE;
// ...
// ...
// ...
// ...
// ...
// ...
// ...
// ...
import static org.jooq.conf.ParamType.INLINED;
import static org.jooq.impl.Keywords.K_CUBE;
import static org.jooq.impl.Keywords.K_DEFAULT;
import static org.jooq.impl.Keywords.K_GROUPING_SETS;
import static org.jooq.impl.Names.N_AVG;
import static org.jooq.impl.Names.N_COUNT;
import static org.jooq.impl.Names.N_CUME_DIST;
import static org.jooq.impl.Names.N_DENSE_RANK;
import static org.jooq.impl.Names.N_IF;
import static org.jooq.impl.Names.N_IIF;
import static org.jooq.impl.Names.N_MAX;
import static org.jooq.impl.Names.N_MIN;
import static org.jooq.impl.Names.N_PERCENTILE_CONT;
import static org.jooq.impl.Names.N_PERCENTILE_DISC;
import static org.jooq.impl.Names.N_PERCENT_RANK;
import static org.jooq.impl.Names.N_RANK;
import static org.jooq.impl.Names.N_SUM;
import static org.jooq.impl.Names.N_SYSTEM_TIME;
import static org.jooq.impl.Names.N_VALUE;
import static org.jooq.impl.PositionalWindowFunction.PositionalFunctionType.FIRST_VALUE;
import static org.jooq.impl.PositionalWindowFunction.PositionalFunctionType.LAG;
import static org.jooq.impl.PositionalWindowFunction.PositionalFunctionType.LAST_VALUE;
import static org.jooq.impl.PositionalWindowFunction.PositionalFunctionType.LEAD;
import static org.jooq.impl.PositionalWindowFunction.PositionalFunctionType.NTH_VALUE;
import static org.jooq.impl.RankingFunction.RankingType.CUME_DIST;
import static org.jooq.impl.RankingFunction.RankingType.DENSE_RANK;
import static org.jooq.impl.RankingFunction.RankingType.PERCENT_RANK;
import static org.jooq.impl.RankingFunction.RankingType.RANK;
import static org.jooq.impl.SQLDataType.DATE;
import static org.jooq.impl.SQLDataType.INTEGER;
import static org.jooq.impl.SQLDataType.JSON;
import static org.jooq.impl.SQLDataType.JSONB;
import static org.jooq.impl.SQLDataType.NUMERIC;
import static org.jooq.impl.SQLDataType.TIME;
import static org.jooq.impl.SQLDataType.TIMESTAMP;
import static org.jooq.impl.Tools.EMPTY_FIELD;
import static org.jooq.impl.Tools.combine;
import static org.jooq.impl.Tools.configuration;
import static org.jooq.impl.Tools.map;
import static org.jooq.tools.StringUtils.isEmpty;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.function.Function;

import javax.sql.DataSource;

import org.jooq.AggregateFunction;
import org.jooq.AlterTableStep;
import org.jooq.ArrayAggOrderByStep;
// ...
import org.jooq.Asterisk;
import org.jooq.Block;
import org.jooq.Case;
import org.jooq.CaseConditionStep;
import org.jooq.CaseValueStep;
import org.jooq.Catalog;
import org.jooq.CharacterSet;
import org.jooq.CheckReturnValue;
import org.jooq.CloseableDSLContext;
import org.jooq.Collation;
import org.jooq.Comment;
import org.jooq.CommonTableExpression;
import org.jooq.Condition;
import org.jooq.Configuration;
import org.jooq.ConnectionProvider;
import org.jooq.ConstraintEnforcementStep;
import org.jooq.ConstraintForeignKeyReferencesStep1;
import org.jooq.ConstraintForeignKeyReferencesStep10;
import org.jooq.ConstraintForeignKeyReferencesStep11;
import org.jooq.ConstraintForeignKeyReferencesStep12;
import org.jooq.ConstraintForeignKeyReferencesStep13;
import org.jooq.ConstraintForeignKeyReferencesStep14;
import org.jooq.ConstraintForeignKeyReferencesStep15;
import org.jooq.ConstraintForeignKeyReferencesStep16;
import org.jooq.ConstraintForeignKeyReferencesStep17;
import org.jooq.ConstraintForeignKeyReferencesStep18;
import org.jooq.ConstraintForeignKeyReferencesStep19;
import org.jooq.ConstraintForeignKeyReferencesStep2;
import org.jooq.ConstraintForeignKeyReferencesStep20;
import org.jooq.ConstraintForeignKeyReferencesStep21;
import org.jooq.ConstraintForeignKeyReferencesStep22;
import org.jooq.ConstraintForeignKeyReferencesStep3;
import org.jooq.ConstraintForeignKeyReferencesStep4;
import org.jooq.ConstraintForeignKeyReferencesStep5;
import org.jooq.ConstraintForeignKeyReferencesStep6;
import org.jooq.ConstraintForeignKeyReferencesStep7;
import org.jooq.ConstraintForeignKeyReferencesStep8;
import org.jooq.ConstraintForeignKeyReferencesStep9;
import org.jooq.ConstraintForeignKeyReferencesStepN;
import org.jooq.ConstraintTypeStep;
// ...
import org.jooq.CreateTableColumnStep;
import org.jooq.CreateTypeStep;
import org.jooq.CreateViewAsStep;
import org.jooq.DSLContext;
import org.jooq.DataType;
import org.jooq.DatePart;
// ...
import org.jooq.Delete;
import org.jooq.DeleteUsingStep;
import org.jooq.DerivedColumnList;
import org.jooq.Domain;
import org.jooq.DropTypeStep;
// ...
import org.jooq.False;
import org.jooq.Field;
import org.jooq.FieldOrRow;
// ...
import org.jooq.GroupConcatOrderByStep;
import org.jooq.GroupConcatSeparatorStep;
import org.jooq.GroupField;
// ...
import org.jooq.Index;
import org.jooq.Insert;
import org.jooq.InsertSetStep;
import org.jooq.InsertValuesStep1;
import org.jooq.InsertValuesStep10;
import org.jooq.InsertValuesStep11;
import org.jooq.InsertValuesStep12;
import org.jooq.InsertValuesStep13;
import org.jooq.InsertValuesStep14;
import org.jooq.InsertValuesStep15;
import org.jooq.InsertValuesStep16;
import org.jooq.InsertValuesStep17;
import org.jooq.InsertValuesStep18;
import org.jooq.InsertValuesStep19;
import org.jooq.InsertValuesStep2;
import org.jooq.InsertValuesStep20;
import org.jooq.InsertValuesStep21;
import org.jooq.InsertValuesStep22;
import org.jooq.InsertValuesStep3;
import org.jooq.InsertValuesStep4;
import org.jooq.InsertValuesStep5;
import org.jooq.InsertValuesStep6;
import org.jooq.InsertValuesStep7;
import org.jooq.InsertValuesStep8;
import org.jooq.InsertValuesStep9;
import org.jooq.InsertValuesStepN;
import org.jooq.JSON;
import org.jooq.JSONArrayAggOrderByStep;
import org.jooq.JSONArrayNullStep;
import org.jooq.JSONB;
import org.jooq.JSONEntry;
import org.jooq.JSONEntryValueStep;
import org.jooq.JSONExistsOnStep;
import org.jooq.JSONFormat;
import org.jooq.JSONObjectAggNullStep;
import org.jooq.JSONObjectNullStep;
import org.jooq.JSONTableColumnsFirstStep;
import org.jooq.JSONValueOnStep;
import org.jooq.Keyword;
// ...
// ...
// ...
import org.jooq.Merge;
import org.jooq.MergeKeyStep1;
import org.jooq.MergeKeyStep10;
import org.jooq.MergeKeyStep11;
import org.jooq.MergeKeyStep12;
import org.jooq.MergeKeyStep13;
import org.jooq.MergeKeyStep14;
import org.jooq.MergeKeyStep15;
import org.jooq.MergeKeyStep16;
import org.jooq.MergeKeyStep17;
import org.jooq.MergeKeyStep18;
import org.jooq.MergeKeyStep19;
import org.jooq.MergeKeyStep2;
import org.jooq.MergeKeyStep20;
import org.jooq.MergeKeyStep21;
import org.jooq.MergeKeyStep22;
import org.jooq.MergeKeyStep3;
import org.jooq.MergeKeyStep4;
import org.jooq.MergeKeyStep5;
import org.jooq.MergeKeyStep6;
import org.jooq.MergeKeyStep7;
import org.jooq.MergeKeyStep8;
import org.jooq.MergeKeyStep9;
import org.jooq.MergeKeyStepN;
import org.jooq.MergeUsingStep;
import org.jooq.Name;
import org.jooq.Name.Quoted;
import org.jooq.Operator;
import org.jooq.OrderField;
import org.jooq.OrderedAggregateFunction;
import org.jooq.OrderedAggregateFunctionOfDeferredType;
import org.jooq.Param;
import org.jooq.ParamMode;
import org.jooq.Parameter;
// ...
import org.jooq.PlainSQL;
import org.jooq.Privilege;
// ...
import org.jooq.QualifiedRecord;
import org.jooq.QuantifiedSelect;
import org.jooq.Queries;
import org.jooq.Query;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.Record1;
import org.jooq.Record10;
import org.jooq.Record11;
import org.jooq.Record12;
import org.jooq.Record13;
import org.jooq.Record14;
import org.jooq.Record15;
import org.jooq.Record16;
import org.jooq.Record17;
import org.jooq.Record18;
import org.jooq.Record19;
import org.jooq.Record2;
import org.jooq.Record20;
import org.jooq.Record21;
import org.jooq.Record22;
import org.jooq.Record3;
import org.jooq.Record4;
import org.jooq.Record5;
import org.jooq.Record6;
import org.jooq.Record7;
import org.jooq.Record8;
import org.jooq.Record9;
import org.jooq.RecordHandler;
import org.jooq.RecordType;
// ...
import org.jooq.Result;
import org.jooq.ResultQuery;
import org.jooq.Role;
import org.jooq.Row;
import org.jooq.Row1;
import org.jooq.Row10;
import org.jooq.Row11;
import org.jooq.Row12;
import org.jooq.Row13;
import org.jooq.Row14;
import org.jooq.Row15;
import org.jooq.Row16;
import org.jooq.Row17;
import org.jooq.Row18;
import org.jooq.Row19;
import org.jooq.Row2;
import org.jooq.Row20;
import org.jooq.Row21;
import org.jooq.Row22;
import org.jooq.Row3;
import org.jooq.Row4;
import org.jooq.Row5;
import org.jooq.Row6;
import org.jooq.Row7;
import org.jooq.Row8;
import org.jooq.Row9;
import org.jooq.RowCountQuery;
import org.jooq.RowN;
import org.jooq.Rows;
import org.jooq.SQL;
import org.jooq.SQLDialect;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.SelectField;
import org.jooq.SelectFieldOrAsterisk;
import org.jooq.SelectForStep;
import org.jooq.SelectSelectStep;
import org.jooq.SelectWhereStep;
import org.jooq.Sequence;
import org.jooq.Statement;
import org.jooq.Stringly;
import org.jooq.Support;
import org.jooq.Table;
import org.jooq.TableLike;
import org.jooq.True;
import org.jooq.UDTRecord;
import org.jooq.Update;
import org.jooq.UpdateSetFirstStep;
import org.jooq.User;
// ...
import org.jooq.WindowFromFirstLastStep;
import org.jooq.WindowIgnoreNullsStep;
import org.jooq.WindowOverStep;
import org.jooq.WindowSpecification;
import org.jooq.WindowSpecificationExcludeStep;
import org.jooq.WindowSpecificationOrderByStep;
import org.jooq.WindowSpecificationRowsAndStep;
import org.jooq.WindowSpecificationRowsStep;
import org.jooq.WithAsStep;
import org.jooq.WithAsStep1;
import org.jooq.WithAsStep10;
import org.jooq.WithAsStep11;
import org.jooq.WithAsStep12;
import org.jooq.WithAsStep13;
import org.jooq.WithAsStep14;
import org.jooq.WithAsStep15;
import org.jooq.WithAsStep16;
import org.jooq.WithAsStep17;
import org.jooq.WithAsStep18;
import org.jooq.WithAsStep19;
import org.jooq.WithAsStep2;
import org.jooq.WithAsStep20;
import org.jooq.WithAsStep21;
import org.jooq.WithAsStep22;
import org.jooq.WithAsStep3;
import org.jooq.WithAsStep4;
import org.jooq.WithAsStep5;
import org.jooq.WithAsStep6;
import org.jooq.WithAsStep7;
import org.jooq.WithAsStep8;
import org.jooq.WithAsStep9;
import org.jooq.WithStep;
import org.jooq.XML;
import org.jooq.XMLAggOrderByStep;
import org.jooq.XMLAttributes;
import org.jooq.XMLExistsPassingStep;
import org.jooq.XMLFormat;
import org.jooq.XMLQueryPassingStep;
import org.jooq.XMLTablePassingStep;
import org.jooq.conf.NestedCollectionEmulation;
import org.jooq.conf.Settings;
import org.jooq.exception.SQLDialectNotSupportedException;
import org.jooq.impl.XMLParse.DocumentOrContent;
import org.jooq.tools.StringUtils;
import org.jooq.tools.jdbc.JDBCUtils;
import org.jooq.types.DayToSecond;
import org.jooq.types.UByte;
import org.jooq.types.UInteger;
import org.jooq.types.ULong;
import org.jooq.types.UShort;

import org.jetbrains.annotations.NotNull;

import io.r2dbc.spi.ConnectionFactory;

/**
 * A DSL "entry point" providing implementations to the <code>org.jooq</code>
 * interfaces.
 * <p>
 * The {@link DSLContext} and this <code>DSL</code> are the main entry point for
 * client code, to access jOOQ classes and functionality. Here, you can
 * instantiate all of those objects that cannot be accessed through other
 * objects. For example, to create a {@link Field} representing a constant
 * value, you can write:
 * <p>
 * <code><pre>
 * Field&lt;String&gt; field = DSL.val("Hello World")
 * </pre></code>
 * <p>
 * Another example is the <code>EXISTS</code> clause, which you can apply to any
 * <code>SELECT</code> to form a {@link Condition}:
 * <p>
 * <code><pre>
 * Condition condition = DSL.exists(DSL.select(...));
 * </pre></code>
 * <p>
 * <h5>DSL and static imports</h5>
 * <p>
 * For increased fluency and readability of your jOOQ client code, it is
 * recommended that you static import all methods from the <code>DSL</code>. For
 * example: <code><pre>
 * import static org.jooq.impl.DSL.*;
 *
 * public class Main {
 *   public static void main(String[] args) {
 *     DSL.select(val("Hello"), inline("World"));
 *     // DSL.val ^^^           ^^^^^^ DSL.inline
 *   }
 * }
 * </pre></code>
 * <p>
 * In order to use the "contextual DSL", call one of the various overloaded
 * {@link #using(Configuration)} methods:
 * <p>
 * <code><pre>
 * // Create and immediately execute a SELECT statement:
 * DSL.using(connection, dialect)
 *    .selectOne()
 *    .fetch();
 * </pre></code>
 *
 * @see DSLContext
 * @author Lukas Eder
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class DSL {

    // -------------------------------------------------------------------------
    // XXX Contextual factory methods
    // -------------------------------------------------------------------------

    /**
     * Create an executor with a dialect configured.
     * <p>
     * Without a connection or data source, this executor cannot execute
     * queries. Use it to render SQL only.
     *
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(SQLDialect dialect) {
        return new DefaultDSLContext(dialect, null);
    }

    /**
     * Create an executor with a dialect and settings configured.
     * <p>
     * Without a connection or data source, this executor cannot execute
     * queries. Use it to render SQL only.
     *
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(dialect, settings);
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <code><pre>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test")) {
     *
     *     // ...
     * }
     * </pre></code>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @NotNull
    public static CloseableDSLContext using(String url) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(connection, true), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                throw Tools.translate("Error when initialising Connection", e);
            }
        }
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <code><pre>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test", "sa", "")) {
     *
     *     // ...
     * }
     * </pre></code>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @param username The connection user name.
     * @param password The connection password.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @NotNull
    public static CloseableDSLContext using(String url, String username, String password) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url, username, password);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(connection, true), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url, username, password);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                throw Tools.translate("Error when initialising Connection", e);
            }
        }
    }

    /**
     * Create an executor from a JDBC or R2DBC connection URL.
     * <p>
     * Clients must ensure connections are closed properly by calling
     * {@link CloseableDSLContext#close()} on the resulting {@link DSLContext}.
     * For example:
     * <p>
     * <code><pre>
     * // Auto-closing DSLContext instance to free resources
     * try (CloseableDSLContext ctx = DSL.using("jdbc:h2:~/test", properties)) {
     *
     *     // ...
     * }
     * </pre></code>
     * <p>
     * Both acquisition and release of JDBC and R2DBC connection URLs are
     * blocking.
     *
     * @param url The connection URL.
     * @param properties The connection properties.
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(String)
     */
    @NotNull
    public static CloseableDSLContext using(String url, Properties properties) {
        if (url.startsWith("r2dbc")) {
            io.r2dbc.spi.Connection connection = R2DBC.getConnection(url, properties);
            return new DefaultCloseableDSLContext(new DefaultConnectionFactory(connection, true), JDBCUtils.dialect(connection));
        }
        else {
            try {
                Connection connection = DriverManager.getConnection(url, properties);
                return new DefaultCloseableDSLContext(new DefaultCloseableConnectionProvider(connection), JDBCUtils.dialect(connection));
            }
            catch (SQLException e) {
                throw Tools.translate("Error when initialising Connection", e);
            }
        }
    }

    /**
     * Create an executor with a connection configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(Connection, Settings)}, guessing the {@link SQLDialect}
     * using {@link JDBCUtils#dialect(Connection)}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(Connection)
     */
    @NotNull
    public static DSLContext using(Connection connection) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), null);
    }

    /**
     * Create an executor with a connection and a dialect configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @see DefaultConnectionProvider
     */
    @NotNull
    public static DSLContext using(Connection connection, SQLDialect dialect) {
        return new DefaultDSLContext(connection, dialect, null);
    }

    /**
     * Create an executor with a connection, a dialect and settings configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider} and guessing the {@link SQLDialect}
     * using {@link JDBCUtils#dialect(Connection)}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DefaultConnectionProvider
     * @see JDBCUtils#dialect(Connection)
     */
    @NotNull
    public static DSLContext using(Connection connection, Settings settings) {
        return new DefaultDSLContext(connection, JDBCUtils.dialect(connection), settings);
    }

    /**
     * Create an executor with a connection, a dialect and settings configured.
     * <p>
     * If you provide a JDBC connection to a jOOQ Configuration, jOOQ will use
     * that connection directly for creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DefaultConnectionProvider}
     *
     * @param connection The connection to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DefaultConnectionProvider
     */
    @NotNull
    public static DSLContext using(Connection connection, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connection, dialect, settings);
    }

    /**
     * Create an executor with a data source and a dialect configured.
     * <p>
     * If you provide a JDBC data source to a jOOQ Configuration, jOOQ will use
     * that data source for initialising connections, and creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect)} using a
     * {@link DataSourceConnectionProvider}
     *
     * @param datasource The data source to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @see DataSourceConnectionProvider
     */
    @NotNull
    public static DSLContext using(DataSource datasource, SQLDialect dialect) {
        return new DefaultDSLContext(datasource, dialect);
    }

    /**
     * Create an executor with a data source, a dialect and settings configured.
     * <p>
     * If you provide a JDBC data source to a jOOQ Configuration, jOOQ will use
     * that data source for initialising connections, and creating statements.
     * <p>
     * This is a convenience constructor for
     * {@link #using(ConnectionProvider, SQLDialect, Settings)} using a
     * {@link DataSourceConnectionProvider}
     *
     * @param datasource The data source to use with objects created from this
     *            executor
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     * @see DataSourceConnectionProvider
     */
    @NotNull
    public static DSLContext using(DataSource datasource, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(datasource, dialect, settings);
    }

    /**
     * Create an executor with a custom connection provider and a dialect
     * configured.
     *
     * @param connectionProvider The connection provider providing jOOQ with
     *            JDBC connections
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect) {
        return new DefaultDSLContext(connectionProvider, dialect);
    }

    /**
     * Create an executor with a custom connection provider, a dialect and settings
     * configured.
     *
     * @param connectionProvider The connection provider providing jOOQ with
     *            JDBC connections
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(ConnectionProvider connectionProvider, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connectionProvider, dialect, settings);
    }

    /**
     * Create an executor with a custom R2DBC connection factory and guess the
     * dialect from it.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory) {
        return new DefaultDSLContext(connectionFactory, JDBCUtils.dialect(connectionFactory));
    }

    /**
     * Create an executor with a custom R2DBC connection factory and a dialect
     * configured.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory, SQLDialect dialect) {
        return new DefaultDSLContext(connectionFactory, dialect);
    }

    /**
     * Create an executor with a custom R2DBC connection factory, a dialect and
     * settings configured.
     *
     * @param connectionFactory The R2DBC connection factory providing jOOQ with
     *            R2DBC connections
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(ConnectionFactory connectionFactory, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(connectionFactory, dialect, settings);
    }

    /**
     * Create an executor with a custom R2DBC connection and guess the dialect.
     *
     * @param connection The R2DBC connection
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection) {
        return new DefaultDSLContext(new DefaultConnectionFactory(connection), JDBCUtils.dialect(connection));
    }

    /**
     * Create an executor with a custom R2DBC connection and a dialect
     * configured.
     *
     * @param connection The R2DBC connection
     * @param dialect The dialect to use with objects created from this executor
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection, SQLDialect dialect) {
        return new DefaultDSLContext(new DefaultConnectionFactory(connection), dialect);
    }

    /**
     * Create an executor with a custom R2DBC connection, a dialect and settings
     * configured.
     *
     * @param connection The R2DBC connection
     * @param dialect The dialect to use with objects created from this executor
     * @param settings The runtime settings to apply to objects created from
     *            this executor
     */
    @NotNull
    public static DSLContext using(io.r2dbc.spi.Connection connection, SQLDialect dialect, Settings settings) {
        return new DefaultDSLContext(new DefaultConnectionFactory(connection), dialect, settings);
    }

    /**
     * Create an executor from a custom configuration.
     *
     * @param configuration The configuration
     */
    @NotNull
    public static DSLContext using(Configuration configuration) {
        return new DefaultDSLContext(configuration);
    }

    // -------------------------------------------------------------------------
    // XXX Static subselect factory methods
    // -------------------------------------------------------------------------

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String)} for strictly non-recursive CTE
     * and {@link #withRecursive(String)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(String alias) {
        return new WithImpl(null, false).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(String alias, String... fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(String alias, Collection<String> fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(Name alias) {
        return new WithImpl(null, false).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(Name alias, Name... fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(Name alias, Collection<? extends Name> fieldAliases) {
        return new WithImpl(null, false).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE and
     * {@link #withRecursive(String, String...)} for strictly recursive CTE.
     * <p>
     * This works in a similar way as {@link #with(String, String...)}, except
     * that all column names are produced by a function that receives the CTE's
     * {@link Select} columns as input.
     *
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep with(String alias, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return new WithImpl(null, false).with(alias, fieldNameFunction);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep1 with(String alias, String fieldAlias1) {
        return new WithImpl(null, false).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep2 with(String alias, String fieldAlias1, String fieldAlias2) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep3 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep4 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep5 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep6 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep7 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep8 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep9 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep10 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep11 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep12 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep13 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep14 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep15 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep16 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep17 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep18 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep19 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep20 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep21 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep22 with(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21, String fieldAlias22) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep1 with(Name alias, Name fieldAlias1) {
        return new WithImpl(null, false).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep2 with(Name alias, Name fieldAlias1, Name fieldAlias2) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep3 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep4 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep5 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep6 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep7 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep8 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep9 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep10 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep11 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep12 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep13 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep14 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep15 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep16 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep17 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep18 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep19 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep20 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep21 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep22 with(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21, Name fieldAlias22) {
        return new WithImpl(null, false).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(Select)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithStep with(CommonTableExpression<?>... tables) {
        return new WithImpl(null, false).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(Select)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithStep with(Collection<? extends CommonTableExpression<?>> tables) {
        return new WithImpl(null, false).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String)} for strictly non-recursive CTE
     * and {@link #withRecursive(String)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(String alias) {
        return new WithImpl(null, true).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(String alias, String... fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(String alias, Collection<String> fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(Name alias) {
        return new WithImpl(null, true).with(alias);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(Name alias, Name... fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(Name, Name...)} for strictly non-recursive CTE
     * and {@link #withRecursive(Name, Name...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(Name alias, Collection<? extends Name> fieldAliases) {
        return new WithImpl(null, true).with(alias, fieldAliases);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     * <p>
     * This works in a similar way as {@link #with(String, String...)}, except
     * that all column names are produced by a function that receives the CTE's
     * {@link Select} columns as input.
     *
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep withRecursive(String alias, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return new WithImpl(null, true).with(alias, fieldNameFunction);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep1 withRecursive(String alias, String fieldAlias1) {
        return new WithImpl(null, true).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep2 withRecursive(String alias, String fieldAlias1, String fieldAlias2) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep3 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep4 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep5 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep6 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep7 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep8 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep9 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep10 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep11 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep12 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep13 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep14 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep15 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep16 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep17 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep18 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep19 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep20 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep21 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep22 withRecursive(String alias, String fieldAlias1, String fieldAlias2, String fieldAlias3, String fieldAlias4, String fieldAlias5, String fieldAlias6, String fieldAlias7, String fieldAlias8, String fieldAlias9, String fieldAlias10, String fieldAlias11, String fieldAlias12, String fieldAlias13, String fieldAlias14, String fieldAlias15, String fieldAlias16, String fieldAlias17, String fieldAlias18, String fieldAlias19, String fieldAlias20, String fieldAlias21, String fieldAlias22) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep1 withRecursive(Name alias, Name fieldAlias1) {
        return new WithImpl(null, true).with(alias, fieldAlias1);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep2 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep3 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep4 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep5 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep6 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep7 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep8 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep9 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep10 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep11 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep12 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep13 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep14 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep15 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep16 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep17 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep18 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep19 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep20 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep21 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(String, String...)} for strictly non-recursive CTE
     * and {@link #withRecursive(String, String...)} for strictly
     * recursive CTE.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithAsStep22 withRecursive(Name alias, Name fieldAlias1, Name fieldAlias2, Name fieldAlias3, Name fieldAlias4, Name fieldAlias5, Name fieldAlias6, Name fieldAlias7, Name fieldAlias8, Name fieldAlias9, Name fieldAlias10, Name fieldAlias11, Name fieldAlias12, Name fieldAlias13, Name fieldAlias14, Name fieldAlias15, Name fieldAlias16, Name fieldAlias17, Name fieldAlias18, Name fieldAlias19, Name fieldAlias20, Name fieldAlias21, Name fieldAlias22) {
        return new WithImpl(null, true).with(alias, fieldAlias1, fieldAlias2, fieldAlias3, fieldAlias4, fieldAlias5, fieldAlias6, fieldAlias7, fieldAlias8, fieldAlias9, fieldAlias10, fieldAlias11, fieldAlias12, fieldAlias13, fieldAlias14, fieldAlias15, fieldAlias16, fieldAlias17, fieldAlias18, fieldAlias19, fieldAlias20, fieldAlias21, fieldAlias22);
    }



    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(Select)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithStep withRecursive(CommonTableExpression<?>... tables) {
        return new WithImpl(null, true).with(tables);
    }

    /**
     * Create a <code>WITH</code> clause to supply subsequent
     * <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>,
     * <code>DELETE</code>, and <code>MERGE</code> statements with
     * {@link CommonTableExpression}s.
     * <p>
     * Reusable {@link CommonTableExpression} types can be constructed through
     * <ul>
     * <li>{@link #name(String...)}</li>
     * <li>{@link Name#fields(String...)}</li>
     * <li>
     * {@link DerivedColumnList#as(Select)}</li>
     * </ul>
     * <p>
     * The <code>RECURSIVE</code> keyword may be optional or unsupported in some
     * databases, in case of which it will not be rendered. For optimal database
     * interoperability and readability, however, it is suggested that you use
     * {@link #with(CommonTableExpression...)} for strictly non-recursive CTE
     * and {@link #withRecursive(CommonTableExpression...)} for strictly
     * recursive CTE.
     * <p>
     * Note that the {@link SQLDialect#H2} database only supports single-table,
     * <code>RECURSIVE</code> common table expression lists.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WithStep withRecursive(Collection<? extends CommonTableExpression<?>> tables) {
        return new WithImpl(null, true).with(tables);
    }

    /**
     * Create a new DSL select statement, projecting the known columns from a
     * table.
     * <p>
     * This will project the known columns from the argument table querying
     * {@link Table#fields()}. If no known columns are available (e.g. because
     * the table has been created using {@link DSL#table(String)}), then
     * <code>SELECT *</code> is projected.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * SELECT table.col1, table.col2 FROM table
     * </pre></code>
     */
    @NotNull
    @Support
    public static <R extends Record> SelectWhereStep<R> selectFrom(Table<R> table) {
        return dsl().selectFrom(table);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(Table)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <code><pre>
     * SELECT * FROM table
     * </pre></code>
     *
     * @see DSL#table(Name)
     */
    @NotNull
    @Support
    public static SelectWhereStep<Record> selectFrom(Name table) {
        return dsl().selectFrom(table);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(Table)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <code><pre>
     * SELECT * FROM table
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(SQL)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(SQL sql) {
        return dsl().selectFrom(sql);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(Table)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <code><pre>
     * SELECT * FROM table
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String)
     * @see DSL#sql(String)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql) {
        return dsl().selectFrom(sql);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(Table)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <code><pre>
     * SELECT * FROM table
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String, Object...)
     * @see DSL#sql(String, Object...)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql, Object... bindings) {
        return dsl().selectFrom(sql, bindings);
    }

    /**
     * Create a new DSL select statement, projecting <code>*</code>.
     * <p>
     * Without knowing any columns from the argument table (see
     * {@link #selectFrom(Table)}), this will project <code>SELECT *</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * Example:
     * <p>
     * <code><pre>
     * SELECT * FROM table
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @see DSL#table(String, QueryPart...)
     * @see DSL#sql(String, QueryPart...)
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SelectWhereStep<Record> selectFrom(String sql, QueryPart... parts) {
        return dsl().selectFrom(sql, parts);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(fields)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT tab1.col1, tab1.col2, ..., tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#select(Collection)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> select(Collection<? extends SelectFieldOrAsterisk> fields) {
        return dsl().select(fields);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT tab1.col1, tab1.col2, ..., tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> select(SelectFieldOrAsterisk... fields) {
        return dsl().select(fields);
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Field#in(Select)}, {@link Field#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1> SelectSelectStep<Record1<T1>> select(SelectField<T1> field1) {
        return (SelectSelectStep) select(new SelectField[] { field1 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row2#in(Select)}, {@link Row2#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2> SelectSelectStep<Record2<T1, T2>> select(SelectField<T1> field1, SelectField<T2> field2) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row3#in(Select)}, {@link Row3#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3> SelectSelectStep<Record3<T1, T2, T3>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row4#in(Select)}, {@link Row4#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, field4)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> SelectSelectStep<Record4<T1, T2, T3, T4>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row5#in(Select)}, {@link Row5#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, field4, field5)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> SelectSelectStep<Record5<T1, T2, T3, T4, T5>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row6#in(Select)}, {@link Row6#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field5, field6)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> SelectSelectStep<Record6<T1, T2, T3, T4, T5, T6>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row7#in(Select)}, {@link Row7#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field6, field7)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> SelectSelectStep<Record7<T1, T2, T3, T4, T5, T6, T7>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row8#in(Select)}, {@link Row8#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field7, field8)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> SelectSelectStep<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row9#in(Select)}, {@link Row9#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field8, field9)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> SelectSelectStep<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row10#in(Select)}, {@link Row10#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field9, field10)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> SelectSelectStep<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row11#in(Select)}, {@link Row11#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field10, field11)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> SelectSelectStep<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row12#in(Select)}, {@link Row12#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field11, field12)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> SelectSelectStep<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row13#in(Select)}, {@link Row13#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field12, field13)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> SelectSelectStep<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row14#in(Select)}, {@link Row14#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field13, field14)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> SelectSelectStep<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row15#in(Select)}, {@link Row15#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field14, field15)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> SelectSelectStep<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row16#in(Select)}, {@link Row16#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field15, field16)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> SelectSelectStep<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row17#in(Select)}, {@link Row17#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field16, field17)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> SelectSelectStep<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row18#in(Select)}, {@link Row18#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field17, field18)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> SelectSelectStep<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row19#in(Select)}, {@link Row19#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field18, field19)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> SelectSelectStep<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row20#in(Select)}, {@link Row20#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field19, field20)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> SelectSelectStep<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row21#in(Select)}, {@link Row21#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field20, field21)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> SelectSelectStep<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #select(SelectFieldOrAsterisk...)}, except that it declares
     * additional record-level typesafety, which is needed by
     * {@link Row22#in(Select)}, {@link Row22#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * select(field1, field2, field3, .., field21, field22)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#select(SelectFieldOrAsterisk...)
     * @see #select(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> SelectSelectStep<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> select(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return (SelectSelectStep) select(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(fields)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT DISTINCT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT DISTINCT tab1.col1, tab1.col2, ..., tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT DISTINCT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#selectDistinct(Collection)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> selectDistinct(Collection<? extends SelectFieldOrAsterisk> fields) {
        return dsl().selectDistinct(fields);
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     * <p>
     * Note that passing an empty collection conveniently produces
     * <code>SELECT DISTINCT *</code> semantics, i.e. it:
     * <ul>
     * <li>Renders <code>SELECT DISTINCT tab1.col1, tab1.col2, ..., tabN.colN</code> if
     * all columns are known</li>
     * <li>Renders <code>SELECT DISTINCT *</code> if not all columns are known, e.g. when
     * using plain SQL</li>
     * </ul>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record> selectDistinct(SelectFieldOrAsterisk... fields) {
        return dsl().selectDistinct(fields);
    }



    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Field#in(Select)}, {@link Field#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1> SelectSelectStep<Record1<T1>> selectDistinct(SelectField<T1> field1) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row2#in(Select)}, {@link Row2#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2> SelectSelectStep<Record2<T1, T2>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row3#in(Select)}, {@link Row3#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3> SelectSelectStep<Record3<T1, T2, T3>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row4#in(Select)}, {@link Row4#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, field4)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> SelectSelectStep<Record4<T1, T2, T3, T4>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row5#in(Select)}, {@link Row5#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, field4, field5)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> SelectSelectStep<Record5<T1, T2, T3, T4, T5>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row6#in(Select)}, {@link Row6#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field5, field6)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> SelectSelectStep<Record6<T1, T2, T3, T4, T5, T6>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row7#in(Select)}, {@link Row7#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field6, field7)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> SelectSelectStep<Record7<T1, T2, T3, T4, T5, T6, T7>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row8#in(Select)}, {@link Row8#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field7, field8)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> SelectSelectStep<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row9#in(Select)}, {@link Row9#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field8, field9)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> SelectSelectStep<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row10#in(Select)}, {@link Row10#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field9, field10)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> SelectSelectStep<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row11#in(Select)}, {@link Row11#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field10, field11)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> SelectSelectStep<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row12#in(Select)}, {@link Row12#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field11, field12)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> SelectSelectStep<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row13#in(Select)}, {@link Row13#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field12, field13)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> SelectSelectStep<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row14#in(Select)}, {@link Row14#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field13, field14)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> SelectSelectStep<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row15#in(Select)}, {@link Row15#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field14, field15)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> SelectSelectStep<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row16#in(Select)}, {@link Row16#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field15, field16)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> SelectSelectStep<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row17#in(Select)}, {@link Row17#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field16, field17)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> SelectSelectStep<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row18#in(Select)}, {@link Row18#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field17, field18)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> SelectSelectStep<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row19#in(Select)}, {@link Row19#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field18, field19)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> SelectSelectStep<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row20#in(Select)}, {@link Row20#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field19, field20)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> SelectSelectStep<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row21#in(Select)}, {@link Row21#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field20, field21)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> SelectSelectStep<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL subselect statement.
     * <p>
     * This is the same as {@link #selectDistinct(SelectFieldOrAsterisk...)}, except that it
     * declares additional record-level typesafety, which is needed by
     * {@link Row22#in(Select)}, {@link Row22#equal(Select)} and other predicate
     * building methods taking subselect arguments.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectDistinct(field1, field2, field3, .., field21, field22)
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSLContext#selectDistinct(SelectFieldOrAsterisk...)
     * @see #selectDistinct(SelectFieldOrAsterisk...)
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> SelectSelectStep<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> selectDistinct(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return (SelectSelectStep) selectDistinct(new SelectField[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL subselect statement for a constant <code>0</code>
     * literal.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectZero()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSL#zero()
     * @see DSLContext#selectZero()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectZero() {
        return dsl().selectZero();
    }

    /**
     * Create a new DSL subselect statement for a constant <code>1</code>
     * literal.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectOne()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSL#one()
     * @see DSLContext#selectOne()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectOne() {
        return dsl().selectOne();
    }

    /**
     * Create a new DSL subselect statement for <code>COUNT(*)</code>.
     * <p>
     * Unlike {@link Select} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>SELECT</code> statement. You can use this statement in two ways:
     * <ul>
     * <li>As a subselect within another select</li>
     * <li>As a statement, after attaching it using
     * {@link Select#attach(org.jooq.Configuration)}</li>
     * </ul>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * selectCount()
     *  .from(table1)
     *  .join(table2).on(field1.equal(field2))
     *  .where(field1.greaterThan(100))
     *  .orderBy(field2);
     * </pre></code>
     *
     * @see DSL#count()
     * @see DSLContext#selectCount()
     */
    @NotNull
    @Support
    public static SelectSelectStep<Record1<Integer>> selectCount() {
        return dsl().selectCount();
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * This type of insert may feel more convenient to some users, as it uses
     * the <code>UPDATE</code> statement's <code>SET a = b</code> syntax.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table)
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .newRecord()
     *   .set(field1, value3)
     *   .set(field2, value4)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertSetStep<R> insertInto(Table<R> into) {
        return dsl().insertInto(into);
    }



    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1)
     *   .values(field1)
     *   .values(field1)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1> InsertValuesStep1<R, T1> insertInto(Table<R> into, Field<T1> field1) {
        return (InsertValuesStep1) insertInto(into, new Field[] { field1 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(field1, field2)
     *   .values(field1, field2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2> InsertValuesStep2<R, T1, T2> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2) {
        return (InsertValuesStep2) insertInto(into, new Field[] { field1, field2 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3)
     *   .values(field1, field2, field3)
     *   .values(field1, field2, field3)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3> InsertValuesStep3<R, T1, T2, T3> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return (InsertValuesStep3) insertInto(into, new Field[] { field1, field2, field3 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, field4)
     *   .values(field1, field2, field3, field4)
     *   .values(field1, field2, field3, field4)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4> InsertValuesStep4<R, T1, T2, T3, T4> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return (InsertValuesStep4) insertInto(into, new Field[] { field1, field2, field3, field4 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, field4, field5)
     *   .values(field1, field2, field3, field4, field5)
     *   .values(field1, field2, field3, field4, field5)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5> InsertValuesStep5<R, T1, T2, T3, T4, T5> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return (InsertValuesStep5) insertInto(into, new Field[] { field1, field2, field3, field4, field5 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field5, field6)
     *   .values(valueA1, valueA2, valueA3, .., valueA5, valueA6)
     *   .values(valueB1, valueB2, valueB3, .., valueB5, valueB6)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6> InsertValuesStep6<R, T1, T2, T3, T4, T5, T6> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return (InsertValuesStep6) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field6, field7)
     *   .values(valueA1, valueA2, valueA3, .., valueA6, valueA7)
     *   .values(valueB1, valueB2, valueB3, .., valueB6, valueB7)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7> InsertValuesStep7<R, T1, T2, T3, T4, T5, T6, T7> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return (InsertValuesStep7) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field7, field8)
     *   .values(valueA1, valueA2, valueA3, .., valueA7, valueA8)
     *   .values(valueB1, valueB2, valueB3, .., valueB7, valueB8)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8> InsertValuesStep8<R, T1, T2, T3, T4, T5, T6, T7, T8> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return (InsertValuesStep8) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field8, field9)
     *   .values(valueA1, valueA2, valueA3, .., valueA8, valueA9)
     *   .values(valueB1, valueB2, valueB3, .., valueB8, valueB9)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9> InsertValuesStep9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return (InsertValuesStep9) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field9, field10)
     *   .values(valueA1, valueA2, valueA3, .., valueA9, valueA10)
     *   .values(valueB1, valueB2, valueB3, .., valueB9, valueB10)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> InsertValuesStep10<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return (InsertValuesStep10) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field10, field11)
     *   .values(valueA1, valueA2, valueA3, .., valueA10, valueA11)
     *   .values(valueB1, valueB2, valueB3, .., valueB10, valueB11)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> InsertValuesStep11<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return (InsertValuesStep11) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field11, field12)
     *   .values(valueA1, valueA2, valueA3, .., valueA11, valueA12)
     *   .values(valueB1, valueB2, valueB3, .., valueB11, valueB12)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> InsertValuesStep12<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return (InsertValuesStep12) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field12, field13)
     *   .values(valueA1, valueA2, valueA3, .., valueA12, valueA13)
     *   .values(valueB1, valueB2, valueB3, .., valueB12, valueB13)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> InsertValuesStep13<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return (InsertValuesStep13) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field13, field14)
     *   .values(valueA1, valueA2, valueA3, .., valueA13, valueA14)
     *   .values(valueB1, valueB2, valueB3, .., valueB13, valueB14)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> InsertValuesStep14<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return (InsertValuesStep14) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field14, field15)
     *   .values(valueA1, valueA2, valueA3, .., valueA14, valueA15)
     *   .values(valueB1, valueB2, valueB3, .., valueB14, valueB15)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> InsertValuesStep15<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return (InsertValuesStep15) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field15, field16)
     *   .values(valueA1, valueA2, valueA3, .., valueA15, valueA16)
     *   .values(valueB1, valueB2, valueB3, .., valueB15, valueB16)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> InsertValuesStep16<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return (InsertValuesStep16) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field16, field17)
     *   .values(valueA1, valueA2, valueA3, .., valueA16, valueA17)
     *   .values(valueB1, valueB2, valueB3, .., valueB16, valueB17)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> InsertValuesStep17<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return (InsertValuesStep17) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field17, field18)
     *   .values(valueA1, valueA2, valueA3, .., valueA17, valueA18)
     *   .values(valueB1, valueB2, valueB3, .., valueB17, valueB18)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> InsertValuesStep18<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return (InsertValuesStep18) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field18, field19)
     *   .values(valueA1, valueA2, valueA3, .., valueA18, valueA19)
     *   .values(valueB1, valueB2, valueB3, .., valueB18, valueB19)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> InsertValuesStep19<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return (InsertValuesStep19) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field19, field20)
     *   .values(valueA1, valueA2, valueA3, .., valueA19, valueA20)
     *   .values(valueB1, valueB2, valueB3, .., valueB19, valueB20)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> InsertValuesStep20<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return (InsertValuesStep20) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field20, field21)
     *   .values(valueA1, valueA2, valueA3, .., valueA20, valueA21)
     *   .values(valueB1, valueB2, valueB3, .., valueB20, valueB21)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> InsertValuesStep21<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return (InsertValuesStep21) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2, field3, .., field21, field22)
     *   .values(valueA1, valueA2, valueA3, .., valueA21, valueA22)
     *   .values(valueB1, valueB2, valueB3, .., valueB21, valueB22)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field, Field)
     */
    @NotNull
    @Support
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> InsertValuesStep22<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> insertInto(Table<R> into, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return (InsertValuesStep22) insertInto(into, new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(valueA1, valueA2)
     *   .values(valueB1, valueB2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Field...)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertValuesStepN<R> insertInto(Table<R> into, Field<?>... fields) {
        return dsl().insertInto(into, fields);
    }

    /**
     * Create a new DSL insert statement.
     * <p>
     * Unlike {@link Insert} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>INSERT</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * insertInto(table, field1, field2)
     *   .values(valueA1, valueA2)
     *   .values(valueB1, valueB2)
     *   .onDuplicateKeyUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     * </pre></code>
     *
     * @see DSLContext#insertInto(Table, Collection)
     */
    @NotNull
    @Support
    public static <R extends Record> InsertValuesStepN<R> insertInto(Table<R> into, Collection<? extends Field<?>> fields) {
        return dsl().insertInto(into, fields);
    }

    /**
     * Create a new DSL update statement.
     * <p>
     * Unlike {@link Update} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>UPDATE</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * update(table)
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .where(field1.greaterThan(100))
     * </pre></code>
     * <p>
     * Note that some databases support table expressions more complex than
     * simple table references. In MySQL, for instance, you can write
     * <code><pre>
     * update(t1.join(t2).on(t1.id.eq(t2.id)))
     *   .set(t1.value, value1)
     *   .set(t2.value, value2)
     *   .where(t1.id.eq(10))
     * </pre></code>
     */
    @NotNull
    @Support
    public static <R extends Record> UpdateSetFirstStep<R> update(Table<R> table) {
        return dsl().update(table);
    }

    /**
     * Create a new DSL SQL standard MERGE statement.
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     * <p>
     * This statement is available from DSL syntax only. It is known to be
     * supported in some way by any of these dialects:
     * <table border="1">
     * <tr>
     * <th>dialect</th>
     * <th>support type</th>
     * <th>documentation</th>
     * </tr>
     * <tr>
     * <td>DB2</td>
     * <td>SQL:2008 standard and major enhancements</td>
     * <td><a href=
     * "http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=/com.ibm.db2.udb.admin.doc/doc/r0010873.htm"
     * >http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=/com.
     * ibm.db2.udb.admin.doc/doc/r0010873.htm</a></td>
     * </tr>
     * <tr>
     * <td>HSQLDB</td>
     * <td>SQL:2008 standard</td>
     * <td><a
     * href="http://hsqldb.org/doc/2.0/guide/dataaccess-chapt.html#N129BA"
     * >http://hsqldb.org/doc/2.0/guide/dataaccess-chapt.html#N129BA</a></td>
     * </tr>
     * <tr>
     * <td>Oracle</td>
     * <td>SQL:2008 standard and minor enhancements</td>
     * <td><a href=
     * "http://download.oracle.com/docs/cd/B28359_01/server.111/b28286/statements_9016.htm"
     * >http://download.oracle.com/docs/cd/B28359_01/server.111/b28286/
     * statements_9016.htm</a></td>
     * </tr>
     * <tr>
     * <td>SQL Server</td>
     * <td>Similar to SQL:2008 standard with some major enhancements</td>
     * <td><a href= "http://msdn.microsoft.com/de-de/library/bb510625.aspx"
     * >http://msdn.microsoft.com/de-de/library/bb510625.aspx</a></td>
     * </tr>
     * <tr>
     * <td>Sybase</td>
     * <td>Similar to SQL:2008 standard with some major enhancements</td>
     * <td><a href=
     * "http://dcx.sybase.com/1100/en/dbreference_en11/merge-statement.html"
     * >http://dcx.sybase.com/1100/en/dbreference_en11/merge-statement.html</a></td>
     * </tr>
     * </table>
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * mergeInto(table)
     *   .using(select)
     *   .on(condition)
     *   .whenMatchedThenUpdate()
     *   .set(field1, value1)
     *   .set(field2, value2)
     *   .whenNotMatchedThenInsert(field1, field2)
     *   .values(value1, value2)
     * </pre></code>
     * <p>
     * Note: Using this method, you can also create an H2-specific MERGE
     * statement without field specification. See also
     * {@link #mergeInto(Table, Field...)}
     *
     * @see DSLContext#mergeInto(Table)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> MergeUsingStep<R> mergeInto(Table<R> table) {
        return dsl().mergeInto(table);
    }



    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1> MergeKeyStep1<R, T1> mergeInto(Table<R> table, Field<T1> field1) {
        return using(new DefaultConfiguration()).mergeInto(table, field1);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2> MergeKeyStep2<R, T1, T2> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3> MergeKeyStep3<R, T1, T2, T3> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4> MergeKeyStep4<R, T1, T2, T3, T4> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5> MergeKeyStep5<R, T1, T2, T3, T4, T5> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6> MergeKeyStep6<R, T1, T2, T3, T4, T5, T6> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7> MergeKeyStep7<R, T1, T2, T3, T4, T5, T6, T7> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8> MergeKeyStep8<R, T1, T2, T3, T4, T5, T6, T7, T8> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9> MergeKeyStep9<R, T1, T2, T3, T4, T5, T6, T7, T8, T9> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MergeKeyStep10<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> MergeKeyStep11<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> MergeKeyStep12<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> MergeKeyStep13<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> MergeKeyStep14<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> MergeKeyStep15<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> MergeKeyStep16<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> MergeKeyStep17<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> MergeKeyStep18<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> MergeKeyStep19<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> MergeKeyStep20<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> MergeKeyStep21<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a new DSL UPSERT statement ({@link SQLDialect#H2}
     * <code>MERGE</code>) or {@link SQLDialect#HANA} <code>UPSERT</code>).
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> MergeKeyStep22<R, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> mergeInto(Table<R> table, Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return using(new DefaultConfiguration()).mergeInto(table, field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create a new DSL merge statement (H2-specific syntax).
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     * <p>
     * This statement is available from DSL syntax only. It is known to be
     * supported in some way by any of these dialects:
     * <table border="1">
     * <tr>
     * <td>H2</td>
     * <td>H2 natively supports this special syntax</td>
     * <td><a href= "www.h2database.com/html/grammar.html#merge"
     * >www.h2database.com/html/grammar.html#merge</a></td>
     * </tr>
     * <tr>
     * <td>DB2, HSQLDB, Oracle, SQL Server, Sybase SQL Anywhere</td>
     * <td>These databases can emulate the H2-specific MERGE statement using a
     * standard SQL MERGE statement, without restrictions</td>
     * <td>See {@link #mergeInto(Table)} for the standard MERGE statement</td>
     * </tr>
     * </table>
     *
     * @see DSLContext#mergeInto(Table, Field...)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> MergeKeyStepN<R> mergeInto(Table<R> table, Field<?>... fields) {
        return dsl().mergeInto(table, fields);
    }

    /**
     * Create a new DSL merge statement (H2-specific syntax).
     * <p>
     * Unlike {@link Merge} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>MERGE</code> statement.
     *
     * @see DSLContext#mergeInto(Table, Collection)
     * @deprecated - [#10045] - 3.14.0 - Use the standard SQL MERGE API instead, via {@link #mergeInto(Table)}
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> MergeKeyStepN<R> mergeInto(Table<R> table, Collection<? extends Field<?>> fields) {
        return dsl().mergeInto(table, fields);
    }

    /**
     * Create a new DSL delete statement.
     * <p>
     * Unlike {@link Delete} factory methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * <code>DELETE</code> statement.
     * <p>
     * Example: <code><pre>
     * import static org.jooq.impl.DSL.*;
     *
     * // [...]
     *
     * deleteFrom(table)
     *   .where(field1.greaterThan(100))
     * </pre></code>
     * <p>
     * Some but not all databases support aliased tables in delete statements.
     *
     * @see DSLContext#deleteFrom(Table)
     */
    @NotNull
    @Support
    public static <R extends Record> DeleteUsingStep<R> deleteFrom(Table<R> table) {
        return dsl().deleteFrom(table);
    }

    /**
     * Create a new DSL delete statement.
     * <p>
     * This is an alias for {@link #deleteFrom(Table)}
     */
    @NotNull
    @Support
    public static <R extends Record> DeleteUsingStep<R> delete(Table<R> table) {
        return dsl().deleteFrom(table);
    }

    // -------------------------------------------------------------------------
    // XXX Comments
    // -------------------------------------------------------------------------

    /**
     * Create a comment.
     */
    @NotNull
    @Support
    public static Comment comment(String comment) {
        return isEmpty(comment) ? CommentImpl.NO_COMMENT : new CommentImpl(comment);
    }

    // -------------------------------------------------------------------------
    // XXX DDL Clauses
    // -------------------------------------------------------------------------

    /**
     * Create an unnamed (system named) <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint() {
        return new ConstraintImpl();
    }

    /**
     * Create a <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint(Name name) {
        return new ConstraintImpl(name);
    }

    /**
     * Create a <code>CONSTRAINT</code> specification.
     */
    @NotNull
    @Support
    public static ConstraintTypeStep constraint(String name) {
        return constraint(name(name));
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(String... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Name... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Field<?>... fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Create an unnamed (system named) <code>PRIMARY KEY</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep primaryKey(Collection<? extends Field<?>> fields) {
        return constraint().primaryKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(String... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Name... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Field<?>... fields) {
        return constraint().foreignKey(fields);
    }

    /**
     * Add a <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStepN foreignKey(Collection<? extends Field<?>> fields) {
        return constraint().foreignKey(fields);
    }



    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1> ConstraintForeignKeyReferencesStep1<T1> foreignKey(Field<T1> field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2> ConstraintForeignKeyReferencesStep2<T1, T2> foreignKey(Field<T1> field1, Field<T2> field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> ConstraintForeignKeyReferencesStep3<T1, T2, T3> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> ConstraintForeignKeyReferencesStep4<T1, T2, T3, T4> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> ConstraintForeignKeyReferencesStep5<T1, T2, T3, T4, T5> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> ConstraintForeignKeyReferencesStep6<T1, T2, T3, T4, T5, T6> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> ConstraintForeignKeyReferencesStep7<T1, T2, T3, T4, T5, T6, T7> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> ConstraintForeignKeyReferencesStep8<T1, T2, T3, T4, T5, T6, T7, T8> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> ConstraintForeignKeyReferencesStep9<T1, T2, T3, T4, T5, T6, T7, T8, T9> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ConstraintForeignKeyReferencesStep10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ConstraintForeignKeyReferencesStep11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ConstraintForeignKeyReferencesStep12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ConstraintForeignKeyReferencesStep13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ConstraintForeignKeyReferencesStep14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ConstraintForeignKeyReferencesStep15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ConstraintForeignKeyReferencesStep16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ConstraintForeignKeyReferencesStep17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ConstraintForeignKeyReferencesStep18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ConstraintForeignKeyReferencesStep19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ConstraintForeignKeyReferencesStep20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ConstraintForeignKeyReferencesStep21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ConstraintForeignKeyReferencesStep22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> foreignKey(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep1<?> foreignKey(Name field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep2<?, ?> foreignKey(Name field1, Name field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep3<?, ?, ?> foreignKey(Name field1, Name field2, Name field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep4<?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep5<?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep6<?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep7<?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep8<?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep9<?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20, Name field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(Name field1, Name field2, Name field3, Name field4, Name field5, Name field6, Name field7, Name field8, Name field9, Name field10, Name field11, Name field12, Name field13, Name field14, Name field15, Name field16, Name field17, Name field18, Name field19, Name field20, Name field21, Name field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep1<?> foreignKey(String field1) {
        return constraint().foreignKey(field1);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep2<?, ?> foreignKey(String field1, String field2) {
        return constraint().foreignKey(field1, field2);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep3<?, ?, ?> foreignKey(String field1, String field2, String field3) {
        return constraint().foreignKey(field1, field2, field3);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep4<?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4) {
        return constraint().foreignKey(field1, field2, field3, field4);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep5<?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5) {
        return constraint().foreignKey(field1, field2, field3, field4, field5);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep6<?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep7<?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep8<?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep9<?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep10<?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep11<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep12<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep13<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep14<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep15<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep16<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep17<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep18<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep19<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep20<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep21<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20, String field21) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Add an unnamed (system named) <code>FOREIGN KEY</code> clause to the <code>CONSTRAINT</code>.
     */
    @NotNull
    @Support
    public static ConstraintForeignKeyReferencesStep22<?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?> foreignKey(String field1, String field2, String field3, String field4, String field5, String field6, String field7, String field8, String field9, String field10, String field11, String field12, String field13, String field14, String field15, String field16, String field17, String field18, String field19, String field20, String field21, String field22) {
        return constraint().foreignKey(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(String... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Name... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Field<?>... fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>UNIQUE</code> constraint.
     */
    @NotNull
    @Support
    public static ConstraintEnforcementStep unique(Collection<? extends Field<?>> fields) {
        return constraint().unique(fields);
    }

    /**
     * Create an unnamed (system named) <code>CHECK</code> constraint.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static ConstraintEnforcementStep check(Condition condition) {
        return constraint().check(condition);
    }

    // -------------------------------------------------------------------------
    // XXX DDL Statements
    // -------------------------------------------------------------------------



    // -------------------------------------------------------------------------
    // DDL statements
    // -------------------------------------------------------------------------

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabase(@Stringly.Name String database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabase(Name database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabase(Catalog database) {
        return dsl().alterDatabase(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(@Stringly.Name String database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(Name database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDatabaseIfExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterDatabaseStep alterDatabaseIfExists(Catalog database) {
        return dsl().alterDatabaseIfExists(database);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(@Stringly.Name String domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(Name domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomain(Domain<T> domain) {
        return dsl().alterDomain(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(@Stringly.Name String domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(Name domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterDomainIfExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, HSQLDB, POSTGRES })
    public static <T> org.jooq.AlterDomainStep<T> alterDomainIfExists(Domain<T> domain) {
        return dsl().alterDomainIfExists(domain);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(@Stringly.Name String index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(Name index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndex(Index index) {
        return dsl().alterIndex(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(@Stringly.Name String index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(Name index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterIndexIfExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterIndexOnStep alterIndexIfExists(Index index) {
        return dsl().alterIndexIfExists(index);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(@Stringly.Name String schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(Name schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterSchemaStep alterSchema(Schema schema) {
        return dsl().alterSchema(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(@Stringly.Name String schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(Name schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSchemaIfExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ H2 })
    public static org.jooq.AlterSchemaStep alterSchemaIfExists(Schema schema) {
        return dsl().alterSchemaIfExists(schema);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.AlterSequenceStep<Number> alterSequence(@Stringly.Name String sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.AlterSequenceStep<Number> alterSequence(Name sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static <T extends Number> org.jooq.AlterSequenceStep<T> alterSequence(Sequence<T> sequence) {
        return dsl().alterSequence(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES })
    public static org.jooq.AlterSequenceStep<Number> alterSequenceIfExists(@Stringly.Name String sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES })
    public static org.jooq.AlterSequenceStep<Number> alterSequenceIfExists(Name sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterSequenceIfExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, POSTGRES })
    public static <T extends Number> org.jooq.AlterSequenceStep<T> alterSequenceIfExists(Sequence<T> sequence) {
        return dsl().alterSequenceIfExists(sequence);
    }

    /**
     * The <code>ALTER TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterType(String)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterType(@Stringly.Name String type) {
        return dsl().alterType(type);
    }

    /**
     * The <code>ALTER TYPE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterType(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.AlterTypeStep alterType(Name type) {
        return dsl().alterType(type);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterViewStep alterView(@Stringly.Name String view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterViewStep alterView(Name view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.AlterViewStep alterView(Table<?> view) {
        return dsl().alterView(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterViewStep alterViewIfExists(@Stringly.Name String view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterViewStep alterViewIfExists(Name view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>ALTER VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#alterViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, POSTGRES })
    public static org.jooq.AlterViewStep alterViewIfExists(Table<?> view) {
        return dsl().alterViewIfExists(view);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnTable(@Stringly.Name String table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnTable(Name table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnTable(Table<?> table) {
        return dsl().commentOnTable(table);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnView(@Stringly.Name String view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnView(Name view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnView(Table<?> view) {
        return dsl().commentOnView(view);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnColumn(@Stringly.Name String field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnColumn(Name field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>COMMENT ON COLUMN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#commentOnColumn(Field)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CommentOnIsStep commentOnColumn(Field<?> field) {
        return dsl().commentOnColumn(field);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(@Stringly.Name String database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(Name database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateDatabaseFinalStep createDatabase(Catalog database) {
        return dsl().createDatabase(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(@Stringly.Name String database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(Name database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DATABASE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDatabaseIfNotExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.CreateDatabaseFinalStep createDatabaseIfNotExists(Catalog database) {
        return dsl().createDatabaseIfNotExists(database);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomain(@Stringly.Name String domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomain(Name domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomain(Domain<?> domain) {
        return dsl().createDomain(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(@Stringly.Name String domain) {
        return dsl().createDomainIfNotExists(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(Name domain) {
        return dsl().createDomainIfNotExists(domain);
    }

    /**
     * The <code>CREATE DOMAIN IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createDomainIfNotExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, POSTGRES })
    public static org.jooq.CreateDomainAsStep createDomainIfNotExists(Domain<?> domain) {
        return dsl().createDomainIfNotExists(domain);
    }





































































    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateIndexStep createIndex(@Stringly.Name String index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateIndexStep createIndex(Name index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateIndexStep createIndex(Index index) {
        return dsl().createIndex(index);
    }

    /**
     * The <code>CREATE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndex()
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.CreateIndexStep createIndex() {
        return dsl().createIndex();
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(@Stringly.Name String index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(Name index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createIndexIfNotExists(Index index) {
        return dsl().createIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createIndexIfNotExists()
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createIndexIfNotExists() {
        return dsl().createIndexIfNotExists();
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndex(@Stringly.Name String index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndex(Name index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndex(Index index) {
        return dsl().createUniqueIndex(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndex()
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndex() {
        return dsl().createUniqueIndex();
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(@Stringly.Name String index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(Name index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists(Index index) {
        return dsl().createUniqueIndexIfNotExists(index);
    }

    /**
     * The <code>CREATE UNIQUE INDEX IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createUniqueIndexIfNotExists()
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES, SQLITE })
    public static org.jooq.CreateIndexStep createUniqueIndexIfNotExists() {
        return dsl().createUniqueIndexIfNotExists();
    }





































































































































    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchema(@Stringly.Name String schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchema(Name schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchema(Schema schema) {
        return dsl().createSchema(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(@Stringly.Name String schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(Name schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SCHEMA IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSchemaIfNotExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.CreateSchemaFinalStep createSchemaIfNotExists(Schema schema) {
        return dsl().createSchemaIfNotExists(schema);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequence(@Stringly.Name String sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequence(Name sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequence(Sequence<?> sequence) {
        return dsl().createSequence(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequenceIfNotExists(@Stringly.Name String sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequenceIfNotExists(Name sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }

    /**
     * The <code>CREATE SEQUENCE IF NOT EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#createSequenceIfNotExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.CreateSequenceFlagsStep createSequenceIfNotExists(Sequence<?> sequence) {
        return dsl().createSequenceIfNotExists(sequence);
    }

    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(String)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(@Stringly.Name String database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(Name database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabase(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabase(Catalog database) {
        return dsl().dropDatabase(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(@Stringly.Name String database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(Name database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DATABASE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDatabaseIfExists(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropDatabaseFinalStep dropDatabaseIfExists(Catalog database) {
        return dsl().dropDatabaseIfExists(database);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomain(@Stringly.Name String domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomain(Name domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomain(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomain(Domain<?> domain) {
        return dsl().dropDomain(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(@Stringly.Name String domain) {
        return dsl().dropDomainIfExists(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(Name domain) {
        return dsl().dropDomainIfExists(domain);
    }

    /**
     * The <code>DROP DOMAIN IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropDomainIfExists(Domain)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static org.jooq.DropDomainCascadeStep dropDomainIfExists(Domain<?> domain) {
        return dsl().dropDomainIfExists(domain);
    }





































































    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropIndexOnStep dropIndex(@Stringly.Name String index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropIndexOnStep dropIndex(Name index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndex(Index)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropIndexOnStep dropIndex(Index index) {
        return dsl().dropIndex(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(@Stringly.Name String index) {
        return dsl().dropIndexIfExists(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(Name index) {
        return dsl().dropIndexIfExists(index);
    }

    /**
     * The <code>DROP INDEX IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropIndexIfExists(Index)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, POSTGRES, SQLITE })
    public static org.jooq.DropIndexOnStep dropIndexIfExists(Index index) {
        return dsl().dropIndexIfExists(index);
    }





































































    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchema(@Stringly.Name String schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchema(Name schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchema(Schema schema) {
        return dsl().dropSchema(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(@Stringly.Name String schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(Name schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SCHEMA IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSchemaIfExists(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropSchemaStep dropSchemaIfExists(Schema schema) {
        return dsl().dropSchemaIfExists(schema);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequence(@Stringly.Name String sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequence(Name sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequence(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequence(Sequence<?> sequence) {
        return dsl().dropSequence(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(@Stringly.Name String sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(Name sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }

    /**
     * The <code>DROP SEQUENCE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropSequenceIfExists(Sequence)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static org.jooq.DropSequenceFinalStep dropSequenceIfExists(Sequence<?> sequence) {
        return dsl().dropSequenceIfExists(sequence);
    }

    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(@Stringly.Name String table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(Name table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.DropTableStep dropTable(Table<?> table) {
        return dsl().dropTable(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropTableStep dropTableIfExists(@Stringly.Name String table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropTableStep dropTableIfExists(Name table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTableIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropTableStep dropTableIfExists(Table<?> table) {
        return dsl().dropTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTable(@Stringly.Name String table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTable(Name table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTable(Table<?> table) {
        return dsl().dropTemporaryTable(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(@Stringly.Name String table) {
        return dsl().dropTemporaryTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(Name table) {
        return dsl().dropTemporaryTableIfExists(table);
    }

    /**
     * The <code>DROP TEMPORARY TABLE IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropTemporaryTableIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.DropTableStep dropTemporaryTableIfExists(Table<?> table) {
        return dsl().dropTemporaryTableIfExists(table);
    }





































































    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropView(@Stringly.Name String view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropView(Name view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropView(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropView(Table<?> view) {
        return dsl().dropView(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(String)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropViewIfExists(@Stringly.Name String view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropViewIfExists(Name view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>DROP VIEW IF EXISTS</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#dropViewIfExists(Table)
     */
    @NotNull @CheckReturnValue
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static org.jooq.DropViewFinalStep dropViewIfExists(Table<?> view) {
        return dsl().dropViewIfExists(view);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.GrantOnStep grant(Privilege privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.GrantOnStep grant(Privilege... privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>GRANT</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#grant(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.GrantOnStep grant(Collection<? extends Privilege> privileges) {
        return dsl().grant(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RevokeOnStep revoke(Privilege privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RevokeOnStep revoke(Privilege... privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revoke(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RevokeOnStep revoke(Collection<? extends Privilege> privileges) {
        return dsl().revoke(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Privilege)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Privilege privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Privilege...)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Privilege... privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>REVOKE GRANT OPTION FOR</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#revokeGrantOptionFor(Collection)
     */
    @NotNull @CheckReturnValue
    @Support({ HSQLDB, POSTGRES })
    public static org.jooq.RevokeOnStep revokeGrantOptionFor(Collection<? extends Privilege> privileges) {
        return dsl().revokeGrantOptionFor(privileges);
    }

    /**
     * The <code>SET</code> statement.
     * <p>
     * Set a vendor specific session configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#set(Name, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ MYSQL, POSTGRES })
    public static org.jooq.RowCountQuery set(Name name, Param<?> value) {
        return dsl().set(name, value);
    }

    /**
     * The <code>SET LOCAL</code> statement.
     * <p>
     * Set a vendor specific transaction-local configuration to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setLocal(Name, Param)
     */
    @NotNull @CheckReturnValue
    @Support({ POSTGRES })
    public static org.jooq.RowCountQuery setLocal(Name name, Param<?> value) {
        return dsl().setLocal(name, value);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(String)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(@Stringly.Name String catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(Name catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET CATALOG</code> statement.
     * <p>
     * Set the current catalog to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setCatalog(Catalog)
     */
    @NotNull @CheckReturnValue
    @Support({ MARIADB, MYSQL })
    public static org.jooq.RowCountQuery setCatalog(Catalog catalog) {
        return dsl().setCatalog(catalog);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(String)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RowCountQuery setSchema(@Stringly.Name String schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(Name)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RowCountQuery setSchema(Name schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>SET SCHEMA</code> statement.
     * <p>
     * Set the current schema to a new value.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#setSchema(Schema)
     */
    @NotNull @CheckReturnValue
    @Support({ DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static org.jooq.RowCountQuery setSchema(Schema schema) {
        return dsl().setSchema(schema);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(@Stringly.Name String table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncate(Name table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncate(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static <R extends Record> org.jooq.TruncateIdentityStep<R> truncate(Table<R> table) {
        return dsl().truncate(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(String)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(@Stringly.Name String table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Name)
     */
    @NotNull @CheckReturnValue
    @Support
    public static org.jooq.TruncateIdentityStep<Record> truncateTable(Name table) {
        return dsl().truncateTable(table);
    }

    /**
     * The <code>TRUNCATE TABLE</code> statement.
     * <p>
     * Unlike statement construction methods in the {@link DSLContext} API, this
     * creates an unattached, and thus not directly renderable or executable
     * statement. It can be used as a subquery or nested in procedural logic.
     *
     * @see DSLContext#truncateTable(Table)
     */
    @NotNull @CheckReturnValue
    @Support
    public static <R extends Record> org.jooq.TruncateIdentityStep<R> truncateTable(Table<R> table) {
        return dsl().truncateTable(table);
    }















































    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTable(String)
     */
    @NotNull
    @Support
    public static CreateTableColumnStep createTable(String table) {
        return dsl().createTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTable(Name)
     */
    @NotNull
    @Support
    public static CreateTableColumnStep createTable(Name table) {
        return dsl().createTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTable(Table)
     */
    @NotNull
    @Support
    public static CreateTableColumnStep createTable(Table<?> table) {
        return dsl().createTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTableIfNotExists(String)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateTableColumnStep createTableIfNotExists(String table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTableIfNotExists(Name)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateTableColumnStep createTableIfNotExists(Name table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE TABLE</code> statement.
     *
     * @see DSLContext#createTableIfNotExists(Table)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateTableColumnStep createTableIfNotExists(Table<?> table) {
        return dsl().createTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTable(String)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTable(String table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTable(Name)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTable(Name table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTable(Table)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTable(Table<?> table) {
        return dsl().createTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(String)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTableIfNotExists(String table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(Name)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTableIfNotExists(Name table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createTemporaryTableIfNotExists(Table)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createTemporaryTableIfNotExists(Table<?> table) {
        return dsl().createTemporaryTableIfNotExists(table);
    }

    /**
     * Create a new DSL <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createGlobalTemporaryTable(String)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createGlobalTemporaryTable(String table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createGlobalTemporaryTable(Name)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createGlobalTemporaryTable(Name table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE GLOBAL TEMPORARY TABLE</code> statement.
     *
     * @see DSLContext#createGlobalTemporaryTable(Table)
     */
    @NotNull
    @Support({ FIREBIRD, MARIADB, MYSQL, POSTGRES })
    public static CreateTableColumnStep createGlobalTemporaryTable(Table<?> table) {
        return dsl().createGlobalTemporaryTable(table);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     *
     * @see DSLContext#createView(String, String...)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(String view, String... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     *
     * @see DSLContext#createView(Name, Name...)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(Name view, Name... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     *
     * @see DSLContext#createView(Table, Field...)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(Table<?> view, Field<?>... fields) {
        return dsl().createView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW</code> statement.
     * <p>
     * This works like {@link #createView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createView(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createView(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     *
     * @see DSLContext#createOrReplaceView(String, String...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(String view, String... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     *
     * @see DSLContext#createOrReplaceView(Name, Name...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(Name view, Name... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     *
     * @see DSLContext#createOrReplaceView(Table, Field...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(Table<?> view, Field<?>... fields) {
        return dsl().createOrReplaceView(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE OR REPLACE VIEW</code> statement.
     * <p>
     * This works like {@link #createOrReplaceView(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createOrReplaceView(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES })
    public static CreateViewAsStep createOrReplaceView(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createOrReplaceView(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     *
     * @see DSLContext#createViewIfNotExists(String, String...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(String view, String... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     *
     * @see DSLContext#createViewIfNotExists(Name, Name...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(Name view, Name... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     *
     * @see DSLContext#createViewIfNotExists(Table, Field...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(Table<?> view, Field<?>... fields) {
        return dsl().createViewIfNotExists(view, fields);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(String, String...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(String, String...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(String view, Function<? super Field<?>, ? extends String> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(Name, Name...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(Name, Name...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(Name view, Function<? super Field<?>, ? extends Name> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE VIEW IF NOT EXISTS</code> statement.
     * <p>
     * This works like {@link #createViewIfNotExists(Table, Field...)} except that the
     * view's field names are derived from the view's {@link Select} statement
     * using a function.
     *
     * @see DSLContext#createViewIfNotExists(Table, Field...)
     * @deprecated - 3.14.0 - [#10156] - These methods will be removed without
     *             replacement from a future jOOQ. They offer convenience that
     *             is unidiomatic for jOOQ's DSL, without offering functionality
     *             that would not be possible otherwise - yet they add
     *             complexity in jOOQ's internals.
     */
    @Deprecated(forRemoval = true, since = "3.14")
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static CreateViewAsStep createViewIfNotExists(Table<?> view, Function<? super Field<?>, ? extends Field<?>> fieldNameFunction) {
        return dsl().createViewIfNotExists(view, fieldNameFunction);
    }

    /**
     * Create a new DSL <code>CREATE TYPE</code> statement.
     *
     * @see DSLContext#createType(String)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static CreateTypeStep createType(String type) {
        return dsl().createType(type);
    }

    /**
     * Create a new DSL <code>CREATE TYPE</code> statement.
     *
     * @see DSLContext#createType(Name)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static CreateTypeStep createType(Name type) {
        return dsl().createType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropType(String)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropType(String type) {
        return dsl().dropType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropType(Name)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropType(Name type) {
        return dsl().dropType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropType(String...)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropType(String... type) {
        return dsl().dropType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropType(Name...)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropType(Name... type) {
        return dsl().dropType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropType(Collection)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropType(Collection<?> type) {
        return dsl().dropType(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropTypeIfExists(String)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropTypeIfExists(String type) {
        return dsl().dropTypeIfExists(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropTypeIfExists(Name)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropTypeIfExists(Name type) {
        return dsl().dropTypeIfExists(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropTypeIfExists(String...)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropTypeIfExists(String... type) {
        return dsl().dropTypeIfExists(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropTypeIfExists(Name...)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropTypeIfExists(Name... type) {
        return dsl().dropTypeIfExists(type);
    }

    /**
     * Create a new DSL <code>DROP TYPE</code> statement.
     *
     * @see DSL#dropTypeIfExists(Collection)
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static DropTypeStep dropTypeIfExists(Collection<?> type) {
        return dsl().dropTypeIfExists(type);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(String)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(String table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(Name)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(Name table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTable(Table)
     */
    @NotNull
    @Support
    public static AlterTableStep alterTable(Table<?> table) {
        return dsl().alterTable(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(String)
     */
    @NotNull
    @Support({ H2, IGNITE, MARIADB, POSTGRES })
    public static AlterTableStep alterTableIfExists(String table) {
        return dsl().alterTableIfExists(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(Name)
     */
    @NotNull
    @Support({ H2, IGNITE, MARIADB, POSTGRES })
    public static AlterTableStep alterTableIfExists(Name table) {
        return dsl().alterTableIfExists(table);
    }

    /**
     * Create a new DSL <code>ALTER TABLE</code> statement.
     *
     * @see DSLContext#alterTableIfExists(Table)
     */
    @NotNull
    @Support({ H2, IGNITE, MARIADB, POSTGRES })
    public static AlterTableStep alterTableIfExists(Table<?> table) {
        return dsl().alterTableIfExists(table);
    }

    // -------------------------------------------------------------------------
    // XXX Quantified comparison predicate expressions
    // -------------------------------------------------------------------------

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> QuantifiedSelect<R> all(Select<R> select) {
        return new QuantifiedSelectImpl<>(Quantifier.ALL, select);
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static <T> QuantifiedSelect<Record1<T>> all(T... array) {
        return array instanceof Field[] ? all((Field<T>[]) array) : new QuantifiedSelectImpl<>(Quantifier.ALL, val(array));
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> QuantifiedSelect<Record1<T>> all(Field<T[]> array) {
        return new QuantifiedSelectImpl<>(Quantifier.ALL, array);
    }

    /**
     * Create an <code>ALL</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> QuantifiedSelect<Record1<T>> all(Field<T>... fields) {
        return new QuantifiedSelectImpl<>(Quantifier.ALL, fields);
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> QuantifiedSelect<R> any(Select<R> select) {
        return new QuantifiedSelectImpl<>(Quantifier.ANY, select);
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static <T> QuantifiedSelect<Record1<T>> any(T... array) {
        return array instanceof Field[] ? any((Field<T>[]) array) : new QuantifiedSelectImpl<>(Quantifier.ANY, val(array));
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> QuantifiedSelect<Record1<T>> any(Field<T[]> array) {
        return new QuantifiedSelectImpl<>(Quantifier.ANY, array);
    }

    /**
     * Create an <code>ANY</code> quantified select to be used in quantified
     * comparison predicate expressions.
     * <p>
     * This is natively supported by {@link SQLDialect#POSTGRES}. Other dialects
     * will render a subselect unnesting the array.
     *
     * @see Field#equal(QuantifiedSelect)
     * @see Field#notEqual(QuantifiedSelect)
     * @see Field#greaterThan(QuantifiedSelect)
     * @see Field#greaterOrEqual(QuantifiedSelect)
     * @see Field#lessThan(QuantifiedSelect)
     * @see Field#lessOrEqual(QuantifiedSelect)
     * @see Field#like(QuantifiedSelect)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> QuantifiedSelect<Record1<T>> any(Field<T>... fields) {
        return new QuantifiedSelectImpl<>(Quantifier.ANY, fields);
    }

    // -------------------------------------------------------------------------
    // XXX Other objects
    // -------------------------------------------------------------------------

    /**
     * Create a collation by its unqualified name.
     */
    @NotNull
    @Support({ HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Collation collation(String collation) {
        return collation(name(collation));
    }

    /**
     * Create a collation by its qualified name.
     */
    @NotNull
    @Support({ HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Collation collation(Name collation) {
        return new CollationImpl(collation);
    }

    /**
     * Create a character set by its unqualified name.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static CharacterSet characterSet(String characterSet) {
        return characterSet(name(characterSet));
    }

    /**
     * Create a character set by its qualified name.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static CharacterSet characterSet(Name characterSet) {
        return new CharacterSetImpl(characterSet);
    }

    /**
     * Create a new privilege reference.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     */
    @PlainSQL
    @NotNull
    @Support
    public static Privilege privilege(String privilege) {
        return privilege(keyword(privilege));
    }

    /**
     * Create a new privilege reference.
     */
    @NotNull
    @Support
    static Privilege privilege(Keyword privilege) {
        return new PrivilegeImpl(privilege);
    }

    /**
     * Create a new user reference.
     *
     * @see #user(Name)
     */
    @NotNull
    @Support
    public static User user(String name) {
        return user(name(name));
    }

    /**
     * Create a new user reference.
     */
    @NotNull
    @Support
    public static User user(Name name) {
        return new UserImpl(name);
    }

    /**
     * Create a new role reference.
     *
     * @see #role(Name)
     */
    @NotNull
    @Support
    public static Role role(String name) {
        return role(name(name));
    }

    /**
     * Create a new role reference.
     */
    @NotNull
    @Support
    public static Role role(Name name) {
        return new RoleImpl(name);
    }

    // -------------------------------------------------------------------------
    // XXX Conversion of objects into tables
    // -------------------------------------------------------------------------

    /**
     * A synonym for {@link Select#asTable()}, which might look a bit more fluent
     * like this, to some users.
     *
     * @see Select#asTable()
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(Select<R> select) {
        return select.asTable();
    }

    /**
     * Use a previously obtained result as a new {@link Table} that can be used
     * in SQL statements through {@link #values(RowN...)}.
     *
     * @see #values(RowN...)
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(Result<R> result) {

        // TODO [#2986] Coerce the record type upon the resulting table.
        return (Table<R>) values0(map(result, r -> r.valuesRow(), Row[]::new)).as(
            name("v"),
            map(result.fields(), f -> f.getUnqualifiedName(), Name[]::new)
        );
    }

    /**
     * Use a previously obtained record as a new Table
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(R record) {
        return table((R[]) new Record[] { record });
    }

    /**
     * Use a previously obtained set of records as a new Table
     */
    @NotNull
    @Support
    public static <R extends Record> Table<R> table(R... records) {
        if (records == null || records.length == 0)
            return (Table<R>) new Dual();

        Result<R> result = new ResultImpl(configuration(records[0]), (AbstractRow) records[0].fieldsRow());
        result.addAll(Arrays.asList(records));

        return table(result);
    }

    /**
     * A synonym for {@link #unnest(Collection)}.
     *
     * @see #unnest(Collection)
     */
    @NotNull
    @Support
    public static Table<?> table(Collection<?> list) {
        return table(list.toArray());
    }

    /**
     * A synonym for {@link #unnest(Object[])}.
     *
     * @see #unnest(Object[])
     */
    @NotNull
    @Support
    public static Table<?> table(Object[] array) {
        return unnest0(val(array));
    }















    /**
     * A synonym for {@link #unnest(Field)}.
     *
     * @see #unnest(Field)
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Table<?> table(Field<?> cursor) {
        return unnest0(cursor);
    }

    /**
     * Create a table from a list of values.
     * <p>
     * This is equivalent to the <code>TABLE</code> function for H2, or the
     * <code>UNNEST</code> function in HSQLDB and Postgres
     * <p>
     * For Oracle, use {@link #table(ArrayRecord)} instead, as Oracle knows only
     * typed arrays
     * <p>
     * In all other dialects, unnesting of arrays is emulated using several
     * <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support
    public static Table<?> unnest(Collection<?> list) {
        return unnest(list.toArray());
    }

    /**
     * Create a table from an array of values.
     * <p>
     * This is equivalent to the <code>TABLE</code> function for H2, or the
     * <code>UNNEST</code> function in HSQLDB and Postgres
     * <p>
     * For Oracle, use {@link #table(ArrayRecord)} instead, as Oracle knows only
     * typed arrays
     * <p>
     * In all other dialects, unnesting of arrays is emulated using several
     * <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support
    public static Table<?> unnest(Object[] array) {
        return unnest0(val(array));
    }
















    /**
     * Create a table from a field.
     * <p>
     * The supplied field can have any of these types:
     * <ul>
     * <li> {@link Result}: For <code>CURSOR</code> or <code>REF CURSOR</code>
     * fields, typically fetched from stored functions or from nested tables</li>
     * <li> {@link ArrayRecord}: For Oracle-style <code>VARRAY</code> types.</li>
     * <li> {@link Object}[]: Array types, for other RDBMS's ARRAY types (e.g.
     * H2, HSQLDB, and Postgres)</li>
     * <li> {@link Object}: Any other type that jOOQ will try to convert in an
     * array first, before converting that array into a table</li>
     * </ul>
     * <p>
     * This functionality has only limited scope when used in H2, as ARRAY types
     * involved with stored functions can only be of type <code>Object[]</code>.
     * Such arrays are converted into <code>VARCHAR</code> arrays by jOOQ.
     * <p>
     * In all dialects where arrays are not supported, unnesting of arrays is
     * emulated using several <code>UNION ALL</code> connected subqueries.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Table<?> unnest(Field<?> cursor) {
        return unnest0(cursor);
    }

    private static Table<?> unnest0(Field<?> cursor) {
        if (cursor == null)
            throw new IllegalArgumentException();

        // The field is an actual CURSOR or REF CURSOR returned from a stored
        // procedure or from a NESTED TABLE
        else if (cursor.getType() == Result.class)
            return new FunctionTable<Record>(cursor);











        // The field is a regular array
        else if (cursor.getType().isArray() && cursor.getType() != byte[].class)
            return new ArrayTable(cursor);

        // The field has any other type. Try to make it an array
        throw new SQLDialectNotSupportedException("Converting arbitrary types into array tables is currently not supported");
    }

    // -------------------------------------------------------------------------
    // XXX Table functions
    // -------------------------------------------------------------------------

    /**
     * The <code>DUAL</code> table to be used for syntactic completeness.
     * <p>
     * In general, jOOQ will generate a <code>DUAL</code> table (or any
     * equivalent construct, see below), if this is needed syntactically in
     * generated SQL. You may still wish to explicitly use a <code>DUAL</code>
     * construct in jOOQ code for various reasons. This <code>DUAL</code> table
     * will always contain a single record with a single varchar(1) value:
     * <code><pre>
     * +-------+
     * | DUMMY |
     * +-------+
     * | X     |
     * +-------+
     * </pre></code>
     */
    @NotNull
    @Support
    public static Table<Record> dual() {
        return new Dual(true);
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, int to) {
        return generateSeries(val(from), val(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to) {
        return generateSeries(val(from), Tools.nullSafe(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to) {
        return new GenerateSeries(Tools.nullSafe(from), val(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive).
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL - 1 FROM DUAL CONNECT BY a + LEVEL - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects
     * may be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c- 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, int to, int step) {
        return generateSeries(val(from), val(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to, int step) {
        return generateSeries(val(from), Tools.nullSafe(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to, int step) {
        return new GenerateSeries(Tools.nullSafe(from), val(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to, int step) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to), val(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects
     * may be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c- 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, int to, Field<Integer> step) {
        return generateSeries(val(from), val(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(int from, Field<Integer> to, Field<Integer> step) {
        return generateSeries(val(from), Tools.nullSafe(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, int to, Field<Integer> step) {
        return new GenerateSeries(Tools.nullSafe(from), val(to), Tools.nullSafe(step));
    }

    /**
     * A table function generating a series of values from <code>from</code> to
     * <code>to</code> (inclusive), increasing values by <code>step</code>.
     * <p>
     * This function is inspired by PostgreSQL's
     * <code>GENERATE_SERIES(from, to, step)</code> function. Other SQL dialects may
     * be capable of emulating this behaviour, e.g. Oracle: <code><pre>
     * -- PostgreSQL
     * SELECT * FROM GENERATE_SERIES(a, b, c)
     *
     * -- Oracle
     * SELECT * FROM (SELECT a + LEVEL * c - 1 FROM DUAL CONNECT BY a + LEVEL * c - 1 &lt;= b)
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Table<Record1<Integer>> generateSeries(Field<Integer> from, Field<Integer> to, Field<Integer> step) {
        return new GenerateSeries(Tools.nullSafe(from), Tools.nullSafe(to), Tools.nullSafe(step));
    }

    /**
     * Create a <code>LATERAL</code> joined table.
     * <p>
     * Example:
     * <code><pre>
     * SELECT *
     * FROM employees e,
     *      LATERAL(SELECT * FROM departments d
     *              WHERE e.department_id = d.department_id);
     * </pre></code>
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static <R extends Record> Table<R> lateral(TableLike<R> table) {
        return new Lateral<>(table.asTable());
    }

    /**
     * Create a <code>ROWS FROM (tables...)</code> expression.
     * <p>
     * Example: <code><pre>
     * SELECT *
     * FROM ROWS FROM (function1('a', 'b'), function2('c', 'd'));
     * </pre></code>
     * <p>
     * This allows for full outer joining several table-valued functions on the
     * row number of each function's produced rows.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Table<Record> rowsFrom(Table<?>... tables) {
        return new RowsFrom(tables);
    }

    // -------------------------------------------------------------------------
    // XXX SQL keywords
    // -------------------------------------------------------------------------

    /**
     * Create a SQL keyword.
     * <p>
     * A <code>Keyword</code> is a {@link QueryPart} that renders a SQL keyword
     * according to the settings specified in
     * {@link Settings#getRenderKeywordCase()}. It can be embedded in other
     * plain SQL <code>QueryParts</code> as shown in this example:
     * <p>
     * <code><pre>
     * Condition c = condition("{0} {1} {2} {3} {4}",
     *     value1, keyword("between")
     *     value2, keyword("and")
     *     value3
     * );
     * </pre></code>
     */
    @NotNull
    @Support
    public static Keyword keyword(String keyword) {
        return new KeywordImpl(keyword);
    }

    // -------------------------------------------------------------------------
    // XXX Names
    // -------------------------------------------------------------------------

    /**
     * Create a new SQL identifier using an unqualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <code><pre>
     * // This unqualified name here
     * name("book");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </pre></code>
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName);
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <code><pre>
     * // This qualified name here
     * name("book", "title");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </pre></code>
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(String... qualifiedName) {
        if (qualifiedName == null || qualifiedName.length != 1)
            return new QualifiedName(qualifiedName);
        else
            return new UnqualifiedName(qualifiedName[0]);
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Unlike other {@link #name(String...)} constructors, this one constructs a
     * name from its argument {@link Name#unqualifiedName()} parts, retaining
     * the quoted flag, to construct a new name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li>{@link #field(Name)}</li>
     * <li>{@link #field(Name, Class)}</li>
     * <li>{@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <code><pre>
     * // This qualified name here
     * name(quotedName("book"), unquotedName("title"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].title
     * </pre></code>
     *
     * @param nameParts The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(Name... nameParts) {
        return new QualifiedName(nameParts);
    }

    /**
     * Create a new SQL identifier using a qualified name.
     * <p>
     * Use this method to construct syntax-safe, SQL-injection-safe SQL
     * identifiers for use in plain SQL where {@link QueryPart} objects are
     * accepted. For instance, this can be used with any of these methods:
     * <ul>
     * <li> {@link #field(Name)}</li>
     * <li> {@link #field(Name, Class)}</li>
     * <li> {@link #field(Name, DataType)}</li>
     * </ul>
     * <p>
     * An example: <code><pre>
     * // This qualified name here
     * name("book", "title");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [book].[title]
     * </pre></code>
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name name(Collection<String> qualifiedName) {
        return name(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    /**
     * Create a new SQL identifier using an unqualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName, Quoted.QUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(String... qualifiedName) {
        return new QualifiedName(qualifiedName, Quoted.QUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(Collection)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name quotedName(Collection<String> qualifiedName) {
        return quotedName(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    /**
     * Create a new SQL identifier using an unqualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param unqualifiedName The SQL identifier's unqualified name
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(String unqualifiedName) {
        return new UnqualifiedName(unqualifiedName, Quoted.UNQUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(String...)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(String... qualifiedName) {
        if (qualifiedName == null || qualifiedName.length != 1)
            return new QualifiedName(qualifiedName, Quoted.UNQUOTED);
        else
            return new UnqualifiedName(qualifiedName[0], Quoted.UNQUOTED);
    }

    /**
     * Create a new SQL identifier using a qualified, quoted name.
     * <p>
     * This works like {@link #name(Collection)}, except that generated
     * identifiers will be guaranteed to be quoted in databases that support
     * quoted identifiers.
     *
     * @param qualifiedName The SQL identifier's qualified name parts
     * @return A {@link QueryPart} that will render the SQL identifier
     */
    @NotNull
    @Support
    public static Name unquotedName(Collection<String> qualifiedName) {
        return unquotedName(qualifiedName.toArray(Tools.EMPTY_STRING));
    }

    // -------------------------------------------------------------------------
    // XXX QueryPart composition
    // -------------------------------------------------------------------------

    /**
     * Compose a list of <code>QueryParts</code> into a new
     * <code>QueryPart</code>, with individual parts being comma-separated.
     */
    @NotNull
    @Support
    public static QueryPart list(QueryPart... parts) {
        return list(Arrays.asList(parts));
    }

    /**
     * Compose a list of <code>QueryParts</code> into a new
     * <code>QueryPart</code>, with individual parts being comma-separated.
     */
    @NotNull
    @Support
    public static QueryPart list(Collection<? extends QueryPart> parts) {
        return new QueryPartList<>(parts);
    }

    // -------------------------------------------------------------------------
    // XXX SQL identifiers
    // -------------------------------------------------------------------------

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * While the <code>DEFAULT</code> keyword works with all data types, you may
     * still prefer to associate a {@link Field} type with your
     * <code>DEFAULT</code> value. In that case, use
     * {@link #defaultValue(Class)} or {@link #defaultValue(DataType)} instead.
     * <p>
     * This is an alias for {@link #default_()}.
     *
     * @see #default_()
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Object> defaultValue() {
        return default_();
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(Class)}.
     *
     * @see #default_(Class)
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> defaultValue(Class<T> type) {
        return default_(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(DataType)}.
     *
     * @see #default_(DataType)
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> defaultValue(DataType<T> type) {
        return default_(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * This is an alias for {@link #default_(Field)}.
     *
     * @see #default_(Field)
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> defaultValue(Field<T> field) {
        return default_(field);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     * <p>
     * While the <code>DEFAULT</code> keyword works with all data types, you may
     * still prefer to associate a {@link Field} type with your
     * <code>DEFAULT</code> value. In that case, use
     * {@link #defaultValue(Class)} or {@link #defaultValue(DataType)} instead.
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Object> default_() {
        return default_(Object.class);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> default_(Class<T> type) {
        return default_(getDataType(type));
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> default_(DataType<T> type) {
        return new Default<T>(type);
    }

    /**
     * Create a <code>DEFAULT</code> keyword for use with <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>MERGE</code> statements.
     */
    @NotNull
    @Support({ CUBRID, DERBY, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T> Field<T> default_(Field<T> field) {
        return default_(field.getDataType());
    }

    /**
     * Create a qualified schema, given its schema name.
     * <p>
     * This constructs a schema reference given the schema's qualified name.
     * <p>
     * Example: <code><pre>
     * // This schema...
     * schemaByName("MY_SCHEMA");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA]
     * </pre></code>
     *
     * @param name The schema's reference name.
     * @return A schema referenced by <code>name</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #schema(Name)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    public static Schema schemaByName(String name) {
        return new SchemaImpl(name);
    }

    /**
     * Create a qualified catalog, given its catalog name.
     * <p>
     * This constructs a catalog reference given the catalog's qualified name.
     * <p>
     * Example: <code><pre>
     * // This catalog...
     * catalog(name("MY_CATALOG"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG]
     * </pre></code>
     */
    @NotNull
    @Support
    public static Catalog catalog(String name) {
        return catalog(name(name));
    }

    /**
     * Create a qualified catalog, given its catalog name.
     * <p>
     * This constructs a catalog reference given the catalog's qualified name.
     * <p>
     * Example: <code><pre>
     * // This catalog...
     * catalog(name("MY_CATALOG"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG]
     * </pre></code>
     */
    @NotNull
    @Support
    public static Catalog catalog(Name name) {
        return new CatalogImpl(name);
    }

    /**
     * Create a qualified schema, given its schema name.
     * <p>
     * This constructs a schema reference given the schema's qualified name.
     * <p>
     * Example: <code><pre>
     * // This schema...
     * schema(name("MY_CATALOG", "MY_SCHEMA"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG].[MY_SCHEMA]
     * </pre></code>
     */
    @NotNull
    @Support
    public static Schema schema(String name) {
        return schema(name(name));
    }

    /**
     * Create a qualified schema, given its schema name.
     * <p>
     * This constructs a schema reference given the schema's qualified name.
     * <p>
     * Example: <code><pre>
     * // This schema...
     * schema(name("MY_CATALOG", "MY_SCHEMA"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_CATALOG].[MY_SCHEMA]
     * </pre></code>
     */
    @NotNull
    @Support
    public static Schema schema(Name name) {
        return new SchemaImpl(name);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequenceByName("MY_SCHEMA", "MY_SEQUENCE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your sequence's
     *            reference name.
     * @return A sequence referenced by <code>sequenceName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #sequence(Name)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static Sequence<BigInteger> sequenceByName(String... qualifiedName) {
        return sequenceByName(BigInteger.class, qualifiedName);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequenceByName("MY_SCHEMA", "MY_SEQUENCE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your sequence's
     *            reference name.
     * @param type The type of the returned field
     * @return A sequence referenced by <code>sequenceName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #sequence(Name, Class)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static <T extends Number> Sequence<T> sequenceByName(Class<T> type, String... qualifiedName) {
        return sequenceByName(getDataType(type), qualifiedName);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequenceByName("MY_SCHEMA", "MY_SEQUENCE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your sequence's
     *            reference name.
     * @param type The type of the returned field
     * @return A sequence referenced by <code>sequenceName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #sequence(Name, DataType)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static <T extends Number> Sequence<T> sequenceByName(DataType<T> type, String... qualifiedName) {
        return sequence(name(qualifiedName), type);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static Sequence<BigInteger> sequence(Name name) {
        return sequence(name, BigInteger.class);
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     *
     * @param name The sequence name
     * @param type The sequence type (a type that is supported by
     *            {@link SQLDataType})
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static <T extends Number> Sequence<T> sequence(Name name, Class<T> type) {
        return sequence(name, getDataType(type));
    }

    /**
     * Create a qualified sequence, given its sequence name.
     * <p>
     * This constructs a sequence reference given the sequence's qualified name.
     * <p>
     * Example: <code><pre>
     * // This sequence...
     * sequence(name("MY_SCHEMA", "MY_SEQUENCE"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_SEQUENCE]
     * </pre></code>
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, POSTGRES })
    public static <T extends Number> Sequence<T> sequence(Name name, DataType<T> type) {
        return new SequenceImpl<>(
            name.unqualifiedName(),
            name.qualified() ? schema(name.qualifier()) : null,
            type,
            false
        );
    }

    /**
     * Create a qualified table, given its table name.
     * <p>
     * This constructs a table reference given the table's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This table...
     * tableByName("MY_SCHEMA", "MY_TABLE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your table's reference
     *            name.
     * @return A table referenced by <code>tableName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #table(Name)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    public static Table<Record> tableByName(String... qualifiedName) {
        return table(name(qualifiedName));
    }

    /**
     * Create a qualified table, given its table name.
     * <p>
     * This constructs a table reference given the table's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This table...
     * tableByName("MY_SCHEMA", "MY_TABLE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE]
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     */
    @NotNull
    @Support
    public static Table<Record> table(Name name) {
        return new TableImpl<>(name);
    }

    /**
     * Create a qualified table, given its table name.
     * <p>
     * This constructs a table reference given the table's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This table...
     * tableByName("MY_SCHEMA", "MY_TABLE");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE]
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     */
    @NotNull
    @Support
    public static Table<Record> table(Name name, Comment comment) {
        return new TableImpl<>(name, null, null, null, comment);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * fieldByName("MY_SCHEMA", "MY_TABLE", "MY_FIELD");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, fieldByName("TITLE")))
     *       .from(tableByName("T_BOOK"))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your field's reference
     *            name.
     * @return A field referenced by <code>fieldName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #field(Name)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    public static Field<Object> fieldByName(String... qualifiedName) {
        return fieldByName(Object.class, qualifiedName);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * fieldByName("MY_SCHEMA", "MY_TABLE", "MY_FIELD");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, fieldByName("TITLE")))
     *       .from(tableByName("T_BOOK"))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your field's reference
     *            name.
     * @param type The type of the returned field
     * @return A field referenced by <code>fieldName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #field(Name, Class)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    public static <T> Field<T> fieldByName(Class<T> type, String... qualifiedName) {
        return fieldByName(getDataType(type), qualifiedName);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * fieldByName("MY_SCHEMA", "MY_TABLE", "MY_FIELD");
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, fieldByName("TITLE")))
     *       .from(tableByName("T_BOOK"))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     *
     * @param qualifiedName The various parts making up your field's reference
     *            name.
     * @param type The type of the returned field
     * @return A field referenced by <code>fieldName</code>
     * @deprecated - [#3843] - 3.6.0 - use {@link #field(Name, DataType)} instead
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    public static <T> Field<T> fieldByName(DataType<T> type, String... qualifiedName) {
        return field(name(qualifiedName), type);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     */
    @NotNull
    @Support
    public static Field<Object> field(Name name) {
        return field(name, Object.class);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     *
     * @param name The field name
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, Class<T> type) {
        return field(name, getDataType(type));
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, DataType<T> type) {
        return field(name, type, null);
    }

    /**
     * Create a qualified field, given its (qualified) field name.
     * <p>
     * This constructs a field reference given the field's qualified name. jOOQ
     * <p>
     * Example: <code><pre>
     * // This field...
     * field(name("MY_SCHEMA", "MY_TABLE", "MY_FIELD"));
     *
     * // ... will render this SQL by default, using the SQL Server dialect
     * [MY_SCHEMA].[MY_TABLE].[MY_FIELD]
     * </pre></code>
     * <p>
     * Another example: <code><pre>
     * create.select(field("length({1})", Integer.class, field(name("TITLE"))))
     *       .from(table(name("T_BOOK")))
     *       .fetch();
     *
     * // ... will execute this SQL on SQL Server:
     * select length([TITLE]) from [T_BOOK]
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Name name, DataType<T> type, Comment comment) {
        return new TableFieldImpl<>(name, type, comment);
    }

    /**
     * Create a qualified index reference by name.
     */
    @NotNull
    @Support
    public static Index index(Name name) {
        return new IndexImpl(name);
    }





































































    // -------------------------------------------------------------------------
    // XXX: Routine parameter constructors
    // -------------------------------------------------------------------------

    /**
     * Create an <code>IN</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> in(String name, DataType<T> type) {
        return in(name(name), type);
    }

    /**
     * Create an <code>IN</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> in(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.IN, name, type);
    }

    /**
     * Create an <code>IN OUT</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> inOut(String name, DataType<T> type) {
        return inOut(name(name), type);
    }

    /**
     * Create an <code>IN OUT</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> inOut(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.INOUT, name, type);
    }

    /**
     * Create an <code>OUT</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> out(String name, DataType<T> type) {
        return out(name(name), type);
    }

    /**
     * Create an <code>OUT</code> parameter.
     */
    @NotNull
    @Support
    public static <T> Parameter<T> out(Name name, DataType<T> type) {
        return new ParameterImpl<>(ParamMode.OUT, name, type);
    }

    // -------------------------------------------------------------------------
    // XXX: Queries
    // -------------------------------------------------------------------------

    /**
     * Wrap a collection of queries.
     *
     * @see DSLContext#queries(Query...)
     */
    @NotNull
    @Support
    public static Queries queries(Query... queries) {
        return queries(Arrays.asList(queries));
    }

    /**
     * Wrap a collection of queries.
     *
     * @see DSLContext#queries(Collection)
     */
    @NotNull
    @Support
    public static Queries queries(Collection<? extends Query> queries) {
        return DSL.using(new DefaultConfiguration()).queries(queries);
    }

    /**
     * Wrap a collection of statements in an anonymous procedural block.
     *
     * @see DSLContext#begin(Statement...)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Block begin(Statement... statements) {
        return begin(Arrays.asList(statements));
    }

    /**
     * Wrap a collection of statements in an anonymous procedural block.
     *
     * @see DSLContext#begin(Collection)
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Block begin(Collection<? extends Statement> statements) {
        return DSL.using(new DefaultConfiguration()).begin(statements);
    }






























































































































































































































































































































































































































































































































































    // -------------------------------------------------------------------------
    // XXX Plain SQL object factory
    // -------------------------------------------------------------------------

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql) {
        return sql(sql, new Object[0]);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * This overload takes a set of {@link QueryPart} arguments which are
     * replaced into the SQL string template at the appropriate index. Example:
     * <p>
     * <code><pre>
     * // Argument QueryParts are replaced into the SQL string at the appropriate index
     * sql("select {0}, {1} from {2}", TABLE.COL1, TABLE.COL2, TABLE);
     *
     * // Bind variables are supported as well, for backwards compatibility
     * sql("select col1, col2 from table where col1 = ?", val(1));
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query part wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql, QueryPart... parts) {
        return sql(sql, (Object[]) parts);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL. There must be as many bind variables contained
     * in the SQL, as passed in the bindings parameter
     * <p>
     * This overload takes a set of bind value arguments which are replaced our
     * bound into the SQL string template at the appropriate index. Example:
     * <p>
     * <code><pre>
     * sql("select col1, col2 from table where col1 = ?", 1);
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static SQL sql(String sql, Object... bindings) {
        return new SQLImpl(sql, bindings);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @deprecated - 3.6.0 - [#3854] - Use {@link #sql(String)} instead
     * @see SQL
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    @PlainSQL
    public static QueryPart queryPart(String sql) {
        return sql(sql);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query part wrapping the plain SQL
     * @deprecated - 3.6.0 - [#3854] - Use {@link #sql(String, QueryPart...)} instead
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    @PlainSQL
    public static QueryPart queryPart(String sql, QueryPart... parts) {
        return sql(sql, parts);
    }

    /**
     * A custom SQL clause that can render arbitrary expressions.
     * <p>
     * A plain SQL <code>QueryPart</code> is a <code>QueryPart</code> that can
     * contain user-defined plain SQL, because sometimes it is easier to express
     * things directly in SQL. There must be as many bind variables contained
     * in the SQL, as passed in the bindings parameter
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query part wrapping the plain SQL
     * @deprecated - 3.6.0 - [#3854] - Use {@link #sql(String, Object...)} instead
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @Deprecated(forRemoval = true, since = "3.6")
    @NotNull
    @Support
    @PlainSQL
    public static QueryPart queryPart(String sql, Object... bindings) {
        return sql(sql, bindings);
    }

    // -------------------------------------------------------------------------
    // XXX Plain SQL API
    // -------------------------------------------------------------------------

    /**
     * Create a new query holding plain SQL. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "SET SCHEMA 'abc'";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(SQL sql) {
        return dsl().query(sql);
    }

    /**
     * Create a new query holding plain SQL. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "SET SCHEMA 'abc'";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A query wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql) {
        return dsl().query(sql);
    }

    /**
     * Create a new query holding plain SQL. There must be as many bind
     * variables contained in the SQL, as passed in the bindings parameter.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "SET SCHEMA 'abc'";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql, Object... bindings) {
        return dsl().query(sql, bindings);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * Unlike {@link #query(String, Object...)}, the SQL passed to this method
     * should not contain any bind variables. Instead, you can pass
     * {@link QueryPart} objects to the method which will be rendered at indexed
     * locations of your SQL string as such: <code><pre>
     * // The following query
     * query("select {0}, {1} from {2}", val(1), inline("test"), name("DUAL"));
     *
     * // Will render this SQL by default, using Oracle SQL dialect
     * select ?, 'test' from "DUAL"
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link DSL#name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static RowCountQuery query(String sql, QueryPart... parts) {
        return dsl().query(sql, parts);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <code><pre>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</pre></code> Example
     * (SQLite):
     * <p>
     * <code><pre>
     * String sql = "pragma table_info('my_table')";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return An executable query
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(SQL sql) {
        return dsl().resultQuery(sql);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <code><pre>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</pre></code> Example
     * (SQLite):
     * <p>
     * <code><pre>
     * String sql = "pragma table_info('my_table')";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return An executable query
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql) {
        return dsl().resultQuery(sql);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * There must be as many bind variables contained in the SQL, as passed in
     * the bindings parameter
     * <p>
     * Use this method, when you want to take advantage of the many ways to
     * fetch results in jOOQ, using {@link ResultQuery}. Some examples:
     * <p>
     * <table border="1">
     * <tr>
     * <td> {@link ResultQuery#fetchLazy()}</td>
     * <td>Open a cursor and fetch records one by one</td>
     * </tr>
     * <tr>
     * <td> {@link ResultQuery#fetchInto(Class)}</td>
     * <td>Fetch records into a custom POJO (optionally annotated with JPA
     * annotations)</td>
     * </tr>
     * </table>
     * <p>
     * Example (Postgres):
     * <p>
     * <code><pre>
     * String sql = "FETCH ALL IN \"&lt;unnamed cursor 1&gt;\"";</pre></code> Example
     * (SQLite):
     * <p>
     * <code><pre>
     * String sql = "pragma table_info('my_table')";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql, Object... bindings) {
        return dsl().resultQuery(sql, bindings);
    }

    /**
     * Create a new query holding plain SQL.
     * <p>
     * Unlike {@link #resultQuery(String, Object...)}, the SQL passed to this
     * method should not contain any bind variables. Instead, you can pass
     * {@link QueryPart} objects to the method which will be rendered at indexed
     * locations of your SQL string as such: <code><pre>
     * // The following query
     * resultQuery("select {0}, {1} from {2}", val(1), inline("test"), name("DUAL"));
     *
     * // Will render this SQL by default, using Oracle SQL dialect
     * select ?, 'test' from "DUAL"
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link DSL#name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A query wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static ResultQuery<Record> resultQuery(String sql, QueryPart... parts) {
        return dsl().resultQuery(sql, parts);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <code><pre>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = 'MY_SCHEMA')";
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(SQL sql) {
        return new SQLTable(sql);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <code><pre>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = 'MY_SCHEMA')";
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql) {
        return table(sql, new Object[0]);
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * There must be as many bind variables contained in the SQL, as passed
     * in the bindings parameter
     * <p>
     * Example
     * <p>
     * <code><pre>
     * String sql = "(SELECT * FROM USER_TABLES WHERE OWNER = ?)";
     * Object[] bindings = new Object[] { "MY_SCHEMA" };
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A table wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql, Object... bindings) {
        return table(sql(sql, bindings));
    }

    /**
     * A custom SQL clause that can render arbitrary table expressions.
     * <p>
     * A plain SQL table is a table that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex, but static subqueries or tables from different schemas.
     * <p>
     * Example
     * <p>
     * <code><pre>
     * String sql = "(SELECT * FROM USER_TABLES WHERE {0})";
     * QueryPart[] parts = new QueryPart[] { USER_TABLES.OWNER.equal("MY_SCHEMA") };
     * </pre></code>
     * <p>
     * The returned table does not know its field references, i.e.
     * {@link Table#fields()} returns an empty array.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A table wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Table<Record> table(String sql, QueryPart... parts) {
        return table(sql, (Object[]) parts);
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name)} instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, POSTGRES })
    @PlainSQL
    public static Sequence<BigInteger> sequence(String sql) {
        return sequence(sql, BigInteger.class);
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The sequence name
     * @param type The sequence type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name, Class)} instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, POSTGRES })
    @PlainSQL
    public static <T extends Number> Sequence<T> sequence(String sql, Class<T> type) {
        return sequence(sql, getDataType(type));
    }

    /**
     * Create a "plain SQL" sequence.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     * @deprecated - 3.10 - [#6162] - Use {@link #sequence(Name, DataType)}
     *             instead.
     */
    @Deprecated(forRemoval = true, since = "3.10")
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, POSTGRES })
    @PlainSQL
    public static <T extends Number> Sequence<T> sequence(String sql, DataType<T> type) {
        return new SequenceImpl<>(sql, null, type, true);
    }

    /**
     * Create the <code>VALUE</code> pseudo field for usage with
     * <code>DOMAIN</code> specifications.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> value(Class<T> type) {
        return value(DefaultDataType.getDataType(null, type));
    }

    /**
     * Create the <code>VALUE</code> pseudo field for usage with
     * <code>DOMAIN</code> specifications.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> value(DataType<T> type) {
        return field("{0}", type, N_VALUE);
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static Domain<?> domain(String name) {
        return domain(name(name));
    }

    /**
     * Create a <code>DOMAIN</code> reference.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, POSTGRES })
    public static Domain<?> domain(Name name) {
        return new DomainImpl<>(
            name.qualified() ? schema(name.qualifier()) : null,
            name.unqualifiedName(),
            new DefaultDataType<>(null, Object.class, name)
        );
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(SQL sql) {
        return field(sql, Object.class);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql) {
        return field(sql, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql, Object... bindings) {
        return field(sql, Object.class, bindings);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(SQL sql, Class<T> type) {
        return field(sql, getDataType(type));
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type) {
        return field(sql, type, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type, Object... bindings) {
        return field(sql, getDataType(type), bindings);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(SQL sql, DataType<T> type) {
        return new SQLField(type, sql);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must not be any binding
     * variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, 1, 100, 200)";
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @return A field wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type) {
        return field(sql, type, new Object[0]);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * A PlainSQLField is a field that can contain user-defined plain SQL,
     * because sometimes it is easier to express things directly in SQL, for
     * instance complex proprietary functions. There must be as many binding
     * variables contained in the SQL, as passed in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "DECODE(MY_FIELD, ?, ?, ?)";
     * Object[] bindings = new Object[] { 1, 100, 200 };</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param type The field type
     * @param bindings The bindings for the field
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type, Object... bindings) {
        return field(sql(sql, bindings), type);
    }

    /**
     * Create a "plain SQL" field.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL: <code><pre>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </pre></code>
     * <p>
     * The above MySQL function can be expressed as such: <code><pre>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL
     * @param type The field type
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, DataType<T> type, QueryPart... parts) {
        return field(sql(sql, parts), type);
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL: <code><pre>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </pre></code>
     * <p>
     * The above MySQL function can be expressed as such: <code><pre>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Field<Object> field(String sql, QueryPart... parts) {
        return field(sql, (Object[]) parts);
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Field</code> types are expected. An example for this is MySQL's
     * <code>GROUP_CONCAT</code> aggregate function, which has MySQL-specific
     * keywords that are hard to reflect in jOOQ's DSL: <code><pre>
     * GROUP_CONCAT([DISTINCT] expr [,expr ...]
     *       [ORDER BY {unsigned_integer | col_name | expr}
     *           [ASC | DESC] [,col_name ...]]
     *       [SEPARATOR str_val])
     *       </pre></code>
     * <p>
     * The above MySQL function can be expressed as such: <code><pre>
     * field("GROUP_CONCAT(DISTINCT {0} ORDER BY {1} ASC SEPARATOR '-')", expr1, expr2);
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL clause, containing {numbered placeholders} where query
     *            parts can be injected
     * @param type The field type (a type that is supported by
     *            {@link SQLDataType})
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A field wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> field(String sql, Class<T> type, QueryPart... parts) {
        return field(sql, getDataType(type), (Object[]) parts);
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The function name (without parentheses)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, Class<T> type, Field<?>... arguments) {
        return function(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The function name (without parentheses)
     * @param type The function return type
     * @param arguments The function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> Field<T> function(String name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.Function<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type (a type that is supported by
     *            {@link SQLDataType})
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, Class<T> type, Field<?>... arguments) {
        return function(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    public static <T> Field<T> function(Name name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.Function<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>function()</code> can be used to access native or user-defined
     * functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The function name (possibly qualified)
     * @param type The function return type
     * @param arguments The function arguments
     */
    @NotNull
    @Support
    static <T> Field<T> function(Name name, DataType<T> type, Field<?> argument) {
        return new org.jooq.impl.Function1<>(name, type, Tools.nullSafe(argument));
    }

    /**
     * <code>aggregate()</code> can be used to access native or user-defined
     * aggregate functions that are not yet or insufficiently supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregate(String name, Class<T> type, Field<?>... arguments) {
        return aggregate(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregate(String name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or user-defined
     * aggregate functions that are not yet or insufficiently supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregate(Name name, Class<T> type, Field<?>... arguments) {
        return aggregate(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregate()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregate(Name name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregateDistinct(String name, Class<T> type, Field<?>... arguments) {
        return aggregateDistinct(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param name The aggregate function name
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static <T> AggregateFunction<T> aggregateDistinct(String name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(true, name, type, Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type (a type that is supported
     *            by {@link SQLDataType})
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregateDistinct(Name name, Class<T> type, Field<?>... arguments) {
        return aggregateDistinct(name, getDataType(type), Tools.nullSafe(arguments));
    }

    /**
     * <code>aggregateDistinct()</code> can be used to access native or
     * user-defined aggregate functions that are not yet or insufficiently
     * supported by jOOQ.
     *
     * @param name The aggregate function name (possibly qualified)
     * @param type The aggregate function return type
     * @param arguments The aggregate function arguments
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> aggregateDistinct(Name name, DataType<T> type, Field<?>... arguments) {
        return new org.jooq.impl.DefaultAggregateFunction<>(true, name, type, Tools.nullSafe(arguments));
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "(X = 1 and Y = 2)";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A condition wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(SQL sql) {
        return new SQLCondition(sql);
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must not be any bind variables contained in the SQL.
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "(X = 1 and Y = 2)";</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @return A condition wrapping the plain SQL
     * @see SQL
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql) {
        return condition(sql, new Object[0]);
    }

    /**
     * Create a new condition holding plain SQL.
     * <p>
     * There must be as many bind variables contained in the SQL, as passed
     * in the bindings parameter
     * <p>
     * Example:
     * <p>
     * <code><pre>
     * String sql = "(X = ? and Y = ?)";
     * Object[] bindings = new Object[] { 1, 2 };</pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses!
     *
     * @param sql The SQL
     * @param bindings The bindings
     * @return A condition wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, Object...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql, Object... bindings) {
        return condition(sql(sql, bindings));
    }

    /**
     * A custom SQL clause that can render arbitrary SQL elements.
     * <p>
     * This is useful for constructing more complex SQL syntax elements wherever
     * <code>Condition</code> types are expected. An example for this are
     * Postgres's various operators, some of which are missing in the jOOQ API.
     * For instance, the "overlap" operator for arrays:
     * <code><pre>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</pre></code>
     * <p>
     * The above Postgres operator can be expressed as such: <code><pre>
     * condition("{0} &amp;&amp; {1}", array1, array2);
     * </pre></code>
     * <p>
     * <b>NOTE</b>: When inserting plain SQL into jOOQ objects, you must
     * guarantee syntax integrity. You may also create the possibility of
     * malicious SQL injection. Be sure to properly use bind variables and/or
     * escape literals when concatenated into SQL clauses! One way to escape
     * literals is to use {@link #name(String...)} and similar methods
     *
     * @param sql The SQL
     * @param parts The {@link QueryPart} objects that are rendered at the
     *            {numbered placeholder} locations
     * @return A condition wrapping the plain SQL
     * @see SQL
     * @see DSL#sql(String, QueryPart...)
     */
    @NotNull
    @Support
    @PlainSQL
    public static Condition condition(String sql, QueryPart... parts) {
        return condition(sql, (Object[]) parts);
    }

    /**
     * Create a condition from a boolean field.
     * <p>
     * Databases that support boolean data types can use boolean expressions
     * as predicates or as columns interchangeably. This extends to any type
     * of field, including functions. A Postgres example:
     * <p>
     * <code><pre>
     * select 1 where texteq('a', 'a');
     * </pre></code>
     *
     * @param value The boolean expression.
     * @return A condition wrapping the boolean expression
     */
    @NotNull
    @Support
    public static Condition condition(Boolean value) {
        return condition(Tools.field(value));
    }

    /**
     * Create a condition from a boolean field.
     * <p>
     * Databases that support boolean data types can use boolean expressions
     * as predicates or as columns interchangeably. This extends to any type
     * of field, including functions. A Postgres example:
     * <p>
     * <code><pre>
     * select 1 where texteq('a', 'a');
     * </pre></code>
     *
     * @param field The boolean expression.
     * @return A condition wrapping the boolean expression
     */
    @NotNull
    @Support
    public static Condition condition(Field<Boolean> field) {
        return field instanceof ConditionAsField
            ? ((ConditionAsField) field).condition
            : new FieldCondition(field);
    }

    /**
     * Create a condition from a map.
     * <p>
     * The result is a condition generated from keys and values of the argument <code>map</code>, such that:
     *
     * <code><pre>
     * key1 = value1 AND key2 = value2 AND ... AND keyN = valueN
     * </pre></code>
     *
     * @param map A map containing keys and values to form predicates.
     * @return A condition comparing keys with values.
     */
    @NotNull
    @Support
    public static Condition condition(Map<Field<?>, ?> map) {
        return new MapCondition(map);
    }

    /**
     * Create a "Query By Example" (QBE) {@link Condition} from a {@link Record}
     * .
     * <p>
     * This will take all the non-null values in the argument
     * <code>record</code> to form a predicate from them. If all values in the
     * <code>record</code> are <code>null</code>, the predicate will be the
     * {@link #trueCondition()}.
     *
     * @param record The record from which to create a condition.
     * @return The condition.
     * @see <a href="https://en.wikipedia.org/wiki/Query_by_Example">https://en.
     *      wikipedia.org/wiki/Query_by_Example</a>
     */
    @NotNull
    @Support
    public static Condition condition(Record record) {
        return new RecordCondition(record);
    }

    // -------------------------------------------------------------------------
    // XXX Global Condition factory
    // -------------------------------------------------------------------------

    /**
     * Return a <code>Condition</code> that behaves like no condition being
     * present.
     * <p>
     * This is useful as an "identity" condition for reduction operations, for
     * both <code>AND</code> and <code>OR</code> reductions, e.g.
     * <p>
     * <code><pre>
     * Condition combined =
     * Stream.of(cond1, cond2, cond3)
     *       .reduce(noCondition(), Condition::and);
     * </pre></code>
     * <p>
     * When this condition is passed to SQL clauses, such as the
     * <code>WHERE</code> clause, the entire clause is omitted:
     * <p>
     * <code><pre>
     * selectFrom(T).where(noCondition())
     * </pre></code>
     * <p>
     * ... will produce
     * <p>
     * <code><pre>
     * SELECT * FROM t
     * </pre></code>
     */
    @NotNull
    @Support
    public static Condition noCondition() {
        return NoCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that will always evaluate to true.
     */
    @NotNull
    @Support
    public static True trueCondition() {
        return TrueCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that will always evaluate to false.
     */
    @NotNull
    @Support
    public static False falseCondition() {
        return FalseCondition.INSTANCE;
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Condition left, Condition right) {
        return condition(AND, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Condition... conditions) {
        return condition(AND, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#AND}.
     */
    @NotNull
    @Support
    public static Condition and(Collection<? extends Condition> conditions) {
        return condition(AND, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Condition left, Condition right) {
        return condition(OR, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Condition... conditions) {
        return condition(OR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with {@link Operator#OR}.
     */
    @NotNull
    @Support
    public static Condition or(Collection<? extends Condition> conditions) {
        return condition(OR, conditions);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Condition left, Condition right) {
        return CombinedCondition.of(operator, left, right);
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Condition... conditions) {
        return condition(operator, asList(conditions));
    }

    /**
     * Return a <code>Condition</code> that connects all argument
     * <code>conditions</code> with <code>Operator</code>.
     */
    @NotNull
    @Support
    public static Condition condition(Operator operator, Collection<? extends Condition> conditions) {
        return CombinedCondition.of(operator, conditions);
    }

    /**
     * Create an exists condition.
     * <p>
     * <code>EXISTS ([query])</code>
     */
    @NotNull
    @Support
    public static Condition exists(Select<?> query) {
        return new ExistsCondition(query);
    }

    /**
     * Create a not exists condition.
     * <p>
     * <code>NOT EXISTS ([query])</code>
     */
    @NotNull
    @Support
    public static Condition notExists(Select<?> query) {
        return not(exists(query));
    }

    /**
     * Create a unique condition.
     * <p>
     * <code>UNIQUE ([query])</code>
     */
    @NotNull
    @Support
    public static Condition unique(Select<?> query) {
        return new UniqueCondition(query, true);
    }

    /**
     * Create a not unique condition.
     * <p>
     * <code>NOT UNIQUE ([query])</code>
     */
    @NotNull
    @Support
    public static Condition notUnique(Select<?> query) {
        return new UniqueCondition(query, false);
    }

    /**
     * Invert a condition.
     * <p>
     * This is the same as calling {@link Condition#not()}
     */
    @NotNull
    @Support
    public static Condition not(Condition condition) {
        return condition.not();
    }

    /**
     * Invert a boolean value.
     * <p>
     * This is convenience for calling {@link #field(Condition)},
     * {@link #not(Condition)}, {@link #condition(Field)}, i.e. <code><pre>
     * field(not(condition(field)));
     * </pre></code>
     */
    @NotNull
    @Support
    public static Field<Boolean> not(Field<Boolean> field) {
        return new NotField(field);
    }

    /**
     * Transform a condition into a boolean field.
     */
    @NotNull
    @Support
    public static Field<Boolean> field(Condition condition) {
        return condition instanceof FieldCondition
            ? ((FieldCondition) condition).field
            : new ConditionAsField(condition);
    }

    // -------------------------------------------------------------------------
    // XXX Global Field and Function factory
    // -------------------------------------------------------------------------

    /**
     * Get the MySQL <code>FIELD(expr, expr1, expr2, ...)</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<Integer> field(Field<T> field, T... list) {
        return field(field, Tools.fieldsArray(list, field.getDataType()));
    }

    /**
     * Get the MySQL <code>FIELD(expr, expr1, expr2, ...)</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<Integer> field(Field<T> field, Field<T>... list) {
        return new FieldFunction<>(field, list);
    }

    /**
     * Wrap a {@link SelectField} in a general-purpose {@link Field}
     */
    @NotNull
    @Support
    public static <T> Field<T> field(SelectField<T> field) {
        return field instanceof Field ? (Field<T>) field : field("{0}", field.getDataType(), field);
    }



    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link RowN} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static  Field<Record> rowField(RowN row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row1} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1> Field<Record1<T1>> rowField(Row1<T1> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row2} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2> Field<Record2<T1, T2>> rowField(Row2<T1, T2> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row3} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3> Field<Record3<T1, T2, T3>> rowField(Row3<T1, T2, T3> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row4} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4> Field<Record4<T1, T2, T3, T4>> rowField(Row4<T1, T2, T3, T4> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row5} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5> Field<Record5<T1, T2, T3, T4, T5>> rowField(Row5<T1, T2, T3, T4, T5> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row6} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6> Field<Record6<T1, T2, T3, T4, T5, T6>> rowField(Row6<T1, T2, T3, T4, T5, T6> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row7} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7> Field<Record7<T1, T2, T3, T4, T5, T6, T7>> rowField(Row7<T1, T2, T3, T4, T5, T6, T7> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row8} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Field<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> rowField(Row8<T1, T2, T3, T4, T5, T6, T7, T8> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row9} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Field<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> rowField(Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row10} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Field<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> rowField(Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row11} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Field<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> rowField(Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row12} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Field<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> rowField(Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row13} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Field<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> rowField(Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row14} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Field<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> rowField(Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row15} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Field<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> rowField(Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row16} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Field<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> rowField(Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row17} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Field<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> rowField(Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row18} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Field<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> rowField(Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row19} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Field<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> rowField(Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row20} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Field<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> rowField(Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row21} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Field<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> rowField(Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row) {
        return new RowField<>(row);
    }

    /**
     * @deprecated - [#11812] - 3.15.0 - Use {@link Row22} as a {@link SelectField} directly, instead.
     */
    @NotNull
    @Support
    @Deprecated(forRemoval = true, since = "3.15")
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Field<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> rowField(Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row) {
        return new RowField<>(row);
    }



    /**
     * Transform a subquery into a correlated subquery.
     */
    @NotNull
    @Support
    public static <T> Field<T> field(Select<? extends Record1<T>> select) {
        if (select == null)
            return (Field) NULL();
        else
            return select.asField();
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, T ifTrue, T ifFalse) {
        return iif0(N_IF, condition, Tools.field(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, T ifTrue, Field<T> ifFalse) {
        return iif0(N_IF, condition, Tools.field(ifTrue), Tools.nullSafe(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, Field<T> ifTrue, T ifFalse) {
        return iif0(N_IF, condition, Tools.nullSafe(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Create a MySQL style <code>IF(condition, ifTrue, ifFalse)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> if_(Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return iif0(N_IF, condition, Tools.nullSafe(ifTrue), Tools.nullSafe(ifFalse));
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case"
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case choose() {
        return decode();
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </pre></code>
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case".
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> choose(V value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </pre></code>
     * <p>
     * Choose is used as a method name to avoid name clashes with Java's
     * reserved literal "case".
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> choose(Field<V> value) {
        return decode().value(value);
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> choose(int index, T... values) {
        return choose(val(index), Tools.fieldsArray(values));
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> choose(int index, Field<T>... values) {
        return choose(val(index), values);
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> choose(Field<Integer> index, T... values) {
        return choose(index, Tools.fieldsArray(values));
    }

    /**
     * The T-SQL <code>CHOOSE()</code> function.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> choose(Field<Integer> index, Field<T>... values) {
        return new Choose<>(index, values);
    }

    /**
     * Initialise a {@link Case} statement.
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case case_() {
        return decode();
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </pre></code>
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> case_(V value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE value WHEN 1 THEN 'one'
     *            WHEN 2 THEN 'two'
     *            ELSE        'three'
     * END
     * </pre></code>
     *
     * @see Case
     */
    @NotNull
    @Support
    public static <V> CaseValueStep<V> case_(Field<V> value) {
        return decode().value(value);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, T result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, Field<T> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Condition condition, Select<? extends Record1<T>> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, T result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, Field<T> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * This API can be used to create expressions of the type <code><pre>
     * CASE WHEN x &lt; 1  THEN 'one'
     *      WHEN x &gt;= 2 THEN 'two'
     *      ELSE            'three'
     * END
     * </pre></code>
     */
    @NotNull
    @Support
    public static <T> CaseConditionStep<T> when(Field<Boolean> condition, Select<? extends Record1<T>> result) {
        return decode().when(condition, result);
    }

    /**
     * Initialise a {@link Case} statement.
     * <p>
     * Decode is used as a method name to avoid name clashes with Java's
     * reserved literal "case"
     *
     * @see Case
     */
    @NotNull
    @Support
    public static Case decode() {
        return new CaseImpl();
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]... [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(T value, T search, Z result) {
        return decode(value, search, result, new Object[0]);
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]... [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(T value, T search, Z result, Object... more) {
        return decode(Tools.field(value), Tools.field(search), Tools.field(result), Tools.fieldsArray(more));
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]... [, default])</code>
     * function.
     *
     * @see #decode(Field, Field, Field, Field[])
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(Field<T> value, Field<T> search, Field<Z> result) {
        return decode(Tools.nullSafe(value), Tools.nullSafe(search), Tools.nullSafe(result), EMPTY_FIELD);
    }

    /**
     * Gets the Oracle-style
     * <code>DECODE(expression, search, result[, search , result]... [, default])</code>
     * function.
     * <p>
     * Returns the dialect's equivalent to DECODE:
     * <ul>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/decode.php">DECODE</a>
     * </li>
     * </ul>
     * <p>
     * Other dialects: <code><pre>
     * CASE WHEN [this IS NOT DISTINCT FROM search] THEN [result],
     *     [WHEN more...                            THEN more...]
     *     [ELSE more...]
     * END
     * </pre></code>
     * <p>
     * Note the use of the <code>DISTINCT</code> predicate to produce the same,
     * conveniently <code>NULL</code>-agnostic behaviour as Oracle.
     *
     * @param value The value to decode
     * @param search the mandatory first search parameter
     * @param result the mandatory first result candidate parameter
     * @param more the optional parameters. If <code>more.length</code> is even,
     *            then it is assumed that it contains more search/result pairs.
     *            If <code>more.length</code> is odd, then it is assumed that it
     *            contains more search/result pairs plus a default at the end.
     */
    @NotNull
    @Support
    public static <Z, T> Field<Z> decode(Field<T> value, Field<T> search, Field<Z> result, Field<?>... more) {
        return new Decode<>(Tools.nullSafe(value), Tools.nullSafe(search), Tools.nullSafe(result), Tools.nullSafe(more));
    }

    /**
     * Coerce this field to the type of another field.
     *
     * @see #coerce(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, Field<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce this field to another type.
     *
     * @param value The value to be coerced
     * @param as The field type (a type that is supported by
     *            {@link SQLDataType})
     * @see #coerce(Field, Class)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, Class<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce a field to another type.
     *
     * @see #coerce(Field, DataType)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Object value, DataType<T> as) {
        return Tools.field(value).coerce(as);
    }

    /**
     * Coerce this field to the type of another field.
     * <p>
     * Unlike with casting, coercing doesn't affect the way the database sees a
     * <code>Field</code>'s type. This is how coercing affects your SQL:
     * <h3>Bind values</h3> <code><pre>
     * // This binds an int value to a JDBC PreparedStatement
     * DSL.val(1).coerce(String.class);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(String.class);
     * </pre></code>
     * <h3>Other Field types</h3> <code><pre>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(String.class);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(String.class);
     * </pre></code>
     *
     * @param <T> The generic type of the coerced field
     * @param field The field to be coerced
     * @param as The field whose type is used for the coercion
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, Field<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }

    /**
     * Coerce this field to another type.
     * <p>
     * Unlike with casting, coercing doesn't affect the way the database sees a
     * <code>Field</code>'s type. This is how coercing affects your SQL:
     * <h3>Bind values</h3> <code><pre>
     * // This binds an int value to a JDBC PreparedStatement
     * DSL.val(1).coerce(String.class);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(String.class);
     * </pre></code>
     * <h3>Other Field types</h3> <code><pre>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(String.class);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(String.class);
     * </pre></code>
     *
     * @param <T> The generic type of the coerced field
     * @param value The value to be coerced
     * @param as The field type (a type that is supported by
     *            {@link SQLDataType})
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(Class)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, Class<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }

    /**
     * Coerce a field to another type.
     * <p>
     * Unlike with casting, coercing doesn't affect the way the database sees a
     * <code>Field</code>'s type. This is how coercing affects your SQL:
     * <h3>Bind values</h3> <code><pre>
     * // This binds an int value to a JDBC PreparedStatement
     * DSL.val(1).coerce(String.class);
     *
     * // This binds an int value to a JDBC PreparedStatement
     * // and casts it to VARCHAR in SQL
     * DSL.val(1).cast(String.class);
     * </pre></code>
     * <h3>Other Field types</h3> <code><pre>
     * // This fetches a String value for the BOOK.ID field from JDBC
     * BOOK.ID.coerce(String.class);
     *
     * // This fetches a String value for the BOOK.ID field from JDBC
     * // after casting it to VARCHAR in the database
     * BOOK.ID.cast(String.class);
     * </pre></code>
     *
     * @param <T> The generic type of the coerced field
     * @param field The field to be coerced
     * @param as The type that is used for the coercion
     * @return The coerced field
     * @see Field#coerce(DataType)
     * @see Field#cast(DataType)
     */
    @NotNull
    @Support
    public static <T> Field<T> coerce(Field<?> field, DataType<T> as) {
        return Tools.nullSafe(field).coerce(as);
    }







































    /**
     * Cast a value to the type of another field.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, Field<T> as) {
        return Tools.field(value, as).cast(as);
    }

    /**
     * Cast a field to the type of another field.
     *
     * @param <T> The generic type of the cast field
     * @param field The field to cast
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, Field<T> as) {
        return Tools.nullSafe(field).cast(as);
    }

    /**
     * Cast null to the type of another field.
     *
     * @param <T> The generic type of the cast field
     * @param as The field whose type is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(Field<T> as) {
        return NULL().cast(as);
    }

    /**
     * Cast a value to another type.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param type The type that is used for the cast (a type that is supported
     *            by {@link SQLDataType})
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, Class<T> type) {
        return Tools.field(value, type).cast(type);
    }

    /**
     * Cast a field to another type.
     *
     * @param <T> The generic type of the cast field
     * @param field The field to cast
     * @param type The type that is used for the cast (a type that is supported
     *            by {@link SQLDataType})
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, Class<T> type) {
        return Tools.nullSafe(field).cast(type);
    }

    /**
     * Cast null to a type.
     *
     * @param <T> The generic type of the cast field
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(DataType<T> type) {
        return NULL().cast(type);
    }

    /**
     * Cast a value to another type.
     *
     * @param <T> The generic type of the cast field
     * @param value The value to cast
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Object value, DataType<T> type) {
        return Tools.field(value).cast(type);
    }

    /**
     * Cast a field to another type.
     *
     * @param <T> The generic type of the cast field
     * @param field The value to cast
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> cast(Field<?> field, DataType<T> type) {
        return Tools.nullSafe(field).cast(type);
    }

    /**
     * Cast null to a type.
     *
     * @param <T> The generic type of the cast field
     * @param type The type that is used for the cast
     * @return The cast field
     */
    @NotNull
    @Support
    public static <T> Field<T> castNull(Class<T> type) {
        return NULL().cast(type);
    }

    /**
     * The <code>COALESCE(value1, value2, ... , value n)</code> function.
     *
     * @see #coalesce(Field, Field...)
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(T value, T... values) {
        return coalesce0(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * The <code>COALESCE(field, value)</code> function.
     *
     * @see #coalesce(Field, Field...)
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(Field<T> field, T value) {
        return coalesce0(field, Tools.field(value, field));
    }

    /**
     * The <code>COALESCE(field1, field2, ... , field n)</code> function.
     */
    @NotNull
    @Support
    public static <T> Field<T> coalesce(Field<T> field, Field<?>... fields) {
        return coalesce0(field, fields);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> coalesce0(Field<T> field, Field<?>... fields) {
        return new Coalesce<>(Tools.nullSafe(combine(field, fields)));
    }

    /**
     * Gets the SQL Server-style ISNULL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(T value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * Gets the SQL Server-style ISNULL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(T value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * Gets the SQL Server-style ISNULL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(Field<T> value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * Gets the SQL Server-style ISNULL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> isnull(Field<T> value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * Gets the Oracle-style NVL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(T value, T defaultValue) {
        return nvl0(Tools.field(value), Tools.field(defaultValue));
    }

    /**
     * Gets the Oracle-style NVL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(T value, Field<T> defaultValue) {
        return nvl0(Tools.field(value, defaultValue), Tools.nullSafe(defaultValue));
    }

    /**
     * Gets the Oracle-style NVL(value, defaultValue) function.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(Field<T> value, T defaultValue) {
        return nvl0(Tools.nullSafe(value), Tools.field(defaultValue, value));
    }

    /**
     * Gets the Oracle-style NVL(value, defaultValue) function.
     * <p>
     * Returns the dialect's equivalent to NVL:
     * <ul>
     * <li>DB2 <a href=
     * "http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/index.jsp?topic=/com.ibm.db2.luw.sql.ref.doc/doc/r0052627.html"
     * >NVL</a></li>
     * <li>Derby <a
     * href="http://db.apache.org/derby/docs/10.7/ref/rreffunccoalesce.html"
     * >COALESCE</a></li>
     * <li>H2 <a
     * href="http://www.h2database.com/html/functions.html#ifnull">IFNULL</a></li>
     * <li>HSQLDB <a
     * href="http://hsqldb.org/doc/2.0/guide/builtinfunctions-chapt.html"
     * >NVL</a></li>
     * <li>MySQL <a href=
     * "http://dev.mysql.com/doc/refman/5.0/en/control-flow-functions.html"
     * >IFNULL</a></li>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/nvl.php">NVL</a></li>
     * <li>Postgres <a href=
     * "http://www.postgresql.org/docs/8.1/static/functions-conditional.html"
     * >COALESCE</a></li>
     * <li>SQLite <a
     * href="http://www.sqlite.org/lang_corefunc.html#ifnull">IFNULL</a></li>
     * </ul>
     */
    @NotNull
    @Support
    public static <T> Field<T> nvl(Field<T> value, Field<T> defaultValue) {
        return nvl0(value, defaultValue);
    }

    /**
     * The <code>IFNULL()</code> function, a synonym of <code>NVL()</code>.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(T value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL()</code> function, a synonym of <code>NVL()</code>.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(T value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL()</code> function, a synonym of <code>NVL()</code>.
     *
     * @see #nvl(Field, Object)
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(Field<T> value, T defaultValue) {
        return nvl(value, defaultValue);
    }

    /**
     * The <code>IFNULL()</code> function, a synonym of <code>NVL()</code>.
     *
     * @see #nvl(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> ifnull(Field<T> value, Field<T> defaultValue) {
        return nvl(value, defaultValue);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> nvl0(Field<T> value, Field<T> defaultValue) {
        return new Nvl<>(Tools.nullSafe(value), Tools.nullSafe(defaultValue));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Z valueIfNotNull, Z valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.field(valueIfNotNull), Tools.field(valueIfNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Z valueIfNotNull, Field<Z> valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.field(valueIfNotNull, valueIfNull), Tools.nullSafe(valueIfNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     *
     * @see #nvl2(Field, Field, Field)
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Field<Z> valueIfNotNull, Z valueIfNull) {
        return nvl20(Tools.nullSafe(value), Tools.nullSafe(valueIfNotNull), Tools.field(valueIfNull, valueIfNotNull));
    }

    /**
     * Gets the Oracle-style NVL2(value, valueIfNotNull, valueIfNull) function.
     * <p>
     * Returns the dialect's equivalent to NVL2:
     * <ul>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/nvl2.php">NVL2</a></li>
     * </ul>
     * <p>
     * Other dialects:
     * <code>CASE WHEN [value] IS NULL THEN [valueIfNull] ELSE [valueIfNotNull] END</code>
     */
    @NotNull
    @Support
    public static <Z> Field<Z> nvl2(Field<?> value, Field<Z> valueIfNotNull, Field<Z> valueIfNull) {
        return nvl20(value, valueIfNotNull, valueIfNull);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <Z> Field<Z> nvl20(Field<?> value, Field<Z> valueIfNotNull, Field<Z> valueIfNull) {
        return new Nvl2<>(Tools.nullSafe(value), Tools.nullSafe(valueIfNotNull), Tools.nullSafe(valueIfNull));
    }

    /**
     * Gets the Oracle-style NULLIF(value, other) function.
     *
     * @see #nullif(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(T value, T other) {
        return nullif0(Tools.field(value), Tools.field(other));
    }

    /**
     * Gets the Oracle-style NULLIF(value, other) function.
     *
     * @see #nullif(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(T value, Field<T> other) {
        return nullif0(Tools.field(value, other), Tools.nullSafe(other));
    }

    /**
     * Gets the Oracle-style NULLIF(value, other) function.
     *
     * @see #nullif(Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(Field<T> value, T other) {
        return nullif0(Tools.nullSafe(value), Tools.field(other, value));
    }

    /**
     * Gets the Oracle-style NULLIF(value, other) function.
     * <p>
     * Returns the dialect's equivalent to NULLIF:
     * <ul>
     * <li>Oracle <a
     * href="http://www.techonthenet.com/oracle/functions/nullif.php">NULLIF</a></li>
     * </ul>
     * <p>
     */
    @NotNull
    @Support
    public static <T> Field<T> nullif(Field<T> value, Field<T> other) {
        return nullif0(value, other);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> nullif0(Field<T> value, Field<T> other) {
        return new NullIf<>(Tools.nullSafe(value), Tools.nullSafe(other));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, T ifTrue, T ifFalse) {
        return iif0(N_IIF, condition, Tools.field(ifTrue), Tools.field(ifFalse));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, T ifTrue, Field<T> ifFalse) {
        return iif0(N_IIF, condition, Tools.field(ifTrue, ifFalse), Tools.nullSafe(ifFalse));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     *
     * @see #iif(Condition, Field, Field)
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, Field<T> ifTrue, T ifFalse) {
        return iif0(N_IIF, condition, Tools.nullSafe(ifTrue), Tools.field(ifFalse, ifTrue));
    }

    /**
     * Gets the SQL Server style IIF(condition, ifTrue, ifFalse) function.
     */
    @NotNull
    @Support
    public static <T> Field<T> iif(Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return iif0(N_IIF, condition, ifTrue, ifFalse);
    }

    // Java 8 is stricter than Java 7 with respect to generics and overload
    // resolution (http://stackoverflow.com/q/5361513/521799)
    static <T> Field<T> iif0(Name name, Condition condition, Field<T> ifTrue, Field<T> ifFalse) {
        return new Iif<>(name, condition, Tools.nullSafe(ifTrue), Tools.nullSafe(ifFalse));
    }



    // -------------------------------------------------------------------------
    // Numeric functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ABS</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> abs(T number) {
        return new Abs(Tools.field(number));
    }

    /**
     * The <code>ABS</code> function.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> abs(Field<T> number) {
        return new Abs(number);
    }

    /**
     * The <code>ACOS</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> acos(Number number) {
        return new Acos(Tools.field(number));
    }

    /**
     * The <code>ACOS</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> acos(Field<? extends Number> number) {
        return new Acos(number);
    }

    /**
     * The <code>ASIN</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> asin(Number number) {
        return new Asin(Tools.field(number));
    }

    /**
     * The <code>ASIN</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> asin(Field<? extends Number> number) {
        return new Asin(number);
    }

    /**
     * The <code>ATAN</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan(Number number) {
        return new Atan(Tools.field(number));
    }

    /**
     * The <code>ATAN</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan(Field<? extends Number> number) {
        return new Atan(number);
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param x is wrapped as {@link #val(Object)}.
     * @param y is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan2(Number x, Number y) {
        return new Atan2(Tools.field(x), Tools.field(y));
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param x is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan2(Number x, Field<? extends Number> y) {
        return new Atan2(Tools.field(x), y);
    }

    /**
     * The <code>ATAN2</code> function.
     *
     * @param y is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan2(Field<? extends Number> x, Number y) {
        return new Atan2(x, Tools.field(y));
    }

    /**
     * The <code>ATAN2</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> atan2(Field<? extends Number> x, Field<? extends Number> y) {
        return new Atan2(x, y);
    }

    /**
     * The <code>CEIL</code> function.
     * <p>
     * Get the smallest integer value equal or greater to a value.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> ceil(T value) {
        return new Ceil(Tools.field(value));
    }

    /**
     * The <code>CEIL</code> function.
     * <p>
     * Get the smallest integer value equal or greater to a value.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> ceil(Field<T> value) {
        return new Ceil(value);
    }

    /**
     * The <code>COS</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cos(Number number) {
        return new Cos(Tools.field(number));
    }

    /**
     * The <code>COS</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cos(Field<? extends Number> number) {
        return new Cos(number);
    }

    /**
     * The <code>COSH</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cosh(Number number) {
        return new Cosh(Tools.field(number));
    }

    /**
     * The <code>COSH</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cosh(Field<? extends Number> number) {
        return new Cosh(number);
    }

    /**
     * The <code>COT</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cot(Number number) {
        return new Cot(Tools.field(number));
    }

    /**
     * The <code>COT</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> cot(Field<? extends Number> number) {
        return new Cot(number);
    }

    /**
     * The <code>COTH</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> coth(Number number) {
        return new Coth(Tools.field(number));
    }

    /**
     * The <code>COTH</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> coth(Field<? extends Number> number) {
        return new Coth(number);
    }

    /**
     * The <code>DEG</code> function.
     * <p>
     * Turn a value in radians to degrees.
     *
     * @param radians The value in radians.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> deg(Number radians) {
        return new Degrees(Tools.field(radians));
    }

    /**
     * The <code>DEG</code> function.
     * <p>
     * Turn a value in radians to degrees.
     *
     * @param radians The value in radians.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> deg(Field<? extends Number> radians) {
        return new Degrees(radians);
    }

    /**
     * The <code>E</code> function.
     * <p>
     * The E literal (Euler number).
     */
    @NotNull
    @Support
    public static Field<BigDecimal> e() {
        return new Euler();
    }

    /**
     * The <code>EXP</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> exp(Number value) {
        return new Exp(Tools.field(value));
    }

    /**
     * The <code>EXP</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> exp(Field<? extends Number> value) {
        return new Exp(value);
    }

    /**
     * The <code>FLOOR</code> function.
     * <p>
     * Get the biggest integer value equal or less than a value.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> floor(T value) {
        return new Floor(Tools.field(value));
    }

    /**
     * The <code>FLOOR</code> function.
     * <p>
     * Get the biggest integer value equal or less than a value.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> floor(Field<T> value) {
        return new Floor(value);
    }

    /**
     * The <code>LN</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> ln(Number value) {
        return new Log(Tools.field(value));
    }

    /**
     * The <code>LN</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> ln(Field<? extends Number> value) {
        return new Log(value);
    }

    /**
     * The <code>LOG</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     * @param base is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log(Number value, int base) {
        return new Log(Tools.field(value), Tools.field(base));
    }

    /**
     * The <code>LOG</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log(Number value, Field<? extends Number> base) {
        return new Log(Tools.field(value), base);
    }

    /**
     * The <code>LOG</code> function.
     *
     * @param base is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log(Field<? extends Number> value, int base) {
        return new Log(value, Tools.field(base));
    }

    /**
     * The <code>LOG</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log(Field<? extends Number> value, Field<? extends Number> base) {
        return new Log(value, base);
    }

    /**
     * The <code>LOG10</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log10(Number value) {
        return new Log10(Tools.field(value));
    }

    /**
     * The <code>LOG10</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> log10(Field<? extends Number> value) {
        return new Log10(value);
    }

    /**
     * The <code>PI</code> function.
     * <p>
     * The  literal.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> pi() {
        return new Pi();
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     * @param exponent is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> power(Number value, Number exponent) {
        return new Power(Tools.field(value), Tools.field(exponent));
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> power(Number value, Field<? extends Number> exponent) {
        return new Power(Tools.field(value), exponent);
    }

    /**
     * The <code>POWER</code> function.
     *
     * @param exponent is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> power(Field<? extends Number> value, Number exponent) {
        return new Power(value, Tools.field(exponent));
    }

    /**
     * The <code>POWER</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> power(Field<? extends Number> value, Field<? extends Number> exponent) {
        return new Power(value, exponent);
    }

    /**
     * The <code>RAD</code> function.
     * <p>
     * Turn a value in degrees to radians.
     *
     * @param degrees The value in degrees.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rad(Number degrees) {
        return new Radians(Tools.field(degrees));
    }

    /**
     * The <code>RAD</code> function.
     * <p>
     * Turn a value in degrees to radians.
     *
     * @param degrees The value in degrees.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rad(Field<? extends Number> degrees) {
        return new Radians(degrees);
    }

    /**
     * The <code>RAND</code> function.
     * <p>
     * Get a random numeric value.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> rand() {
        return new Rand();
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value, int decimals) {
        return new Round(Tools.field(value), Tools.field(decimals));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value, Field<Integer> decimals) {
        return new Round(Tools.field(value), decimals);
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value, int decimals) {
        return new Round(value, Tools.field(decimals));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     * @param decimals The decimals to round to.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value, Field<Integer> decimals) {
        return new Round(value, decimals);
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(T value) {
        return new Round(Tools.field(value));
    }

    /**
     * The <code>ROUND</code> function.
     * <p>
     * Round a numeric value to the nearest decimal precision.
     *
     * @param value The number to be rounded.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> round(Field<T> value) {
        return new Round(value);
    }

    /**
     * The <code>SIGN</code> function.
     * <p>
     * Get the sign of a number and return it as any of +1, 0, -1.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> sign(Number number) {
        return new Sign(Tools.field(number));
    }

    /**
     * The <code>SIGN</code> function.
     * <p>
     * Get the sign of a number and return it as any of +1, 0, -1.
     */
    @NotNull
    @Support
    public static Field<Integer> sign(Field<? extends Number> number) {
        return new Sign(number);
    }

    /**
     * The <code>SIN</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sin(Number number) {
        return new Sin(Tools.field(number));
    }

    /**
     * The <code>SIN</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sin(Field<? extends Number> number) {
        return new Sin(number);
    }

    /**
     * The <code>SINH</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sinh(Number number) {
        return new Sinh(Tools.field(number));
    }

    /**
     * The <code>SINH</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sinh(Field<? extends Number> number) {
        return new Sinh(number);
    }

    /**
     * The <code>SQRT</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sqrt(Number value) {
        return new Sqrt(Tools.field(value));
    }

    /**
     * The <code>SQRT</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> sqrt(Field<? extends Number> value) {
        return new Sqrt(value);
    }

    /**
     * The <code>SQUARE</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> square(T value) {
        return new Square(Tools.field(value));
    }

    /**
     * The <code>SQUARE</code> function.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> square(Field<T> value) {
        return new Square(value);
    }

    /**
     * The <code>TAN</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> tan(Number number) {
        return new Tan(Tools.field(number));
    }

    /**
     * The <code>TAN</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> tan(Field<? extends Number> number) {
        return new Tan(number);
    }

    /**
     * The <code>TANH</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> tanh(Number number) {
        return new Tanh(Tools.field(number));
    }

    /**
     * The <code>TANH</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES })
    public static Field<BigDecimal> tanh(Field<? extends Number> number) {
        return new Tanh(number);
    }

    /**
     * The <code>TAU</code> function.
     * <p>
     * The  literal, or , in a better world.
     */
    @NotNull
    @Support
    public static Field<BigDecimal> tau() {
        return new Tau();
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(T value, int decimals) {
        return new Trunc(Tools.field(value), Tools.field(decimals));
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(T value, Field<Integer> decimals) {
        return new Trunc(Tools.field(value), decimals);
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(Field<T> value, int decimals) {
        return new Trunc(value, Tools.field(decimals));
    }

    /**
     * The <code>TRUNC</code> function.
     * <p>
     * Truncate a number to a given number of decimals.
     *
     * @param value The number to be truncated
     * @param decimals The decimals to truncate to.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(Field<T> value, Field<Integer> decimals) {
        return new Trunc(value, decimals);
    }

    /**
     * The <code>WIDTH_BUCKET</code> function.
     * <p>
     * Divide a range into buckets of equal size.
     *
     * @param field The value to divide into the range.
     * @param low The lower bound of the range.
     * @param high The upper bound of the range.
     * @param buckets The number of buckets to produce.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> widthBucket(Field<T> field, T low, T high, int buckets) {
        return new WidthBucket(field, Tools.field(low), Tools.field(high), Tools.field(buckets));
    }

    /**
     * The <code>WIDTH_BUCKET</code> function.
     * <p>
     * Divide a range into buckets of equal size.
     *
     * @param field The value to divide into the range.
     * @param low The lower bound of the range.
     * @param high The upper bound of the range.
     * @param buckets The number of buckets to produce.
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> widthBucket(Field<T> field, Field<T> low, Field<T> high, Field<Integer> buckets) {
        return new WidthBucket(field, low, high, buckets);
    }

    // -------------------------------------------------------------------------
    // String functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ASCII</code> function.
     * <p>
     * The ASCII value of a character.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> ascii(@Stringly.Param String string) {
        return new Ascii(Tools.field(string));
    }

    /**
     * The <code>ASCII</code> function.
     * <p>
     * The ASCII value of a character.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> ascii(Field<String> string) {
        return new Ascii(string);
    }

    /**
     * The <code>BIT_LENGTH</code> function.
     * <p>
     * The length of a string in bits.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> bitLength(@Stringly.Param String string) {
        return new BitLength(Tools.field(string));
    }

    /**
     * The <code>BIT_LENGTH</code> function.
     * <p>
     * The length of a string in bits.
     */
    @NotNull
    @Support
    public static Field<Integer> bitLength(Field<String> string) {
        return new BitLength(string);
    }

    /**
     * The <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> charLength(@Stringly.Param String string) {
        return new CharLength(Tools.field(string));
    }

    /**
     * The <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     */
    @NotNull
    @Support
    public static Field<Integer> charLength(Field<String> string) {
        return new CharLength(string);
    }

    /**
     * The <code>CHR</code> function.
     *
     * @param number is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> chr(Number number) {
        return new Chr(Tools.field(number));
    }

    /**
     * The <code>CHR</code> function.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> chr(Field<? extends Number> number) {
        return new Chr(number);
    }

    /**
     * The <code>DIGITS</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<String> digits(Number value) {
        return new Digits(Tools.field(value));
    }

    /**
     * The <code>DIGITS</code> function.
     */
    @NotNull
    @Support
    public static Field<String> digits(Field<? extends Number> value) {
        return new Digits(value);
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(@Stringly.Param String string, int length) {
        return new Left(Tools.field(string), Tools.field(length));
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(@Stringly.Param String string, Field<? extends Number> length) {
        return new Left(Tools.field(string), length);
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(Field<String> string, int length) {
        return new Left(string, Tools.field(length));
    }

    /**
     * The <code>LEFT</code> function.
     * <p>
     * Get the left outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> left(Field<String> string, Field<? extends Number> length) {
        return new Left(string, length);
    }

    /**
     * The <code>LENGTH</code> function, an alias for the <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> length(@Stringly.Param String string) {
        return charLength(Tools.field(string));
    }

    /**
     * The <code>LENGTH</code> function, an alias for the <code>CHAR_LENGTH</code> function.
     * <p>
     * The length of a string in characters.
     */
    @NotNull
    @Support
    public static Field<Integer> length(Field<String> string) {
        return charLength(string);
    }

    /**
     * The <code>LOWER</code> function.
     * <p>
     * Turn a string into lower case.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<String> lower(@Stringly.Param String string) {
        return new Lower(Tools.field(string));
    }

    /**
     * The <code>LOWER</code> function.
     * <p>
     * Turn a string into lower case.
     */
    @NotNull
    @Support
    public static Field<String> lower(Field<String> string) {
        return new Lower(string);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, int length, @Stringly.Param String character) {
        return new Lpad(string, Tools.field(length), Tools.field(character));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, int length, Field<String> character) {
        return new Lpad(string, Tools.field(length), character);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length, @Stringly.Param String character) {
        return new Lpad(string, length, Tools.field(character));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length, Field<String> character) {
        return new Lpad(string, length, character);
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, int length) {
        return new Lpad(string, Tools.field(length));
    }

    /**
     * The <code>LPAD</code> function.
     * <p>
     * Left-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> string, Field<? extends Number> length) {
        return new Lpad(string, length);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> ltrim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Ltrim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> ltrim(@Stringly.Param String string, Field<String> characters) {
        return new Ltrim(Tools.field(string), characters);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> ltrim(Field<String> string, @Stringly.Param String characters) {
        return new Ltrim(string, Tools.field(characters));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> ltrim(Field<String> string, Field<String> characters) {
        return new Ltrim(string, characters);
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> ltrim(@Stringly.Param String string) {
        return new Ltrim(Tools.field(string));
    }

    /**
     * The <code>LTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> ltrim(Field<String> string) {
        return new Ltrim(string);
    }

    /**
     * The <code>MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a string.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> md5(@Stringly.Param String string) {
        return new Md5(Tools.field(string));
    }

    /**
     * The <code>MD5</code> function.
     * <p>
     * Calculate an MD5 hash from a string.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> md5(Field<String> string) {
        return new Md5(string);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition, int length) {
        return substring(string, Tools.field(startingPosition), Tools.field(length));
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition, Field<? extends Number> length) {
        return substring(string, Tools.field(startingPosition), length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition, int length) {
        return substring(string, startingPosition, Tools.field(length));
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition, Field<? extends Number> length) {
        return substring(string, startingPosition, length);
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, int startingPosition) {
        return substring(string, Tools.field(startingPosition));
    }

    /**
     * The <code>MID</code> function, an alias for the <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> mid(Field<String> string, Field<? extends Number> startingPosition) {
        return substring(string, startingPosition);
    }

    /**
     * The <code>OCTET_LENGTH</code> function.
     * <p>
     * The length of a string in octets.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<Integer> octetLength(@Stringly.Param String string) {
        return new OctetLength(Tools.field(string));
    }

    /**
     * The <code>OCTET_LENGTH</code> function.
     * <p>
     * The length of a string in octets.
     */
    @NotNull
    @Support
    public static Field<Integer> octetLength(Field<String> string) {
        return new OctetLength(string);
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, @Stringly.Param String placing, Number startIndex, Number length) {
        return new Overlay(in, Tools.field(placing), Tools.field(startIndex), Tools.field(length));
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     * @param length The length in the original string that will be replaced, if different from the overlay length.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, Field<String> placing, Field<? extends Number> startIndex, Field<? extends Number> length) {
        return new Overlay(in, placing, startIndex, length);
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, @Stringly.Param String placing, Number startIndex) {
        return new Overlay(in, Tools.field(placing), Tools.field(startIndex));
    }

    /**
     * The <code>OVERLAY</code> function.
     * <p>
     * Place a string on top of another string, replacing the original contents.
     *
     * @param in The original string on top of which the overlay is placed.
     * @param placing The string that is being placed on top of the other string.
     * @param startIndex The start index (1-based) starting from where the overlay is placed.
     */
    @NotNull
    @Support
    public static Field<String> overlay(Field<String> in, Field<String> placing, Field<? extends Number> startIndex) {
        return new Overlay(in, placing, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search, int startIndex) {
        return new Position(Tools.field(in), Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search, Field<? extends Number> startIndex) {
        return new Position(Tools.field(in), Tools.field(search), startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search, int startIndex) {
        return new Position(Tools.field(in), search, Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search, Field<? extends Number> startIndex) {
        return new Position(Tools.field(in), search, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search, int startIndex) {
        return new Position(in, Tools.field(search), Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search, Field<? extends Number> startIndex) {
        return new Position(in, Tools.field(search), startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search, int startIndex) {
        return new Position(in, search, Tools.field(startIndex));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     * @param startIndex The start index (1-based) from which to start looking for the substring.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search, Field<? extends Number> startIndex) {
        return new Position(in, search, startIndex);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, @Stringly.Param String search) {
        return new Position(Tools.field(in), Tools.field(search));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(@Stringly.Param String in, Field<String> search) {
        return new Position(Tools.field(in), search);
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, @Stringly.Param String search) {
        return new Position(in, Tools.field(search));
    }

    /**
     * The <code>POSITION</code> function.
     * <p>
     * Search the position (1-based) of a substring in another string.
     *
     * @param in The string in which to search the substring.
     * @param search The substring to search for.
     */
    @NotNull
    @Support
    public static Field<Integer> position(Field<String> in, Field<String> search) {
        return new Position(in, search);
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> repeat(@Stringly.Param String string, int count) {
        return new Repeat(Tools.field(string), Tools.field(count));
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> repeat(@Stringly.Param String string, Field<? extends Number> count) {
        return new Repeat(Tools.field(string), count);
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> repeat(Field<String> string, int count) {
        return new Repeat(string, Tools.field(count));
    }

    /**
     * The <code>REPEAT</code> function.
     * <p>
     * Repeat a string a number of times.
     *
     * @param string The string to be repeated.
     * @param count The number of times to repeat the string.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> repeat(Field<String> string, Field<? extends Number> count) {
        return new Repeat(string, count);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search, @Stringly.Param String replace) {
        return new Replace(string, Tools.field(search), Tools.field(replace));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search, Field<String> replace) {
        return new Replace(string, Tools.field(search), replace);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, Field<String> search, @Stringly.Param String replace) {
        return new Replace(string, search, Tools.field(replace));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     * @param replace The replacement for each substring, if not empty.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, Field<String> search, Field<String> replace) {
        return new Replace(string, search, replace);
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, @Stringly.Param String search) {
        return new Replace(string, Tools.field(search));
    }

    /**
     * The <code>REPLACE</code> function.
     * <p>
     * Replace all occurrences of a substring in another string.
     *
     * @param string The string in which to replace contents.
     * @param search The substring to search for.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> replace(Field<String> string, Field<String> search) {
        return new Replace(string, search);
    }

    /**
     * The <code>REVERSE</code> function.
     * <p>
     * Reverse a string.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ CUBRID, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<String> reverse(@Stringly.Param String string) {
        return new Reverse(Tools.field(string));
    }

    /**
     * The <code>REVERSE</code> function.
     * <p>
     * Reverse a string.
     */
    @NotNull
    @Support({ CUBRID, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<String> reverse(Field<String> string) {
        return new Reverse(string);
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(@Stringly.Param String string, int length) {
        return new Right(Tools.field(string), Tools.field(length));
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(@Stringly.Param String string, Field<? extends Number> length) {
        return new Right(Tools.field(string), length);
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(Field<String> string, int length) {
        return new Right(string, Tools.field(length));
    }

    /**
     * The <code>RIGHT</code> function.
     * <p>
     * Get the right outermost characters from a string.
     *
     * @param string The string whose characters are extracted.
     * @param length The number of characters to extract from the string.
     */
    @NotNull
    @Support
    public static Field<String> right(Field<String> string, Field<? extends Number> length) {
        return new Right(string, length);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, int length, @Stringly.Param String character) {
        return new Rpad(string, Tools.field(length), Tools.field(character));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, int length, Field<String> character) {
        return new Rpad(string, Tools.field(length), character);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length, @Stringly.Param String character) {
        return new Rpad(string, length, Tools.field(character));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     * @param character The padding character, if different from whitespace
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length, Field<String> character) {
        return new Rpad(string, length, character);
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, int length) {
        return new Rpad(string, Tools.field(length));
    }

    /**
     * The <code>RPAD</code> function.
     * <p>
     * Right-pad a string with a character (whitespace as default) for a number of times.
     *
     * @param string The string to be padded.
     * @param length The maximum length to pad the string to.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> string, Field<? extends Number> length) {
        return new Rpad(string, length);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rtrim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Rtrim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rtrim(@Stringly.Param String string, Field<String> characters) {
        return new Rtrim(Tools.field(string), characters);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rtrim(Field<String> string, @Stringly.Param String characters) {
        return new Rtrim(string, Tools.field(characters));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rtrim(Field<String> string, Field<String> characters) {
        return new Rtrim(string, characters);
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> rtrim(@Stringly.Param String string) {
        return new Rtrim(Tools.field(string));
    }

    /**
     * The <code>RTRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> rtrim(Field<String> string) {
        return new Rtrim(string);
    }

    /**
     * The <code>SPACE</code> function.
     * <p>
     * Get a string of spaces of a given length.
     *
     * @param count The number of spaces to produce.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> space(Number count) {
        return new Space(Tools.field(count));
    }

    /**
     * The <code>SPACE</code> function.
     * <p>
     * Get a string of spaces of a given length.
     *
     * @param count The number of spaces to produce.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> space(Field<? extends Number> count) {
        return new Space(count);
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> splitPart(Field<String> string, @Stringly.Param String delimiter, Number n) {
        return new SplitPart(string, Tools.field(delimiter), Tools.field(n));
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> splitPart(Field<String> string, @Stringly.Param String delimiter, Field<? extends Number> n) {
        return new SplitPart(string, Tools.field(delimiter), n);
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> splitPart(Field<String> string, Field<String> delimiter, Number n) {
        return new SplitPart(string, delimiter, Tools.field(n));
    }

    /**
     * The <code>SPLIT_PART</code> function.
     * <p>
     * Split a string into tokens, and retrieve the nth token.
     *
     * @param string The string to be split into parts.
     * @param delimiter The delimiter used for splitting.
     * @param n The token number (1-based).
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static Field<String> splitPart(Field<String> string, Field<String> delimiter, Field<? extends Number> n) {
        return new SplitPart(string, delimiter, n);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition, int length) {
        return new Substring(string, Tools.field(startingPosition), Tools.field(length));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition, Field<? extends Number> length) {
        return new Substring(string, Tools.field(startingPosition), length);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition, int length) {
        return new Substring(string, startingPosition, Tools.field(length));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     * @param length The maximum length of the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition, Field<? extends Number> length) {
        return new Substring(string, startingPosition, length);
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, int startingPosition) {
        return new Substring(string, Tools.field(startingPosition));
    }

    /**
     * The <code>SUBSTRING</code> function.
     * <p>
     * Get a substring of a string, from a given position.
     *
     * @param string The string from which to get the substring.
     * @param startingPosition The position (1-based) from which to get the substring.
     */
    @NotNull
    @Support
    public static Field<String> substring(Field<String> string, Field<? extends Number> startingPosition) {
        return new Substring(string, startingPosition);
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, @Stringly.Param String delimiter, int n) {
        return new SubstringIndex(string, Tools.field(delimiter), Tools.field(n));
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, @Stringly.Param String delimiter, Field<? extends Number> n) {
        return new SubstringIndex(string, Tools.field(delimiter), n);
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, Field<String> delimiter, int n) {
        return new SubstringIndex(string, delimiter, Tools.field(n));
    }

    /**
     * The <code>SUBSTRING_INDEX</code> function.
     * <p>
     * Get a substring of a string, from the beginning until the nth occurrence of a substring.
     *
     * @param string The string from which to get the substring.
     * @param delimiter The delimiter.
     * @param n The number of occurrences of the delimiter.
     */
    @NotNull
    @Support({ MARIADB, MYSQL })
    public static Field<String> substringIndex(Field<String> string, Field<String> delimiter, Field<? extends Number> n) {
        return new SubstringIndex(string, delimiter, n);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Object value, @Stringly.Param String formatMask) {
        return new ToChar(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Object value, Field<String> formatMask) {
        return new ToChar(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Field<?> value, @Stringly.Param String formatMask) {
        return new ToChar(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static Field<String> toChar(Field<?> value, Field<String> formatMask) {
        return new ToChar(value, formatMask);
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     */
    @NotNull
    @Support
    public static Field<String> toChar(Object value) {
        return new ToChar(Tools.field(value));
    }

    /**
     * The <code>TO_CHAR</code> function.
     * <p>
     * Format an arbitrary value as a string.
     *
     * @param value The value to be formatted.
     */
    @NotNull
    @Support
    public static Field<String> toChar(Field<?> value) {
        return new ToChar(value);
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Date> toDate(@Stringly.Param String value, @Stringly.Param String formatMask) {
        return new ToDate(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Date> toDate(@Stringly.Param String value, Field<String> formatMask) {
        return new ToDate(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Date> toDate(Field<String> value, @Stringly.Param String formatMask) {
        return new ToDate(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_DATE</code> function.
     * <p>
     * Parse a string-formatted date value to a date.
     *
     * @param value The formatted DATE value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Date> toDate(Field<String> value, Field<String> formatMask) {
        return new ToDate(value, formatMask);
    }

    /**
     * The <code>TO_HEX</code> function.
     * <p>
     * Format a number to its hex value.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> toHex(Number value) {
        return new ToHex(Tools.field(value));
    }

    /**
     * The <code>TO_HEX</code> function.
     * <p>
     * Format a number to its hex value.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> toHex(Field<? extends Number> value) {
        return new ToHex(value);
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> toTimestamp(@Stringly.Param String value, @Stringly.Param String formatMask) {
        return new ToTimestamp(Tools.field(value), Tools.field(formatMask));
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> toTimestamp(@Stringly.Param String value, Field<String> formatMask) {
        return new ToTimestamp(Tools.field(value), formatMask);
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> toTimestamp(Field<String> value, @Stringly.Param String formatMask) {
        return new ToTimestamp(value, Tools.field(formatMask));
    }

    /**
     * The <code>TO_TIMESTAMP</code> function.
     * <p>
     * Parse a string-formatted timestamp value to a timestamp.
     *
     * @param value The formatted TIMESTAMP value.
     * @param formatMask The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> toTimestamp(Field<String> value, Field<String> formatMask) {
        return new ToTimestamp(value, formatMask);
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<String> translate(Field<String> string, @Stringly.Param String from, @Stringly.Param String to) {
        return new Translate(string, Tools.field(from), Tools.field(to));
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<String> translate(Field<String> string, @Stringly.Param String from, Field<String> to) {
        return new Translate(string, Tools.field(from), to);
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<String> translate(Field<String> string, Field<String> from, @Stringly.Param String to) {
        return new Translate(string, from, Tools.field(to));
    }

    /**
     * The <code>TRANSLATE</code> function.
     * <p>
     * Translate a set of characters to another set of characters in a string.
     *
     * @param string The string to translate.
     * @param from The set of source characters.
     * @param to The set of target characters, matched with source characters by position.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<String> translate(Field<String> string, Field<String> from, Field<String> to) {
        return new Translate(string, from, to);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(@Stringly.Param String string, @Stringly.Param String characters) {
        return new Trim(Tools.field(string), Tools.field(characters));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(@Stringly.Param String string, Field<String> characters) {
        return new Trim(Tools.field(string), characters);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(Field<String> string, @Stringly.Param String characters) {
        return new Trim(string, Tools.field(characters));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     * @param characters The characters to be trimmed.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> trim(Field<String> string, Field<String> characters) {
        return new Trim(string, characters);
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> trim(@Stringly.Param String string) {
        return new Trim(Tools.field(string));
    }

    /**
     * The <code>TRIM</code> function.
     * <p>
     * Trim characters (whitespace as default) from both sides of a string.
     *
     * @param string The string to be trimmed.
     */
    @NotNull
    @Support
    public static Field<String> trim(Field<String> string) {
        return new Trim(string);
    }

    /**
     * The <code>UPPER</code> function.
     * <p>
     * Turn a string into upper case.
     *
     * @param string is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support
    public static Field<String> upper(@Stringly.Param String string) {
        return new Upper(Tools.field(string));
    }

    /**
     * The <code>UPPER</code> function.
     * <p>
     * Turn a string into upper case.
     */
    @NotNull
    @Support
    public static Field<String> upper(Field<String> string) {
        return new Upper(string);
    }

    /**
     * The <code>UUID</code> function.
     * <p>
     * Generate a random UUID.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, IGNITE, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<UUID> uuid() {
        return new Uuid();
    }

    // -------------------------------------------------------------------------
    // Date functions
    // -------------------------------------------------------------------------

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Date date, Number interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Date date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Field<Date> date, Number interval, DatePart datePart) {
        return new DateAdd(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Field<Date> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(date, interval, datePart);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Date date, Number interval) {
        return new DateAdd(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Date date, Field<? extends Number> interval) {
        return new DateAdd(Tools.field(date), interval);
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Field<Date> date, Number interval) {
        return new DateAdd(date, Tools.field(interval));
    }

    /**
     * The <code>DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<Date> dateAdd(Field<Date> date, Field<? extends Number> interval) {
        return new DateAdd(date, interval);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(LocalDate date, Number interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(LocalDate date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(Field<LocalDate> date, Number interval, DatePart datePart) {
        return new DateAdd(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(Field<LocalDate> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(date, interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(LocalDate date, Number interval) {
        return new DateAdd(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(LocalDate date, Field<? extends Number> interval) {
        return new DateAdd(Tools.field(date), interval);
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(Field<LocalDate> date, Number interval) {
        return new DateAdd(date, Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_ADD</code> function.
     * <p>
     * Add an interval to a date.
     *
     * @param date The date to add an interval to
     * @param interval The interval to add to the date
     */
    @NotNull
    @Support
    public static <T> Field<LocalDate> localDateAdd(Field<LocalDate> date, Field<? extends Number> interval) {
        return new DateAdd(date, interval);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Timestamp date, Number interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Timestamp date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Field<Timestamp> date, Number interval, DatePart datePart) {
        return new DateAdd(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Field<Timestamp> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(date, interval, datePart);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Timestamp date, Number interval) {
        return new DateAdd(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Timestamp date, Field<? extends Number> interval) {
        return new DateAdd(Tools.field(date), interval);
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Field<Timestamp> date, Number interval) {
        return new DateAdd(date, Tools.field(interval));
    }

    /**
     * The <code>TIMESTAMP_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<Timestamp> timestampAdd(Field<Timestamp> date, Field<? extends Number> interval) {
        return new DateAdd(date, interval);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Number interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(Tools.field(date), interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Number interval, DatePart datePart) {
        return new DateAdd(date, Tools.field(interval), datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     * @param datePart The date part describing the interval
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd(date, interval, datePart);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Number interval) {
        return new DateAdd(Tools.field(date), Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(LocalDateTime date, Field<? extends Number> interval) {
        return new DateAdd(Tools.field(date), interval);
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Number interval) {
        return new DateAdd(date, Tools.field(interval));
    }

    /**
     * The <code>LOCAL_DATE_TIME_ADD</code> function.
     * <p>
     * Add an interval to a timestamp.
     *
     * @param date The timestamp to add an interval to
     * @param interval The interval to add to the timestamp
     */
    @NotNull
    @Support
    public static <T> Field<LocalDateTime> localDateTimeAdd(Field<LocalDateTime> date, Field<? extends Number> interval) {
        return new DateAdd(date, interval);
    }

    // -------------------------------------------------------------------------
    // System functions
    // -------------------------------------------------------------------------

    /**
     * The <code>CURRENT_CATALOG</code> function.
     */
    @NotNull
    @Support({ FIREBIRD, POSTGRES, SQLITE })
    public static Field<String> currentCatalog() {
        return new CurrentCatalog();
    }

    /**
     * The <code>CURRENT_SCHEMA</code> function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> currentSchema() {
        return new CurrentSchema();
    }

    /**
     * The <code>CURRENT_USER</code> function.
     */
    @NotNull
    @Support
    public static Field<String> currentUser() {
        return new CurrentUser();
    }


































































































    // -------------------------------------------------------------------------
    // XML functions
    // -------------------------------------------------------------------------

    /**
     * The <code>XMLCOMMENT</code> function.
     *
     * @param comment is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlcomment(@Stringly.Param String comment) {
        return new Xmlcomment(Tools.field(comment));
    }

    /**
     * The <code>XMLCOMMENT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlcomment(Field<String> comment) {
        return new Xmlcomment(comment);
    }

    /**
     * The <code>XMLFOREST</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlforest(Field<?>... fields) {
        return new Xmlforest(Arrays.asList(fields));
    }

    /**
     * The <code>XMLFOREST</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlforest(Collection<? extends Field<?>> fields) {
        return new Xmlforest(fields);
    }

    /**
     * The <code>XMLSERIALIZE_DOCUMENT</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeDocument(XML value, DataType<T> type) {
        return new Xmlserialize(false, Tools.field(value), type);
    }

    /**
     * The <code>XMLSERIALIZE_DOCUMENT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeDocument(Field<XML> value, DataType<T> type) {
        return new Xmlserialize(false, value, type);
    }

    /**
     * The <code>XMLSERIALIZE_CONTENT</code> function.
     *
     * @param value is wrapped as {@link #val(Object)}.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeContent(XML value, DataType<T> type) {
        return new Xmlserialize(true, Tools.field(value), type);
    }

    /**
     * The <code>XMLSERIALIZE_CONTENT</code> function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static <T> Field<T> xmlserializeContent(Field<XML> value, DataType<T> type) {
        return new Xmlserialize(true, value, type);
    }

    // -------------------------------------------------------------------------
    // JSON functions
    // -------------------------------------------------------------------------

    /**
     * The <code>JSON_ARRAY</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayNullStep<JSON> jsonArray(Field<?>... fields) {
        return new JSONArray<>(SQLDataType.JSON, Arrays.asList(fields));
    }

    /**
     * The <code>JSON_ARRAY</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayNullStep<JSON> jsonArray(Collection<? extends Field<?>> fields) {
        return new JSONArray<>(SQLDataType.JSON, fields);
    }

    /**
     * The <code>JSONB_ARRAY</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayNullStep<JSONB> jsonbArray(Field<?>... fields) {
        return new JSONArray<>(SQLDataType.JSONB, Arrays.asList(fields));
    }

    /**
     * The <code>JSONB_ARRAY</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayNullStep<JSONB> jsonbArray(Collection<? extends Field<?>> fields) {
        return new JSONArray<>(SQLDataType.JSONB, fields);
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(Field<?>... entries) {
        return new JSONObject<>(SQLDataType.JSON, Tools.jsonEntries(entries));
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(JSONEntry<?>... entries) {
        return new JSONObject<>(SQLDataType.JSON, Arrays.asList(entries));
    }

    /**
     * The <code>JSON_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(Collection<? extends JSONEntry<?>> entries) {
        return new JSONObject<>(SQLDataType.JSON, entries);
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSONB> jsonbObject(Field<?>... entries) {
        return new JSONObject<>(SQLDataType.JSONB, Tools.jsonEntries(entries));
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSONB> jsonbObject(JSONEntry<?>... entries) {
        return new JSONObject<>(SQLDataType.JSONB, Arrays.asList(entries));
    }

    /**
     * The <code>JSONB_OBJECT</code> function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSONB> jsonbObject(Collection<? extends JSONEntry<?>> entries) {
        return new JSONObject<>(SQLDataType.JSONB, entries);
    }







































    // -------------------------------------------------------------------------
    // Aggregate functions
    // -------------------------------------------------------------------------

    /**
     * The <code>BIT_AND_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>AND</code> aggregate value.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> AggregateFunction<T> bitAndAgg(Field<T> value) {
        return new BitAndAgg(value);
    }

    /**
     * The <code>BIT_OR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>OR</code> aggregate value.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> AggregateFunction<T> bitOrAgg(Field<T> value) {
        return new BitOrAgg(value);
    }

    /**
     * The <code>BIT_XOR_AGG</code> function.
     * <p>
     * Calculate the bitwise <code>XOR</code> aggregate value.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> AggregateFunction<T> bitXorAgg(Field<T> value) {
        return new BitXorAgg(value);
    }

    /**
     * The <code>CORR</code> function.
     * <p>
     * Calculate the correlation coefficient. This standard SQL function may be supported
     * natively, or emulated using {@link #covarPop(Field, Field)} and {@link #stddevPop(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> corr(Field<? extends Number> y, Field<? extends Number> x) {
        return new Corr(y, x);
    }

    /**
     * The <code>COVAR_SAMP</code> function.
     * <p>
     * Calculate the sample covariance. This standard SQL function may be supported natively,
     * or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> covarSamp(Field<? extends Number> y, Field<? extends Number> x) {
        return new CovarSamp(y, x);
    }

    /**
     * The <code>COVAR_POP</code> function.
     * <p>
     * Calculate the population covariance. This standard SQL function may be supported
     * natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an
     * emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> covarPop(Field<? extends Number> y, Field<? extends Number> x) {
        return new CovarPop(y, x);
    }

    /**
     * The <code>MEDIAN</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, POSTGRES })
    public static AggregateFunction<BigDecimal> median(Field<? extends Number> field) {
        return new Median(field);
    }

    /**
     * The <code>REGR_AVG_X</code> function.
     * <p>
     * Calculate the average of the independent values (x). This standard SQL function may
     * be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrAvgX(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrAvgx(y, x);
    }

    /**
     * The <code>REGR_AVG_Y</code> function.
     * <p>
     * Calculate the average of the dependent values (y). This standard SQL function may
     * be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrAvgY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrAvgy(y, x);
    }

    /**
     * The <code>REGR_COUNT</code> function.
     * <p>
     * Calculate the number of non-<code>NULL</code> pairs. This standard SQL function may
     * be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrCount(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrCount(y, x);
    }

    /**
     * The <code>REGR_INTERCEPT</code> function.
     * <p>
     * Calculate the y intercept of the regression line. This standard SQL function may
     * be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrIntercept(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrIntercept(y, x);
    }

    /**
     * The <code>REGR_R2</code> function.
     * <p>
     * Calculate the coefficient of determination. This standard SQL function may be supported
     * natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an
     * emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> regrR2(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrR2(y, x);
    }

    /**
     * The <code>REGR_SLOPE</code> function.
     * <p>
     * Calculate the slope of the regression line. This standard SQL function may be supported
     * natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an
     * emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSlope(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSlope(y, x);
    }

    /**
     * The <code>REGR_SXX</code> function.
     * <p>
     * Calculate the <code>REGR_SXX</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSXX(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSxx(y, x);
    }

    /**
     * The <code>REGR_SXY</code> function.
     * <p>
     * Calculate the <code>REGR_SXY</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSXY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSxy(y, x);
    }

    /**
     * The <code>REGR_SYY</code> function.
     * <p>
     * Calculate the <code>REGR_SYY</code> auxiliary function. This standard SQL function
     * may be supported natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}.
     * If an emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> regrSYY(Field<? extends Number> y, Field<? extends Number> x) {
        return new RegrSyy(y, x);
    }

    /**
     * The <code>STDDEV_POP</code> function.
     * <p>
     * Calculate the population standard deviation. This standard SQL function may be supported
     * natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an
     * emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> stddevPop(Field<? extends Number> field) {
        return new StddevPop(field);
    }

    /**
     * The <code>STDDEV_SAMP</code> function.
     * <p>
     * Calculate the sample standard deviation. This standard SQL function may be supported
     * natively, or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an
     * emulation is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> stddevSamp(Field<? extends Number> field) {
        return new StddevSamp(field);
    }

    /**
     * The <code>VAR_POP</code> function.
     * <p>
     * Calculate the population variance. This standard SQL function may be supported natively,
     * or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> varPop(Field<? extends Number> field) {
        return new VarPop(field);
    }

    /**
     * The <code>VAR_SAMP</code> function.
     * <p>
     * Calculate the sample variance. This standard SQL function may be supported natively,
     * or emulated using {@link #sum(Field)} and {@link #count(Field)}. If an emulation
     * is applied, beware of the risk of "<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">Catastrophic
     * cancellation</a>" in case the calculations are performed using floating point arithmetic.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> varSamp(Field<? extends Number> field) {
        return new VarSamp(field);
    }

































































    /**
     * Get the rpad(field, length, character) function.
     *
     * @see #rpad(Field, Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> rpad(Field<String> field, int length, char character) {
        return rpad(field, length, Character.toString(character));
    }

    /**
     * Get the lpad(field, length, character) function.
     *
     * @see #lpad(Field, Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> lpad(Field<String> field, int length, char character) {
        return lpad(field, length, Character.toString(character));
    }

    /**
     * Convenience method for {@link #replace(Field, String, String)} to escape
     * data for use with {@link Field#like(Field, char)}.
     * <p>
     * Essentially, this escapes <code>%</code> and <code>_</code> characters
     *
     * @see #replace(Field, String, String)
     * @see Field#like(Field, char)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static String escape(String value, char escape) {
        String esc = "" + escape;
        return StringUtils.replace(
                   StringUtils.replace(
                       StringUtils.replace(value, esc, esc + esc), "%", esc + "%"
                   ), "_", esc + "_"
               );
    }

    /**
     * Convenience method for {@link #replace(Field, String, String)} to escape
     * data for use with {@link Field#like(Field, char)}.
     * <p>
     * Essentially, this escapes <code>%</code> and <code>_</code> characters
     *
     * @see #replace(Field, String, String)
     * @see Field#like(Field, char)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<String> escape(Field<String> field, char escape) {
        Field<String> replace = field;

        String esc = "" + escape;
        replace = replace(replace, inline(esc), inline(esc + esc));
        replace = replace(replace, inline("%"), inline(esc + "%"));
        replace = replace(replace, inline("_"), inline(esc + "_"));

        return replace;
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<String> regexpReplaceAll(Field<String> field, String pattern, String replacement) {
        return regexpReplaceAll(field, Tools.field(pattern), Tools.field(replacement));
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<String> regexpReplaceAll(Field<String> field, Field<String> pattern, Field<String> replacement) {
        return new RegexpReplace(field, Tools.nullSafe(pattern), Tools.nullSafe(replacement), true);
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static Field<String> regexpReplaceFirst(Field<String> field, String pattern, String replacement) {
        return regexpReplaceFirst(field, Tools.field(pattern), Tools.field(replacement));
    }

    /**
     * Get the <code>REGEXP_REPLACE_ALL</code> function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static Field<String> regexpReplaceFirst(Field<String> field, Field<String> pattern, Field<String> replacement) {
        return new RegexpReplace(field, Tools.nullSafe(pattern), Tools.nullSafe(replacement), false);
    }

    /**
     * Get the insert(in, startIndex, length, placing) function.
     */
    @NotNull
    @Support
    public static Field<String> insert(Field<String> in, Number startIndex, Number length, String placing) {
        return insert(Tools.nullSafe(in), Tools.field(startIndex), Tools.field(length), Tools.field(placing));
    }

    /**
     * Get the insert(in, startIndex, length, placing) function.
     */
    @NotNull
    @Support
    public static Field<String> insert(Field<String> in, Field<? extends Number> startIndex, Field<? extends Number> length, Field<String> placing) {
        return overlay(in, placing, startIndex, length);
    }

    /**
     * Get the <code>concat(field, value)</code> function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(Field<String> field, String value) {
        return concat(Tools.nullSafe(field), Tools.field(value));
    }

    /**
     * Get the <code>concat(value, field)</code> function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(String value, Field<String> field) {
        return concat(Tools.field(value), Tools.nullSafe(field));
    }

    /**
     * Get the concat(value[, value, ...]) function.
     *
     * @see #concat(Field...)
     */
    @NotNull
    @Support
    public static Field<String> concat(String... values) {
        return concat(Tools.fieldsArray(values));
    }

    /**
     * Get the concat(field[, field, ...]) function.
     * <p>
     * This creates <code>fields[0] || fields[1] || ...</code> as an
     * expression, or <code>concat(fields[0], fields[1], ...)</code>,
     * depending on the dialect.
     * <p>
     * If any of the given fields is not a {@link String} field, they are cast
     * to <code>Field&lt;String&gt;</code> first using {@link #cast(Object, Class)}
     */
    @NotNull
    @Support
    public static Field<String> concat(Field<?>... fields) {
        return new Concat(Tools.nullSafe(fields));
    }

    // ------------------------------------------------------------------------
    // XXX Date and time functions
    // ------------------------------------------------------------------------

    /**
     * Get the current_date() function returning a SQL standard
     * {@link SQLDataType#DATE} type.
     * <p>
     * Note, while there is a <code>CURRENT_DATE</code> function in
     * {@link SQLDialect#ORACLE}, that function returns a seconds-precision
     * {@link SQLDataType#TIMESTAMP}, which is undesired from a vendor
     * agnosticity perspective. This function thus produces an expression that
     * conforms to the SQL standard idea of a {@link SQLDataType#DATE} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> currentDate() {
        return new CurrentDate<>(DATE.notNull());
    }

    /**
     * Get the current_time() function returning a SQL standard
     * {@link SQLDataType#TIME} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Time> currentTime() {
        return new CurrentTime<>(TIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> currentTimestamp() {
        return new CurrentTimestamp<>(TIMESTAMP.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> currentTimestamp(int precision) {
        return currentTimestamp(Tools.field(precision));
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> currentTimestamp(Field<Integer> precision) {
        return new CurrentTimestamp<>(TIMESTAMP.notNull(), precision);
    }

    /**
     * Synonym for {@link #currentTimestamp()}.
     */
    @NotNull
    @Support
    public static Field<Timestamp> now() {
        return currentTimestamp();
    }

    /**
     * Synonym for {@link #currentTimestamp(Field)}.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Timestamp> now(Field<Integer> precision) {
        return currentTimestamp(precision);
    }

    /**
     * Get the current_date() function returning a SQL standard
     * {@link SQLDataType#DATE} type.
     * <p>
     * Note, while there is a <code>CURRENT_DATE</code> function in
     * {@link SQLDialect#ORACLE}, that function returns a seconds-precision
     * {@link SQLDataType#TIMESTAMP}, which is undesired from a vendor
     * agnosticity perspective. This function thus produces an expression that
     * conforms to the SQL standard idea of a {@link SQLDataType#DATE} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> currentLocalDate() {
        return new CurrentDate<>(SQLDataType.LOCALDATE.notNull());
    }

    /**
     * Get the current_time() function returning a SQL standard
     * {@link SQLDataType#TIME} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalTime> currentLocalTime() {
        return new CurrentTime<>(SQLDataType.LOCALTIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> currentLocalDateTime() {
        return new CurrentTimestamp<>(SQLDataType.LOCALDATETIME.notNull());
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<LocalDateTime> currentLocalDateTime(int precision) {
        return currentLocalDateTime(Tools.field(precision));
    }

    /**
     * Get the current_timestamp() function returning a SQL standard
     * {@link SQLDataType#TIMESTAMP} type with the specified fractional
     * seconds precision.
     */
    @NotNull
    @Support({ FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<LocalDateTime> currentLocalDateTime(Field<Integer> precision) {
        return new CurrentTimestamp<>(SQLDataType.LOCALDATETIME.notNull(), precision);
    }

    /**
     * Get the current_time() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<OffsetTime> currentOffsetTime() {
        return currentTime().cast(SQLDataType.OFFSETTIME.notNull());
    }

    /**
     * Get the current_timestamp() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<OffsetDateTime> currentOffsetDateTime() {
        return currentTimestamp().cast(SQLDataType.OFFSETDATETIME.notNull());
    }

    /**
     * Get the current_timestamp() function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Instant> currentInstant() {
        return currentTimestamp().cast(SQLDataType.INSTANT.notNull());
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Date endDate, Date startDate) {
        return dateDiff(Tools.field(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Field<Date> endDate, Date startDate) {
        return dateDiff(Tools.nullSafe(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Date endDate, Field<Date> startDate) {
        return dateDiff(Tools.field(endDate), Tools.nullSafe(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> dateDiff(Field<Date> endDate, Field<Date> startDate) {
        return new DateDiff<>(null, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> dateDiff(DatePart part, Date startDate, Date endDate) {
        return dateDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> dateDiff(DatePart part, Field<Date> startDate, Date endDate) {
        return dateDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> dateDiff(DatePart part, Date startDate, Field<Date> endDate) {
        return dateDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> dateDiff(DatePart part, Field<Date> startDate, Field<Date> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Number interval) {
        return dateSub(Tools.field(date), Tools.field(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Field)
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Field<? extends Number> interval) {
        return Tools.nullSafe(date).sub(interval);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Number interval, DatePart datePart) {
        return dateSub(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Date date, Field<? extends Number> interval, DatePart datePart) {
        return dateSub(Tools.field(date), Tools.nullSafe(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Number interval, DatePart datePart) {
        return dateSub(Tools.nullSafe(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Date> dateSub(Field<Date> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Number)
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp timestamp, Number interval) {
        return timestampSub(Tools.field(timestamp), Tools.field(interval));
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> timestamp, Field<? extends Number> interval) {
        return Tools.nullSafe(timestamp).sub(interval);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Timestamp date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Timestamp> timestampSub(Field<Timestamp> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Timestamp timestamp1, Timestamp timestamp2) {
        return timestampDiff(Tools.field(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Field<Timestamp> timestamp1, Timestamp timestamp2) {
        return timestampDiff(Tools.nullSafe(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Timestamp timestamp1, Field<Timestamp> timestamp2) {
        return timestampDiff(Tools.field(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> timestampDiff(Field<Timestamp> timestamp1, Field<Timestamp> timestamp2) {
        return new TimestampDiff(Tools.nullSafe(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Timestamp startDate, Timestamp endDate) {
        return timestampDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Field<Timestamp> startDate, Timestamp endDate) {
        return timestampDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Timestamp startDate, Field<Timestamp> endDate) {
        return timestampDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> timestampDiff(DatePart part, Field<Timestamp> startDate, Field<Timestamp> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(LocalDate endDate, LocalDate startDate) {
        return localDateDiff(Tools.field(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(Field<LocalDate> endDate, LocalDate startDate) {
        return localDateDiff(Tools.nullSafe(endDate), Tools.field(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(LocalDate endDate, Field<LocalDate> startDate) {
        return localDateDiff(Tools.field(endDate), Tools.nullSafe(startDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in
     * number of days.
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<Integer> localDateDiff(Field<LocalDate> endDate, Field<LocalDate> startDate) {
        return new DateDiff<>(null, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, LocalDate startDate, LocalDate endDate) {
        return localDateDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, Field<LocalDate> startDate, LocalDate endDate) {
        return localDateDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, LocalDate startDate, Field<LocalDate> endDate) {
        return localDateDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example, <code>DATEDIFF(YEAR, '2000-03-01', '2002-01-01') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateDiff(DatePart part, Field<LocalDate> startDate, Field<LocalDate> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Number)
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Number interval) {
        return localDateSub(Tools.field(date), Tools.field(interval));
    }

    /**
     * Subtract an interval from a date.
     * <p>
     * This translates into any dialect
     *
     * @see Field#add(Field)
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Field<? extends Number> interval) {
        return Tools.nullSafe(date).sub(interval);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Number interval, DatePart datePart) {
        return localDateSub(Tools.field(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(LocalDate date, Field<? extends Number> interval, DatePart datePart) {
        return localDateSub(Tools.field(date), Tools.nullSafe(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Number interval, DatePart datePart) {
        return localDateSub(Tools.nullSafe(date), Tools.field(interval), datePart);
    }

    /**
     * Subtract an interval from a date, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDate> localDateSub(Field<LocalDate> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Number)
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime timestamp, Number interval) {
        return localDateTimeSub(Tools.field(timestamp), Tools.field(interval));
    }

    /**
     * Subtract an interval from a timestamp.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> timestamp, Field<? extends Number> interval) {
        return Tools.nullSafe(timestamp).sub(interval);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(LocalDateTime date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.field(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> date, Number interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.field(interval).neg(), datePart);
    }

    /**
     * Subtract an interval from a timestamp, given a date part.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<LocalDateTime> localDateTimeSub(Field<LocalDateTime> date, Field<? extends Number> interval, DatePart datePart) {
        return new DateAdd<>(Tools.nullSafe(date), Tools.nullSafe(interval).neg(), datePart);
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(LocalDateTime timestamp1, LocalDateTime timestamp2) {
        return localDateTimeDiff(Tools.field(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(Field<LocalDateTime> timestamp1, LocalDateTime timestamp2) {
        return localDateTimeDiff(Tools.nullSafe(timestamp1), Tools.field(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(LocalDateTime timestamp1, Field<LocalDateTime> timestamp2) {
        return localDateTimeDiff(Tools.field(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the timestamp difference as a <code>INTERVAL DAY TO SECOND</code>
     * type.
     * <p>
     * This translates into any dialect
     *
     * @see Field#sub(Field)
     */
    @NotNull
    @Support
    public static Field<DayToSecond> localDateTimeDiff(Field<LocalDateTime> timestamp1, Field<LocalDateTime> timestamp2) {
        return new TimestampDiff(Tools.nullSafe(timestamp1), Tools.nullSafe(timestamp2));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, LocalDateTime startDate, LocalDateTime endDate) {
        return localDateTimeDiff(part, Tools.field(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, Field<LocalDateTime> startDate, LocalDateTime endDate) {
        return localDateTimeDiff(part, Tools.nullSafe(startDate), Tools.field(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, LocalDateTime startDate, Field<LocalDateTime> endDate) {
        return localDateTimeDiff(part, Tools.field(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Get the date difference between <code>endDate - startDate</code> in terms
     * of <code>part</code>.
     * <p>
     * For example,
     * <code>TIMESTAMPDIFF(YEAR, '2000-03-01 00:00:00', '2002-01-01 00:00:00') = 2</code>,
     * despite there being less than 2 years between the two days. The behaviour
     * replicates that of SQL Server.
     */
    @NotNull
    @Support({ DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> localDateTimeDiff(DatePart part, Field<LocalDateTime> startDate, Field<LocalDateTime> endDate) {
        return new DateDiff<>(part, Tools.nullSafe(startDate), Tools.nullSafe(endDate));
    }

    /**
     * Truncate a date to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Date> trunc(Date date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Date> trunc(Date date, DatePart part) {
        return trunc(Tools.field(date), part);
    }

    /**
     * Truncate a date to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> trunc(LocalDate date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> trunc(LocalDate date, DatePart part) {
        return trunc(Tools.field(date), part);
    }

    /**
     * Truncate a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> trunc(Timestamp timestamp) {
        return trunc(timestamp, DatePart.DAY);
    }

    /**
     * Truncate a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<Timestamp> trunc(Timestamp timestamp, DatePart part) {
        return trunc(Tools.field(timestamp), part);
    }

    /**
     * Truncate a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> trunc(LocalDateTime timestamp) {
        return trunc(timestamp, DatePart.DAY);
    }

    /**
     * Truncate a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> trunc(LocalDateTime timestamp, DatePart part) {
        return trunc(Tools.field(timestamp), part);
    }

    /**
     * Truncate a date or a timestamp to the beginning of the day.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> trunc(Field<T> date) {
        return trunc(date, DatePart.DAY);
    }

    /**
     * Truncate a date or a timestamp to a given datepart.
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, POSTGRES })
    public static <T> Field<T> trunc(Field<T> date, DatePart part) {
        return new TruncDate<>(date, part);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(java.util.Date value, DatePart datePart) {
        return extract(Tools.field(Convert.convert(value, Timestamp.class)), datePart);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(Temporal value, DatePart datePart) {
        return extract(Tools.field(value), datePart);
    }

    /**
     * Get the extract(field, datePart) function.
     * <p>
     * This translates into any dialect
     */
    @NotNull
    @Support
    public static Field<Integer> extract(Field<?> field, DatePart datePart) {
        return new Extract(Tools.nullSafe(field), datePart);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(java.util.Date value) {
        return extract(value, DatePart.EPOCH);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(Temporal value) {
        return extract(value, DatePart.EPOCH);
    }

    /**
     * Get the epoch of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#EPOCH}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> epoch(Field<?> field) {
        return extract(field, DatePart.EPOCH);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(java.util.Date value) {
        return extract(value, DatePart.MILLENNIUM);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(Temporal value) {
        return extract(value, DatePart.MILLENNIUM);
    }

    /**
     * Get the millennium of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLENNIUM}
     */
    @NotNull
    @Support
    public static Field<Integer> millennium(Field<?> field) {
        return extract(field, DatePart.MILLENNIUM);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(java.util.Date value) {
        return extract(value, DatePart.CENTURY);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(Temporal value) {
        return extract(value, DatePart.CENTURY);
    }

    /**
     * Get the century of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#CENTURY}
     */
    @NotNull
    @Support
    public static Field<Integer> century(Field<?> field) {
        return extract(field, DatePart.CENTURY);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(java.util.Date value) {
        return extract(value, DatePart.DECADE);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(Temporal value) {
        return extract(value, DatePart.DECADE);
    }

    /**
     * Get the decade of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DECADE}
     */
    @NotNull
    @Support
    public static Field<Integer> decade(Field<?> field) {
        return extract(field, DatePart.DECADE);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(java.util.Date value) {
        return extract(value, DatePart.QUARTER);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(Temporal value) {
        return extract(value, DatePart.QUARTER);
    }

    /**
     * Get the quarter of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#QUARTER}
     */
    @NotNull
    @Support
    public static Field<Integer> quarter(Field<?> field) {
        return extract(field, DatePart.QUARTER);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(java.util.Date value) {
        return extract(value, DatePart.YEAR);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(Temporal value) {
        return extract(value, DatePart.YEAR);
    }

    /**
     * Get the year part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#YEAR}
     */
    @NotNull
    @Support
    public static Field<Integer> year(Field<?> field) {
        return extract(field, DatePart.YEAR);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(java.util.Date value) {
        return extract(value, DatePart.MONTH);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(Temporal value) {
        return extract(value, DatePart.MONTH);
    }

    /**
     * Get the month part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MONTH}
     */
    @NotNull
    @Support
    public static Field<Integer> month(Field<?> field) {
        return extract(field, DatePart.MONTH);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(java.util.Date value) {
        return extract(value, DatePart.WEEK);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(Temporal value) {
        return extract(value, DatePart.WEEK);
    }

    /**
     * Get the week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> week(Field<?> field) {
        return extract(field, DatePart.WEEK);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(java.util.Date value) {
        return extract(value, DatePart.DAY);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(Temporal value) {
        return extract(value, DatePart.DAY);
    }

    /**
     * Get the day part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY}
     */
    @NotNull
    @Support
    public static Field<Integer> day(Field<?> field) {
        return extract(field, DatePart.DAY);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(java.util.Date value) {
        return extract(value, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(Temporal value) {
        return extract(value, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfWeek(Field<?> field) {
        return extract(field, DatePart.DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(java.util.Date value) {
        return extract(value, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(Temporal value) {
        return extract(value, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the ISO day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#ISO_DAY_OF_WEEK}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> isoDayOfWeek(Field<?> field) {
        return extract(field, DatePart.ISO_DAY_OF_WEEK);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(java.util.Date value) {
        return extract(value, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(Temporal value) {
        return extract(value, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the day of week part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#DAY_OF_YEAR}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> dayOfYear(Field<?> field) {
        return extract(field, DatePart.DAY_OF_YEAR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(java.util.Date value) {
        return extract(value, DatePart.HOUR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(Temporal value) {
        return extract(value, DatePart.HOUR);
    }

    /**
     * Get the hour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#HOUR}
     */
    @NotNull
    @Support
    public static Field<Integer> hour(Field<?> field) {
        return extract(field, DatePart.HOUR);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(java.util.Date value) {
        return extract(value, DatePart.MINUTE);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(Temporal value) {
        return extract(value, DatePart.MINUTE);
    }

    /**
     * Get the minute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MINUTE}
     */
    @NotNull
    @Support
    public static Field<Integer> minute(Field<?> field) {
        return extract(field, DatePart.MINUTE);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(java.util.Date value) {
        return extract(value, DatePart.SECOND);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(Temporal value) {
        return extract(value, DatePart.SECOND);
    }

    /**
     * Get the second part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#SECOND}
     */
    @NotNull
    @Support
    public static Field<Integer> second(Field<?> field) {
        return extract(field, DatePart.SECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(java.util.Date value) {
        return extract(value, DatePart.MILLISECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(Temporal value) {
        return extract(value, DatePart.MILLISECOND);
    }

    /**
     * Get the millisecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MILLISECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> millisecond(Field<?> field) {
        return extract(field, DatePart.MILLISECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(java.util.Date value) {
        return extract(value, DatePart.MICROSECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(Temporal value) {
        return extract(value, DatePart.MICROSECOND);
    }

    /**
     * Get the microsecond part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#MICROSECOND}
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static Field<Integer> microsecond(Field<?> field) {
        return extract(field, DatePart.MICROSECOND);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(Temporal value) {
        return extract(value, DatePart.TIMEZONE);
    }

    /**
     * Get the timezone part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezone(Field<?> field) {
        return extract(field, DatePart.TIMEZONE);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(Temporal value) {
        return extract(value, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneHour part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE_HOUR}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneHour(Field<?> field) {
        return extract(field, DatePart.TIMEZONE_HOUR);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(java.util.Date, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(java.util.Date value) {
        return extract(value, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Temporal, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(Temporal value) {
        return extract(value, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Get the timezoneMinute part of a date.
     * <p>
     * This is the same as calling {@link #extract(Field, DatePart)}
     * with {@link DatePart#TIMEZONE_MINUTE}
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> timezoneMinute(Field<?> field) {
        return extract(field, DatePart.TIMEZONE_MINUTE);
    }

    /**
     * Convert a string value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(String value) {
        return Tools.field(Convert.convert(value, Date.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(java.util.Date value) {
        return Tools.field(Convert.convert(value, Date.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Date> date(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.DATE);
    }

    /**
     * Convert a string value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(String value) {
        return Tools.field(Convert.convert(value, Time.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(java.util.Date value) {
        return Tools.field(Convert.convert(value, Time.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Time> time(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.TIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(String value) {
        return Tools.field(Convert.convert(value, Timestamp.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(java.util.Date value) {
        return Tools.field(Convert.convert(value, Timestamp.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Timestamp> timestamp(Field<? extends java.util.Date> field) {
        return new DateOrTime<>(field, SQLDataType.TIMESTAMP);
    }

    /**
     * Convert a string value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(String value) {
        return Tools.field(Convert.convert(value, LocalDate.class));
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(LocalDate value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>DATE</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDate> localDate(Field<LocalDate> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALDATE);
    }

    /**
     * Convert a string value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(String value) {
        return Tools.field(Convert.convert(value, LocalTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(LocalTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIME</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalTime> localTime(Field<LocalTime> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALTIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(String value) {
        return Tools.field(Convert.convert(value, LocalDateTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(LocalDateTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP</code>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<LocalDateTime> localDateTime(Field<LocalDateTime> field) {
        return new DateOrTime<>(field, SQLDataType.LOCALDATETIME);
    }

    /**
     * Convert a string value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(String value) {
        return Tools.field(Convert.convert(value, OffsetTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(OffsetTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIME WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetTime> offsetTime(Field<OffsetTime> field) {
        return new DateOrTime<>(field, SQLDataType.OFFSETTIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(String value) {
        return Tools.field(Convert.convert(value, OffsetDateTime.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(OffsetDateTime value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<OffsetDateTime> offsetDateTime(Field<OffsetDateTime> field) {
        return new DateOrTime<>(field, SQLDataType.OFFSETDATETIME);
    }

    /**
     * Convert a string value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(String value) {
        return Tools.field(Convert.convert(value, Instant.class));
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(Instant value) {
        return Tools.field(value);
    }

    /**
     * Convert a temporal value to a <code>TIMESTAMP WITH TIME ZONE</code>.
     * <p>
     * Depending on whether the database preserves the time zone information
     * (e.g. {@link SQLDialect#ORACLE}) or not (e.g.
     * {@link SQLDialect#POSTGRES}), the resulting value might be converted to
     * UTC. Regardless of this fact, the result should be the same
     * {@link Instant} (in UTC) as the input.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES, SQLITE })
    public static Field<Instant> instant(Field<Instant> field) {
        return new DateOrTime<>(field, SQLDataType.INSTANT);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(String value, String format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(String value, Field<String> format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(Field<String> value, String format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>DATE</code>.
     *
     * @param value The formatted <code>DATE</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDate> toLocalDate(Field<String> value, Field<String> format) {
        return toDate(value, format).coerce(SQLDataType.LOCALDATE);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(String value, String format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(String value, Field<String> format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(Field<String> value, String format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    /**
     * Parse a value to a <code>TIMESTAMP</code>.
     *
     * @param value The formatted <code>TIMESTAMP</code> value.
     * @param format The vendor-specific formatting string.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<LocalDateTime> toLocalDateTime(Field<String> value, Field<String> format) {
        return toTimestamp(value, format).coerce(SQLDataType.LOCALDATETIME);
    }

    // ------------------------------------------------------------------------
    // XXX Construction of GROUPING SET functions
    // ------------------------------------------------------------------------

    /**
     * Create a ROLLUP(field1, field2, .., fieldn) grouping field.
     *
     * @see #rollup(FieldOrRow...)
     */
    @NotNull
    @Support({ CUBRID, MARIADB, MYSQL, POSTGRES })
    public static GroupField rollup(Field<?>... fields) {
        return rollup((FieldOrRow[]) Tools.nullSafe(fields));
    }

    /**
     * Create a ROLLUP(field1, field2, .., fieldn) grouping field.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>MySQL (emulated using the GROUP BY .. WITH ROLLUP clause)</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>ROLLUP</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ CUBRID, MARIADB, MYSQL, POSTGRES })
    public static GroupField rollup(FieldOrRow... fields) {
        return new Rollup(fields);
    }

    /**
     * Create a CUBE(field1, field2, .., fieldn) grouping field.
     *
     * @see #cube(Field...)
     */
    @NotNull
    @Support({ POSTGRES })
    public static GroupField cube(Field<?>... fields) {
        return cube((FieldOrRow[]) Tools.nullSafe(fields));
    }

    /**
     * Create a CUBE(field1, field2, .., fieldn) grouping field.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>CUBE</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ POSTGRES })
    public static GroupField cube(FieldOrRow... fields) {
        return field("{0} ({1})", Object.class, K_CUBE, new QueryPartList<>(fields));
    }

    /**
     * Create a GROUPING SETS(field1, field2, .., fieldn) grouping field where
     * each grouping set only consists of a single field.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fields The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ POSTGRES })
    public static GroupField groupingSets(Field<?>... fields) {
        List<Field<?>>[] array = map(fields, f -> asList(f), List[]::new);
        return groupingSets(array);
    }

    /**
     * Create a GROUPING SETS((field1a, field1b), (field2a), .., (fieldna,
     * fieldnb)) grouping field.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fieldSets The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ POSTGRES })
    public static GroupField groupingSets(Field<?>[]... fieldSets) {
        List<Field<?>>[] array = map(fieldSets, f -> asList(f), List[]::new);
        return groupingSets(array);
    }

    /**
     * Create a GROUPING SETS((field1a, field1b), (field2a), .., (fieldna,
     * fieldnb)) grouping field.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     * <p>
     * Please check the SQL Server documentation for a very nice explanation of
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * clauses in grouping contexts: <a
     * href="http://msdn.microsoft.com/en-US/library/bb522495.aspx"
     * >http://msdn.microsoft.com/en-US/library/bb522495.aspx</a>
     *
     * @param fieldSets The fields that are part of the <code>GROUPING SETS</code>
     *            function
     * @return A field to be used in a <code>GROUP BY</code> clause
     */
    @NotNull
    @Support({ POSTGRES })
    public static GroupField groupingSets(Collection<? extends Field<?>>... fieldSets) {
        QueryPartList<WrappedList> arg = new QueryPartList<>();

        for (Collection<? extends Field<?>> fieldsSet : fieldSets)
            arg.add(new WrappedList(new QueryPartList<>(fieldsSet)));

        return field("{0} ({1})", SQLDataType.OTHER, K_GROUPING_SETS, arg);
    }











































    /**
     * Create a GROUPING(field) aggregation field to be used along with
     * <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>
     * groupings.
     * <p>
     * This has been observed to work with the following databases:
     * <ul>
     * <li>DB2</li>
     * <li>Oracle</li>
     * <li>PostgreSQL 9.5</li>
     * <li>SQL Server</li>
     * <li>Sybase SQL Anywhere</li>
     * </ul>
     *
     * @param field The function argument
     * @return The <code>GROUPING</code> aggregation field
     * @see #cube(Field...)
     * @see #rollup(Field...)
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<Integer> grouping(Field<?> field) {
        return function("grouping", Integer.class, field);
    }

    // ------------------------------------------------------------------------
    // XXX Bitwise operations
    // ------------------------------------------------------------------------

    /**
     * The MySQL <code>BIT_COUNT(field)</code> function, counting the number of
     * bits that are set in this number.
     *
     * @see #bitCount(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> bitCount(Number value) {
        return bitCount(Tools.field(value));
    }

    /**
     * The MySQL <code>BIT_COUNT(field)</code> function, counting the number of
     * bits that are set in this number.
     * <p>
     * This function is emulated in most other databases like this (for a
     * TINYINT field): <code><pre>
     * ([field] &amp;   1) +
     * ([field] &amp;   2) &gt;&gt; 1 +
     * ([field] &amp;   4) &gt;&gt; 2 +
     * ([field] &amp;   8) &gt;&gt; 3 +
     * ([field] &amp;  16) &gt;&gt; 4 +
     *  ...
     * ([field] &amp; 128) &gt;&gt; 7
     * </pre></code>
     * <p>
     * More efficient algorithms are very welcome
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static Field<Integer> bitCount(Field<? extends Number> field) {
        return new BitCount(Tools.nullSafe(field));
    }

    /**
     * The bitwise not operator.
     *
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNot(T value) {
        return bitNot(Tools.field(value));
    }

    /**
     * The bitwise not operator.
     * <p>
     * Most dialects natively support this using <code>~[field]</code>. jOOQ
     * emulates this operator in some dialects using <code>-[field] - 1</code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNot(Field<T> field) {
        return new Neg<>(Tools.nullSafe(field), false, ExpressionOperator.BIT_NOT);
    }

    /**
     * The bitwise and operator.
     *
     * @see #bitAnd(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitAnd(T value1, T value2) {
        return bitAnd(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise and operator.
     *
     * @see #bitAnd(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitAnd(T value1, Field<T> value2) {
        return bitAnd(Tools.field(value1, value2), Tools.nullSafe(value2));
    }

    /**
     * The bitwise and operator.
     *
     * @see #bitAnd(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitAnd(Field<T> value1, T value2) {
        return bitAnd(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise and operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the and operation where available:
     * <code><pre>[field1] &amp; [field2]</pre></code>
     * ... or the and function elsewhere:
     * <code><pre>bitand([field1], [field2])</pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitAnd(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_AND, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise not and operator.
     *
     * @see #bitNand(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNand(T value1, T value2) {
        return bitNand(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise not and operator.
     *
     * @see #bitNand(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNand(T value1, Field<T> value2) {
        return bitNand(Tools.field(value1, value2), Tools.nullSafe(value2));
    }

    /**
     * The bitwise not and operator.
     *
     * @see #bitNand(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNand(Field<T> value1, T value2) {
        return bitNand(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise not and operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the not and operation where available:
     * <code><pre>~([field1] &amp; [field2])</pre></code>
     * ... or the not and function elsewhere:
     * <code><pre>bitnot(bitand([field1], [field2]))</pre></code>
     *
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNand(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_NAND, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise or operator.
     *
     * @see #bitOr(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitOr(T value1, T value2) {
        return bitOr(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise or operator.
     *
     * @see #bitOr(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitOr(T value1, Field<T> value2) {
        return bitOr(Tools.field(value1, value2), Tools.nullSafe(value2));
    }

    /**
     * The bitwise or operator.
     *
     * @see #bitOr(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitOr(Field<T> value1, T value2) {
        return bitOr(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise or operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the or operation where available:
     * <code><pre>[field1] | [field2]</pre></code>
     * ... or the or function elsewhere:
     * <code><pre>bitor([field1], [field2])</pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitOr(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_OR, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise not or operator.
     *
     * @see #bitNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNor(T value1, T value2) {
        return bitNor(Tools.field(value1), Tools.field(value2));
    }
    /**
     * The bitwise not or operator.
     *
     * @see #bitNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNor(T value1, Field<T> value2) {
        return bitNor(Tools.field(value1, value2), Tools.nullSafe(value2));
    }
    /**
     * The bitwise not or operator.
     *
     * @see #bitNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNor(Field<T> value1, T value2) {
        return bitNor(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise not or operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the not or operation where available:
     * <code><pre>~([field1] | [field2])</pre></code>
     * ... or the not or function elsewhere:
     * <code><pre>bitnot(bitor([field1], [field2]))</pre></code>
     *
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitNor(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_NOR, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise xor operator.
     *
     * @see #bitXor(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXor(T value1, T value2) {
        return bitXor(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise xor operator.
     *
     * @see #bitXor(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXor(T value1, Field<T> value2) {
        return bitXor(Tools.field(value1, value2), Tools.nullSafe(value2));
    }

    /**
     * The bitwise xor operator.
     *
     * @see #bitXor(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXor(Field<T> value1, T value2) {
        return bitXor(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise xor operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the or operation where available:
     * <code><pre>[field1] ^ [field2]</pre></code>
     * ... or the xor function elsewhere:
     * <code><pre>bitxor([field1], [field2])</pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXor(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_XOR, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise not xor operator.
     *
     * @see #bitXNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXNor(T value1, T value2) {
        return bitXNor(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise not xor operator.
     *
     * @see #bitXNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXNor(T value1, Field<T> value2) {
        return bitXNor(Tools.field(value1, value2), Tools.nullSafe(value2));
    }

    /**
     * The bitwise not xor operator.
     *
     * @see #bitXNor(Field, Field)
     * @see #bitNot(Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXNor(Field<T> value1, T value2) {
        return bitXNor(Tools.nullSafe(value1), Tools.field(value2, value1));
    }

    /**
     * The bitwise not xor operator.
     * <p>
     * This is not supported by Derby, Ingres
     * <p>
     * This renders the or operation where available:
     * <code><pre>~([field1] ^ [field2])</pre></code>
     * ... or the not xor function elsewhere:
     * <code><pre>bitnot(bitxor([field1], [field2]))</pre></code>
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> bitXNor(Field<T> field1, Field<T> field2) {
        return new Expression<>(ExpressionOperator.BIT_XNOR, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise left shift operator.
     *
     * @see #shl(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shl(T value1, Number value2) {
        return shl(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise left shift operator.
     *
     * @see #shl(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shl(T value1, Field<? extends Number> value2) {
        return shl(Tools.field(value1), Tools.nullSafe(value2));
    }

    /**
     * The bitwise left shift operator.
     *
     * @see #shl(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shl(Field<T> value1, Number value2) {
        return shl(Tools.nullSafe(value1), Tools.field(value2));
    }

    /**
     * The bitwise left shift operator.
     * <p>
     * Some dialects natively support this using <code>[field1] &lt;&lt; [field2]</code>.
     * jOOQ emulates this operator in some dialects using
     * <code>[field1] * power(2, [field2])</code>, where power might also be emulated.
     *
     * @see #power(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shl(Field<T> field1, Field<? extends Number> field2) {
        return new Expression<>(ExpressionOperator.SHL, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    /**
     * The bitwise right shift operator.
     *
     * @see #shr(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shr(T value1, Number value2) {
        return shr(Tools.field(value1), Tools.field(value2));
    }

    /**
     * The bitwise right shift operator.
     *
     * @see #shr(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shr(T value1, Field<? extends Number> value2) {
        return shr(Tools.field(value1), Tools.nullSafe(value2));
    }

    /**
     * The bitwise right shift operator.
     *
     * @see #shr(Field, Field)
     * @see #power(Field, Number)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shr(Field<T> value1, Number value2) {
        return shr(Tools.nullSafe(value1), Tools.field(value2));
    }

    /**
     * The bitwise right shift operator.
     * <p>
     * Some dialects natively support this using <code>[field1] &gt;&gt; [field2]</code>.
     * jOOQ emulates this operator in some dialects using
     * <code>[field1] / power(2, [field2])</code>, where power might also be emulated.
     *
     * @see #power(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T extends Number> Field<T> shr(Field<T> field1, Field<? extends Number> field2) {
        return new Expression<>(ExpressionOperator.SHR, false, Tools.nullSafe(field1), Tools.nullSafe(field2));
    }

    // ------------------------------------------------------------------------
    // XXX Mathematical functions
    // ------------------------------------------------------------------------

    /**
     * Find the greatest among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     *
     * @see #greatest(Field, Field...)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> greatest(T value, T... values) {
        return greatest(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * Find the greatest among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> greatest(Field<T> field, Field<?>... others) {
        return new Greatest<>(Tools.nullSafeDataType(field), Tools.nullSafe(combine(field, others)));
    }

    /**
     * Find the least among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     *
     * @see #least(Field, Field...)
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> least(T value, T... values) {
        return least(Tools.field(value), Tools.fieldsArray(values));
    }

    /**
     * Find the least among all values.
     * <p>
     * This function has no equivalent in Adaptive Server, Derby, SQL Server and
     * Sybase SQL Anywhere. Its current simulation implementation has
     * <code>O(2^n)</code> complexity and should be avoided for
     * <code>n &gt; 5</code>! Better implementation suggestions are very
     * welcome.
     */
    @NotNull
    @Support
    @SafeVarargs
    public static <T> Field<T> least(Field<T> field, Field<?>... others) {
        return new Least<>(Tools.nullSafeDataType(field), Tools.nullSafe(combine(field, others)));
    }

    /**
     * Negate a field to get its negative value.
     *
     * @see Field#neg()
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> neg(Field<T> field) {
        return field.neg();
    }

    /**
     * Negate a field to get its negative value.
     *
     * @see Field#neg()
     */
    @NotNull
    @Support
    public static <T extends Number> Field<T> minus(Field<T> field) {
        return field.neg();
    }

    /**
     * Truncate a number to a given number of decimals.
     *
     * @see #trunc(Field, Field)
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static <T extends Number> Field<T> trunc(T number) {
        return trunc(Tools.field(number), inline(0));
    }

    // -------------------------------------------------------------------------
    // XXX XML functions
    // -------------------------------------------------------------------------

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseDocument(String content) {
        return xmlparseDocument(Tools.field(content));
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseDocument(Field<String> content) {
        return new XMLParse(content, DocumentOrContent.DOCUMENT);
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseContent(String content) {
        return xmlparseContent(Tools.field(content));
    }

    /**
     * The XML parse function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlparseContent(Field<String> content) {
        return new XMLParse(content, DocumentOrContent.CONTENT);
    }

    /**
     * The XML concat function.
     */
    @NotNull
    @Support({ POSTGRES })
    @SafeVarargs
    public static Field<XML> xmlconcat(Field<?>... fields) {
        return xmlconcat(asList(fields));
    }

    /**
     * The XML concat function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlconcat(Collection<? extends Field<?>> fields) {
        return new XMLConcat(fields);
    }















    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, Field<?>... content) {
        return xmlelement(name(name), (XMLAttributes) null, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, Collection<? extends Field<?>> content) {
        return xmlelement(name(name), (XMLAttributes) null, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, Field<?>... content) {
        return xmlelement(name, (XMLAttributes) null, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, Collection<? extends Field<?>> content) {
        return xmlelement(name, (XMLAttributes) null, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, XMLAttributes attributes, Field<?>... content) {
        return xmlelement(name(name), attributes, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(String name, XMLAttributes attributes, Collection<? extends Field<?>> content) {
        return xmlelement(name(name), attributes, content);
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, XMLAttributes attributes, Field<?>... content) {
        return xmlelement(name, attributes, asList(content));
    }

    /**
     * The XML element constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlelement(Name name, XMLAttributes attributes, Collection<? extends Field<?>> content) {
        return new XMLElement(name, attributes, content);
    }

    /**
     * The XML attributes constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAttributes xmlattributes(Field<?>... attributes) {
        return xmlattributes(asList(attributes));
    }

    /**
     * The XML attributes constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAttributes xmlattributes(Collection<? extends Field<?>> attributes) {
        return new XMLAttributesImpl(attributes);
    }

    /**
     * The XML processing instruction constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(String target) {
        return xmlpi(name(target), null);
    }

    /**
     * The XML processing instruction constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(Name target) {
        return xmlpi(target, null);
    }

    /**
     * The XML processing instruction constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(String target, Field<?> content) {
        return xmlpi(name(target), content);
    }

    /**
     * The XML processing instruction constructor.
     */
    @NotNull
    @Support({ POSTGRES })
    public static Field<XML> xmlpi(Name target, Field<?> content) {
        return new XMLPI(target, content);
    }

    /**
     * The XML aggregate function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLAggOrderByStep<XML> xmlagg(Field<XML> field) {
        return new XMLAgg(field);
    }

    /**
     * The XML query function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLQueryPassingStep xmlquery(String xpath) {
        return xmlquery(Tools.field(xpath));
    }

    /**
     * The XML query function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLQueryPassingStep xmlquery(Field<String> xpath) {
        return new XMLQuery(xpath);
    }

    /**
     * The XML exists function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLExistsPassingStep xmlexists(String xpath) {
        return xmlexists(Tools.field(xpath));
    }

    /**
     * The XML exists function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLExistsPassingStep xmlexists(Field<String> xpath) {
        return new XMLExists(xpath);
    }

    /**
     * The XML table function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLTablePassingStep xmltable(String xpath) {
        return xmltable(Tools.field(xpath));
    }

    /**
     * The XML table function.
     */
    @NotNull
    @Support({ POSTGRES })
    public static XMLTablePassingStep xmltable(Field<String> xpath) {
        return new XMLTable(xpath);
    }

    // -------------------------------------------------------------------------
    // XXX JSON functions
    // -------------------------------------------------------------------------

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONValueOnStep<JSON> jsonValue(Field<JSON> json, String path) {
        return jsonValue(json, Tools.field(path));
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONValueOnStep<JSON> jsonValue(Field<JSON> json, Field<String> path) {
        return new JSONValue<>(SQLDataType.JSON, json, path, null);
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONValueOnStep<JSONB> jsonbValue(Field<JSONB> json, String path) {
        return jsonbValue(json, Tools.field(path));
    }

    /**
     * The JSON value extractor function.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONValueOnStep<JSONB> jsonbValue(Field<JSONB> json, Field<String> path) {
        return new JSONValue<>(SQLDataType.JSONB, json, path, null);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONEntryValueStep key(String key) {
        return key(Tools.field(key));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(Field, Field)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONEntryValueStep key(Field<String> key) {
        return new JSONEntryImpl<>(key);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(Field<T> value) {
        return jsonEntry(value.getName(), value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(String key, T value) {
        return jsonEntry(Tools.field(key), Tools.field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(String key, Field<T> value) {
        return jsonEntry(Tools.field(key), value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(String key, Select<? extends Record1<T>> value) {
        return jsonEntry(Tools.field(key), field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, T value) {
        return jsonEntry(key, Tools.field(value));
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, Field<T> value) {
        return new JSONEntryImpl<>(key, value);
    }

    /**
     * A constructor for JSON entries to be used with
     * {@link #jsonObject(JSONEntry...)}.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T> JSONEntry<T> jsonEntry(Field<String> key, Select<? extends Record1<T>> value) {
        return jsonEntry(key, field(value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(String key, Field<?> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(Field<String> key, Field<?> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject(Field<String> key, Select<? extends Record1<?>> value) {
        return jsonObject(jsonEntry(key, value));
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSON> jsonObject() {
        return jsonObject(Tools.EMPTY_JSONENTRY);
    }

    /**
     * The JSON object constructor.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectNullStep<JSONB> jsonbObject() {
        return jsonbObject(Tools.EMPTY_JSONENTRY);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayAggOrderByStep<JSON> jsonArrayAgg(Field<?> value) {
        return new JSONArrayAgg<>(JSON, value);
    }

    /**
     * The JSON array aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONArrayAggOrderByStep<JSONB> jsonbArrayAgg(Field<?> value) {
        return new JSONArrayAgg<>(JSONB, value);
    }

    /**
     * The JSON object aggregate function.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(Field<?> value) {
        return jsonObjectAgg(jsonEntry(value));
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(String key, Field<?> value) {
        return jsonObjectAgg(Tools.field(key), value);
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(Field<String> key, Field<?> value) {
        return jsonObjectAgg(jsonEntry(key, value));
    }

    /**
     * The JSON object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSON> jsonObjectAgg(JSONEntry<?> entry) {
        return new JSONObjectAgg<>(JSON, entry);
    }

    /**
     * The JSONB object aggregate function.
     * <p>
     * This is the same as calling {@link #jsonEntry(String, Field)} with
     * {@link Field#getName()} as a key.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(Field<?> field) {
        return jsonbObjectAgg(jsonEntry(field));
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(String key, Field<?> value) {
        return jsonbObjectAgg(Tools.field(key), value);
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(Field<String> key, Field<?> value) {
        return jsonbObjectAgg(jsonEntry(key, value));
    }

    /**
     * The JSONB object aggregate function.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static JSONObjectAggNullStep<JSONB> jsonbObjectAgg(JSONEntry<?> entry) {
        return new JSONObjectAgg<>(JSONB, entry);
    }

    /**
     * The JSON exists predicate.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONExistsOnStep jsonExists(Field<JSON> field, String path) {
        return jsonExists(field, Tools.field(path));
    }

    /**
     * The JSON exists predicate.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONExistsOnStep jsonExists(Field<JSON> field, Field<String> path) {
        return new JSONExists(field, Tools.nullSafe(path));
    }

    /**
     * The JSONB exists predicate.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONExistsOnStep jsonbExists(Field<JSONB> field, String path) {
        return jsonbExists(field, Tools.field(path));
    }

    /**
     * The JSONB exists predicate.
     */
    @NotNull
    @Support({ MARIADB, MYSQL, POSTGRES })
    public static JSONExistsOnStep jsonbExists(Field<JSONB> field, Field<String> path) {
        return new JSONExists(field, Tools.nullSafe(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static JSONTableColumnsFirstStep jsonTable(JSON json, String path) {
        return jsonTable(Tools.field(json), Tools.field(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static JSONTableColumnsFirstStep jsonTable(Field<JSON> json, Field<String> path) {
        return new JSONTable(Tools.nullSafe(json), Tools.nullSafe(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static JSONTableColumnsFirstStep jsonbTable(JSONB json, String path) {
        return jsonbTable(Tools.field(json), Tools.field(path));
    }

    /**
     * The JSON table function.
     */
    @NotNull
    @Support({ MYSQL, POSTGRES })
    public static JSONTableColumnsFirstStep jsonbTable(Field<JSONB> json, Field<String> path) {
        return new JSONTable(Tools.nullSafe(json), Tools.nullSafe(path));
    }

    // -------------------------------------------------------------------------
    // XXX Array functions
    // -------------------------------------------------------------------------

    /**
     * Create an array literal.
     * <p>
     * This translates to the following databases and syntaxes:
     * <table>
     * <tr>
     * <th><code>SQLDialect</code></th>
     * <th>Java</th>
     * <th>SQL</th>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#H2}</td>
     * <td>array(1, 2)</td>
     * <td>(1, 2)</td>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#HSQLDB}, {@link SQLDialect#POSTGRES}</td>
     * <td>array(1, 2)</td>
     * <td>array[1, 2]</td>
     * </tr>
     * </table>
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T[]> array(T... values) {
        return array(Tools.fields(values));
    }

    /**
     * Create an array literal.
     * <p>
     * This translates to the following databases and syntaxes:
     * <table>
     * <tr>
     * <th><code>SQLDialect</code></th>
     * <th>Java</th>
     * <th>SQL</th>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#H2}</td>
     * <td>array(1, 2)</td>
     * <td>(1, 2)</td>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#HSQLDB}, {@link SQLDialect#POSTGRES}</td>
     * <td>array(1, 2)</td>
     * <td>array[1, 2]</td>
     * </tr>
     * </table>
     */
    @SafeVarargs
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T[]> array(Field<T>... fields) {
        return array(Arrays.asList(fields));
    }

    /**
     * Create an array literal.
     * <p>
     * This translates to the following databases and syntaxes:
     * <table>
     * <tr>
     * <th><code>SQLDialect</code></th>
     * <th>Java</th>
     * <th>SQL</th>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#H2}</td>
     * <td>array(1, 2)</td>
     * <td>(1, 2)</td>
     * </tr>
     * <tr>
     * <td>{@link SQLDialect#HSQLDB}, {@link SQLDialect#POSTGRES}</td>
     * <td>array(1, 2)</td>
     * <td>array[1, 2]</td>
     * </tr>
     * </table>
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T[]> array(Collection<? extends Field<T>> fields) {
        return new Array<>(fields);
    }

    /**
     * The PostgreSQL <code>array(select)</code> function.
     * <p>
     * Example: <code><pre>
     * {1, 2, 3} = array(select 1 union select 2 union select 3)
     * </pre></code>
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T[]> array(Select<? extends Record1<T>> select) {
        return new ArraySelect<>(select);
    }

    /**
     * Calculate the cardinality of an array field.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static Field<Integer> cardinality(Field<? extends Object[]> field) {
        return new Cardinality(field);
    }

    /**
     * Get an array element at a given index (1 based)
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T> arrayGet(Field<T[]> field, int index) {
        return arrayGet(field, Tools.field(index));
    }

    /**
     * Get an array element at a given index (1 based)
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> Field<T> arrayGet(Field<T[]> field, Field<Integer> index) {
        return new ArrayGet<>(Tools.nullSafe(field), Tools.nullSafe(index));
    }

    /**
     * Get the <code>MULTISET</code> operator to nest subqueries.
     * <p>
     * EXPERIMENTAL: The standard SQL <code>MULTISET</code> operator is poorly
     * supported by most dialects. As such, it needs to be emulated using
     * elaborate mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * An important limitation is that correlating <code>MULTISET</code>
     * subqueries currently only works on dialects that support correlating
     * derived tables. This excludes:
     * <ul>
     * <li>{@link SQLDialect#DB2}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#MARIADB}</li>
     * <li>{@link SQLDialect#MYSQL_5_7}</li>
     * </ul>
     * <p>
     * See also <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12045">https://github.com/jOOQ/jOOQ/issues/12045</a>.
     * The various {@link #multisetAgg(Field...)} overloads are not affected
     * from this limitation.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <R extends Record> Field<Result<R>> multiset(Select<R> select) {
        return new Multiset<>(select);
    }

    // -------------------------------------------------------------------------
    // XXX Aggregate functions
    // -------------------------------------------------------------------------

    /**
     * The <code>ANY_VALUE</code> function.
     * <p>
     * Get any arbitrary value from the group.
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> anyValue(Field<T> value) {
        return new AnyValue(value);
    }

    /**
     * Get the count(*) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count() {
        return count(DefaultAggregateFunction.ASTERISK);
    }

    /**
     * Get the count(field) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(Field<?> field) {
        return new DefaultAggregateFunction<>(N_COUNT, SQLDataType.INTEGER, Tools.nullSafe(field));
    }

    /**
     * Get the count(field) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(SelectFieldOrAsterisk field) {
        return new DefaultAggregateFunction<>(N_COUNT, SQLDataType.INTEGER, field("{0}", field));
    }

    /**
     * Get the count(table) function.
     * <p>
     * If this is not supported by a given database (i.e. non
     * {@link SQLDialect#POSTGRES}, then the primary key is used with
     * {@link #count(Field)}, instead.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> count(Table<?> table) {
        return new CountTable(table, false);
    }

    /**
     * Get the count(distinct field) function.
     */
    @NotNull
    @Support
    public static AggregateFunction<Integer> countDistinct(Field<?> field) {
        return new DefaultAggregateFunction<>(true, N_COUNT, SQLDataType.INTEGER, Tools.nullSafe(field));
    }

    /**
     * Get the count(distinct field) function.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static AggregateFunction<Integer> countDistinct(SelectFieldOrAsterisk field) {
        return new DefaultAggregateFunction<>(true, N_COUNT, SQLDataType.INTEGER, field("{0}", field));
    }

    /**
     * Get the count(distinct table) function.
     * <p>
     * If this is not supported by a given database (i.e. non
     * {@link SQLDialect#POSTGRES}, then the primary key is used with
     * {@link #count(Field)}, instead.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static AggregateFunction<Integer> countDistinct(Table<?> table) {
        return new CountTable(table, true);
    }

    /**
     * Get the count(distinct field1, field2) function.
     * <p>
     * Some dialects support several expressions in the
     * <code>COUNT(DISTINCT expr1, expr2)</code> aggregate function.
     * <p>
     * {@link SQLDialect#POSTGRES} supports this as
     * <code>COUNT(DISTINCT(expr1, expr2))</code>.
     */
    @NotNull
    @Support({ H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<Integer> countDistinct(Field<?>... fields) {
        fields = Tools.nullSafe(fields);
        return fields.length == 0 ? countDistinct(asterisk()) : new DefaultAggregateFunction<>(true, N_COUNT, SQLDataType.INTEGER, fields);
    }

    /**
     * Get the every value over a field: every(field).
     * <p>
     * This is a synonym for {@link #boolAnd(Field)}.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> every(Field<Boolean> field) {
        return boolAnd(field);
    }

    /**
     * Get the every value over a condition: every(condition).
     * <p>
     * This is a synonym for {@link #boolAnd(Condition)}.
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> every(Condition condition) {
        return boolAnd(condition);
    }

    /**
     * Get the every value over a field: bool_and(field).
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolAnd(Field<Boolean> field) {
        return boolAnd(condition(Tools.nullSafe(field)));
    }

    /**
     * Get the every value over a condition: bool_and(condition).
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolAnd(Condition condition) {
        return new BoolAnd(condition);
    }

    /**
     * Get the every value over a field: bool_and(field).
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolOr(Field<Boolean> field) {
        return boolOr(condition(Tools.nullSafe(field)));
    }

    /**
     * Get the every value over a condition: bool_and(condition).
     */
    @NotNull
    @Support
    public static AggregateFunction<Boolean> boolOr(Condition condition) {
        return new BoolOr(condition);
    }

    /**
     * Get the <code>array_agg()</code> aggregate function.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> ArrayAggOrderByStep<T[]> arrayAgg(Field<T> field) {
        return new ArrayAgg(false, Tools.nullSafe(field));
    }

    /**
     * Get the <code>array_agg()</code> aggregate function.
     */
    @NotNull
    @Support({ H2, HSQLDB, POSTGRES })
    public static <T> ArrayAggOrderByStep<T[]> arrayAggDistinct(Field<T> field) {
        return new ArrayAgg(true, Tools.nullSafe(field));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static ArrayAggOrderByStep<Result<Record>> multisetAgg(Collection<? extends Field<?>> fields) {
        return new MultisetAgg<>(false, row(fields));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static ArrayAggOrderByStep<Result<Record>> multisetAgg(Field<?>... fields) {
        return new MultisetAgg<>(false, row(fields));
    }



    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1> ArrayAggOrderByStep<Result<Record1<T1>>> multisetAgg(SelectField<T1> field1) {
        return new MultisetAgg<>(false, row(field1));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2> ArrayAggOrderByStep<Result<Record2<T1, T2>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2) {
        return new MultisetAgg<>(false, row(field1, field2));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3> ArrayAggOrderByStep<Result<Record3<T1, T2, T3>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return new MultisetAgg<>(false, row(field1, field2, field3));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4> ArrayAggOrderByStep<Result<Record4<T1, T2, T3, T4>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5> ArrayAggOrderByStep<Result<Record5<T1, T2, T3, T4, T5>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6> ArrayAggOrderByStep<Result<Record6<T1, T2, T3, T4, T5, T6>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7> ArrayAggOrderByStep<Result<Record7<T1, T2, T3, T4, T5, T6, T7>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8> ArrayAggOrderByStep<Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> ArrayAggOrderByStep<Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ArrayAggOrderByStep<Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ArrayAggOrderByStep<Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ArrayAggOrderByStep<Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ArrayAggOrderByStep<Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ArrayAggOrderByStep<Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ArrayAggOrderByStep<Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> ArrayAggOrderByStep<Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> ArrayAggOrderByStep<Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> ArrayAggOrderByStep<Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> ArrayAggOrderByStep<Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> ArrayAggOrderByStep<Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> ArrayAggOrderByStep<Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21));
    }

    /**
     * Get the <code>MULTISET_AGG</code> aggregate function to nest group
     * contents.
     * <p>
     * EXPERIMENTAL: This synthetic, non-standard aggregate function works in a
     * similar way as the standard SQL <code>ARRAY_AGG</code> aggregate
     * function. It is emulated using mappings to any of:
     * <p>
     * <ul>
     * <li>{@link NestedCollectionEmulation#JSON}: A MULTISET of ROW types works
     * just like a {@link #jsonArrayAgg(Field)} of
     * {@link #jsonObject(Field...)}, or an application of
     * {@link SelectForStep#forJSON()}. jOOQ produces a JSON encoding that is
     * compatible with {@link DSLContext#fetchFromJSON(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link JSONFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#JSONB}: Just like <code>JSON</code>,
     * but we're using {@link #jsonbArrayAgg(Field)} and
     * {@link #jsonbObject(Field...)}, or {@link SelectForStep#forJSONB()}.</li>
     * <li>{@link NestedCollectionEmulation#XML}: A MULTISET of ROW types works
     * just like a {@link #xmlagg(Field)} of
     * {@link #xmlelement(Name, Field...)}, or an application of
     * {@link SelectForStep#forXML()}. jOOQ produces an XML encoding that is
     * compatible with {@link DSLContext#fetchFromXML(String)}. Future jOOQ
     * versions will make this format configurable according to
     * {@link XMLFormat.RecordFormat}.</li>
     * <li>{@link NestedCollectionEmulation#NATIVE}: A few dialects have native
     * support for MULTISET.</li>
     * <li>{@link NestedCollectionEmulation#DEFAULT}: By default, jOOQ chooses
     * the optimal encoding among the above depending on your dialect,
     * transparently.</li>
     * </ul>
     * <p>
     * The emulation to be chosen is governed by
     * {@link Settings#getEmulateMultiset()}.
     * <p>
     * <p>
     * A set of known limitations can be found here: <a href=
     * "https://github.com/jOOQ/jOOQ/issues/12021">https://github.com/jOOQ/jOOQ/issues/12021</a>.
     * <p>
     * Please report any issues you may encounter on the above issue, or in a
     * new issue on github.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES })
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> ArrayAggOrderByStep<Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>>> multisetAgg(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return new MultisetAgg<>(false, row(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22));
    }



































































    /**
     * Get the max value over a field: max(field).
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> max(Field<T> field) {
        return new DefaultAggregateFunction<>(N_MAX, Tools.nullSafeDataType(field), Tools.nullSafe(field));
    }

    /**
     * Get the max value over a field: max(distinct field).
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> maxDistinct(Field<T> field) {
        return new DefaultAggregateFunction<>(true, N_MAX, Tools.nullSafeDataType(field), Tools.nullSafe(field));
    }

    /**
     * Get the min value over a field: min(field).
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> min(Field<T> field) {
        return new DefaultAggregateFunction<>(N_MIN, Tools.nullSafeDataType(field), Tools.nullSafe(field));
    }

    /**
     * Get the min value over a field: min(distinct field).
     */
    @NotNull
    @Support
    public static <T> AggregateFunction<T> minDistinct(Field<T> field) {
        return new DefaultAggregateFunction<>(true, N_MIN, Tools.nullSafeDataType(field), Tools.nullSafe(field));
    }

    /**
     * Get the sum over a numeric field: sum(field).
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> sum(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(N_SUM, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    /**
     * Get the sum over a numeric field: sum(distinct field).
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> sumDistinct(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(true, N_SUM, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    /**
     * Get the product over a numeric field: product(field).
     * <p>
     * No database currently supports multiplicative aggregation natively. jOOQ
     * emulates this using <code>exp(sum(log(arg)))</code> for strictly positive
     * numbers, and does some additional handling for zero and negative numbers.
     * <p>
     * Note that this implementation may introduce rounding errors, even for
     * integer multiplication.
     * <p>
     * More information here: <a href=
     * "https://blog.jooq.org/2018/09/21/how-to-write-a-multiplication-aggregate-function-in-sql">https://blog.jooq.org/2018/09/21/how-to-write-a-multiplication-aggregate-function-in-sql</a>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> product(Field<? extends Number> field) {
        return new Product(false, Tools.nullSafe(field));
    }

    /**
     * Get the sum over a numeric field: product(distinct field).
     * <p>
     * No database currently supports multiplicative aggregation natively. jOOQ
     * emulates this using <code>exp(sum(log(arg)))</code> for strictly positive
     * numbers, and does some additional handling for zero and negative numbers.
     * <p>
     * Note that this implementation may introduce rounding errors, even for
     * integer multiplication.
     * <p>
     * More information here: <a href=
     * "https://blog.jooq.org/2018/09/21/how-to-write-a-multiplication-aggregate-function-in-sql">https://blog.jooq.org/2018/09/21/how-to-write-a-multiplication-aggregate-function-in-sql</a>.
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static AggregateFunction<BigDecimal> productDistinct(Field<? extends Number> field) {
        return new Product(true, Tools.nullSafe(field));
    }

    /**
     * Get the average over a numeric field: avg(field).
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> avg(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(N_AVG, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    /**
     * Get the average over a numeric field: avg(distinct field).
     */
    @NotNull
    @Support
    public static AggregateFunction<BigDecimal> avgDistinct(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(true, N_AVG, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    /**
     * The <code>mode(field)</code> aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static <T> AggregateFunction<T> mode(Field<T> field) {
        return new Mode(Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by {@link SQLDialect#ORACLE11G} upwards. It is
     * emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}: Using <code>GROUP_CONCAT</code></li>
     * <li> {@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li> {@link SQLDialect#H2}: Using <code>GROUP_CONCAT()</code></li>
     * <li> {@link SQLDialect#HSQLDB}: Using <code>GROUP_CONCAT()</code></li>
     * <li> {@link SQLDialect#MYSQL}: Using <code>GROUP_CONCAT()</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> listAgg(Field<?> field) {
        return new ListAgg(false, Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by {@link SQLDialect#ORACLE11G} upwards. It is
     * emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}: Using <code>GROUP_CONCAT</code></li>
     * <li> {@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li> {@link SQLDialect#H2}: Using <code>GROUP_CONCAT</code></li>
     * <li> {@link SQLDialect#HSQLDB}: Using <code>GROUP_CONCAT</code></li>
     * <li> {@link SQLDialect#MYSQL}: Using <code>GROUP_CONCAT</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #groupConcat(Field)
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static OrderedAggregateFunction<String> listAgg(Field<?> field, String separator) {
        return new ListAgg(false, Tools.nullSafe(field), inline(separator));
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#MEMSQL} (but without <code>ORDER BY</code>)</li>
     * <li> {@link SQLDialect#MYSQL}</li>
     * <li> {@link SQLDialect#SQLITE} (but without <code>ORDER BY</code>)</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li> {@link SQLDialect#ORACLE}: Using <code>LISTAGG()</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static GroupConcatOrderByStep groupConcat(Field<?> field) {
        return new GroupConcat(Tools.nullSafe(field));
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li>{@link SQLDialect#AURORA_MYSQL}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#HSQLDB}</li>
     * <li>{@link SQLDialect#MEMSQL}</li>
     * <li>{@link SQLDialect#MYSQL}</li>
     * <li>{@link SQLDialect#SQLITE}</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li>{@link SQLDialect#DB2}: Using <code>XMLAGG()</code></li>
     * <li>{@link SQLDialect#ORACLE}: Using <code>LISTAGG()</code></li>
     * <li>{@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * <li>{@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     * @deprecated - [#7956] - 3.12.0 - Use {@link #groupConcat(Field)} and
     *             {@link GroupConcatSeparatorStep#separator(String)} instead.
     */
    @Deprecated(forRemoval = true, since = "3.12")
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static AggregateFunction<String> groupConcat(Field<?> field, String separator) {
        return new GroupConcat(Tools.nullSafe(field)).separator(separator);
    }

    /**
     * Get the aggregated concatenation for a field.
     * <p>
     * This is natively supported by
     * <ul>
     * <li> {@link SQLDialect#AURORA_MYSQL}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#MYSQL}</li>
     * </ul>
     * <p>
     * It is emulated by the following dialects:
     * <ul>
     * <li> {@link SQLDialect#SYBASE}: Using <code>LIST()</code></li>
     * <li> {@link SQLDialect#POSTGRES}: Using <code>STRING_AGG()</code></li>
     * </ul>
     *
     * @see #listAgg(Field)
     */
    @NotNull
    @Support({ CUBRID, H2, HSQLDB, MARIADB, MYSQL, POSTGRES })
    public static GroupConcatOrderByStep groupConcatDistinct(Field<?> field) {
        return new GroupConcat(Tools.nullSafe(field), true);
    }

    // -------------------------------------------------------------------------
    // XXX Ordered-set aggregate functions and hypothetical set functions
    // -------------------------------------------------------------------------

    /**
     * The <code>mode() within group (oder by [order clause])</code> ordered
     * aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunctionOfDeferredType mode() {
        return new ModeDeferred();
    }

    /**
     * The <code>rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> rank(Field<?>... fields) {
        return new DefaultAggregateFunction<>(N_RANK, SQLDataType.INTEGER, fields);
    }

    /**
     * The <code>rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> rank(Collection<? extends Field<?>> fields) {
        return new DefaultAggregateFunction<>(N_RANK, SQLDataType.INTEGER, fields.toArray(EMPTY_FIELD));
    }

    /**
     * The <code>dense_rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> denseRank(Field<?>... fields) {
        return new DefaultAggregateFunction<>(N_DENSE_RANK, SQLDataType.INTEGER, fields);
    }

    /**
     * The <code>dense_rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> denseRank(Collection<? extends Field<?>> fields) {
        return new DefaultAggregateFunction<>(N_DENSE_RANK, SQLDataType.INTEGER, fields.toArray(EMPTY_FIELD));
    }

    /**
     * The <code>percent_rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> percentRank(Field<?>... fields) {
        return new DefaultAggregateFunction<>(N_PERCENT_RANK, SQLDataType.INTEGER, fields);
    }

    /**
     * The <code>percent_rank(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<Integer> percentRank(Collection<? extends Field<?>> fields) {
        return new DefaultAggregateFunction<>(N_PERCENT_RANK, SQLDataType.INTEGER, fields.toArray(EMPTY_FIELD));
    }

    /**
     * The <code>cume_dist(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> cumeDist(Field<?>... fields) {
        return new DefaultAggregateFunction<>(N_CUME_DIST, SQLDataType.NUMERIC, fields);
    }

    /**
     * The <code>cume_dist(expr) within group (order by [order clause])</code>
     * ordered-set aggregate function.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> cumeDist(Collection<? extends Field<?>> fields) {
        return new DefaultAggregateFunction<>(N_CUME_DIST, SQLDataType.NUMERIC, fields.toArray(EMPTY_FIELD));
    }

    /**
     * The
     * <code>percentile_cont([number]) within group (order by [column])</code>
     * function.
     * <p>
     * While most dialects support this as an aggregate function,
     * {@link SQLDialect#BIGQUERY}, {@link SQLDialect#SQLSERVER}, and
     * {@link SQLDialect#REDSHIFT} support only its window function variant.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> percentileCont(Number number) {
        return percentileCont(val(number));
    }

    /**
     * The
     * <code>percentile_cont([number]) within group (order by [column])</code>
     * function.
     * <p>
     * While most dialects support this as an aggregate function,
     * {@link SQLDialect#BIGQUERY}, {@link SQLDialect#SQLSERVER}, and
     * {@link SQLDialect#REDSHIFT} support only its window function variant.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> percentileCont(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(N_PERCENTILE_CONT, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    /**
     * The
     * <code>percentile_disc([number]) within group (order by [column])</code>
     * function.
     * <p>
     * While most dialects support this as an aggregate function,
     * {@link SQLDialect#BIGQUERY}, {@link SQLDialect#SQLSERVER}, and
     * {@link SQLDialect#REDSHIFT} support only its window function variant.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> percentileDisc(Number number) {
        return percentileDisc(val(number));
    }

    /**
     * The
     * <code>percentile_disc([number]) within group (order by [column])</code>
     * function.
     * <p>
     * While most dialects support this as an aggregate function,
     * {@link SQLDialect#BIGQUERY}, {@link SQLDialect#SQLSERVER}, and
     * {@link SQLDialect#REDSHIFT} support only its window function variant.
     */
    @NotNull
    @Support({ H2, POSTGRES })
    public static OrderedAggregateFunction<BigDecimal> percentileDisc(Field<? extends Number> field) {
        return new DefaultAggregateFunction<>(N_PERCENTILE_DISC, SQLDataType.NUMERIC, Tools.nullSafe(field));
    }

    // -------------------------------------------------------------------------
    // XXX Window clauses
    // -------------------------------------------------------------------------

    /**
     * Create a {@link WindowSpecification} with a <code>PARTITION BY</code> clause.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationOrderByStep partitionBy(Field<?>... fields) {
        return new WindowSpecificationImpl().partitionBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>PARTITION BY</code> clause.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationOrderByStep partitionBy(Collection<? extends Field<?>> fields) {
        return new WindowSpecificationImpl().partitionBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsStep orderBy(Field<?>... fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsStep orderBy(OrderField<?>... fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with an <code>ORDER BY</code> clause.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsStep orderBy(Collection<? extends OrderField<?>> fields) {
        return new WindowSpecificationImpl().orderBy(fields);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rowsUnboundedPreceding() {
        return new WindowSpecificationImpl().rowsUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rowsPreceding(int number) {
        return new WindowSpecificationImpl().rowsPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rowsCurrentRow() {
        return new WindowSpecificationImpl().rowsCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rowsUnboundedFollowing() {
        return new WindowSpecificationImpl().rowsUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rowsFollowing(int number) {
        return new WindowSpecificationImpl().rowsFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rowsBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().rowsBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rowsBetweenPreceding(int number) {
        return new WindowSpecificationImpl().rowsBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rowsBetweenCurrentRow() {
        return new WindowSpecificationImpl().rowsBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rowsBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().rowsBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>ROWS</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rowsBetweenFollowing(int number) {
        return new WindowSpecificationImpl().rowsBetweenFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rangeUnboundedPreceding() {
        return new WindowSpecificationImpl().rangeUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rangePreceding(int number) {
        return new WindowSpecificationImpl().rangePreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rangeCurrentRow() {
        return new WindowSpecificationImpl().rangeCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rangeUnboundedFollowing() {
        return new WindowSpecificationImpl().rangeUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep rangeFollowing(int number) {
        return new WindowSpecificationImpl().rangeFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rangeBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().rangeBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rangeBetweenPreceding(int number) {
        return new WindowSpecificationImpl().rangeBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rangeBetweenCurrentRow() {
        return new WindowSpecificationImpl().rangeBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rangeBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().rangeBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>RANGE</code> clause.
     */
    @NotNull
    @Support({ H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep rangeBetweenFollowing(int number) {
        return new WindowSpecificationImpl().rangeBetweenFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep groupsUnboundedPreceding() {
        return new WindowSpecificationImpl().groupsUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep groupsPreceding(int number) {
        return new WindowSpecificationImpl().groupsPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep groupsCurrentRow() {
        return new WindowSpecificationImpl().groupsCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep groupsUnboundedFollowing() {
        return new WindowSpecificationImpl().groupsUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationExcludeStep groupsFollowing(int number) {
        return new WindowSpecificationImpl().groupsFollowing(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep groupsBetweenUnboundedPreceding() {
        return new WindowSpecificationImpl().groupsBetweenUnboundedPreceding();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep groupsBetweenPreceding(int number) {
        return new WindowSpecificationImpl().groupsBetweenPreceding(number);
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep groupsBetweenCurrentRow() {
        return new WindowSpecificationImpl().groupsBetweenCurrentRow();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep groupsBetweenUnboundedFollowing() {
        return new WindowSpecificationImpl().groupsBetweenUnboundedFollowing();
    }

    /**
     * Create a {@link WindowSpecification} with a <code>GROUPS</code> clause.
     */
    @NotNull
    @Support({ H2, POSTGRES, SQLITE })
    public static WindowSpecificationRowsAndStep groupsBetweenFollowing(int number) {
        return new WindowSpecificationImpl().groupsBetweenFollowing(number);
    }

    // -------------------------------------------------------------------------
    // XXX Window functions
    // -------------------------------------------------------------------------

    /**
     * The <code>row_number() over ([analytic clause])</code> function.
     * <p>
     * Newer versions of {@link SQLDialect#DERBY} and {@link SQLDialect#H2} also
     * support the <code>ROW_NUMBER() OVER()</code> window function without any
     * window clause. See the respective docs for details.
     * {@link SQLDialect#HSQLDB} can emulate this function using
     * <code>ROWNUM()</code>
     */
    @NotNull
    @Support({ CUBRID, DERBY, FIREBIRD, H2, HSQLDB, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<Integer> rowNumber() {
        return new RowNumber();
    }

    /**
     * The <code>rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<Integer> rank() {
        return new RankingFunction<>(RANK, INTEGER);
    }

    /**
     * The <code>dense_rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<Integer> denseRank() {
        return new RankingFunction<>(DENSE_RANK, INTEGER);
    }

    /**
     * The <code>precent_rank() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<BigDecimal> percentRank() {
        return new RankingFunction<>(PERCENT_RANK, NUMERIC);
    }

    /**
     * The <code>cume_dist() over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<BigDecimal> cumeDist() {
        return new RankingFunction<>(CUME_DIST, NUMERIC);
    }

    /**
     * The <code>ntile([number]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<Integer> ntile(int number) {
        return new Ntile(inline(number));
    }

    /**
     * The <code>ntile([number]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<Integer> ntile(Field<Integer> number) {
        return new Ntile(number);
    }

    /**
     * The <code>ratio_to_report([expression]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<BigDecimal> ratioToReport(Number number) {
        return ratioToReport(Tools.field(number));
    }

    /**
     * The <code>ratio_to_report([expression]) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static WindowOverStep<BigDecimal> ratioToReport(Field<? extends Number> field) {
        return new RatioToReport(Tools.nullSafe(field));
    }

    /**
     * The <code>first_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> firstValue(Field<T> field) {
        return new PositionalWindowFunction(FIRST_VALUE, Tools.nullSafe(field));
    }

    /**
     * The <code>last_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lastValue(Field<T> field) {
        return new PositionalWindowFunction(LAST_VALUE, Tools.nullSafe(field));
    }

    /**
     * The <code>nth_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowFromFirstLastStep<T> nthValue(Field<T> field, int nth) {
        return nthValue(field, val(nth));
    }

    /**
     * The <code>nth_value(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowFromFirstLastStep<T> nthValue(Field<T> field, Field<Integer> nth) {
        return new PositionalWindowFunction(NTH_VALUE, Tools.nullSafe(field), Tools.nullSafe(nth), null);
    }

    /**
     * The <code>lead(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field) {
        return new PositionalWindowFunction(LEAD, Tools.nullSafe(field));
    }

    /**
     * The <code>lead(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset) {
        return lead(field, inline(offset));
    }

    /**
     * The <code>lead(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset) {
        return new PositionalWindowFunction(LEAD, Tools.nullSafe(field), Tools.nullSafe(offset), null);
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset, T defaultValue) {
        return lead(Tools.nullSafe(field), inline(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, int offset, Field<T> defaultValue) {
        return lead(field, inline(offset), defaultValue);
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset, T defaultValue) {
        return lead(field, Tools.nullSafe(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lead(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lead(Field<T> field, Field<Integer> offset, Field<T> defaultValue) {
        return new PositionalWindowFunction(LEAD, Tools.nullSafe(field), Tools.nullSafe(offset), Tools.nullSafe(defaultValue));
    }

    /**
     * The <code>lag(field) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field) {
        return new PositionalWindowFunction(LAG, Tools.nullSafe(field));
    }

    /**
     * The <code>lag(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset) {
        return lag(field, inline(offset));
    }

    /**
     * The <code>lag(field, offset) over ([analytic clause])</code> function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MARIADB, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset) {
        return new PositionalWindowFunction(LAG, Tools.nullSafe(field), Tools.nullSafe(offset), null);
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset, T defaultValue) {
        return lag(Tools.nullSafe(field), inline(offset), Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, int offset, Field<T> defaultValue) {
        return lag(field, inline(offset), defaultValue);
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset, T defaultValue) {
        return lag(field, offset, Tools.field(defaultValue, field));
    }

    /**
     * The
     * <code>lag(field, offset, defaultValue) over ([analytic clause])</code>
     * function.
     */
    @NotNull
    @Support({ CUBRID, FIREBIRD, H2, MYSQL, POSTGRES, SQLITE })
    public static <T> WindowIgnoreNullsStep<T> lag(Field<T> field, Field<Integer> offset, Field<T> defaultValue) {
        return new PositionalWindowFunction(LAG, Tools.nullSafe(field), Tools.nullSafe(offset), Tools.nullSafe(defaultValue));
    }

    // -------------------------------------------------------------------------
    // XXX Bind values
    // -------------------------------------------------------------------------

    /**
     * Create an unnamed parameter with a generic type ({@link Object} /
     * {@link SQLDataType#OTHER}) and no initial value.
     * <p>
     * Try to avoid this method when using any of these databases, as these
     * databases may have trouble inferring the type of the bind value. Use
     * typed named parameters instead, using {@link #param(Class)} or
     * {@link #param(DataType)}
     * <ul>
     * <li> {@link SQLDialect#DB2}</li>
     * <li> {@link SQLDialect#DERBY}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#INGRES}</li>
     * <li> {@link SQLDialect#SYBASE}</li>
     * </ul>
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<Object> param() {
        return param(Object.class);
    }

    /**
     * Create an unnamed parameter with a defined type and no initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(Class<T> type) {
        return param(DefaultDataType.getDataType(null, type));
    }

    /**
     * Create an unnamed parameter with a defined type and no initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(DataType<T> type) {
        return new Val<>(null, type);
    }

    /**
     * Create an unnamed parameter with the defined type of another field and no
     * initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(Field<T> field) {
        return param(field.getDataType());
    }

    /**
     * Create a named parameter with a generic type ({@link Object} /
     * {@link SQLDataType#OTHER}) and no initial value.
     * <p>
     * Try to avoid this method when using any of these databases, as these
     * databases may have trouble inferring the type of the bind value. Use
     * typed named parameters instead, using {@link #param(String, Class)} or
     * {@link #param(String, DataType)}
     * <ul>
     * <li> {@link SQLDialect#DB2}</li>
     * <li> {@link SQLDialect#DERBY}</li>
     * <li> {@link SQLDialect#H2}</li>
     * <li> {@link SQLDialect#HSQLDB}</li>
     * <li> {@link SQLDialect#INGRES}</li>
     * <li> {@link SQLDialect#SYBASE}</li>
     * </ul>
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static Param<Object> param(String name) {
        return param(name, Object.class);
    }

    /**
     * Create a named parameter with a defined type and no initial value.
     *
     * @param name The parameter name
     * @param type The type that is used for the parameter (a type that is
     *            supported by {@link SQLDataType})
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, Class<T> type) {
        return param(name, DefaultDataType.getDataType(null, type));
    }

    /**
     * Create a named parameter with a defined type and no initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, DataType<T> type) {
        return new Val<>(null, type, name);
    }

    /**
     * Create a named parameter with a defined type of another field and no
     * initial value.
     *
     * @see #param(String, Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, Field<T> type) {
        return param(name, type.getDataType());
    }

    /**
     * Create a named parameter with an initial value.
     * <p>
     * Named parameters are useful for several use-cases:
     * <ul>
     * <li>They can be used with Spring's <code>JdbcTemplate</code>, which
     * supports named parameters. Use
     * {@link DSLContext#renderNamedParams(QueryPart)} to render
     * parameter names in SQL</li>
     * <li>Named parameters can be retrieved using a well-known name from
     * {@link Query#getParam(String)} and {@link Query#getParams()}.</li>
     * </ul>
     *
     * @see Query#getParam(String)
     * @see Query#getParams()
     * @see DSLContext#renderNamedParams(QueryPart)
     */
    @NotNull
    @Support
    public static <T> Param<T> param(String name, T value) {
        return new Val<>(value, Tools.field(value).getDataType(), name);
    }

    /**
     * A synonym for {@link #val(Object)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(T value) {
        return val(value);
    }

    /**
     * A synonym for {@link #val(byte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(byte)
     */
    @NotNull
    @Support
    public static Param<Byte> value(byte value) {
        return value((Object) value, SQLDataType.TINYINT);
    }

    /**
     * A synonym for {@link #val(Byte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Byte)
     */
    @NotNull
    @Support
    public static Param<Byte> value(Byte value) {
        return value((Object) value, SQLDataType.TINYINT);
    }

    /**
     * A synonym for {@link #val(UByte)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UByte)
     */
    @NotNull
    @Support
    public static Param<UByte> value(UByte value) {
        return value((Object) value, SQLDataType.TINYINTUNSIGNED);
    }

    /**
     * A synonym for {@link #val(short)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(short)
     */
    @NotNull
    @Support
    public static Param<Short> value(short value) {
        return value((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * A synonym for {@link #val(Short)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Short)
     */
    @NotNull
    @Support
    public static Param<Short> value(Short value) {
        return value((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * A synonym for {@link #val(UShort)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UShort)
     */
    @NotNull
    @Support
    public static Param<UShort> value(UShort value) {
        return value((Object) value, SQLDataType.SMALLINTUNSIGNED);
    }

    /**
     * A synonym for {@link #val(int)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(int)
     */
    @NotNull
    @Support
    public static Param<Integer> value(int value) {
        return value((Object) value, SQLDataType.INTEGER);
    }

    /**
     * A synonym for {@link #val(Integer)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Integer)
     */
    @NotNull
    @Support
    public static Param<Integer> value(Integer value) {
        return value((Object) value, SQLDataType.INTEGER);
    }

    /**
     * A synonym for {@link #val(UInteger)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UInteger)
     */
    @NotNull
    @Support
    public static Param<UInteger> value(UInteger value) {
        return value((Object) value, SQLDataType.INTEGERUNSIGNED);
    }

    /**
     * A synonym for {@link #val(long)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(long)
     */
    @NotNull
    @Support
    public static Param<Long> value(long value) {
        return value((Object) value, SQLDataType.BIGINT);
    }

    /**
     * A synonym for {@link #val(Long)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Long)
     */
    @NotNull
    @Support
    public static Param<Long> value(Long value) {
        return value((Object) value, SQLDataType.BIGINT);
    }

    /**
     * A synonym for {@link #val(ULong)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(ULong)
     */
    @NotNull
    @Support
    public static Param<ULong> value(ULong value) {
        return value((Object) value, SQLDataType.BIGINTUNSIGNED);
    }

    /**
     * A synonym for {@link #val(float)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(float)
     */
    @NotNull
    @Support
    public static Param<Float> value(float value) {
        return value((Object) value, SQLDataType.REAL);
    }

    /**
     * A synonym for {@link #val(Float)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Float)
     */
    @NotNull
    @Support
    public static Param<Float> value(Float value) {
        return value((Object) value, SQLDataType.REAL);
    }

    /**
     * A synonym for {@link #val(double)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(double)
     */
    @NotNull
    @Support
    public static Param<Double> value(double value) {
        return value((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * A synonym for {@link #val(Double)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Double)
     */
    @NotNull
    @Support
    public static Param<Double> value(Double value) {
        return value((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * A synonym for {@link #val(boolean)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(boolean)
     */
    @NotNull
    @Support
    public static Param<Boolean> value(boolean value) {
        return value((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * A synonym for {@link #val(Boolean)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Boolean)
     */
    @NotNull
    @Support
    public static Param<Boolean> value(Boolean value) {
        return value((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * A synonym for {@link #val(BigDecimal)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(BigDecimal)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> value(BigDecimal value) {
        return value((Object) value, SQLDataType.DECIMAL);
    }

    /**
     * A synonym for {@link #val(BigInteger)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(BigInteger)
     */
    @NotNull
    @Support
    public static Param<BigInteger> value(BigInteger value) {
        return value((Object) value, SQLDataType.DECIMAL_INTEGER);
    }

    /**
     * A synonym for {@link #val(byte[])} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(byte[])
     */
    @NotNull
    @Support
    public static Param<byte[]> value(byte[] value) {
        return value((Object) value, SQLDataType.VARBINARY);
    }

    /**
     * A synonym for {@link #val(String)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(String)
     */
    @NotNull
    @Support
    public static Param<String> value(String value) {
        return value((Object) value, SQLDataType.VARCHAR);
    }

    /**
     * A synonym for {@link #val(Date)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Date)
     */
    @NotNull
    @Support
    public static Param<Date> value(Date value) {
        return value((Object) value, SQLDataType.DATE);
    }

    /**
     * A synonym for {@link #val(Time)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Time)
     */
    @NotNull
    @Support
    public static Param<Time> value(Time value) {
        return value((Object) value, SQLDataType.TIME);
    }

    /**
     * A synonym for {@link #val(Timestamp)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Timestamp)
     */
    @NotNull
    @Support
    public static Param<Timestamp> value(Timestamp value) {
        return value((Object) value, SQLDataType.TIMESTAMP);
    }

    /**
     * A synonym for {@link #val(LocalDate)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalDate)
     */
    @NotNull
    @Support
    public static Param<LocalDate> value(LocalDate value) {
        return value((Object) value, SQLDataType.LOCALDATE);
    }

    /**
     * A synonym for {@link #val(LocalTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalTime)
     */
    @NotNull
    @Support
    public static Param<LocalTime> value(LocalTime value) {
        return value((Object) value, SQLDataType.LOCALTIME);
    }

    /**
     * A synonym for {@link #val(LocalDateTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(LocalDateTime)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> value(LocalDateTime value) {
        return value((Object) value, SQLDataType.LOCALDATETIME);
    }

    /**
     * A synonym for {@link #val(OffsetTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(OffsetTime)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> value(OffsetTime value) {
        return value((Object) value, SQLDataType.OFFSETTIME);
    }

    /**
     * A synonym for {@link #val(OffsetDateTime)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(OffsetDateTime)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> value(OffsetDateTime value) {
        return value((Object) value, SQLDataType.OFFSETDATETIME);
    }

    /**
     * A synonym for {@link #val(Instant)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Instant)
     */
    @NotNull
    @Support
    public static Param<Instant> value(Instant value) {
        return value((Object) value, SQLDataType.INSTANT);
    }

    /**
     * A synonym for {@link #val(UUID)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(UUID)
     */
    @NotNull
    @Support
    public static Param<UUID> value(UUID value) {
        return value((Object) value, SQLDataType.UUID);
    }

    /**
     * A synonym for {@link #val(JSON)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(JSON)
     */
    @NotNull
    @Support
    public static Param<JSON> value(JSON value) {
        return value((Object) value, SQLDataType.JSON);
    }

    /**
     * A synonym for {@link #val(JSONB)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(JSONB)
     */
    @NotNull
    @Support
    public static Param<JSONB> value(JSONB value) {
        return value((Object) value, SQLDataType.JSONB);
    }

    /**
     * A synonym for {@link #val(XML)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(XML)
     */
    @NotNull
    @Support
    public static Param<XML> value(XML value) {
        return value((Object) value, SQLDataType.XML);
    }

    /**
     * A synonym for {@link #val(Object, Class)} to be used in Scala and Groovy,
     * where <code>val</code> is a reserved keyword.
     *
     * @param value The bind value
     * @param type The type that is used for the bind value (a type that is
     *            supported by {@link SQLDataType})
     * @see #val(Object, Class)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, Class<T> type) {
        return val(value, type);
    }

    /**
     * A synonym for {@link #val(Object, Field)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Object, Field)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, Field<T> field) {
        return val(value, field);
    }

    /**
     * A synonym for {@link #val(Object, DataType)} to be used in Scala and Groovy, where
     * <code>val</code> is a reserved keyword.
     *
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> value(Object value, DataType<T> type) {
        return val(value, type);
    }

    /**
     * Inline all bind variables produced by the argument {@link Field}.
     */
    @NotNull
    @Support
    public static <T> Field<T> inlined(Field<T> field) {
        return CustomField.of(field.getQualifiedName(), field.getDataType(), c -> c.visit(field, INLINED));
    }

    /**
     * Inline all bind variables produced by the argument {@link Condition}.
     */
    @NotNull
    @Support
    public static Condition inlined(Condition condition) {
        return CustomCondition.of(c -> c.visit(condition, INLINED));
    }

    /**
     * Inline all bind variables produced by the argument {@link QueryPart}.
     */
    @NotNull
    @Support
    public static QueryPart inlined(QueryPart part) {
        return CustomQueryPart.of(c -> c.visit(part, INLINED));
    }














    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(T value) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> inline(byte value) {
        return inline((Object) value, SQLDataType.TINYINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> inline(Byte value) {
        return inline((Object) value, SQLDataType.TINYINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UByte> inline(UByte value) {
        return inline((Object) value, SQLDataType.TINYINTUNSIGNED);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> inline(short value) {
        return inline((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> inline(Short value) {
        return inline((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UShort> inline(UShort value) {
        return inline((Object) value, SQLDataType.SMALLINTUNSIGNED);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> inline(int value) {
        return inline((Object) value, SQLDataType.INTEGER);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> inline(Integer value) {
        return inline((Object) value, SQLDataType.INTEGER);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UInteger> inline(UInteger value) {
        return inline((Object) value, SQLDataType.INTEGERUNSIGNED);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> inline(long value) {
        return inline((Object) value, SQLDataType.BIGINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> inline(Long value) {
        return inline((Object) value, SQLDataType.BIGINT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<ULong> inline(ULong value) {
        return inline((Object) value, SQLDataType.BIGINTUNSIGNED);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> inline(float value) {
        return inline((Object) value, SQLDataType.REAL);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> inline(Float value) {
        return inline((Object) value, SQLDataType.REAL);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> inline(double value) {
        return inline((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> inline(Double value) {
        return inline((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> inline(boolean value) {
        return inline((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> inline(Boolean value) {
        return inline((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> inline(BigDecimal value) {
        return inline((Object) value, SQLDataType.DECIMAL);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigInteger> inline(BigInteger value) {
        return inline((Object) value, SQLDataType.DECIMAL_INTEGER);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<byte[]> inline(byte[] value) {
        return inline((Object) value, SQLDataType.VARBINARY);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(String value) {
        return inline((Object) value, SQLDataType.VARCHAR);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Date> inline(Date value) {
        return inline((Object) value, SQLDataType.DATE);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Time> inline(Time value) {
        return inline((Object) value, SQLDataType.TIME);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Timestamp> inline(Timestamp value) {
        return inline((Object) value, SQLDataType.TIMESTAMP);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDate> inline(LocalDate value) {
        return inline((Object) value, SQLDataType.LOCALDATE);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalTime> inline(LocalTime value) {
        return inline((Object) value, SQLDataType.LOCALTIME);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> inline(LocalDateTime value) {
        return inline((Object) value, SQLDataType.LOCALDATETIME);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> inline(OffsetTime value) {
        return inline((Object) value, SQLDataType.OFFSETTIME);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> inline(OffsetDateTime value) {
        return inline((Object) value, SQLDataType.OFFSETDATETIME);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Instant> inline(Instant value) {
        return inline((Object) value, SQLDataType.INSTANT);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UUID> inline(UUID value) {
        return inline((Object) value, SQLDataType.UUID);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSON> inline(JSON value) {
        return inline((Object) value, SQLDataType.JSON);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSONB> inline(JSONB value) {
        return inline((Object) value, SQLDataType.JSONB);
    }

    /**
     * Create a bind value that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String)}, you can expect <code>value</code> to
     * be properly escaped for SQL syntax correctness and SQL injection
     * prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #inline(Object)
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<XML> inline(XML value) {
        return inline((Object) value, SQLDataType.XML);
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;Character&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(char character) {
        return inline("" + character);
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;Character&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(Character character) {
        return inline((character == null) ? null : ("" + character));
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * This is a convenience method for {@link #inline(Object)}, returning
     * <code>Field&lt;String&gt;</code>, rather than
     * <code>Field&lt;CharSequence&gt;</code>
     *
     * @see #inline(Object)
     */
    @NotNull
    @Support
    public static Param<String> inline(CharSequence character) {

        // Delegate to inline(T)
        return (Param) inline((Object) ((character == null) ? null : ("" + character)));
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, Class)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @param value The inline value
     * @param type The data type to enforce upon the value (a type that is
     *            supported by {@link SQLDataType})
     * @see #val(Object, Class)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, Class<T> type) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value, type);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, DataType)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #val(Object, Field)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, Field<T> field) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value, field);
        val.setInline0(true);
        return val;
    }

    /**
     * Create a bind value, that is always inlined.
     * <p>
     * The resulting bind value is always inlined, regardless of the
     * {@link Settings#getStatementType()} property of the rendering factory.
     * Unlike with {@link #field(String, DataType)}, you can expect
     * <code>value</code> to be properly escaped for SQL syntax correctness and
     * SQL injection prevention. For example:
     * <ul>
     * <li><code>inline("abc'def")</code> renders <code>'abc''def'</code></li>
     * <li><code>field("abc'def")</code> renders <code>abc'def</code></li>
     * </ul>
     *
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> inline(Object value, DataType<T> type) {
        AbstractParamX<T> val = (AbstractParamX<T>) val(value, type);
        val.setInline0(true);
        return val;
    }

    /**
     * Get a bind value.
     * <p>
     * jOOQ tries to derive the RDBMS {@link DataType} from the provided Java
     * type <code>&lt;T&gt;</code>. This may not always be accurate, which can
     * lead to problems in some strongly typed RDMBS, especially when value is
     * <code>null</code>. These databases are namely:
     * <ul>
     * <li>{@link SQLDialect#DERBY}</li>
     * <li>{@link SQLDialect#DB2}</li>
     * <li>{@link SQLDialect#H2}</li>
     * <li>{@link SQLDialect#HSQLDB}</li>
     * <li>{@link SQLDialect#INGRES}</li>
     * <li>{@link SQLDialect#SYBASE}</li>
     * </ul>
     * <p>
     * If you need more type-safety, please use {@link #val(Object, DataType)}
     * instead, and provide the precise RDMBS-specific data type, that is
     * needed.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @return A field representing the constant value
     */
    @NotNull
    @Support
    public static <T> Param<T> val(T value) {
        Class type = value == null ? Object.class : value.getClass();
        return val(value, getDataType0(type));
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> val(byte value) {
        return val((Object) value, SQLDataType.TINYINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Byte> val(Byte value) {
        return val((Object) value, SQLDataType.TINYINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UByte> val(UByte value) {
        return val((Object) value, SQLDataType.TINYINTUNSIGNED);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> val(short value) {
        return val((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Short> val(Short value) {
        return val((Object) value, SQLDataType.SMALLINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UShort> val(UShort value) {
        return val((Object) value, SQLDataType.SMALLINTUNSIGNED);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> val(int value) {
        return val((Object) value, SQLDataType.INTEGER);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Integer> val(Integer value) {
        return val((Object) value, SQLDataType.INTEGER);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UInteger> val(UInteger value) {
        return val((Object) value, SQLDataType.INTEGERUNSIGNED);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> val(long value) {
        return val((Object) value, SQLDataType.BIGINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Long> val(Long value) {
        return val((Object) value, SQLDataType.BIGINT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<ULong> val(ULong value) {
        return val((Object) value, SQLDataType.BIGINTUNSIGNED);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> val(float value) {
        return val((Object) value, SQLDataType.REAL);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Float> val(Float value) {
        return val((Object) value, SQLDataType.REAL);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> val(double value) {
        return val((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Double> val(Double value) {
        return val((Object) value, SQLDataType.DOUBLE);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> val(boolean value) {
        return val((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Boolean> val(Boolean value) {
        return val((Object) value, SQLDataType.BOOLEAN);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigDecimal> val(BigDecimal value) {
        return val((Object) value, SQLDataType.DECIMAL);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<BigInteger> val(BigInteger value) {
        return val((Object) value, SQLDataType.DECIMAL_INTEGER);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<byte[]> val(byte[] value) {
        return val((Object) value, SQLDataType.VARBINARY);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<String> val(String value) {
        return val((Object) value, SQLDataType.VARCHAR);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Date> val(Date value) {
        return val((Object) value, SQLDataType.DATE);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Time> val(Time value) {
        return val((Object) value, SQLDataType.TIME);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Timestamp> val(Timestamp value) {
        return val((Object) value, SQLDataType.TIMESTAMP);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDate> val(LocalDate value) {
        return val((Object) value, SQLDataType.LOCALDATE);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalTime> val(LocalTime value) {
        return val((Object) value, SQLDataType.LOCALTIME);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<LocalDateTime> val(LocalDateTime value) {
        return val((Object) value, SQLDataType.LOCALDATETIME);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetTime> val(OffsetTime value) {
        return val((Object) value, SQLDataType.OFFSETTIME);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<OffsetDateTime> val(OffsetDateTime value) {
        return val((Object) value, SQLDataType.OFFSETDATETIME);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<Instant> val(Instant value) {
        return val((Object) value, SQLDataType.INSTANT);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<UUID> val(UUID value) {
        return val((Object) value, SQLDataType.UUID);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSON> val(JSON value) {
        return val((Object) value, SQLDataType.JSON);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<JSONB> val(JSONB value) {
        return val((Object) value, SQLDataType.JSONB);
    }

    /**
     * Get a bind value.
     *
     * @see #val(Object)
     */
    @NotNull
    @Support
    public static Param<XML> val(XML value) {
        return val((Object) value, SQLDataType.XML);
    }

    /**
     * Get a bind value with an associated type, taken from a field.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param type The data type to enforce upon the value (a type that is
     *            supported by {@link SQLDataType})
     * @return A field representing the constant value
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, Class<T> type) {
        return val(value, getDataType(type));
    }

    /**
     * Get a bind value with an associated type, taken from a field.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param field The field whose data type to enforce upon the value
     * @return A field representing the constant value
     * @see #val(Object, DataType)
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, Field<T> field) {
        return val(value, Tools.nullSafeDataType(field));
    }

    /**
     * Get a bind value with an associated type.
     * <p>
     * This will try to bind <code>value</code> as <code>type</code> in a
     * <code>PreparedStatement</code>. If <code>value</code> and
     * <code>type</code> are not compatible, jOOQ will first try to convert and
     * then to cast <code>value</code> to <code>type</code>.
     *
     * @param <T> The generic value type
     * @param value The constant value
     * @param type The data type to enforce upon the value
     * @return A field representing the constant value
     */
    @NotNull
    @Support
    public static <T> Param<T> val(Object value, DataType<T> type) {

        // Advanced data types have dedicated constant types
        if (value instanceof QualifiedRecord) {
            return new QualifiedRecordConstant((QualifiedRecord<?>) value);
        }





        // The default behaviour
        else {
            T converted = type.convert(value);
            return new Val<>(converted, mostSpecific(converted, type));
        }
    }

    /**
     * Get the "most specific" data type between a concrete value and an actual
     * coercion data type.
     * <p>
     * [#2007] When coercing a (previously converted) value to a type, it may be that
     * the type is still more general than the actual type. This is typically
     * the case when <code>dataType == SQLDataType.OTHER</code>, i.e. when
     * <code>dataType.getType() == Object.class</code>. In that case, it is wise
     * to keep the additional type information of the <code>value</code>
     *
     * @param value The value
     * @param dataType The coercion data type
     * @return The most specific data type
     */
    private static <T> DataType<T> mostSpecific(T value, DataType<T> dataType) {

        // [#3888] With custom data type conversion, users may wish to
        // allow for a less specific data type than the actual value. Example:
        //   data type: Serializable
        //   value    : byte[]
        // [#3889] TODO: Improve this once DataType.getBinding() is available

        if (value != null && !(dataType instanceof ConvertedDataType)) {
            Class<T> valueType = (Class<T>) value.getClass();
            Class<T> coercionType = dataType.getType();

            if (valueType != coercionType && coercionType.isAssignableFrom(valueType)) {
                return DefaultDataType.getDataType(null, valueType, dataType);
            }
        }

        return dataType;
    }

    /**
     * Create a {@link RecordType} of an arbitrary degree.
     */
    @NotNull
    public static <T1> RecordType<Record> recordType(Field<?>[] fields) {
        return new FieldsImpl(fields);
    }

    /**
     * Create a {@link RecordType} of an arbitrary degree.
     */
    @NotNull
    public static <T1> RecordType<Record> recordType(Collection<? extends Field<?>> fields) {
        return new FieldsImpl(fields);
    }



    /**
     * Create a {@link RecordType} of degree <code>1</code>.
     */
    @NotNull
    public static <T1> RecordType<Record1<T1>> recordType(Field<T1> field1) {
        return new FieldsImpl(field1);
    }

    /**
     * Create a {@link RecordType} of degree <code>2</code>.
     */
    @NotNull
    public static <T1, T2> RecordType<Record2<T1, T2>> recordType(Field<T1> field1, Field<T2> field2) {
        return new FieldsImpl(field1, field2);
    }

    /**
     * Create a {@link RecordType} of degree <code>3</code>.
     */
    @NotNull
    public static <T1, T2, T3> RecordType<Record3<T1, T2, T3>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return new FieldsImpl(field1, field2, field3);
    }

    /**
     * Create a {@link RecordType} of degree <code>4</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4> RecordType<Record4<T1, T2, T3, T4>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return new FieldsImpl(field1, field2, field3, field4);
    }

    /**
     * Create a {@link RecordType} of degree <code>5</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5> RecordType<Record5<T1, T2, T3, T4, T5>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return new FieldsImpl(field1, field2, field3, field4, field5);
    }

    /**
     * Create a {@link RecordType} of degree <code>6</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6> RecordType<Record6<T1, T2, T3, T4, T5, T6>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a {@link RecordType} of degree <code>7</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7> RecordType<Record7<T1, T2, T3, T4, T5, T6, T7>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a {@link RecordType} of degree <code>8</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8> RecordType<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a {@link RecordType} of degree <code>9</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> RecordType<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a {@link RecordType} of degree <code>10</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> RecordType<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a {@link RecordType} of degree <code>11</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> RecordType<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a {@link RecordType} of degree <code>12</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> RecordType<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a {@link RecordType} of degree <code>13</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> RecordType<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a {@link RecordType} of degree <code>14</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> RecordType<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a {@link RecordType} of degree <code>15</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> RecordType<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a {@link RecordType} of degree <code>16</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> RecordType<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a {@link RecordType} of degree <code>17</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> RecordType<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a {@link RecordType} of degree <code>18</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> RecordType<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a {@link RecordType} of degree <code>19</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> RecordType<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a {@link RecordType} of degree <code>20</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> RecordType<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a {@link RecordType} of degree <code>21</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> RecordType<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a {@link RecordType} of degree <code>22</code>.
     */
    @NotNull
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> RecordType<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> recordType(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return new FieldsImpl(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }





    /**
     * Create a row value expression of degree <code>1</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1> Row1<T1> row(T1 t1) {
        return row(Tools.field(t1));
    }

    /**
     * Create a row value expression of degree <code>2</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2> Row2<T1, T2> row(T1 t1, T2 t2) {
        return row(Tools.field(t1), Tools.field(t2));
    }

    /**
     * Create a row value expression of degree <code>3</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> Row3<T1, T2, T3> row(T1 t1, T2 t2, T3 t3) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3));
    }

    /**
     * Create a row value expression of degree <code>4</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Row4<T1, T2, T3, T4> row(T1 t1, T2 t2, T3 t3, T4 t4) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4));
    }

    /**
     * Create a row value expression of degree <code>5</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Row5<T1, T2, T3, T4, T5> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5));
    }

    /**
     * Create a row value expression of degree <code>6</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Row6<T1, T2, T3, T4, T5, T6> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6));
    }

    /**
     * Create a row value expression of degree <code>7</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Row7<T1, T2, T3, T4, T5, T6, T7> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7));
    }

    /**
     * Create a row value expression of degree <code>8</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Row8<T1, T2, T3, T4, T5, T6, T7, T8> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8));
    }

    /**
     * Create a row value expression of degree <code>9</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9));
    }

    /**
     * Create a row value expression of degree <code>10</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10));
    }

    /**
     * Create a row value expression of degree <code>11</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11));
    }

    /**
     * Create a row value expression of degree <code>12</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12));
    }

    /**
     * Create a row value expression of degree <code>13</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13));
    }

    /**
     * Create a row value expression of degree <code>14</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14));
    }

    /**
     * Create a row value expression of degree <code>15</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15));
    }

    /**
     * Create a row value expression of degree <code>16</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16));
    }

    /**
     * Create a row value expression of degree <code>17</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17));
    }

    /**
     * Create a row value expression of degree <code>18</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18));
    }

    /**
     * Create a row value expression of degree <code>19</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19));
    }

    /**
     * Create a row value expression of degree <code>20</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20));
    }

    /**
     * Create a row value expression of degree <code>21</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20), Tools.field(t21));
    }

    /**
     * Create a row value expression of degree <code>22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15, T16 t16, T17 t17, T18 t18, T19 t19, T20 t20, T21 t21, T22 t22) {
        return row(Tools.field(t1), Tools.field(t2), Tools.field(t3), Tools.field(t4), Tools.field(t5), Tools.field(t6), Tools.field(t7), Tools.field(t8), Tools.field(t9), Tools.field(t10), Tools.field(t11), Tools.field(t12), Tools.field(t13), Tools.field(t14), Tools.field(t15), Tools.field(t16), Tools.field(t17), Tools.field(t18), Tools.field(t19), Tools.field(t20), Tools.field(t21), Tools.field(t22));
    }



    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(Object... values) {
        return row(Tools.fieldsArray(values));
    }



    /**
     * Create a row value expression of degree <code>1</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1> Row1<T1> row(SelectField<T1> field1) {
        return new RowImpl1<>(field1);
    }

    /**
     * Create a row value expression of degree <code>2</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2> Row2<T1, T2> row(SelectField<T1> field1, SelectField<T2> field2) {
        return new RowImpl2<>(field1, field2);
    }

    /**
     * Create a row value expression of degree <code>3</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3> Row3<T1, T2, T3> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3) {
        return new RowImpl3<>(field1, field2, field3);
    }

    /**
     * Create a row value expression of degree <code>4</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Row4<T1, T2, T3, T4> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4) {
        return new RowImpl4<>(field1, field2, field3, field4);
    }

    /**
     * Create a row value expression of degree <code>5</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Row5<T1, T2, T3, T4, T5> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5) {
        return new RowImpl5<>(field1, field2, field3, field4, field5);
    }

    /**
     * Create a row value expression of degree <code>6</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Row6<T1, T2, T3, T4, T5, T6> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6) {
        return new RowImpl6<>(field1, field2, field3, field4, field5, field6);
    }

    /**
     * Create a row value expression of degree <code>7</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Row7<T1, T2, T3, T4, T5, T6, T7> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7) {
        return new RowImpl7<>(field1, field2, field3, field4, field5, field6, field7);
    }

    /**
     * Create a row value expression of degree <code>8</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Row8<T1, T2, T3, T4, T5, T6, T7, T8> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8) {
        return new RowImpl8<>(field1, field2, field3, field4, field5, field6, field7, field8);
    }

    /**
     * Create a row value expression of degree <code>9</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9) {
        return new RowImpl9<>(field1, field2, field3, field4, field5, field6, field7, field8, field9);
    }

    /**
     * Create a row value expression of degree <code>10</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10) {
        return new RowImpl10<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10);
    }

    /**
     * Create a row value expression of degree <code>11</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11) {
        return new RowImpl11<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11);
    }

    /**
     * Create a row value expression of degree <code>12</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12) {
        return new RowImpl12<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12);
    }

    /**
     * Create a row value expression of degree <code>13</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13) {
        return new RowImpl13<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13);
    }

    /**
     * Create a row value expression of degree <code>14</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14) {
        return new RowImpl14<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14);
    }

    /**
     * Create a row value expression of degree <code>15</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15) {
        return new RowImpl15<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15);
    }

    /**
     * Create a row value expression of degree <code>16</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16) {
        return new RowImpl16<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16);
    }

    /**
     * Create a row value expression of degree <code>17</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17) {
        return new RowImpl17<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17);
    }

    /**
     * Create a row value expression of degree <code>18</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18) {
        return new RowImpl18<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18);
    }

    /**
     * Create a row value expression of degree <code>19</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19) {
        return new RowImpl19<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19);
    }

    /**
     * Create a row value expression of degree <code>20</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20) {
        return new RowImpl20<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20);
    }

    /**
     * Create a row value expression of degree <code>21</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21) {
        return new RowImpl21<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21);
    }

    /**
     * Create a row value expression of degree <code>22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> row(SelectField<T1> field1, SelectField<T2> field2, SelectField<T3> field3, SelectField<T4> field4, SelectField<T5> field5, SelectField<T6> field6, SelectField<T7> field7, SelectField<T8> field8, SelectField<T9> field9, SelectField<T10> field10, SelectField<T11> field11, SelectField<T12> field12, SelectField<T13> field13, SelectField<T14> field14, SelectField<T15> field15, SelectField<T16> field16, SelectField<T17> field17, SelectField<T18> field18, SelectField<T19> field19, SelectField<T20> field20, SelectField<T21> field21, SelectField<T22> field22) {
        return new RowImpl22<>(field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22);
    }



    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(SelectField<?>... values) {
        return new RowImplN(values);
    }

    /**
     * Create a row value expression of degree <code>N &gt; 22</code>.
     * <p>
     * Note: Not all databases support row value expressions, but many row value
     * expression operations can be emulated on all databases. See relevant row
     * value expression method Javadocs for details.
     */
    @NotNull
    @Support
    public static RowN row(Collection<?> values) {
        return row(values.toArray());
    }

    // -------------------------------------------------------------------------
    // XXX [#915] VALUES() table constructors
    // -------------------------------------------------------------------------

    /**
     * Create a <code>VALUES()</code> expression of arbitrary degree.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2),
     *       (val2_1, val2_2),
     *       (val3_1, val3_2)
     * AS "v"("c1"  , "c2"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function...)
     */
    @NotNull
    @Support
    public static Table<Record> values(RowN... rows) {
        return values0(rows);
    }

    /**
     * Internal values constructor.
     * <p>
     * [#6003] TODO: Make this public
     */
    @NotNull
    @Support
    static Table<Record> values0(Row... rows) {
        Values.assertNotEmpty(rows);
        int size = rows[0].size();

        String[] columns = new String[size];

        for (int i = 0; i < size; i++)
            columns[i] = "c" + (i + 1);

        return new Values<Record>(rows).as("v", columns);
    }



    /**
     * Create a <code>VALUES()</code> expression of degree <code>1</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1),
     *       (val2_1),
     *       (val3_1)
     * AS "v"("c1"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1") UNION ALL
     * SELECT val1_1 AS "c1") UNION ALL
     * SELECT val1_1 AS "c1")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1> Table<Record1<T1>> values(Row1<T1>... rows) {
        return new Values<Record1<T1>>(rows).as("v", "c1");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>2</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2),
     *       (val2_1, val2_2),
     *       (val3_1, val3_2)
     * AS "v"("c1"  , "c2"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2> Table<Record2<T1, T2>> values(Row2<T1, T2>... rows) {
        return new Values<Record2<T1, T2>>(rows).as("v", "c1", "c2");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>3</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3),
     *       (val2_1, val2_2, val2_3),
     *       (val3_1, val3_2, val3_3)
     * AS "v"("c1"  , "c2"  , "c3"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3> Table<Record3<T1, T2, T3>> values(Row3<T1, T2, T3>... rows) {
        return new Values<Record3<T1, T2, T3>>(rows).as("v", "c1", "c2", "c3");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>4</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4),
     *       (val2_1, val2_2, val2_3, val2_4),
     *       (val3_1, val3_2, val3_3, val3_4)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4> Table<Record4<T1, T2, T3, T4>> values(Row4<T1, T2, T3, T4>... rows) {
        return new Values<Record4<T1, T2, T3, T4>>(rows).as("v", "c1", "c2", "c3", "c4");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>5</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5> Table<Record5<T1, T2, T3, T4, T5>> values(Row5<T1, T2, T3, T4, T5>... rows) {
        return new Values<Record5<T1, T2, T3, T4, T5>>(rows).as("v", "c1", "c2", "c3", "c4", "c5");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>6</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6> Table<Record6<T1, T2, T3, T4, T5, T6>> values(Row6<T1, T2, T3, T4, T5, T6>... rows) {
        return new Values<Record6<T1, T2, T3, T4, T5, T6>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>7</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7> Table<Record7<T1, T2, T3, T4, T5, T6, T7>> values(Row7<T1, T2, T3, T4, T5, T6, T7>... rows) {
        return new Values<Record7<T1, T2, T3, T4, T5, T6, T7>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>8</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8> Table<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> values(Row8<T1, T2, T3, T4, T5, T6, T7, T8>... rows) {
        return new Values<Record8<T1, T2, T3, T4, T5, T6, T7, T8>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>9</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9> Table<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> values(Row9<T1, T2, T3, T4, T5, T6, T7, T8, T9>... rows) {
        return new Values<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>10</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Table<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> values(Row10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>... rows) {
        return new Values<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>11</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Table<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> values(Row11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>... rows) {
        return new Values<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>12</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Table<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> values(Row12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>... rows) {
        return new Values<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>13</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Table<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> values(Row13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>... rows) {
        return new Values<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>14</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Table<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> values(Row14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>... rows) {
        return new Values<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>15</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Table<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> values(Row15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>... rows) {
        return new Values<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>16</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Table<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> values(Row16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>... rows) {
        return new Values<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>17</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Table<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> values(Row17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>... rows) {
        return new Values<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>18</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Table<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> values(Row18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>... rows) {
        return new Values<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17", "c18");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>19</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Table<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> values(Row19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>... rows) {
        return new Values<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17", "c18", "c19");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>20</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Table<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> values(Row20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>... rows) {
        return new Values<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17", "c18", "c19", "c20");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>21</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20, val1_21),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20, val2_21),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20, val3_21)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  , "c21"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Table<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> values(Row21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>... rows) {
        return new Values<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17", "c18", "c19", "c20", "c21");
    }

    /**
     * Create a <code>VALUES()</code> expression of degree <code>22</code>.
     * <p>
     * The <code>VALUES()</code> constructor is a tool supported by some
     * databases to allow for constructing tables from constant values.
     * <p>
     * If a database doesn't support the <code>VALUES()</code> constructor, it
     * can be emulated using <code>SELECT .. UNION ALL ..</code>. The following
     * expressions are equivalent:
     * <p>
     * <pre><code>
     * -- Using VALUES() constructor
     * VALUES(val1_1, val1_2, val1_3, val1_4, val1_5, val1_6, val1_7, val1_8, val1_9, val1_10, val1_11, val1_12, val1_13, val1_14, val1_15, val1_16, val1_17, val1_18, val1_19, val1_20, val1_21, val1_22),
     *       (val2_1, val2_2, val2_3, val2_4, val2_5, val2_6, val2_7, val2_8, val2_9, val2_10, val2_11, val2_12, val2_13, val2_14, val2_15, val2_16, val2_17, val2_18, val2_19, val2_20, val2_21, val2_22),
     *       (val3_1, val3_2, val3_3, val3_4, val3_5, val3_6, val3_7, val3_8, val3_9, val3_10, val3_11, val3_12, val3_13, val3_14, val3_15, val3_16, val3_17, val3_18, val3_19, val3_20, val3_21, val3_22)
     * AS "v"("c1"  , "c2"  , "c3"  , "c4"  , "c5"  , "c6"  , "c7"  , "c8"  , "c9"  , "c10"  , "c11"  , "c12"  , "c13"  , "c14"  , "c15"  , "c16"  , "c17"  , "c18"  , "c19"  , "c20"  , "c21"  , "c22"  )
     *
     * -- Using UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22") UNION ALL
     * SELECT val1_1 AS "c1", val1_2 AS "c2", val1_3 AS "c3", val1_4 AS "c4", val1_5 AS "c5", val1_6 AS "c6", val1_7 AS "c7", val1_8 AS "c8", val1_9 AS "c9", val1_10 AS "c10", val1_11 AS "c11", val1_12 AS "c12", val1_13 AS "c13", val1_14 AS "c14", val1_15 AS "c15", val1_16 AS "c16", val1_17 AS "c17", val1_18 AS "c18", val1_19 AS "c19", val1_20 AS "c20", val1_21 AS "c21", val1_22 AS "c22")
     * </code></pre>
     * <p>
     * Use {@link Table#as(String, String...)} to rename the resulting table and
     * its columns.
     *
     * @see Rows#toRowArray(Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function, Function)
     */
    @SafeVarargs
    @NotNull
    @Support
    public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Table<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> values(Row22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>... rows) {
        return new Values<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>>(rows).as("v", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15", "c16", "c17", "c18", "c19", "c20", "c21", "c22");
    }



    // -------------------------------------------------------------------------
    // XXX Literals
    // -------------------------------------------------------------------------

    /**
     * Get the null field.
     */
    static Field<?> NULL() {
        return field("null");
    }

    /**
     * Get the null field.
     */
    static <T> Field<T> NULL(Field<T> field) {
        return NULL(field.getDataType());
    }

    /**
     * Get the null field.
     */
    static <T> Field<T> NULL(DataType<T> type) {
        return field("null", type);
    }

    /**
     * Get the null field.
     */
    static <T> Field<T> NULL(Class<T> type) {
        return field("null", type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> Field<T> nullSafe(Field<T> field) {
        return Tools.nullSafe(field);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> Field<T> nullSafe(Field<T> field, DataType<?> type) {
        return Tools.nullSafe(field, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static Field<?>[] nullSafe(Field<?>... fields) {
        return Tools.nullSafe(fields);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static Field<?>[] nullSafe(Field<?>[] fields, DataType<?> type) {
        return Tools.nullSafe(fields, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static List<Field<?>> nullSafeList(Field<?>... fields) {
        return Tools.nullSafeList(fields);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static List<Field<?>> nullSafeList(Field<?>[] fields, DataType<?> type) {
        return Tools.nullSafeList(fields, type);
    }

    /**
     * @deprecated - [#11092] - 3.15.0 - This method will be removed without
     *             public replacement.
     */
    @Deprecated(forRemoval = true, since = "3.15")
    protected static <T> DataType<T> nullSafeDataType(Field<T> field) {
        return Tools.nullSafeDataType(field);
    }

    /**
     * The asterisk (<code>*</code>) to be used in <code>SELECT</code> clauses.
     * <p>
     * When using an asterisk, jOOQ will let the database server define the
     * order of columns, as well as which columns are included in the result
     * set. If using jOOQ with generated code, this may conflict with the column
     * set and its ordering as defined at code generation time, meaning columns
     * may be in a different order, there may be fewer or more columns than
     * expected. It is usually better to list columns explicitly.
     */
    @NotNull
    @Support
    public static Asterisk asterisk() {
        return AsteriskImpl.INSTANCE;
    }

    /**
     * A <code>0</code> literal.
     * <p>
     * This is useful for mathematical functions or for
     * <code>EXISTS (SELECT 0 ...)</code> or <code>PARTITION BY 0</code> clauses
     * and similar constructs. The <code>0</code> literal will not generate a
     * bind variable.
     *
     * @return A <code>0</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> zero() {
        return inline(0);
    }

    /**
     * A <code>1</code> literal.
     * <p>
     * This is useful for mathematical functions or for
     * <code>EXISTS (SELECT 1 ...)</code> or <code>PARTITION BY 1</code> clauses
     * and similar constructs. The <code>1</code> literal will not generate a
     * bind variable.
     *
     * @return A <code>1</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> one() {
        return inline(1);
    }

    /**
     * A <code>2</code> literal.
     * <p>
     * This is useful for mathematical functions. The <code>1</code> literal
     * will not generate a bind variable.
     *
     * @return A <code>2</code> literal as a <code>Field</code>
     */
    @NotNull
    @Support
    public static Param<Integer> two() {
        return inline(2);
    }

    // -------------------------------------------------------------------------
    // XXX utility API
    // -------------------------------------------------------------------------

    /**
     * Get the default data type for the {@link DSLContext}'s underlying
     * {@link SQLDialect} and a given Java type.
     *
     * @param <T> The generic type
     * @param type The Java type. This must be a type supported by
     *            {@link SQLDataType}.
     * @return The <code>DSL</code>'s underlying default data type.
     * @deprecated - 3.11.0 - [#7483] - The (indirect) use of the internal
     *             static data type registry is not recommended.
     */
    @Deprecated(forRemoval = true, since = "3.11")
    @NotNull
    @Support
    public static <T> DataType<T> getDataType(Class<T> type) {
        return DefaultDataType.getDataType(SQLDialect.DEFAULT, type);
    }

    /**
     * [#9492] [#10438] Get a static data type for a class.
     * <p>
     * This will:
     * <ul>
     * <li>Get a built-in data type, if available</li>
     * <li>Get a DataTypeProxy wrapped LegacyConvertedDataType, if available
     * (#9492)</li>
     * <li>Get a DataTypeProxy, otherwise, for lazy data type lookups
     * (#10438)</li>
     * </ul>
     */
    static <T> DataType<T> getDataType0(Class<T> type) {
        DataType t = DefaultDataType.getDataType(DEFAULT, type, (DataType) SQLDataType.OTHER);

        if (t instanceof LegacyConvertedDataType)
            return new DataTypeProxy((AbstractDataType) t);
        else if (t != SQLDataType.OTHER)
            return t;
        else
            return DefaultDataType.getDataType(DEFAULT, type, new DataTypeProxy((AbstractDataType) SQLDataType.OTHER));
    }

    private static final DSLContext dsl() {
        return using(new DefaultConfiguration());
    }

    /**
     * No instances.
     */
    protected DSL() {
        throw new UnsupportedOperationException();
    }
}
